#![doc = "Peripheral access API for ADUCM410 microcontrollers (generated using svd2rust v0.35.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.35.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, FPU, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
extern "C" {
    fn WUT();
    fn WDT();
    fn GPT0();
    fn GPT1();
    fn GPT2();
    fn GPT3();
    fn GPT4();
    fn MDIO();
    fn FLASH();
    fn UART0();
    fn UART1();
    fn SPI0();
    fn SPI1();
    fn SPI2();
    fn I2C0S();
    fn I2C0M();
    fn I2C1S();
    fn I2C1M();
    fn I2C2S();
    fn I2C2M();
    fn PLA0();
    fn PLA1();
    fn PLA2();
    fn PLA3();
    fn PWM_TRIP();
    fn PWM0();
    fn PWM1();
    fn PWM2();
    fn PWM3();
    fn SRAM_ERR();
    fn DMA_ERR();
    fn DMA_SPI0_TX();
    fn DMA_SPI0_RX();
    fn DMA_SPI1_TX();
    fn DMA_SPI1_RX();
    fn DMA_SPI2_TX();
    fn DMA_SPI2_RX();
    fn DMA_UART0_TX();
    fn DMA_UART0_RX();
    fn DMA_UART1_TX();
    fn DMA_UART1_RX();
    fn DMA_I2C0S_TX();
    fn DMA_I2C0S_RX();
    fn DMA_I2C0M();
    fn DMA_I2C1S_TX();
    fn DMA_I2C1S_RX();
    fn DMA_I2C1M();
    fn DMA_I2C2S_TX();
    fn DMA_I2C2S_RX();
    fn DMA_I2C2M();
    fn DMA_MDIO_TX();
    fn DMA_MDIO_RX();
    fn DMA_FLASH();
    fn DMA_ADC();
    fn PLL();
    fn ADC();
    fn SEQ();
    fn COMP0();
    fn COMP1();
    fn COMP2();
    fn COMP3();
    fn VDAC();
    fn LVD2D();
    fn HVD2D();
    fn DMA_SPI_LV_TX();
    fn DMA_SPI_LV_RX();
    fn DMA_SPI_HV_TX();
    fn DMA_SPI_HV_RX();
    fn DMA_TRIG0();
    fn DMA_TRIG1();
    fn DMA_SW0();
    fn DMA_SW1();
    fn CACHE();
    fn DIG_COMP();
    fn GPIO_INTA();
    fn GPIO_INTB();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 89] = [
    Vector { _handler: WUT },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: WDT },
    Vector { _handler: GPT0 },
    Vector { _handler: GPT1 },
    Vector { _handler: GPT2 },
    Vector { _handler: GPT3 },
    Vector { _handler: GPT4 },
    Vector { _handler: MDIO },
    Vector { _handler: FLASH },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: SPI0 },
    Vector { _handler: SPI1 },
    Vector { _handler: SPI2 },
    Vector { _handler: I2C0S },
    Vector { _handler: I2C0M },
    Vector { _handler: I2C1S },
    Vector { _handler: I2C1M },
    Vector { _handler: I2C2S },
    Vector { _handler: I2C2M },
    Vector { _handler: PLA0 },
    Vector { _handler: PLA1 },
    Vector { _handler: PLA2 },
    Vector { _handler: PLA3 },
    Vector { _handler: PWM_TRIP },
    Vector { _handler: PWM0 },
    Vector { _handler: PWM1 },
    Vector { _handler: PWM2 },
    Vector { _handler: PWM3 },
    Vector { _handler: SRAM_ERR },
    Vector { _handler: DMA_ERR },
    Vector {
        _handler: DMA_SPI0_TX,
    },
    Vector {
        _handler: DMA_SPI0_RX,
    },
    Vector {
        _handler: DMA_SPI1_TX,
    },
    Vector {
        _handler: DMA_SPI1_RX,
    },
    Vector {
        _handler: DMA_SPI2_TX,
    },
    Vector {
        _handler: DMA_SPI2_RX,
    },
    Vector {
        _handler: DMA_UART0_TX,
    },
    Vector {
        _handler: DMA_UART0_RX,
    },
    Vector {
        _handler: DMA_UART1_TX,
    },
    Vector {
        _handler: DMA_UART1_RX,
    },
    Vector {
        _handler: DMA_I2C0S_TX,
    },
    Vector {
        _handler: DMA_I2C0S_RX,
    },
    Vector {
        _handler: DMA_I2C0M,
    },
    Vector {
        _handler: DMA_I2C1S_TX,
    },
    Vector {
        _handler: DMA_I2C1S_RX,
    },
    Vector {
        _handler: DMA_I2C1M,
    },
    Vector {
        _handler: DMA_I2C2S_TX,
    },
    Vector {
        _handler: DMA_I2C2S_RX,
    },
    Vector {
        _handler: DMA_I2C2M,
    },
    Vector {
        _handler: DMA_MDIO_TX,
    },
    Vector {
        _handler: DMA_MDIO_RX,
    },
    Vector {
        _handler: DMA_FLASH,
    },
    Vector { _handler: DMA_ADC },
    Vector { _handler: PLL },
    Vector { _reserved: 0 },
    Vector { _handler: ADC },
    Vector { _handler: SEQ },
    Vector { _handler: COMP0 },
    Vector { _handler: COMP1 },
    Vector { _handler: COMP2 },
    Vector { _handler: COMP3 },
    Vector { _handler: VDAC },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: LVD2D },
    Vector { _handler: HVD2D },
    Vector {
        _handler: DMA_SPI_LV_TX,
    },
    Vector {
        _handler: DMA_SPI_LV_RX,
    },
    Vector {
        _handler: DMA_SPI_HV_TX,
    },
    Vector {
        _handler: DMA_SPI_HV_RX,
    },
    Vector {
        _handler: DMA_TRIG0,
    },
    Vector {
        _handler: DMA_TRIG1,
    },
    Vector { _handler: DMA_SW0 },
    Vector { _handler: DMA_SW1 },
    Vector { _handler: CACHE },
    Vector { _handler: DIG_COMP },
    Vector {
        _handler: GPIO_INTA,
    },
    Vector {
        _handler: GPIO_INTB,
    },
];
#[doc = r"Enumeration of all the interrupts."]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - WUT"]
    WUT = 0,
    #[doc = "11 - WDT"]
    WDT = 11,
    #[doc = "12 - GPT0"]
    GPT0 = 12,
    #[doc = "13 - GPT1"]
    GPT1 = 13,
    #[doc = "14 - GPT2"]
    GPT2 = 14,
    #[doc = "15 - GPT3"]
    GPT3 = 15,
    #[doc = "16 - GPT4"]
    GPT4 = 16,
    #[doc = "17 - MDIO"]
    MDIO = 17,
    #[doc = "18 - FLASH"]
    FLASH = 18,
    #[doc = "19 - UART0"]
    UART0 = 19,
    #[doc = "20 - UART1"]
    UART1 = 20,
    #[doc = "21 - SPI0"]
    SPI0 = 21,
    #[doc = "22 - SPI1"]
    SPI1 = 22,
    #[doc = "23 - SPI2"]
    SPI2 = 23,
    #[doc = "24 - I2C0S"]
    I2C0S = 24,
    #[doc = "25 - I2C0M"]
    I2C0M = 25,
    #[doc = "26 - I2C1S"]
    I2C1S = 26,
    #[doc = "27 - I2C1M"]
    I2C1M = 27,
    #[doc = "28 - I2C2S"]
    I2C2S = 28,
    #[doc = "29 - I2C2M"]
    I2C2M = 29,
    #[doc = "30 - PLA0"]
    PLA0 = 30,
    #[doc = "31 - PLA1"]
    PLA1 = 31,
    #[doc = "32 - PLA2"]
    PLA2 = 32,
    #[doc = "33 - PLA3"]
    PLA3 = 33,
    #[doc = "34 - PWM_TRIP"]
    PWM_TRIP = 34,
    #[doc = "35 - PWM0"]
    PWM0 = 35,
    #[doc = "36 - PWM1"]
    PWM1 = 36,
    #[doc = "37 - PWM2"]
    PWM2 = 37,
    #[doc = "38 - PWM3"]
    PWM3 = 38,
    #[doc = "39 - SRAM_ERR"]
    SRAM_ERR = 39,
    #[doc = "40 - DMA_ERR"]
    DMA_ERR = 40,
    #[doc = "41 - DMA_SPI0_TX"]
    DMA_SPI0_TX = 41,
    #[doc = "42 - DMA_SPI0_RX"]
    DMA_SPI0_RX = 42,
    #[doc = "43 - DMA_SPI1_TX"]
    DMA_SPI1_TX = 43,
    #[doc = "44 - DMA_SPI1_RX"]
    DMA_SPI1_RX = 44,
    #[doc = "45 - DMA_SPI2_TX"]
    DMA_SPI2_TX = 45,
    #[doc = "46 - DMA_SPI2_RX"]
    DMA_SPI2_RX = 46,
    #[doc = "47 - DMA_UART0_TX"]
    DMA_UART0_TX = 47,
    #[doc = "48 - DMA_UART0_RX"]
    DMA_UART0_RX = 48,
    #[doc = "49 - DMA_UART1_TX"]
    DMA_UART1_TX = 49,
    #[doc = "50 - DMA_UART1_RX"]
    DMA_UART1_RX = 50,
    #[doc = "51 - DMA_I2C0S_TX"]
    DMA_I2C0S_TX = 51,
    #[doc = "52 - DMA_I2C0S_RX"]
    DMA_I2C0S_RX = 52,
    #[doc = "53 - DMA_I2C0M"]
    DMA_I2C0M = 53,
    #[doc = "54 - DMA_I2C1S_TX"]
    DMA_I2C1S_TX = 54,
    #[doc = "55 - DMA_I2C1S_RX"]
    DMA_I2C1S_RX = 55,
    #[doc = "56 - DMA_I2C1M"]
    DMA_I2C1M = 56,
    #[doc = "57 - DMA_I2C2S_TX"]
    DMA_I2C2S_TX = 57,
    #[doc = "58 - DMA_I2C2S_RX"]
    DMA_I2C2S_RX = 58,
    #[doc = "59 - DMA_I2C2M"]
    DMA_I2C2M = 59,
    #[doc = "60 - DMA_MDIO_TX"]
    DMA_MDIO_TX = 60,
    #[doc = "61 - DMA_MDIO_RX"]
    DMA_MDIO_RX = 61,
    #[doc = "62 - DMA_FLASH"]
    DMA_FLASH = 62,
    #[doc = "63 - DMA_ADC"]
    DMA_ADC = 63,
    #[doc = "64 - PLL"]
    PLL = 64,
    #[doc = "66 - ADC"]
    ADC = 66,
    #[doc = "67 - SEQ"]
    SEQ = 67,
    #[doc = "68 - COMP0"]
    COMP0 = 68,
    #[doc = "69 - COMP1"]
    COMP1 = 69,
    #[doc = "70 - COMP2"]
    COMP2 = 70,
    #[doc = "71 - COMP3"]
    COMP3 = 71,
    #[doc = "72 - VDAC"]
    VDAC = 72,
    #[doc = "75 - LVD2D"]
    LVD2D = 75,
    #[doc = "76 - HVD2D"]
    HVD2D = 76,
    #[doc = "77 - DMA_SPI_LV_TX"]
    DMA_SPI_LV_TX = 77,
    #[doc = "78 - DMA_SPI_LV_RX"]
    DMA_SPI_LV_RX = 78,
    #[doc = "79 - DMA_SPI_HV_TX"]
    DMA_SPI_HV_TX = 79,
    #[doc = "80 - DMA_SPI_HV_RX"]
    DMA_SPI_HV_RX = 80,
    #[doc = "81 - DMA_TRIG0"]
    DMA_TRIG0 = 81,
    #[doc = "82 - DMA_TRIG1"]
    DMA_TRIG1 = 82,
    #[doc = "83 - DMA_SW0"]
    DMA_SW0 = 83,
    #[doc = "84 - DMA_SW1"]
    DMA_SW1 = 84,
    #[doc = "85 - CACHE"]
    CACHE = 85,
    #[doc = "86 - DIG_COMP"]
    DIG_COMP = 86,
    #[doc = "87 - GPIO_INTA"]
    GPIO_INTA = 87,
    #[doc = "88 - GPIO_INTB"]
    GPIO_INTB = 88,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0)"]
pub struct GPT0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPT0 {}
impl GPT0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpt0::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPT0 {
    type Target = gpt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPT0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT0").finish()
    }
}
#[doc = "Unknown"]
pub mod gpt0 {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ld: LD,
        val: VAL,
        con: CON,
        clri: CLRI,
        _reserved4: [u8; 0x0c],
        sta: STA,
    }
    impl RegisterBlock {
        #[doc = "0x00 - 16-bit Load Value Register"]
        #[inline(always)]
        pub const fn ld(&self) -> &LD {
            &self.ld
        }
        #[doc = "0x04 - 16-bit Timer Value Register"]
        #[inline(always)]
        pub const fn val(&self) -> &VAL {
            &self.val
        }
        #[doc = "0x08 - Control Register"]
        #[inline(always)]
        pub const fn con(&self) -> &CON {
            &self.con
        }
        #[doc = "0x0c - Clear Interrupt Register"]
        #[inline(always)]
        pub const fn clri(&self) -> &CLRI {
            &self.clri
        }
        #[doc = "0x1c - Status Register"]
        #[inline(always)]
        pub const fn sta(&self) -> &STA {
            &self.sta
        }
    }
    #[doc = "LD (rw) register accessor: 16-bit Load Value Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ld::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ld::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:LD)\n\nFor information about available fields see [`mod@ld`]
module"]
    pub type LD = crate::Reg<ld::LDrs>;
    #[doc = "16-bit Load Value Register"]
    pub mod ld {
        #[doc = "Register `LD` reader"]
        pub type R = crate::R<LDrs>;
        #[doc = "Register `LD` writer"]
        pub type W = crate::W<LDrs>;
        #[doc = "Field `LOAD` reader - Load Value"]
        pub type LOAD_R = crate::FieldReader<u16>;
        #[doc = "Field `LOAD` writer - Load Value"]
        pub type LOAD_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Load Value"]
            #[inline(always)]
            pub fn load(&self) -> LOAD_R {
                LOAD_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LD").field("load", &self.load()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Load Value"]
            #[inline(always)]
            pub fn load(&mut self) -> LOAD_W<LDrs> {
                LOAD_W::new(self, 0)
            }
        }
        #[doc = "16-bit Load Value Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ld::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ld::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:LD)"]
        pub struct LDrs;
        impl crate::RegisterSpec for LDrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ld::R`](R) reader structure"]
        impl crate::Readable for LDrs {}
        #[doc = "`write(|w| ..)` method takes [`ld::W`](W) writer structure"]
        impl crate::Writable for LDrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LD to value 0"]
        impl crate::Resettable for LDrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "VAL (rw) register accessor: 16-bit Timer Value Register\n\nYou can [`read`](crate::Reg::read) this register and get [`val::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`val::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:VAL)\n\nFor information about available fields see [`mod@val`]
module"]
    pub type VAL = crate::Reg<val::VALrs>;
    #[doc = "16-bit Timer Value Register"]
    pub mod val {
        #[doc = "Register `VAL` reader"]
        pub type R = crate::R<VALrs>;
        #[doc = "Register `VAL` writer"]
        pub type W = crate::W<VALrs>;
        #[doc = "Field `COUNT_VAL` reader - Current Count"]
        pub type COUNT_VAL_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - Current Count"]
            #[inline(always)]
            pub fn count_val(&self) -> COUNT_VAL_R {
                COUNT_VAL_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VAL")
                    .field("count_val", &self.count_val())
                    .finish()
            }
        }
        impl W {}
        #[doc = "16-bit Timer Value Register\n\nYou can [`read`](crate::Reg::read) this register and get [`val::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`val::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:VAL)"]
        pub struct VALrs;
        impl crate::RegisterSpec for VALrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`val::R`](R) reader structure"]
        impl crate::Readable for VALrs {}
        #[doc = "`write(|w| ..)` method takes [`val::W`](W) writer structure"]
        impl crate::Writable for VALrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets VAL to value 0"]
        impl crate::Resettable for VALrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CON (rw) register accessor: Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:CON)\n\nFor information about available fields see [`mod@con`]
module"]
    pub type CON = crate::Reg<con::CONrs>;
    #[doc = "Control Register"]
    pub mod con {
        #[doc = "Register `CON` reader"]
        pub type R = crate::R<CONrs>;
        #[doc = "Register `CON` writer"]
        pub type W = crate::W<CONrs>;
        #[doc = "Prescaler\n\nValue on reset: 2"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PRE {
            #[doc = "0: Source_clock / \\[1 or 4\\]"]
            Div1or4 = 0,
            #[doc = "1: Source_clock / 16"]
            Div16 = 1,
            #[doc = "2: Source_clock / 256"]
            Div256 = 2,
            #[doc = "3: Source_clock / 32,768"]
            Div32768 = 3,
        }
        impl From<PRE> for u8 {
            #[inline(always)]
            fn from(variant: PRE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PRE {
            type Ux = u8;
        }
        impl crate::IsEnum for PRE {}
        #[doc = "Field `PRE` reader - Prescaler"]
        pub type PRE_R = crate::FieldReader<PRE>;
        impl PRE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PRE {
                match self.bits {
                    0 => PRE::Div1or4,
                    1 => PRE::Div16,
                    2 => PRE::Div256,
                    3 => PRE::Div32768,
                    _ => unreachable!(),
                }
            }
            #[doc = "Source_clock / \\[1 or 4\\]"]
            #[inline(always)]
            pub fn is_div1or4(&self) -> bool {
                *self == PRE::Div1or4
            }
            #[doc = "Source_clock / 16"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PRE::Div16
            }
            #[doc = "Source_clock / 256"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == PRE::Div256
            }
            #[doc = "Source_clock / 32,768"]
            #[inline(always)]
            pub fn is_div32768(&self) -> bool {
                *self == PRE::Div32768
            }
        }
        #[doc = "Field `PRE` writer - Prescaler"]
        pub type PRE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, PRE, crate::Safe>;
        impl<'a, REG> PRE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Source_clock / \\[1 or 4\\]"]
            #[inline(always)]
            pub fn div1or4(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Div1or4)
            }
            #[doc = "Source_clock / 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Div16)
            }
            #[doc = "Source_clock / 256"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Div256)
            }
            #[doc = "Source_clock / 32,768"]
            #[inline(always)]
            pub fn div32768(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Div32768)
            }
        }
        #[doc = "Count up\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UP {
            #[doc = "0: DIS. Timer is Set to Count Down (default)"]
            Dis = 0,
            #[doc = "1: EN. Timer is Set to Count up"]
            En = 1,
        }
        impl From<UP> for bool {
            #[inline(always)]
            fn from(variant: UP) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UP` reader - Count up"]
        pub type UP_R = crate::BitReader<UP>;
        impl UP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> UP {
                match self.bits {
                    false => UP::Dis,
                    true => UP::En,
                }
            }
            #[doc = "DIS. Timer is Set to Count Down (default)"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == UP::Dis
            }
            #[doc = "EN. Timer is Set to Count up"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == UP::En
            }
        }
        #[doc = "Field `UP` writer - Count up"]
        pub type UP_W<'a, REG> = crate::BitWriter<'a, REG, UP>;
        impl<'a, REG> UP_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DIS. Timer is Set to Count Down (default)"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(UP::Dis)
            }
            #[doc = "EN. Timer is Set to Count up"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(UP::En)
            }
        }
        #[doc = "Timer Mode\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MOD {
            #[doc = "0: FREERUN.Timer Runs in Free Running Mode"]
            Freerun = 0,
            #[doc = "1: PERIODIC. Timer Runs in Periodic Mode (default)"]
            Periodic = 1,
        }
        impl From<MOD> for bool {
            #[inline(always)]
            fn from(variant: MOD) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MOD` reader - Timer Mode"]
        pub type MOD_R = crate::BitReader<MOD>;
        impl MOD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MOD {
                match self.bits {
                    false => MOD::Freerun,
                    true => MOD::Periodic,
                }
            }
            #[doc = "FREERUN.Timer Runs in Free Running Mode"]
            #[inline(always)]
            pub fn is_freerun(&self) -> bool {
                *self == MOD::Freerun
            }
            #[doc = "PERIODIC. Timer Runs in Periodic Mode (default)"]
            #[inline(always)]
            pub fn is_periodic(&self) -> bool {
                *self == MOD::Periodic
            }
        }
        #[doc = "Field `MOD` writer - Timer Mode"]
        pub type MOD_W<'a, REG> = crate::BitWriter<'a, REG, MOD>;
        impl<'a, REG> MOD_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "FREERUN.Timer Runs in Free Running Mode"]
            #[inline(always)]
            pub fn freerun(self) -> &'a mut crate::W<REG> {
                self.variant(MOD::Freerun)
            }
            #[doc = "PERIODIC. Timer Runs in Periodic Mode (default)"]
            #[inline(always)]
            pub fn periodic(self) -> &'a mut crate::W<REG> {
                self.variant(MOD::Periodic)
            }
        }
        #[doc = "Timer Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ENABLE {
            #[doc = "0: DIS. Timer is Disabled (default)"]
            Dis = 0,
            #[doc = "1: EN. Timer is Enabled"]
            En = 1,
        }
        impl From<ENABLE> for bool {
            #[inline(always)]
            fn from(variant: ENABLE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ENABLE` reader - Timer Enable"]
        pub type ENABLE_R = crate::BitReader<ENABLE>;
        impl ENABLE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ENABLE {
                match self.bits {
                    false => ENABLE::Dis,
                    true => ENABLE::En,
                }
            }
            #[doc = "DIS. Timer is Disabled (default)"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == ENABLE::Dis
            }
            #[doc = "EN. Timer is Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == ENABLE::En
            }
        }
        #[doc = "Field `ENABLE` writer - Timer Enable"]
        pub type ENABLE_W<'a, REG> = crate::BitWriter<'a, REG, ENABLE>;
        impl<'a, REG> ENABLE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DIS. Timer is Disabled (default)"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(ENABLE::Dis)
            }
            #[doc = "EN. Timer is Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(ENABLE::En)
            }
        }
        #[doc = "Clock Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CLK {
            #[doc = "0: PCLK."]
            Pclk0 = 0,
            #[doc = "1: ROOT_CLK"]
            Hclk = 1,
            #[doc = "2: LFOSC. 32 KHz OSC"]
            Lfosc = 2,
            #[doc = "3: HFXTAL. 16 MHz OSC or XTAL (Dependent on CLKCON0.11)"]
            Hfxtal = 3,
        }
        impl From<CLK> for u8 {
            #[inline(always)]
            fn from(variant: CLK) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CLK {
            type Ux = u8;
        }
        impl crate::IsEnum for CLK {}
        #[doc = "Field `CLK` reader - Clock Select"]
        pub type CLK_R = crate::FieldReader<CLK>;
        impl CLK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CLK {
                match self.bits {
                    0 => CLK::Pclk0,
                    1 => CLK::Hclk,
                    2 => CLK::Lfosc,
                    3 => CLK::Hfxtal,
                    _ => unreachable!(),
                }
            }
            #[doc = "PCLK."]
            #[inline(always)]
            pub fn is_pclk0(&self) -> bool {
                *self == CLK::Pclk0
            }
            #[doc = "ROOT_CLK"]
            #[inline(always)]
            pub fn is_hclk(&self) -> bool {
                *self == CLK::Hclk
            }
            #[doc = "LFOSC. 32 KHz OSC"]
            #[inline(always)]
            pub fn is_lfosc(&self) -> bool {
                *self == CLK::Lfosc
            }
            #[doc = "HFXTAL. 16 MHz OSC or XTAL (Dependent on CLKCON0.11)"]
            #[inline(always)]
            pub fn is_hfxtal(&self) -> bool {
                *self == CLK::Hfxtal
            }
        }
        #[doc = "Field `CLK` writer - Clock Select"]
        pub type CLK_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CLK, crate::Safe>;
        impl<'a, REG> CLK_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "PCLK."]
            #[inline(always)]
            pub fn pclk0(self) -> &'a mut crate::W<REG> {
                self.variant(CLK::Pclk0)
            }
            #[doc = "ROOT_CLK"]
            #[inline(always)]
            pub fn hclk(self) -> &'a mut crate::W<REG> {
                self.variant(CLK::Hclk)
            }
            #[doc = "LFOSC. 32 KHz OSC"]
            #[inline(always)]
            pub fn lfosc(self) -> &'a mut crate::W<REG> {
                self.variant(CLK::Lfosc)
            }
            #[doc = "HFXTAL. 16 MHz OSC or XTAL (Dependent on CLKCON0.11)"]
            #[inline(always)]
            pub fn hfxtal(self) -> &'a mut crate::W<REG> {
                self.variant(CLK::Hfxtal)
            }
        }
        #[doc = "Reload Control\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RLD {
            #[doc = "0: Up/Down Counter is Only Reset on a Timeout Event"]
            Dis = 0,
            #[doc = "1: Resets the Up/down Counter When GPTCLRI\\[0\\]
is Set"]
            En = 1,
        }
        impl From<RLD> for bool {
            #[inline(always)]
            fn from(variant: RLD) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RLD` reader - Reload Control"]
        pub type RLD_R = crate::BitReader<RLD>;
        impl RLD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RLD {
                match self.bits {
                    false => RLD::Dis,
                    true => RLD::En,
                }
            }
            #[doc = "Up/Down Counter is Only Reset on a Timeout Event"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == RLD::Dis
            }
            #[doc = "Resets the Up/down Counter When GPTCLRI\\[0\\]
is Set"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == RLD::En
            }
        }
        #[doc = "Field `RLD` writer - Reload Control"]
        pub type RLD_W<'a, REG> = crate::BitWriter<'a, REG, RLD>;
        impl<'a, REG> RLD_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Up/Down Counter is Only Reset on a Timeout Event"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(RLD::Dis)
            }
            #[doc = "Resets the Up/down Counter When GPTCLRI\\[0\\]
is Set"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(RLD::En)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Prescaler"]
            #[inline(always)]
            pub fn pre(&self) -> PRE_R {
                PRE_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Count up"]
            #[inline(always)]
            pub fn up(&self) -> UP_R {
                UP_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Timer Mode"]
            #[inline(always)]
            pub fn mod_(&self) -> MOD_R {
                MOD_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Timer Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:6 - Clock Select"]
            #[inline(always)]
            pub fn clk(&self) -> CLK_R {
                CLK_R::new(((self.bits >> 5) & 3) as u8)
            }
            #[doc = "Bit 7 - Reload Control"]
            #[inline(always)]
            pub fn rld(&self) -> RLD_R {
                RLD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CON")
                    .field("pre", &self.pre())
                    .field("up", &self.up())
                    .field("mod_", &self.mod_())
                    .field("enable", &self.enable())
                    .field("clk", &self.clk())
                    .field("rld", &self.rld())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Prescaler"]
            #[inline(always)]
            pub fn pre(&mut self) -> PRE_W<CONrs> {
                PRE_W::new(self, 0)
            }
            #[doc = "Bit 2 - Count up"]
            #[inline(always)]
            pub fn up(&mut self) -> UP_W<CONrs> {
                UP_W::new(self, 2)
            }
            #[doc = "Bit 3 - Timer Mode"]
            #[inline(always)]
            pub fn mod_(&mut self) -> MOD_W<CONrs> {
                MOD_W::new(self, 3)
            }
            #[doc = "Bit 4 - Timer Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> ENABLE_W<CONrs> {
                ENABLE_W::new(self, 4)
            }
            #[doc = "Bits 5:6 - Clock Select"]
            #[inline(always)]
            pub fn clk(&mut self) -> CLK_W<CONrs> {
                CLK_W::new(self, 5)
            }
            #[doc = "Bit 7 - Reload Control"]
            #[inline(always)]
            pub fn rld(&mut self) -> RLD_W<CONrs> {
                RLD_W::new(self, 7)
            }
        }
        #[doc = "Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:CON)"]
        pub struct CONrs;
        impl crate::RegisterSpec for CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`con::R`](R) reader structure"]
        impl crate::Readable for CONrs {}
        #[doc = "`write(|w| ..)` method takes [`con::W`](W) writer structure"]
        impl crate::Writable for CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CON to value 0x0a"]
        impl crate::Resettable for CONrs {
            const RESET_VALUE: u32 = 0x0a;
        }
    }
    #[doc = "CLRI (rw) register accessor: Clear Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`clri::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clri::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:CLRI)\n\nFor information about available fields see [`mod@clri`]
module"]
    pub type CLRI = crate::Reg<clri::CLRIrs>;
    #[doc = "Clear Interrupt Register"]
    pub mod clri {
        #[doc = "Register `CLRI` reader"]
        pub type R = crate::R<CLRIrs>;
        #[doc = "Register `CLRI` writer"]
        pub type W = crate::W<CLRIrs>;
        #[doc = "Field `TMOUT` reader - Clear Timeout Interrupt"]
        pub type TMOUT_R = crate::BitReader;
        #[doc = "Field `TMOUT` writer - Clear Timeout Interrupt"]
        pub type TMOUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Clear Timeout Interrupt"]
            #[inline(always)]
            pub fn tmout(&self) -> TMOUT_R {
                TMOUT_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CLRI")
                    .field("tmout", &self.tmout())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Clear Timeout Interrupt"]
            #[inline(always)]
            pub fn tmout(&mut self) -> TMOUT_W<CLRIrs> {
                TMOUT_W::new(self, 0)
            }
        }
        #[doc = "Clear Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`clri::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clri::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:CLRI)"]
        pub struct CLRIrs;
        impl crate::RegisterSpec for CLRIrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clri::R`](R) reader structure"]
        impl crate::Readable for CLRIrs {}
        #[doc = "`write(|w| ..)` method takes [`clri::W`](W) writer structure"]
        impl crate::Writable for CLRIrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CLRI to value 0"]
        impl crate::Resettable for CLRIrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "STA (rw) register accessor: Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sta::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sta::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:STA)\n\nFor information about available fields see [`mod@sta`]
module"]
    pub type STA = crate::Reg<sta::STArs>;
    #[doc = "Status Register"]
    pub mod sta {
        #[doc = "Register `STA` reader"]
        pub type R = crate::R<STArs>;
        #[doc = "Register `STA` writer"]
        pub type W = crate::W<STArs>;
        #[doc = "Timeout Event Occurred\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TMOUT {
            #[doc = "0: No Timeout Event Has Occurred"]
            ClrFlag = 0,
            #[doc = "1: a Timeout Event Has Occurred"]
            SetFlag = 1,
        }
        impl From<TMOUT> for bool {
            #[inline(always)]
            fn from(variant: TMOUT) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TMOUT` reader - Timeout Event Occurred"]
        pub type TMOUT_R = crate::BitReader<TMOUT>;
        impl TMOUT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TMOUT {
                match self.bits {
                    false => TMOUT::ClrFlag,
                    true => TMOUT::SetFlag,
                }
            }
            #[doc = "No Timeout Event Has Occurred"]
            #[inline(always)]
            pub fn is_clr_flag(&self) -> bool {
                *self == TMOUT::ClrFlag
            }
            #[doc = "a Timeout Event Has Occurred"]
            #[inline(always)]
            pub fn is_set_flag(&self) -> bool {
                *self == TMOUT::SetFlag
            }
        }
        #[doc = "Timer Busy\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BUSY {
            #[doc = "0: Timer Ready to Receive Commands to GPTCON"]
            ClrFlag = 0,
            #[doc = "1: Timer Not Ready to Receive Commands to GPTCON"]
            SetFlag = 1,
        }
        impl From<BUSY> for bool {
            #[inline(always)]
            fn from(variant: BUSY) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BUSY` reader - Timer Busy"]
        pub type BUSY_R = crate::BitReader<BUSY>;
        impl BUSY_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BUSY {
                match self.bits {
                    false => BUSY::ClrFlag,
                    true => BUSY::SetFlag,
                }
            }
            #[doc = "Timer Ready to Receive Commands to GPTCON"]
            #[inline(always)]
            pub fn is_clr_flag(&self) -> bool {
                *self == BUSY::ClrFlag
            }
            #[doc = "Timer Not Ready to Receive Commands to GPTCON"]
            #[inline(always)]
            pub fn is_set_flag(&self) -> bool {
                *self == BUSY::SetFlag
            }
        }
        #[doc = "GPTCLRI Synchronization\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PDOK {
            #[doc = "0: CLR. the Interrupt is Cleared in the Timer Clock Domain"]
            ClrFlag = 0,
            #[doc = "1: SET. GPTCLRI\\[0\\]
is Being Updated in the Timer Clock Domain"]
            SetFlag = 1,
        }
        impl From<PDOK> for bool {
            #[inline(always)]
            fn from(variant: PDOK) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PDOK` reader - GPTCLRI Synchronization"]
        pub type PDOK_R = crate::BitReader<PDOK>;
        impl PDOK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PDOK {
                match self.bits {
                    false => PDOK::ClrFlag,
                    true => PDOK::SetFlag,
                }
            }
            #[doc = "CLR. the Interrupt is Cleared in the Timer Clock Domain"]
            #[inline(always)]
            pub fn is_clr_flag(&self) -> bool {
                *self == PDOK::ClrFlag
            }
            #[doc = "SET. GPTCLRI\\[0\\]
is Being Updated in the Timer Clock Domain"]
            #[inline(always)]
            pub fn is_set_flag(&self) -> bool {
                *self == PDOK::SetFlag
            }
        }
        impl R {
            #[doc = "Bit 0 - Timeout Event Occurred"]
            #[inline(always)]
            pub fn tmout(&self) -> TMOUT_R {
                TMOUT_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 6 - Timer Busy"]
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - GPTCLRI Synchronization"]
            #[inline(always)]
            pub fn pdok(&self) -> PDOK_R {
                PDOK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STA")
                    .field("tmout", &self.tmout())
                    .field("busy", &self.busy())
                    .field("pdok", &self.pdok())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sta::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sta::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0:STA)"]
        pub struct STArs;
        impl crate::RegisterSpec for STArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sta::R`](R) reader structure"]
        impl crate::Readable for STArs {}
        #[doc = "`write(|w| ..)` method takes [`sta::W`](W) writer structure"]
        impl crate::Writable for STArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STA to value 0"]
        impl crate::Resettable for STArs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0)"]
pub struct GPT1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPT1 {}
impl GPT1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpt0::RegisterBlock = 0x4000_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPT1 {
    type Target = gpt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPT1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT1").finish()
    }
}
#[doc = "Unknown"]
pub use self::gpt0 as gpt1;
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPT0)"]
pub struct GPT2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPT2 {}
impl GPT2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpt0::RegisterBlock = 0x4000_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPT2 {
    type Target = gpt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPT2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT2").finish()
    }
}
#[doc = "Unknown"]
pub use self::gpt0 as gpt2;
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0)"]
pub struct GPTH0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPTH0 {}
impl GPTH0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpth0::RegisterBlock = 0x4000_0c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpth0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPTH0 {
    type Target = gpth0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPTH0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPTH0").finish()
    }
}
#[doc = "Unknown"]
pub mod gpth0 {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctl: CTL,
        cnt: CNT,
        status: STATUS,
        _reserved3: [u8; 0x04],
        cfg: [CFG; 4],
        cc: [CC; 4],
    }
    impl RegisterBlock {
        #[doc = "0x00 - Timer Control"]
        #[inline(always)]
        pub const fn ctl(&self) -> &CTL {
            &self.ctl
        }
        #[doc = "0x04 - Count Value"]
        #[inline(always)]
        pub const fn cnt(&self) -> &CNT {
            &self.cnt
        }
        #[doc = "0x08 - Timer Status"]
        #[inline(always)]
        pub const fn status(&self) -> &STATUS {
            &self.status
        }
        #[doc = "0x10..0x20 - Capture Compare Configuration"]
        #[inline(always)]
        pub const fn cfg(&self, n: usize) -> &CFG {
            &self.cfg[n]
        }
        #[doc = "Iterator for array of:"]
        #[doc = "0x10..0x20 - Capture Compare Configuration"]
        #[inline(always)]
        pub fn cfg_iter(&self) -> impl Iterator<Item = &CFG> {
            self.cfg.iter()
        }
        #[doc = "0x20..0x30 - Compare and Capture Value"]
        #[inline(always)]
        pub const fn cc(&self, n: usize) -> &CC {
            &self.cc[n]
        }
        #[doc = "Iterator for array of:"]
        #[doc = "0x20..0x30 - Compare and Capture Value"]
        #[inline(always)]
        pub fn cc_iter(&self) -> impl Iterator<Item = &CC> {
            self.cc.iter()
        }
    }
    #[doc = "CTL (rw) register accessor: Timer Control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:CTL)\n\nFor information about available fields see [`mod@ctl`]
module"]
    pub type CTL = crate::Reg<ctl::CTLrs>;
    #[doc = "Timer Control"]
    pub mod ctl {
        #[doc = "Register `CTL` reader"]
        pub type R = crate::R<CTLrs>;
        #[doc = "Register `CTL` writer"]
        pub type W = crate::W<CTLrs>;
        #[doc = "Field `EN` reader - Timer Enable"]
        pub type EN_R = crate::BitReader;
        #[doc = "Field `EN` writer - Timer Enable"]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Clock Source Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SEL {
            #[doc = "0: PCLK"]
            Pclk = 0,
            #[doc = "1: HCLK"]
            Sysclk = 1,
            #[doc = "2: High Frequency Oscillator"]
            Lfosc = 2,
            #[doc = "3: High Frequency XTALL"]
            Hfxstal = 3,
        }
        impl From<SEL> for u8 {
            #[inline(always)]
            fn from(variant: SEL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for SEL {
            type Ux = u8;
        }
        impl crate::IsEnum for SEL {}
        #[doc = "Field `SEL` reader - Clock Source Select"]
        pub type SEL_R = crate::FieldReader<SEL>;
        impl SEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SEL {
                match self.bits {
                    0 => SEL::Pclk,
                    1 => SEL::Sysclk,
                    2 => SEL::Lfosc,
                    3 => SEL::Hfxstal,
                    _ => unreachable!(),
                }
            }
            #[doc = "PCLK"]
            #[inline(always)]
            pub fn is_pclk(&self) -> bool {
                *self == SEL::Pclk
            }
            #[doc = "HCLK"]
            #[inline(always)]
            pub fn is_sysclk(&self) -> bool {
                *self == SEL::Sysclk
            }
            #[doc = "High Frequency Oscillator"]
            #[inline(always)]
            pub fn is_lfosc(&self) -> bool {
                *self == SEL::Lfosc
            }
            #[doc = "High Frequency XTALL"]
            #[inline(always)]
            pub fn is_hfxstal(&self) -> bool {
                *self == SEL::Hfxstal
            }
        }
        #[doc = "Field `SEL` writer - Clock Source Select"]
        pub type SEL_W<'a, REG> = crate::FieldWriter<'a, REG, 2, SEL, crate::Safe>;
        impl<'a, REG> SEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "PCLK"]
            #[inline(always)]
            pub fn pclk(self) -> &'a mut crate::W<REG> {
                self.variant(SEL::Pclk)
            }
            #[doc = "HCLK"]
            #[inline(always)]
            pub fn sysclk(self) -> &'a mut crate::W<REG> {
                self.variant(SEL::Sysclk)
            }
            #[doc = "High Frequency Oscillator"]
            #[inline(always)]
            pub fn lfosc(self) -> &'a mut crate::W<REG> {
                self.variant(SEL::Lfosc)
            }
            #[doc = "High Frequency XTALL"]
            #[inline(always)]
            pub fn hfxstal(self) -> &'a mut crate::W<REG> {
                self.variant(SEL::Hfxstal)
            }
        }
        #[doc = "Field `PRE` reader - Timer Prescale"]
        pub type PRE_R = crate::FieldReader;
        #[doc = "Field `PRE` writer - Timer Prescale"]
        pub type PRE_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        impl R {
            #[doc = "Bit 0 - Timer Enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 2:3 - Clock Source Select"]
            #[inline(always)]
            pub fn sel(&self) -> SEL_R {
                SEL_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:8 - Timer Prescale"]
            #[inline(always)]
            pub fn pre(&self) -> PRE_R {
                PRE_R::new(((self.bits >> 4) & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CTL")
                    .field("en", &self.en())
                    .field("sel", &self.sel())
                    .field("pre", &self.pre())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Timer Enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<CTLrs> {
                EN_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - Clock Source Select"]
            #[inline(always)]
            pub fn sel(&mut self) -> SEL_W<CTLrs> {
                SEL_W::new(self, 2)
            }
            #[doc = "Bits 4:8 - Timer Prescale"]
            #[inline(always)]
            pub fn pre(&mut self) -> PRE_W<CTLrs> {
                PRE_W::new(self, 4)
            }
        }
        #[doc = "Timer Control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:CTL)"]
        pub struct CTLrs;
        impl crate::RegisterSpec for CTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctl::R`](R) reader structure"]
        impl crate::Readable for CTLrs {}
        #[doc = "`write(|w| ..)` method takes [`ctl::W`](W) writer structure"]
        impl crate::Writable for CTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CTL to value 0x0170"]
        impl crate::Resettable for CTLrs {
            const RESET_VALUE: u32 = 0x0170;
        }
    }
    #[doc = "CNT (rw) register accessor: Count Value\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:CNT)\n\nFor information about available fields see [`mod@cnt`]
module"]
    pub type CNT = crate::Reg<cnt::CNTrs>;
    #[doc = "Count Value"]
    pub mod cnt {
        #[doc = "Register `CNT` reader"]
        pub type R = crate::R<CNTrs>;
        #[doc = "Register `CNT` writer"]
        pub type W = crate::W<CNTrs>;
        #[doc = "Field `CNT` reader - Current Counter Value."]
        pub type CNT_R = crate::FieldReader<u32>;
        #[doc = "Field `CNT` writer - Current Counter Value."]
        pub type CNT_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Current Counter Value."]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CNT").field("cnt", &self.cnt()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Current Counter Value."]
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W<CNTrs> {
                CNT_W::new(self, 0)
            }
        }
        #[doc = "Count Value\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:CNT)"]
        pub struct CNTrs;
        impl crate::RegisterSpec for CNTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt::R`](R) reader structure"]
        impl crate::Readable for CNTrs {}
        #[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
        impl crate::Writable for CNTrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CNT to value 0"]
        impl crate::Resettable for CNTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "STATUS (rw) register accessor: Timer Status\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:STATUS)\n\nFor information about available fields see [`mod@status`]
module"]
    pub type STATUS = crate::Reg<status::STATUSrs>;
    #[doc = "Timer Status"]
    pub mod status {
        #[doc = "Register `STATUS` reader"]
        pub type R = crate::R<STATUSrs>;
        #[doc = "Register `STATUS` writer"]
        pub type W = crate::W<STATUSrs>;
        #[doc = "Field `cc0_status` reader - CC0 Status"]
        pub type CC0_STATUS_R = crate::BitReader;
        #[doc = "Field `cc0_status` writer - CC0 Status"]
        pub type CC0_STATUS_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `cc1_status` reader - CC1 Status"]
        pub type CC1_STATUS_R = crate::BitReader;
        #[doc = "Field `cc1_status` writer - CC1 Status"]
        pub type CC1_STATUS_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `cc2_status` reader - CC2 Status"]
        pub type CC2_STATUS_R = crate::BitReader;
        #[doc = "Field `cc2_status` writer - CC2 Status"]
        pub type CC2_STATUS_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `cc3_status` reader - CC3 Status"]
        pub type CC3_STATUS_R = crate::BitReader;
        #[doc = "Field `cc3_status` writer - CC3 Status"]
        pub type CC3_STATUS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - CC0 Status"]
            #[inline(always)]
            pub fn cc0_status(&self) -> CC0_STATUS_R {
                CC0_STATUS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - CC1 Status"]
            #[inline(always)]
            pub fn cc1_status(&self) -> CC1_STATUS_R {
                CC1_STATUS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - CC2 Status"]
            #[inline(always)]
            pub fn cc2_status(&self) -> CC2_STATUS_R {
                CC2_STATUS_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - CC3 Status"]
            #[inline(always)]
            pub fn cc3_status(&self) -> CC3_STATUS_R {
                CC3_STATUS_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STATUS")
                    .field("cc0_status", &self.cc0_status())
                    .field("cc1_status", &self.cc1_status())
                    .field("cc2_status", &self.cc2_status())
                    .field("cc3_status", &self.cc3_status())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - CC0 Status"]
            #[inline(always)]
            pub fn cc0_status(&mut self) -> CC0_STATUS_W<STATUSrs> {
                CC0_STATUS_W::new(self, 0)
            }
            #[doc = "Bit 1 - CC1 Status"]
            #[inline(always)]
            pub fn cc1_status(&mut self) -> CC1_STATUS_W<STATUSrs> {
                CC1_STATUS_W::new(self, 1)
            }
            #[doc = "Bit 2 - CC2 Status"]
            #[inline(always)]
            pub fn cc2_status(&mut self) -> CC2_STATUS_W<STATUSrs> {
                CC2_STATUS_W::new(self, 2)
            }
            #[doc = "Bit 3 - CC3 Status"]
            #[inline(always)]
            pub fn cc3_status(&mut self) -> CC3_STATUS_W<STATUSrs> {
                CC3_STATUS_W::new(self, 3)
            }
        }
        #[doc = "Timer Status\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:STATUS)"]
        pub struct STATUSrs;
        impl crate::RegisterSpec for STATUSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`status::R`](R) reader structure"]
        impl crate::Readable for STATUSrs {}
        #[doc = "`write(|w| ..)` method takes [`status::W`](W) writer structure"]
        impl crate::Writable for STATUSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STATUS to value 0"]
        impl crate::Resettable for STATUSrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CFG (rw) register accessor: Capture Compare Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:CFG[0])\n\nFor information about available fields see [`mod@cfg`]
module"]
    pub type CFG = crate::Reg<cfg::CFGrs>;
    #[doc = "Capture Compare Configuration"]
    pub mod cfg {
        #[doc = "Register `CFG[%s]` reader"]
        pub type R = crate::R<CFGrs>;
        #[doc = "Register `CFG[%s]` writer"]
        pub type W = crate::W<CFGrs>;
        #[doc = "Capture or Compare Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE {
            #[doc = "0: Compare"]
            Cmp = 0,
            #[doc = "1: Capture"]
            Cap = 1,
        }
        impl From<MODE> for bool {
            #[inline(always)]
            fn from(variant: MODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MODE` reader - Capture or Compare Mode"]
        pub type MODE_R = crate::BitReader<MODE>;
        impl MODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MODE {
                match self.bits {
                    false => MODE::Cmp,
                    true => MODE::Cap,
                }
            }
            #[doc = "Compare"]
            #[inline(always)]
            pub fn is_cmp(&self) -> bool {
                *self == MODE::Cmp
            }
            #[doc = "Capture"]
            #[inline(always)]
            pub fn is_cap(&self) -> bool {
                *self == MODE::Cap
            }
        }
        #[doc = "Field `MODE` writer - Capture or Compare Mode"]
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG, MODE>;
        impl<'a, REG> MODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Compare"]
            #[inline(always)]
            pub fn cmp(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Cmp)
            }
            #[doc = "Capture"]
            #[inline(always)]
            pub fn cap(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Cap)
            }
        }
        #[doc = "Field `CC_EN` reader - Capture Compare Enabled"]
        pub type CC_EN_R = crate::BitReader;
        #[doc = "Field `CC_EN` writer - Capture Compare Enabled"]
        pub type CC_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EVENT_SEL` reader - Capture Events Select"]
        pub type EVENT_SEL_R = crate::FieldReader;
        #[doc = "Field `EVENT_SEL` writer - Capture Events Select"]
        pub type EVENT_SEL_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        impl R {
            #[doc = "Bit 0 - Capture or Compare Mode"]
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Capture Compare Enabled"]
            #[inline(always)]
            pub fn cc_en(&self) -> CC_EN_R {
                CC_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:5 - Capture Events Select"]
            #[inline(always)]
            pub fn event_sel(&self) -> EVENT_SEL_R {
                EVENT_SEL_R::new(((self.bits >> 2) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CFG")
                    .field("mode", &self.mode())
                    .field("cc_en", &self.cc_en())
                    .field("event_sel", &self.event_sel())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Capture or Compare Mode"]
            #[inline(always)]
            pub fn mode(&mut self) -> MODE_W<CFGrs> {
                MODE_W::new(self, 0)
            }
            #[doc = "Bit 1 - Capture Compare Enabled"]
            #[inline(always)]
            pub fn cc_en(&mut self) -> CC_EN_W<CFGrs> {
                CC_EN_W::new(self, 1)
            }
            #[doc = "Bits 2:5 - Capture Events Select"]
            #[inline(always)]
            pub fn event_sel(&mut self) -> EVENT_SEL_W<CFGrs> {
                EVENT_SEL_W::new(self, 2)
            }
        }
        #[doc = "Capture Compare Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:CFG[0])"]
        pub struct CFGrs;
        impl crate::RegisterSpec for CFGrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CFGrs {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CFGrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CFG[%s]
to value 0"]
        impl crate::Resettable for CFGrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CC (rw) register accessor: Compare and Capture Value\n\nYou can [`read`](crate::Reg::read) this register and get [`cc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:CC[0])\n\nFor information about available fields see [`mod@cc`]
module"]
    pub type CC = crate::Reg<cc::CCrs>;
    #[doc = "Compare and Capture Value"]
    pub mod cc {
        #[doc = "Register `CC[%s]` reader"]
        pub type R = crate::R<CCrs>;
        #[doc = "Register `CC[%s]` writer"]
        pub type W = crate::W<CCrs>;
        #[doc = "Field `CC` reader - Capture or Compare Value"]
        pub type CC_R = crate::FieldReader<u32>;
        #[doc = "Field `CC` writer - Capture or Compare Value"]
        pub type CC_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Capture or Compare Value"]
            #[inline(always)]
            pub fn cc(&self) -> CC_R {
                CC_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CC").field("cc", &self.cc()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Capture or Compare Value"]
            #[inline(always)]
            pub fn cc(&mut self) -> CC_W<CCrs> {
                CC_W::new(self, 0)
            }
        }
        #[doc = "Compare and Capture Value\n\nYou can [`read`](crate::Reg::read) this register and get [`cc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0:CC[0])"]
        pub struct CCrs;
        impl crate::RegisterSpec for CCrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cc::R`](R) reader structure"]
        impl crate::Readable for CCrs {}
        #[doc = "`write(|w| ..)` method takes [`cc::W`](W) writer structure"]
        impl crate::Writable for CCrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CC[%s]
to value 0"]
        impl crate::Resettable for CCrs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPTH0)"]
pub struct GPTH1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPTH1 {}
impl GPTH1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpth0::RegisterBlock = 0x4000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpth0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPTH1 {
    type Target = gpth0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPTH1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPTH1").finish()
    }
}
#[doc = "Unknown"]
pub use self::gpth0 as gpth1;
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MISC16)"]
pub struct MISC16 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MISC16 {}
impl MISC16 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const misc16::RegisterBlock = 0x4000_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const misc16::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MISC16 {
    type Target = misc16::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MISC16 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MISC16").finish()
    }
}
#[doc = "Unknown"]
pub mod misc16 {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x20],
        adiid: ADIID,
        chipid: CHIPID,
        _reserved2: [u8; 0x010c],
        userkey: USERKEY,
    }
    impl RegisterBlock {
        #[doc = "0x20 - ADI ID"]
        #[inline(always)]
        pub const fn adiid(&self) -> &ADIID {
            &self.adiid
        }
        #[doc = "0x24 - Chip ID"]
        #[inline(always)]
        pub const fn chipid(&self) -> &CHIPID {
            &self.chipid
        }
        #[doc = "0x134 - Open to Customer to Protect Important Registers"]
        #[inline(always)]
        pub const fn userkey(&self) -> &USERKEY {
            &self.userkey
        }
    }
    #[doc = "ADIID (rw) register accessor: ADI ID\n\nYou can [`read`](crate::Reg::read) this register and get [`adiid::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adiid::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MISC16:ADIID)\n\nFor information about available fields see [`mod@adiid`]
module"]
    pub type ADIID = crate::Reg<adiid::ADIIDrs>;
    #[doc = "ADI ID"]
    pub mod adiid {
        #[doc = "Register `ADIID` reader"]
        pub type R = crate::R<ADIIDrs>;
        #[doc = "Register `ADIID` writer"]
        pub type W = crate::W<ADIIDrs>;
        #[doc = "Field `ADIID` reader - ADI ID"]
        pub type ADIID_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - ADI ID"]
            #[inline(always)]
            pub fn adiid(&self) -> ADIID_R {
                ADIID_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADIID")
                    .field("adiid", &self.adiid())
                    .finish()
            }
        }
        impl W {}
        #[doc = "ADI ID\n\nYou can [`read`](crate::Reg::read) this register and get [`adiid::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adiid::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MISC16:ADIID)"]
        pub struct ADIIDrs;
        impl crate::RegisterSpec for ADIIDrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adiid::R`](R) reader structure"]
        impl crate::Readable for ADIIDrs {}
        #[doc = "`write(|w| ..)` method takes [`adiid::W`](W) writer structure"]
        impl crate::Writable for ADIIDrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADIID to value 0x4144"]
        impl crate::Resettable for ADIIDrs {
            const RESET_VALUE: u32 = 0x4144;
        }
    }
    #[doc = "CHIPID (rw) register accessor: Chip ID\n\nYou can [`read`](crate::Reg::read) this register and get [`chipid::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chipid::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MISC16:CHIPID)\n\nFor information about available fields see [`mod@chipid`]
module"]
    pub type CHIPID = crate::Reg<chipid::CHIPIDrs>;
    #[doc = "Chip ID"]
    pub mod chipid {
        #[doc = "Register `CHIPID` reader"]
        pub type R = crate::R<CHIPIDrs>;
        #[doc = "Register `CHIPID` writer"]
        pub type W = crate::W<CHIPIDrs>;
        #[doc = "Field `REVISION` reader - Silicon Revision Number"]
        pub type REVISION_R = crate::FieldReader;
        #[doc = "Field `PARTID` reader - Part Identifier"]
        pub type PARTID_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:3 - Silicon Revision Number"]
            #[inline(always)]
            pub fn revision(&self) -> REVISION_R {
                REVISION_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:15 - Part Identifier"]
            #[inline(always)]
            pub fn partid(&self) -> PARTID_R {
                PARTID_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CHIPID")
                    .field("revision", &self.revision())
                    .field("partid", &self.partid())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Chip ID\n\nYou can [`read`](crate::Reg::read) this register and get [`chipid::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chipid::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MISC16:CHIPID)"]
        pub struct CHIPIDrs;
        impl crate::RegisterSpec for CHIPIDrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`chipid::R`](R) reader structure"]
        impl crate::Readable for CHIPIDrs {}
        #[doc = "`write(|w| ..)` method takes [`chipid::W`](W) writer structure"]
        impl crate::Writable for CHIPIDrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CHIPID to value 0x0571"]
        impl crate::Resettable for CHIPIDrs {
            const RESET_VALUE: u32 = 0x0571;
        }
    }
    #[doc = "USERKEY (rw) register accessor: Open to Customer to Protect Important Registers\n\nYou can [`read`](crate::Reg::read) this register and get [`userkey::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`userkey::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MISC16:USERKEY)\n\nFor information about available fields see [`mod@userkey`]
module"]
    pub type USERKEY = crate::Reg<userkey::USERKEYrs>;
    #[doc = "Open to Customer to Protect Important Registers"]
    pub mod userkey {
        #[doc = "Register `USERKEY` reader"]
        pub type R = crate::R<USERKEYrs>;
        #[doc = "Register `USERKEY` writer"]
        pub type W = crate::W<USERKEYrs>;
        #[doc = "Field `KEY` writer - User Key"]
        pub type KEY_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("USERKEY").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - User Key"]
            #[inline(always)]
            pub fn key(&mut self) -> KEY_W<USERKEYrs> {
                KEY_W::new(self, 0)
            }
        }
        #[doc = "Open to Customer to Protect Important Registers\n\nYou can [`read`](crate::Reg::read) this register and get [`userkey::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`userkey::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MISC16:USERKEY)"]
        pub struct USERKEYrs;
        impl crate::RegisterSpec for USERKEYrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`userkey::R`](R) reader structure"]
        impl crate::Readable for USERKEYrs {}
        #[doc = "`write(|w| ..)` method takes [`userkey::W`](W) writer structure"]
        impl crate::Writable for USERKEYrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets USERKEY to value 0"]
        impl crate::Resettable for USERKEYrs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT)"]
pub struct WUT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WUT {}
impl WUT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wut::RegisterBlock = 0x4000_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wut::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for WUT {
    type Target = wut::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WUT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WUT").finish()
    }
}
#[doc = "Unknown"]
pub mod wut {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        t4val0: T4VAL0,
        t4val1: T4VAL1,
        t4con: T4CON,
        t4inc: T4INC,
        t4wufb0: T4WUFB0,
        t4wufb1: T4WUFB1,
        t4wufc0: T4WUFC0,
        t4wufc1: T4WUFC1,
        t4wufd0: T4WUFD0,
        t4wufd1: T4WUFD1,
        t4ien: T4IEN,
        t4sta: T4STA,
        t4clri: T4CLRI,
        _reserved13: [u8; 0x08],
        t4wufa0: T4WUFA0,
        t4wufa1: T4WUFA1,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Current Count Value - LS 16 Bits"]
        #[inline(always)]
        pub const fn t4val0(&self) -> &T4VAL0 {
            &self.t4val0
        }
        #[doc = "0x04 - Current Count Value - MS 16 Bits"]
        #[inline(always)]
        pub const fn t4val1(&self) -> &T4VAL1 {
            &self.t4val1
        }
        #[doc = "0x08 - Control Register"]
        #[inline(always)]
        pub const fn t4con(&self) -> &T4CON {
            &self.t4con
        }
        #[doc = "0x0c - 12-bit Interval for Wakeup Field a"]
        #[inline(always)]
        pub const fn t4inc(&self) -> &T4INC {
            &self.t4inc
        }
        #[doc = "0x10 - Wakeup Field B - LS 16 Bits"]
        #[inline(always)]
        pub const fn t4wufb0(&self) -> &T4WUFB0 {
            &self.t4wufb0
        }
        #[doc = "0x14 - Wakeup Field B - MS 16 Bits"]
        #[inline(always)]
        pub const fn t4wufb1(&self) -> &T4WUFB1 {
            &self.t4wufb1
        }
        #[doc = "0x18 - Wakeup Field C - LS 16 Bits"]
        #[inline(always)]
        pub const fn t4wufc0(&self) -> &T4WUFC0 {
            &self.t4wufc0
        }
        #[doc = "0x1c - Wakeup Field C - MS 16 Bits"]
        #[inline(always)]
        pub const fn t4wufc1(&self) -> &T4WUFC1 {
            &self.t4wufc1
        }
        #[doc = "0x20 - Wakeup Field D - LS 16 Bits"]
        #[inline(always)]
        pub const fn t4wufd0(&self) -> &T4WUFD0 {
            &self.t4wufd0
        }
        #[doc = "0x24 - Wakeup Field D - MS 16 Bits"]
        #[inline(always)]
        pub const fn t4wufd1(&self) -> &T4WUFD1 {
            &self.t4wufd1
        }
        #[doc = "0x28 - Interrupt Enable Register"]
        #[inline(always)]
        pub const fn t4ien(&self) -> &T4IEN {
            &self.t4ien
        }
        #[doc = "0x2c - Status Register"]
        #[inline(always)]
        pub const fn t4sta(&self) -> &T4STA {
            &self.t4sta
        }
        #[doc = "0x30 - Clear Interrupt Register"]
        #[inline(always)]
        pub const fn t4clri(&self) -> &T4CLRI {
            &self.t4clri
        }
        #[doc = "0x3c - Wakeup Field a - LS 16 Bits"]
        #[inline(always)]
        pub const fn t4wufa0(&self) -> &T4WUFA0 {
            &self.t4wufa0
        }
        #[doc = "0x40 - Wakeup Field a - MS 16 Bits"]
        #[inline(always)]
        pub const fn t4wufa1(&self) -> &T4WUFA1 {
            &self.t4wufa1
        }
    }
    #[doc = "T4VAL0 (rw) register accessor: Current Count Value - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4val0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4val0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4VAL0)\n\nFor information about available fields see [`mod@t4val0`]
module"]
    pub type T4VAL0 = crate::Reg<t4val0::T4VAL0rs>;
    #[doc = "Current Count Value - LS 16 Bits"]
    pub mod t4val0 {
        #[doc = "Register `T4VAL0` reader"]
        pub type R = crate::R<T4VAL0rs>;
        #[doc = "Register `T4VAL0` writer"]
        pub type W = crate::W<T4VAL0rs>;
        #[doc = "Field `T4VALL` reader - Current Count Low"]
        pub type T4VALL_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - Current Count Low"]
            #[inline(always)]
            pub fn t4vall(&self) -> T4VALL_R {
                T4VALL_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4VAL0")
                    .field("t4vall", &self.t4vall())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Current Count Value - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4val0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4val0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4VAL0)"]
        pub struct T4VAL0rs;
        impl crate::RegisterSpec for T4VAL0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4val0::R`](R) reader structure"]
        impl crate::Readable for T4VAL0rs {}
        #[doc = "`write(|w| ..)` method takes [`t4val0::W`](W) writer structure"]
        impl crate::Writable for T4VAL0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4VAL0 to value 0"]
        impl crate::Resettable for T4VAL0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "T4VAL1 (rw) register accessor: Current Count Value - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4val1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4val1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4VAL1)\n\nFor information about available fields see [`mod@t4val1`]
module"]
    pub type T4VAL1 = crate::Reg<t4val1::T4VAL1rs>;
    #[doc = "Current Count Value - MS 16 Bits"]
    pub mod t4val1 {
        #[doc = "Register `T4VAL1` reader"]
        pub type R = crate::R<T4VAL1rs>;
        #[doc = "Register `T4VAL1` writer"]
        pub type W = crate::W<T4VAL1rs>;
        #[doc = "Field `T4VALH` reader - Current Count High"]
        pub type T4VALH_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - Current Count High"]
            #[inline(always)]
            pub fn t4valh(&self) -> T4VALH_R {
                T4VALH_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4VAL1")
                    .field("t4valh", &self.t4valh())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Current Count Value - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4val1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4val1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4VAL1)"]
        pub struct T4VAL1rs;
        impl crate::RegisterSpec for T4VAL1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4val1::R`](R) reader structure"]
        impl crate::Readable for T4VAL1rs {}
        #[doc = "`write(|w| ..)` method takes [`t4val1::W`](W) writer structure"]
        impl crate::Writable for T4VAL1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4VAL1 to value 0"]
        impl crate::Resettable for T4VAL1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "T4CON (rw) register accessor: Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`t4con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4CON)\n\nFor information about available fields see [`mod@t4con`]
module"]
    pub type T4CON = crate::Reg<t4con::T4CONrs>;
    #[doc = "Control Register"]
    pub mod t4con {
        #[doc = "Register `T4CON` reader"]
        pub type R = crate::R<T4CONrs>;
        #[doc = "Register `T4CON` writer"]
        pub type W = crate::W<T4CONrs>;
        #[doc = "Prescaler\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PRE {
            #[doc = "0: PREDIV1: Source Clock/1 (default). If the Selected Clock Source is PCLK, Then This Setting Results in a Prescaler of 4."]
            Prediv1 = 0,
            #[doc = "1: PREDIV16: Source Clock/16"]
            Prediv16 = 1,
            #[doc = "2: PREDIV256: Source Clock/256"]
            Prediv256 = 2,
            #[doc = "3: PREDIV32768: Source Clock/32,768"]
            Prediv32768 = 3,
        }
        impl From<PRE> for u8 {
            #[inline(always)]
            fn from(variant: PRE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PRE {
            type Ux = u8;
        }
        impl crate::IsEnum for PRE {}
        #[doc = "Field `PRE` reader - Prescaler"]
        pub type PRE_R = crate::FieldReader<PRE>;
        impl PRE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PRE {
                match self.bits {
                    0 => PRE::Prediv1,
                    1 => PRE::Prediv16,
                    2 => PRE::Prediv256,
                    3 => PRE::Prediv32768,
                    _ => unreachable!(),
                }
            }
            #[doc = "PREDIV1: Source Clock/1 (default). If the Selected Clock Source is PCLK, Then This Setting Results in a Prescaler of 4."]
            #[inline(always)]
            pub fn is_prediv1(&self) -> bool {
                *self == PRE::Prediv1
            }
            #[doc = "PREDIV16: Source Clock/16"]
            #[inline(always)]
            pub fn is_prediv16(&self) -> bool {
                *self == PRE::Prediv16
            }
            #[doc = "PREDIV256: Source Clock/256"]
            #[inline(always)]
            pub fn is_prediv256(&self) -> bool {
                *self == PRE::Prediv256
            }
            #[doc = "PREDIV32768: Source Clock/32,768"]
            #[inline(always)]
            pub fn is_prediv32768(&self) -> bool {
                *self == PRE::Prediv32768
            }
        }
        #[doc = "Field `PRE` writer - Prescaler"]
        pub type PRE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, PRE, crate::Safe>;
        impl<'a, REG> PRE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "PREDIV1: Source Clock/1 (default). If the Selected Clock Source is PCLK, Then This Setting Results in a Prescaler of 4."]
            #[inline(always)]
            pub fn prediv1(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Prediv1)
            }
            #[doc = "PREDIV16: Source Clock/16"]
            #[inline(always)]
            pub fn prediv16(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Prediv16)
            }
            #[doc = "PREDIV256: Source Clock/256"]
            #[inline(always)]
            pub fn prediv256(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Prediv256)
            }
            #[doc = "PREDIV32768: Source Clock/32,768"]
            #[inline(always)]
            pub fn prediv32768(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Prediv32768)
            }
        }
        #[doc = "Freeze Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FREEZE {
            #[doc = "0: DIS: Cleared by User to Disable This Feature (default)."]
            Dis = 0,
            #[doc = "1: EN: Set by User to Enable the Freeze of the High 16-bits After the Lower Bits Have Been Read from T4VAL0. This Ensures That the Software Will Read an Atomic Shot of the Timer. T4VAL1 Unfreezes After It Has Been Read."]
            En = 1,
        }
        impl From<FREEZE> for bool {
            #[inline(always)]
            fn from(variant: FREEZE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FREEZE` reader - Freeze Enable"]
        pub type FREEZE_R = crate::BitReader<FREEZE>;
        impl FREEZE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FREEZE {
                match self.bits {
                    false => FREEZE::Dis,
                    true => FREEZE::En,
                }
            }
            #[doc = "DIS: Cleared by User to Disable This Feature (default)."]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == FREEZE::Dis
            }
            #[doc = "EN: Set by User to Enable the Freeze of the High 16-bits After the Lower Bits Have Been Read from T4VAL0. This Ensures That the Software Will Read an Atomic Shot of the Timer. T4VAL1 Unfreezes After It Has Been Read."]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == FREEZE::En
            }
        }
        #[doc = "Field `FREEZE` writer - Freeze Enable"]
        pub type FREEZE_W<'a, REG> = crate::BitWriter<'a, REG, FREEZE>;
        impl<'a, REG> FREEZE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DIS: Cleared by User to Disable This Feature (default)."]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(FREEZE::Dis)
            }
            #[doc = "EN: Set by User to Enable the Freeze of the High 16-bits After the Lower Bits Have Been Read from T4VAL0. This Ensures That the Software Will Read an Atomic Shot of the Timer. T4VAL1 Unfreezes After It Has Been Read."]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(FREEZE::En)
            }
        }
        #[doc = "Timer Mode\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TMODE {
            #[doc = "0: PERIODIC: Cleared by User to Operate in Periodic Mode. in This Mode, the Timer Counts up to T4WUFD"]
            Periodic = 0,
            #[doc = "1: FREERUN: Set by User to Operate in Free Running Mode (default)."]
            Freerun = 1,
        }
        impl From<TMODE> for bool {
            #[inline(always)]
            fn from(variant: TMODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TMODE` reader - Timer Mode"]
        pub type TMODE_R = crate::BitReader<TMODE>;
        impl TMODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TMODE {
                match self.bits {
                    false => TMODE::Periodic,
                    true => TMODE::Freerun,
                }
            }
            #[doc = "PERIODIC: Cleared by User to Operate in Periodic Mode. in This Mode, the Timer Counts up to T4WUFD"]
            #[inline(always)]
            pub fn is_periodic(&self) -> bool {
                *self == TMODE::Periodic
            }
            #[doc = "FREERUN: Set by User to Operate in Free Running Mode (default)."]
            #[inline(always)]
            pub fn is_freerun(&self) -> bool {
                *self == TMODE::Freerun
            }
        }
        #[doc = "Field `TMODE` writer - Timer Mode"]
        pub type TMODE_W<'a, REG> = crate::BitWriter<'a, REG, TMODE>;
        impl<'a, REG> TMODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PERIODIC: Cleared by User to Operate in Periodic Mode. in This Mode, the Timer Counts up to T4WUFD"]
            #[inline(always)]
            pub fn periodic(self) -> &'a mut crate::W<REG> {
                self.variant(TMODE::Periodic)
            }
            #[doc = "FREERUN: Set by User to Operate in Free Running Mode (default)."]
            #[inline(always)]
            pub fn freerun(self) -> &'a mut crate::W<REG> {
                self.variant(TMODE::Freerun)
            }
        }
        #[doc = "Timer Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ENABLE {
            #[doc = "0: DIS: Disable the Timer (default)."]
            Dis = 0,
            #[doc = "1: EN: Enable the Timer."]
            En = 1,
        }
        impl From<ENABLE> for bool {
            #[inline(always)]
            fn from(variant: ENABLE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ENABLE` reader - Timer Enable"]
        pub type ENABLE_R = crate::BitReader<ENABLE>;
        impl ENABLE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ENABLE {
                match self.bits {
                    false => ENABLE::Dis,
                    true => ENABLE::En,
                }
            }
            #[doc = "DIS: Disable the Timer (default)."]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == ENABLE::Dis
            }
            #[doc = "EN: Enable the Timer."]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == ENABLE::En
            }
        }
        #[doc = "Field `ENABLE` writer - Timer Enable"]
        pub type ENABLE_W<'a, REG> = crate::BitWriter<'a, REG, ENABLE>;
        impl<'a, REG> ENABLE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DIS: Disable the Timer (default)."]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(ENABLE::Dis)
            }
            #[doc = "EN: Enable the Timer."]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(ENABLE::En)
            }
        }
        #[doc = "Wakeup Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WUEN {
            #[doc = "0: DIS: Cleared by User to Disable the Wake up Timer When the Core Clock is off"]
            Dis = 0,
            #[doc = "1: EN: Set by User to Enable the Wake up Timer Even When the Core Clock is Off."]
            En = 1,
        }
        impl From<WUEN> for bool {
            #[inline(always)]
            fn from(variant: WUEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `WUEN` reader - Wakeup Enable"]
        pub type WUEN_R = crate::BitReader<WUEN>;
        impl WUEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> WUEN {
                match self.bits {
                    false => WUEN::Dis,
                    true => WUEN::En,
                }
            }
            #[doc = "DIS: Cleared by User to Disable the Wake up Timer When the Core Clock is off"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == WUEN::Dis
            }
            #[doc = "EN: Set by User to Enable the Wake up Timer Even When the Core Clock is Off."]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == WUEN::En
            }
        }
        #[doc = "Field `WUEN` writer - Wakeup Enable"]
        pub type WUEN_W<'a, REG> = crate::BitWriter<'a, REG, WUEN>;
        impl<'a, REG> WUEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DIS: Cleared by User to Disable the Wake up Timer When the Core Clock is off"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(WUEN::Dis)
            }
            #[doc = "EN: Set by User to Enable the Wake up Timer Even When the Core Clock is Off."]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(WUEN::En)
            }
        }
        #[doc = "Clock Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CLK {
            #[doc = "0: PCLK: PCLK (default)"]
            Pclk = 0,
            #[doc = "1: LFOSC: 32 KHz Internal Oscillator"]
            Lfosc = 1,
            #[doc = "2: LFOSC: 32kHz Internal Oscillator"]
            Lfosc1 = 2,
            #[doc = "3: ECLKIN: External Clock from P1.0"]
            Eclkin = 3,
        }
        impl From<CLK> for u8 {
            #[inline(always)]
            fn from(variant: CLK) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CLK {
            type Ux = u8;
        }
        impl crate::IsEnum for CLK {}
        #[doc = "Field `CLK` reader - Clock Select"]
        pub type CLK_R = crate::FieldReader<CLK>;
        impl CLK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CLK {
                match self.bits {
                    0 => CLK::Pclk,
                    1 => CLK::Lfosc,
                    2 => CLK::Lfosc1,
                    3 => CLK::Eclkin,
                    _ => unreachable!(),
                }
            }
            #[doc = "PCLK: PCLK (default)"]
            #[inline(always)]
            pub fn is_pclk(&self) -> bool {
                *self == CLK::Pclk
            }
            #[doc = "LFOSC: 32 KHz Internal Oscillator"]
            #[inline(always)]
            pub fn is_lfosc(&self) -> bool {
                *self == CLK::Lfosc
            }
            #[doc = "LFOSC: 32kHz Internal Oscillator"]
            #[inline(always)]
            pub fn is_lfosc1(&self) -> bool {
                *self == CLK::Lfosc1
            }
            #[doc = "ECLKIN: External Clock from P1.0"]
            #[inline(always)]
            pub fn is_eclkin(&self) -> bool {
                *self == CLK::Eclkin
            }
        }
        #[doc = "Field `CLK` writer - Clock Select"]
        pub type CLK_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CLK, crate::Safe>;
        impl<'a, REG> CLK_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "PCLK: PCLK (default)"]
            #[inline(always)]
            pub fn pclk(self) -> &'a mut crate::W<REG> {
                self.variant(CLK::Pclk)
            }
            #[doc = "LFOSC: 32 KHz Internal Oscillator"]
            #[inline(always)]
            pub fn lfosc(self) -> &'a mut crate::W<REG> {
                self.variant(CLK::Lfosc)
            }
            #[doc = "LFOSC: 32kHz Internal Oscillator"]
            #[inline(always)]
            pub fn lfosc1(self) -> &'a mut crate::W<REG> {
                self.variant(CLK::Lfosc1)
            }
            #[doc = "ECLKIN: External Clock from P1.0"]
            #[inline(always)]
            pub fn eclkin(self) -> &'a mut crate::W<REG> {
                self.variant(CLK::Eclkin)
            }
        }
        #[doc = "Field `STOP_WUFA` reader - Disables Updating Field a Register T4WUFA"]
        pub type STOP_WUFA_R = crate::BitReader;
        #[doc = "Field `STOP_WUFA` writer - Disables Updating Field a Register T4WUFA"]
        pub type STOP_WUFA_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - Prescaler"]
            #[inline(always)]
            pub fn pre(&self) -> PRE_R {
                PRE_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 3 - Freeze Enable"]
            #[inline(always)]
            pub fn freeze(&self) -> FREEZE_R {
                FREEZE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 6 - Timer Mode"]
            #[inline(always)]
            pub fn tmode(&self) -> TMODE_R {
                TMODE_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Timer Enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Wakeup Enable"]
            #[inline(always)]
            pub fn wuen(&self) -> WUEN_R {
                WUEN_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bits 9:10 - Clock Select"]
            #[inline(always)]
            pub fn clk(&self) -> CLK_R {
                CLK_R::new(((self.bits >> 9) & 3) as u8)
            }
            #[doc = "Bit 11 - Disables Updating Field a Register T4WUFA"]
            #[inline(always)]
            pub fn stop_wufa(&self) -> STOP_WUFA_R {
                STOP_WUFA_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4CON")
                    .field("pre", &self.pre())
                    .field("freeze", &self.freeze())
                    .field("tmode", &self.tmode())
                    .field("enable", &self.enable())
                    .field("wuen", &self.wuen())
                    .field("clk", &self.clk())
                    .field("stop_wufa", &self.stop_wufa())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Prescaler"]
            #[inline(always)]
            pub fn pre(&mut self) -> PRE_W<T4CONrs> {
                PRE_W::new(self, 0)
            }
            #[doc = "Bit 3 - Freeze Enable"]
            #[inline(always)]
            pub fn freeze(&mut self) -> FREEZE_W<T4CONrs> {
                FREEZE_W::new(self, 3)
            }
            #[doc = "Bit 6 - Timer Mode"]
            #[inline(always)]
            pub fn tmode(&mut self) -> TMODE_W<T4CONrs> {
                TMODE_W::new(self, 6)
            }
            #[doc = "Bit 7 - Timer Enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> ENABLE_W<T4CONrs> {
                ENABLE_W::new(self, 7)
            }
            #[doc = "Bit 8 - Wakeup Enable"]
            #[inline(always)]
            pub fn wuen(&mut self) -> WUEN_W<T4CONrs> {
                WUEN_W::new(self, 8)
            }
            #[doc = "Bits 9:10 - Clock Select"]
            #[inline(always)]
            pub fn clk(&mut self) -> CLK_W<T4CONrs> {
                CLK_W::new(self, 9)
            }
            #[doc = "Bit 11 - Disables Updating Field a Register T4WUFA"]
            #[inline(always)]
            pub fn stop_wufa(&mut self) -> STOP_WUFA_W<T4CONrs> {
                STOP_WUFA_W::new(self, 11)
            }
        }
        #[doc = "Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`t4con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4CON)"]
        pub struct T4CONrs;
        impl crate::RegisterSpec for T4CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4con::R`](R) reader structure"]
        impl crate::Readable for T4CONrs {}
        #[doc = "`write(|w| ..)` method takes [`t4con::W`](W) writer structure"]
        impl crate::Writable for T4CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4CON to value 0x40"]
        impl crate::Resettable for T4CONrs {
            const RESET_VALUE: u32 = 0x40;
        }
    }
    #[doc = "T4INC (rw) register accessor: 12-bit Interval for Wakeup Field a\n\nYou can [`read`](crate::Reg::read) this register and get [`t4inc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4inc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4INC)\n\nFor information about available fields see [`mod@t4inc`]
module"]
    pub type T4INC = crate::Reg<t4inc::T4INCrs>;
    #[doc = "12-bit Interval for Wakeup Field a"]
    pub mod t4inc {
        #[doc = "Register `T4INC` reader"]
        pub type R = crate::R<T4INCrs>;
        #[doc = "Register `T4INC` writer"]
        pub type W = crate::W<T4INCrs>;
        #[doc = "Field `INTERVAL` reader - Interval for Wakeup Field a"]
        pub type INTERVAL_R = crate::FieldReader<u16>;
        #[doc = "Field `INTERVAL` writer - Interval for Wakeup Field a"]
        pub type INTERVAL_W<'a, REG> = crate::FieldWriter<'a, REG, 12, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:11 - Interval for Wakeup Field a"]
            #[inline(always)]
            pub fn interval(&self) -> INTERVAL_R {
                INTERVAL_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4INC")
                    .field("interval", &self.interval())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:11 - Interval for Wakeup Field a"]
            #[inline(always)]
            pub fn interval(&mut self) -> INTERVAL_W<T4INCrs> {
                INTERVAL_W::new(self, 0)
            }
        }
        #[doc = "12-bit Interval for Wakeup Field a\n\nYou can [`read`](crate::Reg::read) this register and get [`t4inc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4inc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4INC)"]
        pub struct T4INCrs;
        impl crate::RegisterSpec for T4INCrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4inc::R`](R) reader structure"]
        impl crate::Readable for T4INCrs {}
        #[doc = "`write(|w| ..)` method takes [`t4inc::W`](W) writer structure"]
        impl crate::Writable for T4INCrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4INC to value 0xc8"]
        impl crate::Resettable for T4INCrs {
            const RESET_VALUE: u32 = 0xc8;
        }
    }
    #[doc = "T4WUFB0 (rw) register accessor: Wakeup Field B - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufb0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufb0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFB0)\n\nFor information about available fields see [`mod@t4wufb0`]
module"]
    pub type T4WUFB0 = crate::Reg<t4wufb0::T4WUFB0rs>;
    #[doc = "Wakeup Field B - LS 16 Bits"]
    pub mod t4wufb0 {
        #[doc = "Register `T4WUFB0` reader"]
        pub type R = crate::R<T4WUFB0rs>;
        #[doc = "Register `T4WUFB0` writer"]
        pub type W = crate::W<T4WUFB0rs>;
        #[doc = "Field `T4WUFBL` reader - Wakeup Field B Low"]
        pub type T4WUFBL_R = crate::FieldReader<u16>;
        #[doc = "Field `T4WUFBL` writer - Wakeup Field B Low"]
        pub type T4WUFBL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Wakeup Field B Low"]
            #[inline(always)]
            pub fn t4wufbl(&self) -> T4WUFBL_R {
                T4WUFBL_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4WUFB0")
                    .field("t4wufbl", &self.t4wufbl())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wakeup Field B Low"]
            #[inline(always)]
            pub fn t4wufbl(&mut self) -> T4WUFBL_W<T4WUFB0rs> {
                T4WUFBL_W::new(self, 0)
            }
        }
        #[doc = "Wakeup Field B - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufb0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufb0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFB0)"]
        pub struct T4WUFB0rs;
        impl crate::RegisterSpec for T4WUFB0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4wufb0::R`](R) reader structure"]
        impl crate::Readable for T4WUFB0rs {}
        #[doc = "`write(|w| ..)` method takes [`t4wufb0::W`](W) writer structure"]
        impl crate::Writable for T4WUFB0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4WUFB0 to value 0x1fff"]
        impl crate::Resettable for T4WUFB0rs {
            const RESET_VALUE: u32 = 0x1fff;
        }
    }
    #[doc = "T4WUFB1 (rw) register accessor: Wakeup Field B - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufb1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufb1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFB1)\n\nFor information about available fields see [`mod@t4wufb1`]
module"]
    pub type T4WUFB1 = crate::Reg<t4wufb1::T4WUFB1rs>;
    #[doc = "Wakeup Field B - MS 16 Bits"]
    pub mod t4wufb1 {
        #[doc = "Register `T4WUFB1` reader"]
        pub type R = crate::R<T4WUFB1rs>;
        #[doc = "Register `T4WUFB1` writer"]
        pub type W = crate::W<T4WUFB1rs>;
        #[doc = "Field `T4WUFBH` reader - Wakeup Field B High"]
        pub type T4WUFBH_R = crate::FieldReader<u16>;
        #[doc = "Field `T4WUFBH` writer - Wakeup Field B High"]
        pub type T4WUFBH_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Wakeup Field B High"]
            #[inline(always)]
            pub fn t4wufbh(&self) -> T4WUFBH_R {
                T4WUFBH_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4WUFB1")
                    .field("t4wufbh", &self.t4wufbh())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wakeup Field B High"]
            #[inline(always)]
            pub fn t4wufbh(&mut self) -> T4WUFBH_W<T4WUFB1rs> {
                T4WUFBH_W::new(self, 0)
            }
        }
        #[doc = "Wakeup Field B - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufb1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufb1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFB1)"]
        pub struct T4WUFB1rs;
        impl crate::RegisterSpec for T4WUFB1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4wufb1::R`](R) reader structure"]
        impl crate::Readable for T4WUFB1rs {}
        #[doc = "`write(|w| ..)` method takes [`t4wufb1::W`](W) writer structure"]
        impl crate::Writable for T4WUFB1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4WUFB1 to value 0"]
        impl crate::Resettable for T4WUFB1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "T4WUFC0 (rw) register accessor: Wakeup Field C - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufc0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufc0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFC0)\n\nFor information about available fields see [`mod@t4wufc0`]
module"]
    pub type T4WUFC0 = crate::Reg<t4wufc0::T4WUFC0rs>;
    #[doc = "Wakeup Field C - LS 16 Bits"]
    pub mod t4wufc0 {
        #[doc = "Register `T4WUFC0` reader"]
        pub type R = crate::R<T4WUFC0rs>;
        #[doc = "Register `T4WUFC0` writer"]
        pub type W = crate::W<T4WUFC0rs>;
        #[doc = "Field `T4WUFCL` reader - Wakeup Field C Low"]
        pub type T4WUFCL_R = crate::FieldReader<u16>;
        #[doc = "Field `T4WUFCL` writer - Wakeup Field C Low"]
        pub type T4WUFCL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Wakeup Field C Low"]
            #[inline(always)]
            pub fn t4wufcl(&self) -> T4WUFCL_R {
                T4WUFCL_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4WUFC0")
                    .field("t4wufcl", &self.t4wufcl())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wakeup Field C Low"]
            #[inline(always)]
            pub fn t4wufcl(&mut self) -> T4WUFCL_W<T4WUFC0rs> {
                T4WUFCL_W::new(self, 0)
            }
        }
        #[doc = "Wakeup Field C - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufc0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufc0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFC0)"]
        pub struct T4WUFC0rs;
        impl crate::RegisterSpec for T4WUFC0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4wufc0::R`](R) reader structure"]
        impl crate::Readable for T4WUFC0rs {}
        #[doc = "`write(|w| ..)` method takes [`t4wufc0::W`](W) writer structure"]
        impl crate::Writable for T4WUFC0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4WUFC0 to value 0x2fff"]
        impl crate::Resettable for T4WUFC0rs {
            const RESET_VALUE: u32 = 0x2fff;
        }
    }
    #[doc = "T4WUFC1 (rw) register accessor: Wakeup Field C - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufc1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufc1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFC1)\n\nFor information about available fields see [`mod@t4wufc1`]
module"]
    pub type T4WUFC1 = crate::Reg<t4wufc1::T4WUFC1rs>;
    #[doc = "Wakeup Field C - MS 16 Bits"]
    pub mod t4wufc1 {
        #[doc = "Register `T4WUFC1` reader"]
        pub type R = crate::R<T4WUFC1rs>;
        #[doc = "Register `T4WUFC1` writer"]
        pub type W = crate::W<T4WUFC1rs>;
        #[doc = "Field `T4WUFCH` reader - Wakeup Field C High"]
        pub type T4WUFCH_R = crate::FieldReader<u16>;
        #[doc = "Field `T4WUFCH` writer - Wakeup Field C High"]
        pub type T4WUFCH_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Wakeup Field C High"]
            #[inline(always)]
            pub fn t4wufch(&self) -> T4WUFCH_R {
                T4WUFCH_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4WUFC1")
                    .field("t4wufch", &self.t4wufch())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wakeup Field C High"]
            #[inline(always)]
            pub fn t4wufch(&mut self) -> T4WUFCH_W<T4WUFC1rs> {
                T4WUFCH_W::new(self, 0)
            }
        }
        #[doc = "Wakeup Field C - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufc1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufc1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFC1)"]
        pub struct T4WUFC1rs;
        impl crate::RegisterSpec for T4WUFC1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4wufc1::R`](R) reader structure"]
        impl crate::Readable for T4WUFC1rs {}
        #[doc = "`write(|w| ..)` method takes [`t4wufc1::W`](W) writer structure"]
        impl crate::Writable for T4WUFC1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4WUFC1 to value 0"]
        impl crate::Resettable for T4WUFC1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "T4WUFD0 (rw) register accessor: Wakeup Field D - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufd0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufd0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFD0)\n\nFor information about available fields see [`mod@t4wufd0`]
module"]
    pub type T4WUFD0 = crate::Reg<t4wufd0::T4WUFD0rs>;
    #[doc = "Wakeup Field D - LS 16 Bits"]
    pub mod t4wufd0 {
        #[doc = "Register `T4WUFD0` reader"]
        pub type R = crate::R<T4WUFD0rs>;
        #[doc = "Register `T4WUFD0` writer"]
        pub type W = crate::W<T4WUFD0rs>;
        #[doc = "Field `T4WUFD0` reader - Wakeup Field D Low"]
        pub type T4WUFD0_R = crate::FieldReader<u16>;
        #[doc = "Field `T4WUFD0` writer - Wakeup Field D Low"]
        pub type T4WUFD0_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Wakeup Field D Low"]
            #[inline(always)]
            pub fn t4wufd0(&self) -> T4WUFD0_R {
                T4WUFD0_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4WUFD0")
                    .field("t4wufd0", &self.t4wufd0())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wakeup Field D Low"]
            #[inline(always)]
            pub fn t4wufd0(&mut self) -> T4WUFD0_W<T4WUFD0rs> {
                T4WUFD0_W::new(self, 0)
            }
        }
        #[doc = "Wakeup Field D - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufd0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufd0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFD0)"]
        pub struct T4WUFD0rs;
        impl crate::RegisterSpec for T4WUFD0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4wufd0::R`](R) reader structure"]
        impl crate::Readable for T4WUFD0rs {}
        #[doc = "`write(|w| ..)` method takes [`t4wufd0::W`](W) writer structure"]
        impl crate::Writable for T4WUFD0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4WUFD0 to value 0x3fff"]
        impl crate::Resettable for T4WUFD0rs {
            const RESET_VALUE: u32 = 0x3fff;
        }
    }
    #[doc = "T4WUFD1 (rw) register accessor: Wakeup Field D - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufd1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufd1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFD1)\n\nFor information about available fields see [`mod@t4wufd1`]
module"]
    pub type T4WUFD1 = crate::Reg<t4wufd1::T4WUFD1rs>;
    #[doc = "Wakeup Field D - MS 16 Bits"]
    pub mod t4wufd1 {
        #[doc = "Register `T4WUFD1` reader"]
        pub type R = crate::R<T4WUFD1rs>;
        #[doc = "Register `T4WUFD1` writer"]
        pub type W = crate::W<T4WUFD1rs>;
        #[doc = "Field `T4WUFDH` reader - Wakeup Field D High"]
        pub type T4WUFDH_R = crate::FieldReader<u16>;
        #[doc = "Field `T4WUFDH` writer - Wakeup Field D High"]
        pub type T4WUFDH_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Wakeup Field D High"]
            #[inline(always)]
            pub fn t4wufdh(&self) -> T4WUFDH_R {
                T4WUFDH_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4WUFD1")
                    .field("t4wufdh", &self.t4wufdh())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wakeup Field D High"]
            #[inline(always)]
            pub fn t4wufdh(&mut self) -> T4WUFDH_W<T4WUFD1rs> {
                T4WUFDH_W::new(self, 0)
            }
        }
        #[doc = "Wakeup Field D - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufd1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufd1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFD1)"]
        pub struct T4WUFD1rs;
        impl crate::RegisterSpec for T4WUFD1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4wufd1::R`](R) reader structure"]
        impl crate::Readable for T4WUFD1rs {}
        #[doc = "`write(|w| ..)` method takes [`t4wufd1::W`](W) writer structure"]
        impl crate::Writable for T4WUFD1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4WUFD1 to value 0"]
        impl crate::Resettable for T4WUFD1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "T4IEN (rw) register accessor: Interrupt Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`t4ien::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4ien::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4IEN)\n\nFor information about available fields see [`mod@t4ien`]
module"]
    pub type T4IEN = crate::Reg<t4ien::T4IENrs>;
    #[doc = "Interrupt Enable Register"]
    pub mod t4ien {
        #[doc = "Register `T4IEN` reader"]
        pub type R = crate::R<T4IENrs>;
        #[doc = "Register `T4IEN` writer"]
        pub type W = crate::W<T4IENrs>;
        #[doc = "Field `WUFA` reader - T4WUFA Interrupt Enable"]
        pub type WUFA_R = crate::BitReader;
        #[doc = "Field `WUFA` writer - T4WUFA Interrupt Enable"]
        pub type WUFA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WUFB` reader - T4WUFB Interrupt Enable"]
        pub type WUFB_R = crate::BitReader;
        #[doc = "Field `WUFB` writer - T4WUFB Interrupt Enable"]
        pub type WUFB_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WUFC` reader - T4WUFC Interrupt Enable"]
        pub type WUFC_R = crate::BitReader;
        #[doc = "Field `WUFC` writer - T4WUFC Interrupt Enable"]
        pub type WUFC_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WUFD` reader - T4WUFD Interrupt Enable"]
        pub type WUFD_R = crate::BitReader;
        #[doc = "Field `WUFD` writer - T4WUFD Interrupt Enable"]
        pub type WUFD_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ROLL` reader - Rollover Interrupt Enable"]
        pub type ROLL_R = crate::BitReader;
        #[doc = "Field `ROLL` writer - Rollover Interrupt Enable"]
        pub type ROLL_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - T4WUFA Interrupt Enable"]
            #[inline(always)]
            pub fn wufa(&self) -> WUFA_R {
                WUFA_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - T4WUFB Interrupt Enable"]
            #[inline(always)]
            pub fn wufb(&self) -> WUFB_R {
                WUFB_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - T4WUFC Interrupt Enable"]
            #[inline(always)]
            pub fn wufc(&self) -> WUFC_R {
                WUFC_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - T4WUFD Interrupt Enable"]
            #[inline(always)]
            pub fn wufd(&self) -> WUFD_R {
                WUFD_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Rollover Interrupt Enable"]
            #[inline(always)]
            pub fn roll(&self) -> ROLL_R {
                ROLL_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4IEN")
                    .field("wufa", &self.wufa())
                    .field("wufb", &self.wufb())
                    .field("wufc", &self.wufc())
                    .field("wufd", &self.wufd())
                    .field("roll", &self.roll())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - T4WUFA Interrupt Enable"]
            #[inline(always)]
            pub fn wufa(&mut self) -> WUFA_W<T4IENrs> {
                WUFA_W::new(self, 0)
            }
            #[doc = "Bit 1 - T4WUFB Interrupt Enable"]
            #[inline(always)]
            pub fn wufb(&mut self) -> WUFB_W<T4IENrs> {
                WUFB_W::new(self, 1)
            }
            #[doc = "Bit 2 - T4WUFC Interrupt Enable"]
            #[inline(always)]
            pub fn wufc(&mut self) -> WUFC_W<T4IENrs> {
                WUFC_W::new(self, 2)
            }
            #[doc = "Bit 3 - T4WUFD Interrupt Enable"]
            #[inline(always)]
            pub fn wufd(&mut self) -> WUFD_W<T4IENrs> {
                WUFD_W::new(self, 3)
            }
            #[doc = "Bit 4 - Rollover Interrupt Enable"]
            #[inline(always)]
            pub fn roll(&mut self) -> ROLL_W<T4IENrs> {
                ROLL_W::new(self, 4)
            }
        }
        #[doc = "Interrupt Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`t4ien::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4ien::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4IEN)"]
        pub struct T4IENrs;
        impl crate::RegisterSpec for T4IENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4ien::R`](R) reader structure"]
        impl crate::Readable for T4IENrs {}
        #[doc = "`write(|w| ..)` method takes [`t4ien::W`](W) writer structure"]
        impl crate::Writable for T4IENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4IEN to value 0"]
        impl crate::Resettable for T4IENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "T4STA (rw) register accessor: Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`t4sta::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4sta::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4STA)\n\nFor information about available fields see [`mod@t4sta`]
module"]
    pub type T4STA = crate::Reg<t4sta::T4STArs>;
    #[doc = "Status Register"]
    pub mod t4sta {
        #[doc = "Register `T4STA` reader"]
        pub type R = crate::R<T4STArs>;
        #[doc = "Register `T4STA` writer"]
        pub type W = crate::W<T4STArs>;
        #[doc = "Field `WUFA` reader - T4WUFA Interrupt Flag"]
        pub type WUFA_R = crate::BitReader;
        #[doc = "Field `WUFB` reader - T4WUFB Interrupt Flag"]
        pub type WUFB_R = crate::BitReader;
        #[doc = "Field `WUFC` reader - T4WUFC Interrupt Flag"]
        pub type WUFC_R = crate::BitReader;
        #[doc = "Field `WUFD` reader - T4WUFD Interrupt Flag"]
        pub type WUFD_R = crate::BitReader;
        #[doc = "Field `ROLL` reader - Rollover Interrupt Flag"]
        pub type ROLL_R = crate::BitReader;
        #[doc = "Field `IRQCRY` reader - Wakeup Status to Powerdown"]
        pub type IRQCRY_R = crate::BitReader;
        #[doc = "Field `FREEZE` reader - Timer Value Freeze"]
        pub type FREEZE_R = crate::BitReader;
        #[doc = "Field `PDOK` reader - Enable Bit Synchronized"]
        pub type PDOK_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - T4WUFA Interrupt Flag"]
            #[inline(always)]
            pub fn wufa(&self) -> WUFA_R {
                WUFA_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - T4WUFB Interrupt Flag"]
            #[inline(always)]
            pub fn wufb(&self) -> WUFB_R {
                WUFB_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - T4WUFC Interrupt Flag"]
            #[inline(always)]
            pub fn wufc(&self) -> WUFC_R {
                WUFC_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - T4WUFD Interrupt Flag"]
            #[inline(always)]
            pub fn wufd(&self) -> WUFD_R {
                WUFD_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Rollover Interrupt Flag"]
            #[inline(always)]
            pub fn roll(&self) -> ROLL_R {
                ROLL_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - Wakeup Status to Powerdown"]
            #[inline(always)]
            pub fn irqcry(&self) -> IRQCRY_R {
                IRQCRY_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Timer Value Freeze"]
            #[inline(always)]
            pub fn freeze(&self) -> FREEZE_R {
                FREEZE_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Enable Bit Synchronized"]
            #[inline(always)]
            pub fn pdok(&self) -> PDOK_R {
                PDOK_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4STA")
                    .field("wufa", &self.wufa())
                    .field("wufb", &self.wufb())
                    .field("wufc", &self.wufc())
                    .field("wufd", &self.wufd())
                    .field("roll", &self.roll())
                    .field("irqcry", &self.irqcry())
                    .field("freeze", &self.freeze())
                    .field("pdok", &self.pdok())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`t4sta::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4sta::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4STA)"]
        pub struct T4STArs;
        impl crate::RegisterSpec for T4STArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4sta::R`](R) reader structure"]
        impl crate::Readable for T4STArs {}
        #[doc = "`write(|w| ..)` method takes [`t4sta::W`](W) writer structure"]
        impl crate::Writable for T4STArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4STA to value 0"]
        impl crate::Resettable for T4STArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "T4CLRI (rw) register accessor: Clear Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`t4clri::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4clri::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4CLRI)\n\nFor information about available fields see [`mod@t4clri`]
module"]
    pub type T4CLRI = crate::Reg<t4clri::T4CLRIrs>;
    #[doc = "Clear Interrupt Register"]
    pub mod t4clri {
        #[doc = "Register `T4CLRI` reader"]
        pub type R = crate::R<T4CLRIrs>;
        #[doc = "Register `T4CLRI` writer"]
        pub type W = crate::W<T4CLRIrs>;
        #[doc = "Field `WUFA` reader - T4WUFA Interrupt Clear"]
        pub type WUFA_R = crate::BitReader;
        #[doc = "Field `WUFA` writer - T4WUFA Interrupt Clear"]
        pub type WUFA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WUFB` reader - T4WUFB Interrupt Clear"]
        pub type WUFB_R = crate::BitReader;
        #[doc = "Field `WUFB` writer - T4WUFB Interrupt Clear"]
        pub type WUFB_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WUFC` reader - T4WUFC Interrupt Clear"]
        pub type WUFC_R = crate::BitReader;
        #[doc = "Field `WUFC` writer - T4WUFC Interrupt Clear"]
        pub type WUFC_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WUFD` reader - T4WUFD Interrupt Clear"]
        pub type WUFD_R = crate::BitReader;
        #[doc = "Field `WUFD` writer - T4WUFD Interrupt Clear"]
        pub type WUFD_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ROLL` reader - Rollover Interrupt Clear"]
        pub type ROLL_R = crate::BitReader;
        #[doc = "Field `ROLL` writer - Rollover Interrupt Clear"]
        pub type ROLL_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - T4WUFA Interrupt Clear"]
            #[inline(always)]
            pub fn wufa(&self) -> WUFA_R {
                WUFA_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - T4WUFB Interrupt Clear"]
            #[inline(always)]
            pub fn wufb(&self) -> WUFB_R {
                WUFB_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - T4WUFC Interrupt Clear"]
            #[inline(always)]
            pub fn wufc(&self) -> WUFC_R {
                WUFC_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - T4WUFD Interrupt Clear"]
            #[inline(always)]
            pub fn wufd(&self) -> WUFD_R {
                WUFD_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Rollover Interrupt Clear"]
            #[inline(always)]
            pub fn roll(&self) -> ROLL_R {
                ROLL_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4CLRI")
                    .field("wufa", &self.wufa())
                    .field("wufb", &self.wufb())
                    .field("wufc", &self.wufc())
                    .field("wufd", &self.wufd())
                    .field("roll", &self.roll())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - T4WUFA Interrupt Clear"]
            #[inline(always)]
            pub fn wufa(&mut self) -> WUFA_W<T4CLRIrs> {
                WUFA_W::new(self, 0)
            }
            #[doc = "Bit 1 - T4WUFB Interrupt Clear"]
            #[inline(always)]
            pub fn wufb(&mut self) -> WUFB_W<T4CLRIrs> {
                WUFB_W::new(self, 1)
            }
            #[doc = "Bit 2 - T4WUFC Interrupt Clear"]
            #[inline(always)]
            pub fn wufc(&mut self) -> WUFC_W<T4CLRIrs> {
                WUFC_W::new(self, 2)
            }
            #[doc = "Bit 3 - T4WUFD Interrupt Clear"]
            #[inline(always)]
            pub fn wufd(&mut self) -> WUFD_W<T4CLRIrs> {
                WUFD_W::new(self, 3)
            }
            #[doc = "Bit 4 - Rollover Interrupt Clear"]
            #[inline(always)]
            pub fn roll(&mut self) -> ROLL_W<T4CLRIrs> {
                ROLL_W::new(self, 4)
            }
        }
        #[doc = "Clear Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`t4clri::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4clri::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4CLRI)"]
        pub struct T4CLRIrs;
        impl crate::RegisterSpec for T4CLRIrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4clri::R`](R) reader structure"]
        impl crate::Readable for T4CLRIrs {}
        #[doc = "`write(|w| ..)` method takes [`t4clri::W`](W) writer structure"]
        impl crate::Writable for T4CLRIrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4CLRI to value 0"]
        impl crate::Resettable for T4CLRIrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "T4WUFA0 (rw) register accessor: Wakeup Field a - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufa0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufa0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFA0)\n\nFor information about available fields see [`mod@t4wufa0`]
module"]
    pub type T4WUFA0 = crate::Reg<t4wufa0::T4WUFA0rs>;
    #[doc = "Wakeup Field a - LS 16 Bits"]
    pub mod t4wufa0 {
        #[doc = "Register `T4WUFA0` reader"]
        pub type R = crate::R<T4WUFA0rs>;
        #[doc = "Register `T4WUFA0` writer"]
        pub type W = crate::W<T4WUFA0rs>;
        #[doc = "Field `T4WUFAL` reader - Wakeup Field a Low"]
        pub type T4WUFAL_R = crate::FieldReader<u16>;
        #[doc = "Field `T4WUFAL` writer - Wakeup Field a Low"]
        pub type T4WUFAL_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Wakeup Field a Low"]
            #[inline(always)]
            pub fn t4wufal(&self) -> T4WUFAL_R {
                T4WUFAL_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4WUFA0")
                    .field("t4wufal", &self.t4wufal())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wakeup Field a Low"]
            #[inline(always)]
            pub fn t4wufal(&mut self) -> T4WUFAL_W<T4WUFA0rs> {
                T4WUFAL_W::new(self, 0)
            }
        }
        #[doc = "Wakeup Field a - LS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufa0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufa0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFA0)"]
        pub struct T4WUFA0rs;
        impl crate::RegisterSpec for T4WUFA0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4wufa0::R`](R) reader structure"]
        impl crate::Readable for T4WUFA0rs {}
        #[doc = "`write(|w| ..)` method takes [`t4wufa0::W`](W) writer structure"]
        impl crate::Writable for T4WUFA0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4WUFA0 to value 0x1900"]
        impl crate::Resettable for T4WUFA0rs {
            const RESET_VALUE: u32 = 0x1900;
        }
    }
    #[doc = "T4WUFA1 (rw) register accessor: Wakeup Field a - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufa1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufa1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFA1)\n\nFor information about available fields see [`mod@t4wufa1`]
module"]
    pub type T4WUFA1 = crate::Reg<t4wufa1::T4WUFA1rs>;
    #[doc = "Wakeup Field a - MS 16 Bits"]
    pub mod t4wufa1 {
        #[doc = "Register `T4WUFA1` reader"]
        pub type R = crate::R<T4WUFA1rs>;
        #[doc = "Register `T4WUFA1` writer"]
        pub type W = crate::W<T4WUFA1rs>;
        #[doc = "Field `T4WUFAH` reader - Wakeup Field a High"]
        pub type T4WUFAH_R = crate::FieldReader<u16>;
        #[doc = "Field `T4WUFAH` writer - Wakeup Field a High"]
        pub type T4WUFAH_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Wakeup Field a High"]
            #[inline(always)]
            pub fn t4wufah(&self) -> T4WUFAH_R {
                T4WUFAH_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("T4WUFA1")
                    .field("t4wufah", &self.t4wufah())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wakeup Field a High"]
            #[inline(always)]
            pub fn t4wufah(&mut self) -> T4WUFAH_W<T4WUFA1rs> {
                T4WUFAH_W::new(self, 0)
            }
        }
        #[doc = "Wakeup Field a - MS 16 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`t4wufa1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t4wufa1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WUT:T4WUFA1)"]
        pub struct T4WUFA1rs;
        impl crate::RegisterSpec for T4WUFA1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t4wufa1::R`](R) reader structure"]
        impl crate::Readable for T4WUFA1rs {}
        #[doc = "`write(|w| ..)` method takes [`t4wufa1::W`](W) writer structure"]
        impl crate::Writable for T4WUFA1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets T4WUFA1 to value 0"]
        impl crate::Resettable for T4WUFA1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT)"]
pub struct WDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT {}
impl WDT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for WDT {
    type Target = wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WDT").finish()
    }
}
#[doc = "Unknown"]
pub mod wdt {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ld: LD,
        vals: VALS,
        con: CON,
        clri: CLRI,
        _reserved4: [u8; 0x08],
        sta: STA,
        minld: MINLD,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Watchdog Timer Load Value"]
        #[inline(always)]
        pub const fn ld(&self) -> &LD {
            &self.ld
        }
        #[doc = "0x04 - Current Count Value"]
        #[inline(always)]
        pub const fn vals(&self) -> &VALS {
            &self.vals
        }
        #[doc = "0x08 - Watchdog Timer Control Register"]
        #[inline(always)]
        pub const fn con(&self) -> &CON {
            &self.con
        }
        #[doc = "0x0c - Refresh Watchdog Register"]
        #[inline(always)]
        pub const fn clri(&self) -> &CLRI {
            &self.clri
        }
        #[doc = "0x18 - Timer Status"]
        #[inline(always)]
        pub const fn sta(&self) -> &STA {
            &self.sta
        }
        #[doc = "0x1c - Minimum Load Value"]
        #[inline(always)]
        pub const fn minld(&self) -> &MINLD {
            &self.minld
        }
    }
    #[doc = "LD (rw) register accessor: Watchdog Timer Load Value\n\nYou can [`read`](crate::Reg::read) this register and get [`ld::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ld::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:LD)\n\nFor information about available fields see [`mod@ld`]
module"]
    pub type LD = crate::Reg<ld::LDrs>;
    #[doc = "Watchdog Timer Load Value"]
    pub mod ld {
        #[doc = "Register `LD` reader"]
        pub type R = crate::R<LDrs>;
        #[doc = "Register `LD` writer"]
        pub type W = crate::W<LDrs>;
        #[doc = "Field `LOAD` reader - WDT Load Value"]
        pub type LOAD_R = crate::FieldReader<u16>;
        #[doc = "Field `LOAD` writer - WDT Load Value"]
        pub type LOAD_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - WDT Load Value"]
            #[inline(always)]
            pub fn load(&self) -> LOAD_R {
                LOAD_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LD").field("load", &self.load()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - WDT Load Value"]
            #[inline(always)]
            pub fn load(&mut self) -> LOAD_W<LDrs> {
                LOAD_W::new(self, 0)
            }
        }
        #[doc = "Watchdog Timer Load Value\n\nYou can [`read`](crate::Reg::read) this register and get [`ld::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ld::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:LD)"]
        pub struct LDrs;
        impl crate::RegisterSpec for LDrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ld::R`](R) reader structure"]
        impl crate::Readable for LDrs {}
        #[doc = "`write(|w| ..)` method takes [`ld::W`](W) writer structure"]
        impl crate::Writable for LDrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LD to value 0x1000"]
        impl crate::Resettable for LDrs {
            const RESET_VALUE: u32 = 0x1000;
        }
    }
    #[doc = "VALS (rw) register accessor: Current Count Value\n\nYou can [`read`](crate::Reg::read) this register and get [`vals::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vals::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:VALS)\n\nFor information about available fields see [`mod@vals`]
module"]
    pub type VALS = crate::Reg<vals::VALSrs>;
    #[doc = "Current Count Value"]
    pub mod vals {
        #[doc = "Register `VALS` reader"]
        pub type R = crate::R<VALSrs>;
        #[doc = "Register `VALS` writer"]
        pub type W = crate::W<VALSrs>;
        #[doc = "Field `CCOUNT` reader - Current WDT Count Value."]
        pub type CCOUNT_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - Current WDT Count Value."]
            #[inline(always)]
            pub fn ccount(&self) -> CCOUNT_R {
                CCOUNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VALS")
                    .field("ccount", &self.ccount())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Current Count Value\n\nYou can [`read`](crate::Reg::read) this register and get [`vals::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vals::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:VALS)"]
        pub struct VALSrs;
        impl crate::RegisterSpec for VALSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vals::R`](R) reader structure"]
        impl crate::Readable for VALSrs {}
        #[doc = "`write(|w| ..)` method takes [`vals::W`](W) writer structure"]
        impl crate::Writable for VALSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets VALS to value 0x1000"]
        impl crate::Resettable for VALSrs {
            const RESET_VALUE: u32 = 0x1000;
        }
    }
    #[doc = "CON (rw) register accessor: Watchdog Timer Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:CON)\n\nFor information about available fields see [`mod@con`]
module"]
    pub type CON = crate::Reg<con::CONrs>;
    #[doc = "Watchdog Timer Control Register"]
    pub mod con {
        #[doc = "Register `CON` reader"]
        pub type R = crate::R<CONrs>;
        #[doc = "Register `CON` writer"]
        pub type W = crate::W<CONrs>;
        #[doc = "Power Down Stop Enable\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PDSTOP {
            #[doc = "0: Continue Counting When in Hibernate"]
            Continue = 0,
            #[doc = "1: Stop Counter When in Hibernate."]
            Stoped = 1,
        }
        impl From<PDSTOP> for bool {
            #[inline(always)]
            fn from(variant: PDSTOP) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PDSTOP` reader - Power Down Stop Enable"]
        pub type PDSTOP_R = crate::BitReader<PDSTOP>;
        impl PDSTOP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PDSTOP {
                match self.bits {
                    false => PDSTOP::Continue,
                    true => PDSTOP::Stoped,
                }
            }
            #[doc = "Continue Counting When in Hibernate"]
            #[inline(always)]
            pub fn is_continue(&self) -> bool {
                *self == PDSTOP::Continue
            }
            #[doc = "Stop Counter When in Hibernate."]
            #[inline(always)]
            pub fn is_stoped(&self) -> bool {
                *self == PDSTOP::Stoped
            }
        }
        #[doc = "Field `PDSTOP` writer - Power Down Stop Enable"]
        pub type PDSTOP_W<'a, REG> = crate::BitWriter<'a, REG, PDSTOP>;
        impl<'a, REG> PDSTOP_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Continue Counting When in Hibernate"]
            #[inline(always)]
            pub fn continue_(self) -> &'a mut crate::W<REG> {
                self.variant(PDSTOP::Continue)
            }
            #[doc = "Stop Counter When in Hibernate."]
            #[inline(always)]
            pub fn stoped(self) -> &'a mut crate::W<REG> {
                self.variant(PDSTOP::Stoped)
            }
        }
        #[doc = "WDT Interrupt Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ {
            #[doc = "0: Watchdog Timer Timeout Creates a Reset."]
            Reset = 0,
            #[doc = "1: Watchdog Timer Timeout Creates an Interrupt Instead of Reset."]
            Interrupt = 1,
        }
        impl From<IRQ> for bool {
            #[inline(always)]
            fn from(variant: IRQ) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ` reader - WDT Interrupt Enable"]
        pub type IRQ_R = crate::BitReader<IRQ>;
        impl IRQ_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ {
                match self.bits {
                    false => IRQ::Reset,
                    true => IRQ::Interrupt,
                }
            }
            #[doc = "Watchdog Timer Timeout Creates a Reset."]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == IRQ::Reset
            }
            #[doc = "Watchdog Timer Timeout Creates an Interrupt Instead of Reset."]
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == IRQ::Interrupt
            }
        }
        #[doc = "Field `IRQ` writer - WDT Interrupt Enable"]
        pub type IRQ_W<'a, REG> = crate::BitWriter<'a, REG, IRQ>;
        impl<'a, REG> IRQ_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Watchdog Timer Timeout Creates a Reset."]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ::Reset)
            }
            #[doc = "Watchdog Timer Timeout Creates an Interrupt Instead of Reset."]
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ::Interrupt)
            }
        }
        #[doc = "Prescaler.\n\nValue on reset: 2"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PRE {
            #[doc = "0: Source Clock/1"]
            Div1 = 0,
            #[doc = "1: Source Clock/16."]
            Div16 = 1,
            #[doc = "2: Source Clock/256 (default)."]
            Div256 = 2,
            #[doc = "3: Source Clock/4096"]
            Div4096 = 3,
        }
        impl From<PRE> for u8 {
            #[inline(always)]
            fn from(variant: PRE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PRE {
            type Ux = u8;
        }
        impl crate::IsEnum for PRE {}
        #[doc = "Field `PRE` reader - Prescaler."]
        pub type PRE_R = crate::FieldReader<PRE>;
        impl PRE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PRE {
                match self.bits {
                    0 => PRE::Div1,
                    1 => PRE::Div16,
                    2 => PRE::Div256,
                    3 => PRE::Div4096,
                    _ => unreachable!(),
                }
            }
            #[doc = "Source Clock/1"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == PRE::Div1
            }
            #[doc = "Source Clock/16."]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PRE::Div16
            }
            #[doc = "Source Clock/256 (default)."]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == PRE::Div256
            }
            #[doc = "Source Clock/4096"]
            #[inline(always)]
            pub fn is_div4096(&self) -> bool {
                *self == PRE::Div4096
            }
        }
        #[doc = "Field `PRE` writer - Prescaler."]
        pub type PRE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, PRE, crate::Safe>;
        impl<'a, REG> PRE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Source Clock/1"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Div1)
            }
            #[doc = "Source Clock/16."]
            #[inline(always)]
            pub fn div16(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Div16)
            }
            #[doc = "Source Clock/256 (default)."]
            #[inline(always)]
            pub fn div256(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Div256)
            }
            #[doc = "Source Clock/4096"]
            #[inline(always)]
            pub fn div4096(self) -> &'a mut crate::W<REG> {
                self.variant(PRE::Div4096)
            }
        }
        #[doc = "Field `EN` reader - Timer Enable"]
        pub type EN_R = crate::BitReader;
        #[doc = "Field `EN` writer - Timer Enable"]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Timer Mode Select\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MDE {
            #[doc = "0: Free-running Mode"]
            Free = 0,
            #[doc = "1: Periodic Mode (default)"]
            Periodic = 1,
        }
        impl From<MDE> for bool {
            #[inline(always)]
            fn from(variant: MDE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MDE` reader - Timer Mode Select"]
        pub type MDE_R = crate::BitReader<MDE>;
        impl MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MDE {
                match self.bits {
                    false => MDE::Free,
                    true => MDE::Periodic,
                }
            }
            #[doc = "Free-running Mode"]
            #[inline(always)]
            pub fn is_free(&self) -> bool {
                *self == MDE::Free
            }
            #[doc = "Periodic Mode (default)"]
            #[inline(always)]
            pub fn is_periodic(&self) -> bool {
                *self == MDE::Periodic
            }
        }
        #[doc = "Field `MDE` writer - Timer Mode Select"]
        pub type MDE_W<'a, REG> = crate::BitWriter<'a, REG, MDE>;
        impl<'a, REG> MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Free-running Mode"]
            #[inline(always)]
            pub fn free(self) -> &'a mut crate::W<REG> {
                self.variant(MDE::Free)
            }
            #[doc = "Periodic Mode (default)"]
            #[inline(always)]
            pub fn periodic(self) -> &'a mut crate::W<REG> {
                self.variant(MDE::Periodic)
            }
        }
        #[doc = "Field `CLKDIV2` reader - Clock Source"]
        pub type CLKDIV2_R = crate::BitReader;
        #[doc = "Field `CLKDIV2` writer - Clock Source"]
        pub type CLKDIV2_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MINLOADEN` reader - Timer Window Control"]
        pub type MINLOADEN_R = crate::BitReader;
        #[doc = "Field `MINLOADEN` writer - Timer Window Control"]
        pub type MINLOADEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDTIRQEN` reader - WDT Interrupt Enable"]
        pub type WDTIRQEN_R = crate::BitReader;
        #[doc = "Field `WDTIRQEN` writer - WDT Interrupt Enable"]
        pub type WDTIRQEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Power Down Stop Enable"]
            #[inline(always)]
            pub fn pdstop(&self) -> PDSTOP_R {
                PDSTOP_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - WDT Interrupt Enable"]
            #[inline(always)]
            pub fn irq(&self) -> IRQ_R {
                IRQ_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:3 - Prescaler."]
            #[inline(always)]
            pub fn pre(&self) -> PRE_R {
                PRE_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bit 5 - Timer Enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Timer Mode Select"]
            #[inline(always)]
            pub fn mde(&self) -> MDE_R {
                MDE_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - Clock Source"]
            #[inline(always)]
            pub fn clkdiv2(&self) -> CLKDIV2_R {
                CLKDIV2_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Timer Window Control"]
            #[inline(always)]
            pub fn minloaden(&self) -> MINLOADEN_R {
                MINLOADEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - WDT Interrupt Enable"]
            #[inline(always)]
            pub fn wdtirqen(&self) -> WDTIRQEN_R {
                WDTIRQEN_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CON")
                    .field("pdstop", &self.pdstop())
                    .field("irq", &self.irq())
                    .field("pre", &self.pre())
                    .field("en", &self.en())
                    .field("mde", &self.mde())
                    .field("clkdiv2", &self.clkdiv2())
                    .field("minloaden", &self.minloaden())
                    .field("wdtirqen", &self.wdtirqen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Power Down Stop Enable"]
            #[inline(always)]
            pub fn pdstop(&mut self) -> PDSTOP_W<CONrs> {
                PDSTOP_W::new(self, 0)
            }
            #[doc = "Bit 1 - WDT Interrupt Enable"]
            #[inline(always)]
            pub fn irq(&mut self) -> IRQ_W<CONrs> {
                IRQ_W::new(self, 1)
            }
            #[doc = "Bits 2:3 - Prescaler."]
            #[inline(always)]
            pub fn pre(&mut self) -> PRE_W<CONrs> {
                PRE_W::new(self, 2)
            }
            #[doc = "Bit 5 - Timer Enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<CONrs> {
                EN_W::new(self, 5)
            }
            #[doc = "Bit 6 - Timer Mode Select"]
            #[inline(always)]
            pub fn mde(&mut self) -> MDE_W<CONrs> {
                MDE_W::new(self, 6)
            }
            #[doc = "Bit 8 - Clock Source"]
            #[inline(always)]
            pub fn clkdiv2(&mut self) -> CLKDIV2_W<CONrs> {
                CLKDIV2_W::new(self, 8)
            }
            #[doc = "Bit 9 - Timer Window Control"]
            #[inline(always)]
            pub fn minloaden(&mut self) -> MINLOADEN_W<CONrs> {
                MINLOADEN_W::new(self, 9)
            }
            #[doc = "Bit 10 - WDT Interrupt Enable"]
            #[inline(always)]
            pub fn wdtirqen(&mut self) -> WDTIRQEN_W<CONrs> {
                WDTIRQEN_W::new(self, 10)
            }
        }
        #[doc = "Watchdog Timer Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:CON)"]
        pub struct CONrs;
        impl crate::RegisterSpec for CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`con::R`](R) reader structure"]
        impl crate::Readable for CONrs {}
        #[doc = "`write(|w| ..)` method takes [`con::W`](W) writer structure"]
        impl crate::Writable for CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CON to value 0x69"]
        impl crate::Resettable for CONrs {
            const RESET_VALUE: u32 = 0x69;
        }
    }
    #[doc = "CLRI (rw) register accessor: Refresh Watchdog Register\n\nYou can [`read`](crate::Reg::read) this register and get [`clri::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clri::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:CLRI)\n\nFor information about available fields see [`mod@clri`]
module"]
    pub type CLRI = crate::Reg<clri::CLRIrs>;
    #[doc = "Refresh Watchdog Register"]
    pub mod clri {
        #[doc = "Register `CLRI` reader"]
        pub type R = crate::R<CLRIrs>;
        #[doc = "Register `CLRI` writer"]
        pub type W = crate::W<CLRIrs>;
        #[doc = "Field `CLRWDG` writer - Refresh Register"]
        pub type CLRWDG_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CLRI").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Refresh Register"]
            #[inline(always)]
            pub fn clrwdg(&mut self) -> CLRWDG_W<CLRIrs> {
                CLRWDG_W::new(self, 0)
            }
        }
        #[doc = "Refresh Watchdog Register\n\nYou can [`read`](crate::Reg::read) this register and get [`clri::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clri::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:CLRI)"]
        pub struct CLRIrs;
        impl crate::RegisterSpec for CLRIrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clri::R`](R) reader structure"]
        impl crate::Readable for CLRIrs {}
        #[doc = "`write(|w| ..)` method takes [`clri::W`](W) writer structure"]
        impl crate::Writable for CLRIrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CLRI to value 0"]
        impl crate::Resettable for CLRIrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "STA (rw) register accessor: Timer Status\n\nYou can [`read`](crate::Reg::read) this register and get [`sta::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sta::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:STA)\n\nFor information about available fields see [`mod@sta`]
module"]
    pub type STA = crate::Reg<sta::STArs>;
    #[doc = "Timer Status"]
    pub mod sta {
        #[doc = "Register `STA` reader"]
        pub type R = crate::R<STArs>;
        #[doc = "Register `STA` writer"]
        pub type W = crate::W<STArs>;
        #[doc = "WDT Interrupt\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ {
            #[doc = "0: Watchdog Timer Interrupt Not Pending"]
            Cleared = 0,
            #[doc = "1: Watchdog Timer Interrupt Pending"]
            Pending = 1,
        }
        impl From<IRQ> for bool {
            #[inline(always)]
            fn from(variant: IRQ) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ` reader - WDT Interrupt"]
        pub type IRQ_R = crate::BitReader<IRQ>;
        impl IRQ_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ {
                match self.bits {
                    false => IRQ::Cleared,
                    true => IRQ::Pending,
                }
            }
            #[doc = "Watchdog Timer Interrupt Not Pending"]
            #[inline(always)]
            pub fn is_cleared(&self) -> bool {
                *self == IRQ::Cleared
            }
            #[doc = "Watchdog Timer Interrupt Pending"]
            #[inline(always)]
            pub fn is_pending(&self) -> bool {
                *self == IRQ::Pending
            }
        }
        #[doc = "Field `CLRI` reader - WDTCLRI Write Status"]
        pub type CLRI_R = crate::BitReader;
        #[doc = "Field `TLD` reader - WDTVAL Write Status"]
        pub type TLD_R = crate::BitReader;
        #[doc = "Field `CON` reader - WDTCON Write Status"]
        pub type CON_R = crate::BitReader;
        #[doc = "Lock Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LOCKS {
            #[doc = "0: Timer Operation Not Locked"]
            Opened = 0,
            #[doc = "1: Timer Enabled and Locked"]
            Locked = 1,
        }
        impl From<LOCKS> for bool {
            #[inline(always)]
            fn from(variant: LOCKS) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `LOCKS` reader - Lock Status"]
        pub type LOCKS_R = crate::BitReader<LOCKS>;
        impl LOCKS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> LOCKS {
                match self.bits {
                    false => LOCKS::Opened,
                    true => LOCKS::Locked,
                }
            }
            #[doc = "Timer Operation Not Locked"]
            #[inline(always)]
            pub fn is_opened(&self) -> bool {
                *self == LOCKS::Opened
            }
            #[doc = "Timer Enabled and Locked"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == LOCKS::Locked
            }
        }
        #[doc = "Field `OTPWRDONE` reader - Reset Type Status"]
        pub type OTPWRDONE_R = crate::BitReader;
        #[doc = "Field `TMINLD` reader - WDTMINLD Write Status"]
        pub type TMINLD_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - WDT Interrupt"]
            #[inline(always)]
            pub fn irq(&self) -> IRQ_R {
                IRQ_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - WDTCLRI Write Status"]
            #[inline(always)]
            pub fn clri(&self) -> CLRI_R {
                CLRI_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - WDTVAL Write Status"]
            #[inline(always)]
            pub fn tld(&self) -> TLD_R {
                TLD_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - WDTCON Write Status"]
            #[inline(always)]
            pub fn con(&self) -> CON_R {
                CON_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Lock Status"]
            #[inline(always)]
            pub fn locks(&self) -> LOCKS_R {
                LOCKS_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Reset Type Status"]
            #[inline(always)]
            pub fn otpwrdone(&self) -> OTPWRDONE_R {
                OTPWRDONE_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - WDTMINLD Write Status"]
            #[inline(always)]
            pub fn tminld(&self) -> TMINLD_R {
                TMINLD_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STA")
                    .field("irq", &self.irq())
                    .field("clri", &self.clri())
                    .field("tld", &self.tld())
                    .field("con", &self.con())
                    .field("locks", &self.locks())
                    .field("otpwrdone", &self.otpwrdone())
                    .field("tminld", &self.tminld())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Timer Status\n\nYou can [`read`](crate::Reg::read) this register and get [`sta::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sta::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:STA)"]
        pub struct STArs;
        impl crate::RegisterSpec for STArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sta::R`](R) reader structure"]
        impl crate::Readable for STArs {}
        #[doc = "`write(|w| ..)` method takes [`sta::W`](W) writer structure"]
        impl crate::Writable for STArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STA to value 0"]
        impl crate::Resettable for STArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MINLD (rw) register accessor: Minimum Load Value\n\nYou can [`read`](crate::Reg::read) this register and get [`minld::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`minld::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:MINLD)\n\nFor information about available fields see [`mod@minld`]
module"]
    pub type MINLD = crate::Reg<minld::MINLDrs>;
    #[doc = "Minimum Load Value"]
    pub mod minld {
        #[doc = "Register `MINLD` reader"]
        pub type R = crate::R<MINLDrs>;
        #[doc = "Register `MINLD` writer"]
        pub type W = crate::W<MINLDrs>;
        #[doc = "Field `MINLOAD` reader - WDT Min Load Value"]
        pub type MINLOAD_R = crate::FieldReader<u16>;
        #[doc = "Field `MINLOAD` writer - WDT Min Load Value"]
        pub type MINLOAD_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - WDT Min Load Value"]
            #[inline(always)]
            pub fn minload(&self) -> MINLOAD_R {
                MINLOAD_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MINLD")
                    .field("minload", &self.minload())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - WDT Min Load Value"]
            #[inline(always)]
            pub fn minload(&mut self) -> MINLOAD_W<MINLDrs> {
                MINLOAD_W::new(self, 0)
            }
        }
        #[doc = "Minimum Load Value\n\nYou can [`read`](crate::Reg::read) this register and get [`minld::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`minld::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#WDT:MINLD)"]
        pub struct MINLDrs;
        impl crate::RegisterSpec for MINLDrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`minld::R`](R) reader structure"]
        impl crate::Readable for MINLDrs {}
        #[doc = "`write(|w| ..)` method takes [`minld::W`](W) writer structure"]
        impl crate::Writable for MINLDrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MINLD to value 0x0800"]
        impl crate::Resettable for MINLDrs {
            const RESET_VALUE: u32 = 0x0800;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON)"]
pub struct ALLON {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ALLON {}
impl ALLON {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const allon::RegisterBlock = 0x4000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const allon::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ALLON {
    type Target = allon::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ALLON {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ALLON").finish()
    }
}
#[doc = "Unknown"]
pub mod allon {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        pwrmod: PWRMOD,
        pwrkey: PWRKEY,
        rstcfg: RSTCFG,
        rstkey: RSTKEY,
        _reserved4: [u8; 0x10],
        ei0cfg: EI0CFG,
        ei1cfg: EI1CFG,
        ei2cfg: EI2CFG,
        _reserved7: [u8; 0x04],
        eiclr: EICLR,
        _reserved8: [u8; 0x0c],
        rststa: RSTSTA,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Power Modes"]
        #[inline(always)]
        pub const fn pwrmod(&self) -> &PWRMOD {
            &self.pwrmod
        }
        #[doc = "0x04 - Key Protection for PWRMOD"]
        #[inline(always)]
        pub const fn pwrkey(&self) -> &PWRKEY {
            &self.pwrkey
        }
        #[doc = "0x08 - Reset Configuration"]
        #[inline(always)]
        pub const fn rstcfg(&self) -> &RSTCFG {
            &self.rstcfg
        }
        #[doc = "0x0c - Key Protection for RSTCFG"]
        #[inline(always)]
        pub const fn rstkey(&self) -> &RSTKEY {
            &self.rstkey
        }
        #[doc = "0x20 - External Interrupt Configuration 0"]
        #[inline(always)]
        pub const fn ei0cfg(&self) -> &EI0CFG {
            &self.ei0cfg
        }
        #[doc = "0x24 - External Interrupt Configuration 1"]
        #[inline(always)]
        pub const fn ei1cfg(&self) -> &EI1CFG {
            &self.ei1cfg
        }
        #[doc = "0x28 - External Interrupt Configuration 2"]
        #[inline(always)]
        pub const fn ei2cfg(&self) -> &EI2CFG {
            &self.ei2cfg
        }
        #[doc = "0x30 - External Interrupt Clear"]
        #[inline(always)]
        pub const fn eiclr(&self) -> &EICLR {
            &self.eiclr
        }
        #[doc = "0x40 - Reset Status"]
        #[inline(always)]
        pub const fn rststa(&self) -> &RSTSTA {
            &self.rststa
        }
    }
    #[doc = "PWRMOD (rw) register accessor: Power Modes\n\nYou can [`read`](crate::Reg::read) this register and get [`pwrmod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwrmod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:PWRMOD)\n\nFor information about available fields see [`mod@pwrmod`]
module"]
    pub type PWRMOD = crate::Reg<pwrmod::PWRMODrs>;
    #[doc = "Power Modes"]
    pub mod pwrmod {
        #[doc = "Register `PWRMOD` reader"]
        pub type R = crate::R<PWRMODrs>;
        #[doc = "Register `PWRMOD` writer"]
        pub type W = crate::W<PWRMODrs>;
        #[doc = "Power Modes Control Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PWRMOD {
            #[doc = "0: Active Mode"]
            Fullactive = 0,
            #[doc = "1: CORE_SLEEP Mode"]
            Coresleep = 1,
            #[doc = "2: SYS_SLEEP Mode"]
            Syssleep = 2,
            #[doc = "3: Hibernate Mode"]
            Hibernate = 3,
        }
        impl From<PWRMOD> for u8 {
            #[inline(always)]
            fn from(variant: PWRMOD) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PWRMOD {
            type Ux = u8;
        }
        impl crate::IsEnum for PWRMOD {}
        #[doc = "Field `PWRMOD` reader - Power Modes Control Bits"]
        pub type PWRMOD_R = crate::FieldReader<PWRMOD>;
        impl PWRMOD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PWRMOD {
                match self.bits {
                    0 => PWRMOD::Fullactive,
                    1 => PWRMOD::Coresleep,
                    2 => PWRMOD::Syssleep,
                    3 => PWRMOD::Hibernate,
                    _ => unreachable!(),
                }
            }
            #[doc = "Active Mode"]
            #[inline(always)]
            pub fn is_fullactive(&self) -> bool {
                *self == PWRMOD::Fullactive
            }
            #[doc = "CORE_SLEEP Mode"]
            #[inline(always)]
            pub fn is_coresleep(&self) -> bool {
                *self == PWRMOD::Coresleep
            }
            #[doc = "SYS_SLEEP Mode"]
            #[inline(always)]
            pub fn is_syssleep(&self) -> bool {
                *self == PWRMOD::Syssleep
            }
            #[doc = "Hibernate Mode"]
            #[inline(always)]
            pub fn is_hibernate(&self) -> bool {
                *self == PWRMOD::Hibernate
            }
        }
        #[doc = "Field `PWRMOD` writer - Power Modes Control Bits"]
        pub type PWRMOD_W<'a, REG> = crate::FieldWriter<'a, REG, 2, PWRMOD, crate::Safe>;
        impl<'a, REG> PWRMOD_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Active Mode"]
            #[inline(always)]
            pub fn fullactive(self) -> &'a mut crate::W<REG> {
                self.variant(PWRMOD::Fullactive)
            }
            #[doc = "CORE_SLEEP Mode"]
            #[inline(always)]
            pub fn coresleep(self) -> &'a mut crate::W<REG> {
                self.variant(PWRMOD::Coresleep)
            }
            #[doc = "SYS_SLEEP Mode"]
            #[inline(always)]
            pub fn syssleep(self) -> &'a mut crate::W<REG> {
                self.variant(PWRMOD::Syssleep)
            }
            #[doc = "Hibernate Mode"]
            #[inline(always)]
            pub fn hibernate(self) -> &'a mut crate::W<REG> {
                self.variant(PWRMOD::Hibernate)
            }
        }
        #[doc = "WIC Acknowledgment for SLEEPDEEP\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WICENACK {
            #[doc = "0: Unknown"]
            Noack = 0,
            #[doc = "1: Unknown"]
            Ack = 1,
        }
        impl From<WICENACK> for bool {
            #[inline(always)]
            fn from(variant: WICENACK) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `WICENACK` reader - WIC Acknowledgment for SLEEPDEEP"]
        pub type WICENACK_R = crate::BitReader<WICENACK>;
        impl WICENACK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> WICENACK {
                match self.bits {
                    false => WICENACK::Noack,
                    true => WICENACK::Ack,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_noack(&self) -> bool {
                *self == WICENACK::Noack
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ack(&self) -> bool {
                *self == WICENACK::Ack
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Power Modes Control Bits"]
            #[inline(always)]
            pub fn pwrmod(&self) -> PWRMOD_R {
                PWRMOD_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 3 - WIC Acknowledgment for SLEEPDEEP"]
            #[inline(always)]
            pub fn wicenack(&self) -> WICENACK_R {
                WICENACK_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWRMOD")
                    .field("pwrmod", &self.pwrmod())
                    .field("wicenack", &self.wicenack())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Power Modes Control Bits"]
            #[inline(always)]
            pub fn pwrmod(&mut self) -> PWRMOD_W<PWRMODrs> {
                PWRMOD_W::new(self, 0)
            }
        }
        #[doc = "Power Modes\n\nYou can [`read`](crate::Reg::read) this register and get [`pwrmod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwrmod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:PWRMOD)"]
        pub struct PWRMODrs;
        impl crate::RegisterSpec for PWRMODrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwrmod::R`](R) reader structure"]
        impl crate::Readable for PWRMODrs {}
        #[doc = "`write(|w| ..)` method takes [`pwrmod::W`](W) writer structure"]
        impl crate::Writable for PWRMODrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWRMOD to value 0"]
        impl crate::Resettable for PWRMODrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWRKEY (rw) register accessor: Key Protection for PWRMOD\n\nYou can [`read`](crate::Reg::read) this register and get [`pwrkey::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwrkey::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:PWRKEY)\n\nFor information about available fields see [`mod@pwrkey`]
module"]
    pub type PWRKEY = crate::Reg<pwrkey::PWRKEYrs>;
    #[doc = "Key Protection for PWRMOD"]
    pub mod pwrkey {
        #[doc = "Register `PWRKEY` reader"]
        pub type R = crate::R<PWRKEYrs>;
        #[doc = "Register `PWRKEY` writer"]
        pub type W = crate::W<PWRKEYrs>;
        #[doc = "Field `PWRKEY` reader - Power Control Key Register"]
        pub type PWRKEY_R = crate::FieldReader<u16>;
        #[doc = "Field `PWRKEY` writer - Power Control Key Register"]
        pub type PWRKEY_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Power Control Key Register"]
            #[inline(always)]
            pub fn pwrkey(&self) -> PWRKEY_R {
                PWRKEY_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWRKEY")
                    .field("pwrkey", &self.pwrkey())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Power Control Key Register"]
            #[inline(always)]
            pub fn pwrkey(&mut self) -> PWRKEY_W<PWRKEYrs> {
                PWRKEY_W::new(self, 0)
            }
        }
        #[doc = "Key Protection for PWRMOD\n\nYou can [`read`](crate::Reg::read) this register and get [`pwrkey::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwrkey::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:PWRKEY)"]
        pub struct PWRKEYrs;
        impl crate::RegisterSpec for PWRKEYrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwrkey::R`](R) reader structure"]
        impl crate::Readable for PWRKEYrs {}
        #[doc = "`write(|w| ..)` method takes [`pwrkey::W`](W) writer structure"]
        impl crate::Writable for PWRKEYrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWRKEY to value 0"]
        impl crate::Resettable for PWRKEYrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RSTCFG (rw) register accessor: Reset Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`rstcfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rstcfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:RSTCFG)\n\nFor information about available fields see [`mod@rstcfg`]
module"]
    pub type RSTCFG = crate::Reg<rstcfg::RSTCFGrs>;
    #[doc = "Reset Configuration"]
    pub mod rstcfg {
        #[doc = "Register `RSTCFG` reader"]
        pub type R = crate::R<RSTCFGrs>;
        #[doc = "Register `RSTCFG` writer"]
        pub type W = crate::W<RSTCFGrs>;
        #[doc = "GPIO/PLA Retain Their Status After WDT and Software Reset\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum GPIO_PLA_RETAIN {
            #[doc = "0: GPIO/PLA Retain Status After Watchdog or Software Reset."]
            Dis = 0,
            #[doc = "1: GPIO/PLA not Retain Status After Watchdog or Software Reset"]
            En = 1,
        }
        impl From<GPIO_PLA_RETAIN> for bool {
            #[inline(always)]
            fn from(variant: GPIO_PLA_RETAIN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `GPIO_PLA_RETAIN` reader - GPIO/PLA Retain Their Status After WDT and Software Reset"]
        pub type GPIO_PLA_RETAIN_R = crate::BitReader<GPIO_PLA_RETAIN>;
        impl GPIO_PLA_RETAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GPIO_PLA_RETAIN {
                match self.bits {
                    false => GPIO_PLA_RETAIN::Dis,
                    true => GPIO_PLA_RETAIN::En,
                }
            }
            #[doc = "GPIO/PLA Retain Status After Watchdog or Software Reset."]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == GPIO_PLA_RETAIN::Dis
            }
            #[doc = "GPIO/PLA not Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == GPIO_PLA_RETAIN::En
            }
        }
        #[doc = "Field `GPIO_PLA_RETAIN` writer - GPIO/PLA Retain Their Status After WDT and Software Reset"]
        pub type GPIO_PLA_RETAIN_W<'a, REG> = crate::BitWriter<'a, REG, GPIO_PLA_RETAIN>;
        impl<'a, REG> GPIO_PLA_RETAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "GPIO/PLA Retain Status After Watchdog or Software Reset."]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(GPIO_PLA_RETAIN::Dis)
            }
            #[doc = "GPIO/PLA not Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(GPIO_PLA_RETAIN::En)
            }
        }
        #[doc = "LV Die Retain Status After Watchdog or Software Reset\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LV_RETAIN {
            #[doc = "0: LV Die Retain Status After Watchdog or Software Reset."]
            Dis = 0,
            #[doc = "1: LV Die not Retain Status After Watchdog or Software Reset"]
            En = 1,
        }
        impl From<LV_RETAIN> for bool {
            #[inline(always)]
            fn from(variant: LV_RETAIN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `LV_RETAIN` reader - LV Die Retain Status After Watchdog or Software Reset"]
        pub type LV_RETAIN_R = crate::BitReader<LV_RETAIN>;
        impl LV_RETAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> LV_RETAIN {
                match self.bits {
                    false => LV_RETAIN::Dis,
                    true => LV_RETAIN::En,
                }
            }
            #[doc = "LV Die Retain Status After Watchdog or Software Reset."]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == LV_RETAIN::Dis
            }
            #[doc = "LV Die not Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == LV_RETAIN::En
            }
        }
        #[doc = "Field `LV_RETAIN` writer - LV Die Retain Status After Watchdog or Software Reset"]
        pub type LV_RETAIN_W<'a, REG> = crate::BitWriter<'a, REG, LV_RETAIN>;
        impl<'a, REG> LV_RETAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "LV Die Retain Status After Watchdog or Software Reset."]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(LV_RETAIN::Dis)
            }
            #[doc = "LV Die not Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(LV_RETAIN::En)
            }
        }
        #[doc = "Analog Block Retain Status After Watchdog or Software Reset\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ANA_RETAIN {
            #[doc = "0: GPIO/PLA Retain Status After Watchdog or Software Reset."]
            Dis = 0,
            #[doc = "1: GPIO/PLA not Retain Status After Watchdog or Software Reset"]
            En = 1,
        }
        impl From<ANA_RETAIN> for bool {
            #[inline(always)]
            fn from(variant: ANA_RETAIN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ANA_RETAIN` reader - Analog Block Retain Status After Watchdog or Software Reset"]
        pub type ANA_RETAIN_R = crate::BitReader<ANA_RETAIN>;
        impl ANA_RETAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ANA_RETAIN {
                match self.bits {
                    false => ANA_RETAIN::Dis,
                    true => ANA_RETAIN::En,
                }
            }
            #[doc = "GPIO/PLA Retain Status After Watchdog or Software Reset."]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == ANA_RETAIN::Dis
            }
            #[doc = "GPIO/PLA not Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == ANA_RETAIN::En
            }
        }
        #[doc = "Field `ANA_RETAIN` writer - Analog Block Retain Status After Watchdog or Software Reset"]
        pub type ANA_RETAIN_W<'a, REG> = crate::BitWriter<'a, REG, ANA_RETAIN>;
        impl<'a, REG> ANA_RETAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "GPIO/PLA Retain Status After Watchdog or Software Reset."]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(ANA_RETAIN::Dis)
            }
            #[doc = "GPIO/PLA not Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(ANA_RETAIN::En)
            }
        }
        impl R {
            #[doc = "Bit 0 - GPIO/PLA Retain Their Status After WDT and Software Reset"]
            #[inline(always)]
            pub fn gpio_pla_retain(&self) -> GPIO_PLA_RETAIN_R {
                GPIO_PLA_RETAIN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - LV Die Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn lv_retain(&self) -> LV_RETAIN_R {
                LV_RETAIN_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Analog Block Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn ana_retain(&self) -> ANA_RETAIN_R {
                ANA_RETAIN_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RSTCFG")
                    .field("gpio_pla_retain", &self.gpio_pla_retain())
                    .field("lv_retain", &self.lv_retain())
                    .field("ana_retain", &self.ana_retain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - GPIO/PLA Retain Their Status After WDT and Software Reset"]
            #[inline(always)]
            pub fn gpio_pla_retain(&mut self) -> GPIO_PLA_RETAIN_W<RSTCFGrs> {
                GPIO_PLA_RETAIN_W::new(self, 0)
            }
            #[doc = "Bit 2 - LV Die Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn lv_retain(&mut self) -> LV_RETAIN_W<RSTCFGrs> {
                LV_RETAIN_W::new(self, 2)
            }
            #[doc = "Bit 3 - Analog Block Retain Status After Watchdog or Software Reset"]
            #[inline(always)]
            pub fn ana_retain(&mut self) -> ANA_RETAIN_W<RSTCFGrs> {
                ANA_RETAIN_W::new(self, 3)
            }
        }
        #[doc = "Reset Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`rstcfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rstcfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:RSTCFG)"]
        pub struct RSTCFGrs;
        impl crate::RegisterSpec for RSTCFGrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rstcfg::R`](R) reader structure"]
        impl crate::Readable for RSTCFGrs {}
        #[doc = "`write(|w| ..)` method takes [`rstcfg::W`](W) writer structure"]
        impl crate::Writable for RSTCFGrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RSTCFG to value 0"]
        impl crate::Resettable for RSTCFGrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RSTKEY (rw) register accessor: Key Protection for RSTCFG\n\nYou can [`read`](crate::Reg::read) this register and get [`rstkey::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rstkey::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:RSTKEY)\n\nFor information about available fields see [`mod@rstkey`]
module"]
    pub type RSTKEY = crate::Reg<rstkey::RSTKEYrs>;
    #[doc = "Key Protection for RSTCFG"]
    pub mod rstkey {
        #[doc = "Register `RSTKEY` reader"]
        pub type R = crate::R<RSTKEYrs>;
        #[doc = "Register `RSTKEY` writer"]
        pub type W = crate::W<RSTKEYrs>;
        #[doc = "Field `RSTKEY` reader - Reset Configuration Key Register"]
        pub type RSTKEY_R = crate::FieldReader<u16>;
        #[doc = "Field `RSTKEY` writer - Reset Configuration Key Register"]
        pub type RSTKEY_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Reset Configuration Key Register"]
            #[inline(always)]
            pub fn rstkey(&self) -> RSTKEY_R {
                RSTKEY_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RSTKEY")
                    .field("rstkey", &self.rstkey())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Reset Configuration Key Register"]
            #[inline(always)]
            pub fn rstkey(&mut self) -> RSTKEY_W<RSTKEYrs> {
                RSTKEY_W::new(self, 0)
            }
        }
        #[doc = "Key Protection for RSTCFG\n\nYou can [`read`](crate::Reg::read) this register and get [`rstkey::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rstkey::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:RSTKEY)"]
        pub struct RSTKEYrs;
        impl crate::RegisterSpec for RSTKEYrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rstkey::R`](R) reader structure"]
        impl crate::Readable for RSTKEYrs {}
        #[doc = "`write(|w| ..)` method takes [`rstkey::W`](W) writer structure"]
        impl crate::Writable for RSTKEYrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RSTKEY to value 0"]
        impl crate::Resettable for RSTKEYrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EI0CFG (rw) register accessor: External Interrupt Configuration 0\n\nYou can [`read`](crate::Reg::read) this register and get [`ei0cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ei0cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:EI0CFG)\n\nFor information about available fields see [`mod@ei0cfg`]
module"]
    pub type EI0CFG = crate::Reg<ei0cfg::EI0CFGrs>;
    #[doc = "External Interrupt Configuration 0"]
    pub mod ei0cfg {
        #[doc = "Register `EI0CFG` reader"]
        pub type R = crate::R<EI0CFGrs>;
        #[doc = "Register `EI0CFG` writer"]
        pub type W = crate::W<EI0CFGrs>;
        #[doc = "External Interrupt 0 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ0MDE {
            #[doc = "0: Rising Edge"]
            Rise = 0,
            #[doc = "1: Falling Edge"]
            Fall = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ0MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ0MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ0MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ0MDE {}
        #[doc = "Field `IRQ0MDE` reader - External Interrupt 0 Mode Registers"]
        pub type IRQ0MDE_R = crate::FieldReader<IRQ0MDE>;
        impl IRQ0MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ0MDE {
                match self.bits {
                    0 => IRQ0MDE::Rise,
                    1 => IRQ0MDE::Fall,
                    2 => IRQ0MDE::Riseorfall,
                    3 => IRQ0MDE::Highlevel,
                    4 => IRQ0MDE::Lowlevel,
                    5 => IRQ0MDE::Fallaux,
                    6 => IRQ0MDE::Riseorfallaux,
                    7 => IRQ0MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IRQ0MDE::Rise
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IRQ0MDE::Fall
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ0MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ0MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ0MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ0MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ0MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ0MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ0MDE` writer - External Interrupt 0 Mode Registers"]
        pub type IRQ0MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ0MDE, crate::Safe>;
        impl<'a, REG> IRQ0MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0MDE::Rise)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0MDE::Fall)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 0 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ0EN {
            #[doc = "0: External Interrupt 0 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 0 Enabled"]
            En = 1,
        }
        impl From<IRQ0EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ0EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ0EN` reader - External Interrupt 0 Enable Bit"]
        pub type IRQ0EN_R = crate::BitReader<IRQ0EN>;
        impl IRQ0EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ0EN {
                match self.bits {
                    false => IRQ0EN::Dis,
                    true => IRQ0EN::En,
                }
            }
            #[doc = "External Interrupt 0 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ0EN::Dis
            }
            #[doc = "External Interrupt 0 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ0EN::En
            }
        }
        #[doc = "Field `IRQ0EN` writer - External Interrupt 0 Enable Bit"]
        pub type IRQ0EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ0EN>;
        impl<'a, REG> IRQ0EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 0 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0EN::Dis)
            }
            #[doc = "External Interrupt 0 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0EN::En)
            }
        }
        #[doc = "External Interrupt 1 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ1MDE {
            #[doc = "0: Rising Edge"]
            Rise = 0,
            #[doc = "1: Falling Edge"]
            Fall = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ1MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ1MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ1MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ1MDE {}
        #[doc = "Field `IRQ1MDE` reader - External Interrupt 1 Mode Registers"]
        pub type IRQ1MDE_R = crate::FieldReader<IRQ1MDE>;
        impl IRQ1MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ1MDE {
                match self.bits {
                    0 => IRQ1MDE::Rise,
                    1 => IRQ1MDE::Fall,
                    2 => IRQ1MDE::Riseorfall,
                    3 => IRQ1MDE::Highlevel,
                    4 => IRQ1MDE::Lowlevel,
                    5 => IRQ1MDE::Fallaux,
                    6 => IRQ1MDE::Riseorfallaux,
                    7 => IRQ1MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IRQ1MDE::Rise
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IRQ1MDE::Fall
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ1MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ1MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ1MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ1MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ1MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ1MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ1MDE` writer - External Interrupt 1 Mode Registers"]
        pub type IRQ1MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ1MDE, crate::Safe>;
        impl<'a, REG> IRQ1MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1MDE::Rise)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1MDE::Fall)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 1 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ1EN {
            #[doc = "0: External Interrupt 0 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 0 Enabled"]
            En = 1,
        }
        impl From<IRQ1EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ1EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ1EN` reader - External Interrupt 1 Enable Bit"]
        pub type IRQ1EN_R = crate::BitReader<IRQ1EN>;
        impl IRQ1EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ1EN {
                match self.bits {
                    false => IRQ1EN::Dis,
                    true => IRQ1EN::En,
                }
            }
            #[doc = "External Interrupt 0 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ1EN::Dis
            }
            #[doc = "External Interrupt 0 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ1EN::En
            }
        }
        #[doc = "Field `IRQ1EN` writer - External Interrupt 1 Enable Bit"]
        pub type IRQ1EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ1EN>;
        impl<'a, REG> IRQ1EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 0 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1EN::Dis)
            }
            #[doc = "External Interrupt 0 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1EN::En)
            }
        }
        #[doc = "External Interrupt 2 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ2MDE {
            #[doc = "0: Rising Edge"]
            Rise = 0,
            #[doc = "1: Falling Edge"]
            Fall = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ2MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ2MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ2MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ2MDE {}
        #[doc = "Field `IRQ2MDE` reader - External Interrupt 2 Mode Registers"]
        pub type IRQ2MDE_R = crate::FieldReader<IRQ2MDE>;
        impl IRQ2MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ2MDE {
                match self.bits {
                    0 => IRQ2MDE::Rise,
                    1 => IRQ2MDE::Fall,
                    2 => IRQ2MDE::Riseorfall,
                    3 => IRQ2MDE::Highlevel,
                    4 => IRQ2MDE::Lowlevel,
                    5 => IRQ2MDE::Fallaux,
                    6 => IRQ2MDE::Riseorfallaux,
                    7 => IRQ2MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IRQ2MDE::Rise
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IRQ2MDE::Fall
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ2MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ2MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ2MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ2MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ2MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ2MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ2MDE` writer - External Interrupt 2 Mode Registers"]
        pub type IRQ2MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ2MDE, crate::Safe>;
        impl<'a, REG> IRQ2MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2MDE::Rise)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2MDE::Fall)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 2 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ2EN {
            #[doc = "0: External Interrupt 2 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 2 Enabled"]
            En = 1,
        }
        impl From<IRQ2EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ2EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ2EN` reader - External Interrupt 2 Enable Bit"]
        pub type IRQ2EN_R = crate::BitReader<IRQ2EN>;
        impl IRQ2EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ2EN {
                match self.bits {
                    false => IRQ2EN::Dis,
                    true => IRQ2EN::En,
                }
            }
            #[doc = "External Interrupt 2 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ2EN::Dis
            }
            #[doc = "External Interrupt 2 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ2EN::En
            }
        }
        #[doc = "Field `IRQ2EN` writer - External Interrupt 2 Enable Bit"]
        pub type IRQ2EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ2EN>;
        impl<'a, REG> IRQ2EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 2 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2EN::Dis)
            }
            #[doc = "External Interrupt 2 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2EN::En)
            }
        }
        #[doc = "External Interrupt 3 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ3MDE {
            #[doc = "0: Rising Edge"]
            Rise = 0,
            #[doc = "1: Falling Edge"]
            Fall = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ3MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ3MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ3MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ3MDE {}
        #[doc = "Field `IRQ3MDE` reader - External Interrupt 3 Mode Registers"]
        pub type IRQ3MDE_R = crate::FieldReader<IRQ3MDE>;
        impl IRQ3MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ3MDE {
                match self.bits {
                    0 => IRQ3MDE::Rise,
                    1 => IRQ3MDE::Fall,
                    2 => IRQ3MDE::Riseorfall,
                    3 => IRQ3MDE::Highlevel,
                    4 => IRQ3MDE::Lowlevel,
                    5 => IRQ3MDE::Fallaux,
                    6 => IRQ3MDE::Riseorfallaux,
                    7 => IRQ3MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IRQ3MDE::Rise
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IRQ3MDE::Fall
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ3MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ3MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ3MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ3MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ3MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ3MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ3MDE` writer - External Interrupt 3 Mode Registers"]
        pub type IRQ3MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ3MDE, crate::Safe>;
        impl<'a, REG> IRQ3MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3MDE::Rise)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3MDE::Fall)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 3 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ3EN {
            #[doc = "0: External Interrupt 3 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 3 Enabled"]
            En = 1,
        }
        impl From<IRQ3EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ3EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ3EN` reader - External Interrupt 3 Enable Bit"]
        pub type IRQ3EN_R = crate::BitReader<IRQ3EN>;
        impl IRQ3EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ3EN {
                match self.bits {
                    false => IRQ3EN::Dis,
                    true => IRQ3EN::En,
                }
            }
            #[doc = "External Interrupt 3 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ3EN::Dis
            }
            #[doc = "External Interrupt 3 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ3EN::En
            }
        }
        #[doc = "Field `IRQ3EN` writer - External Interrupt 3 Enable Bit"]
        pub type IRQ3EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ3EN>;
        impl<'a, REG> IRQ3EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 3 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3EN::Dis)
            }
            #[doc = "External Interrupt 3 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3EN::En)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - External Interrupt 0 Mode Registers"]
            #[inline(always)]
            pub fn irq0mde(&self) -> IRQ0MDE_R {
                IRQ0MDE_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bit 3 - External Interrupt 0 Enable Bit"]
            #[inline(always)]
            pub fn irq0en(&self) -> IRQ0EN_R {
                IRQ0EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:6 - External Interrupt 1 Mode Registers"]
            #[inline(always)]
            pub fn irq1mde(&self) -> IRQ1MDE_R {
                IRQ1MDE_R::new(((self.bits >> 4) & 7) as u8)
            }
            #[doc = "Bit 7 - External Interrupt 1 Enable Bit"]
            #[inline(always)]
            pub fn irq1en(&self) -> IRQ1EN_R {
                IRQ1EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bits 8:10 - External Interrupt 2 Mode Registers"]
            #[inline(always)]
            pub fn irq2mde(&self) -> IRQ2MDE_R {
                IRQ2MDE_R::new(((self.bits >> 8) & 7) as u8)
            }
            #[doc = "Bit 11 - External Interrupt 2 Enable Bit"]
            #[inline(always)]
            pub fn irq2en(&self) -> IRQ2EN_R {
                IRQ2EN_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bits 12:14 - External Interrupt 3 Mode Registers"]
            #[inline(always)]
            pub fn irq3mde(&self) -> IRQ3MDE_R {
                IRQ3MDE_R::new(((self.bits >> 12) & 7) as u8)
            }
            #[doc = "Bit 15 - External Interrupt 3 Enable Bit"]
            #[inline(always)]
            pub fn irq3en(&self) -> IRQ3EN_R {
                IRQ3EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EI0CFG")
                    .field("irq0mde", &self.irq0mde())
                    .field("irq0en", &self.irq0en())
                    .field("irq1mde", &self.irq1mde())
                    .field("irq1en", &self.irq1en())
                    .field("irq2mde", &self.irq2mde())
                    .field("irq2en", &self.irq2en())
                    .field("irq3mde", &self.irq3mde())
                    .field("irq3en", &self.irq3en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:2 - External Interrupt 0 Mode Registers"]
            #[inline(always)]
            pub fn irq0mde(&mut self) -> IRQ0MDE_W<EI0CFGrs> {
                IRQ0MDE_W::new(self, 0)
            }
            #[doc = "Bit 3 - External Interrupt 0 Enable Bit"]
            #[inline(always)]
            pub fn irq0en(&mut self) -> IRQ0EN_W<EI0CFGrs> {
                IRQ0EN_W::new(self, 3)
            }
            #[doc = "Bits 4:6 - External Interrupt 1 Mode Registers"]
            #[inline(always)]
            pub fn irq1mde(&mut self) -> IRQ1MDE_W<EI0CFGrs> {
                IRQ1MDE_W::new(self, 4)
            }
            #[doc = "Bit 7 - External Interrupt 1 Enable Bit"]
            #[inline(always)]
            pub fn irq1en(&mut self) -> IRQ1EN_W<EI0CFGrs> {
                IRQ1EN_W::new(self, 7)
            }
            #[doc = "Bits 8:10 - External Interrupt 2 Mode Registers"]
            #[inline(always)]
            pub fn irq2mde(&mut self) -> IRQ2MDE_W<EI0CFGrs> {
                IRQ2MDE_W::new(self, 8)
            }
            #[doc = "Bit 11 - External Interrupt 2 Enable Bit"]
            #[inline(always)]
            pub fn irq2en(&mut self) -> IRQ2EN_W<EI0CFGrs> {
                IRQ2EN_W::new(self, 11)
            }
            #[doc = "Bits 12:14 - External Interrupt 3 Mode Registers"]
            #[inline(always)]
            pub fn irq3mde(&mut self) -> IRQ3MDE_W<EI0CFGrs> {
                IRQ3MDE_W::new(self, 12)
            }
            #[doc = "Bit 15 - External Interrupt 3 Enable Bit"]
            #[inline(always)]
            pub fn irq3en(&mut self) -> IRQ3EN_W<EI0CFGrs> {
                IRQ3EN_W::new(self, 15)
            }
        }
        #[doc = "External Interrupt Configuration 0\n\nYou can [`read`](crate::Reg::read) this register and get [`ei0cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ei0cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:EI0CFG)"]
        pub struct EI0CFGrs;
        impl crate::RegisterSpec for EI0CFGrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ei0cfg::R`](R) reader structure"]
        impl crate::Readable for EI0CFGrs {}
        #[doc = "`write(|w| ..)` method takes [`ei0cfg::W`](W) writer structure"]
        impl crate::Writable for EI0CFGrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EI0CFG to value 0"]
        impl crate::Resettable for EI0CFGrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EI1CFG (rw) register accessor: External Interrupt Configuration 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ei1cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ei1cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:EI1CFG)\n\nFor information about available fields see [`mod@ei1cfg`]
module"]
    pub type EI1CFG = crate::Reg<ei1cfg::EI1CFGrs>;
    #[doc = "External Interrupt Configuration 1"]
    pub mod ei1cfg {
        #[doc = "Register `EI1CFG` reader"]
        pub type R = crate::R<EI1CFGrs>;
        #[doc = "Register `EI1CFG` writer"]
        pub type W = crate::W<EI1CFGrs>;
        #[doc = "External Interrupt 4 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ4MDE {
            #[doc = "0: Rising Edge"]
            Rise = 0,
            #[doc = "1: Falling Edge"]
            Fall = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ4MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ4MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ4MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ4MDE {}
        #[doc = "Field `IRQ4MDE` reader - External Interrupt 4 Mode Registers"]
        pub type IRQ4MDE_R = crate::FieldReader<IRQ4MDE>;
        impl IRQ4MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ4MDE {
                match self.bits {
                    0 => IRQ4MDE::Rise,
                    1 => IRQ4MDE::Fall,
                    2 => IRQ4MDE::Riseorfall,
                    3 => IRQ4MDE::Highlevel,
                    4 => IRQ4MDE::Lowlevel,
                    5 => IRQ4MDE::Fallaux,
                    6 => IRQ4MDE::Riseorfallaux,
                    7 => IRQ4MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IRQ4MDE::Rise
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IRQ4MDE::Fall
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ4MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ4MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ4MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ4MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ4MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ4MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ4MDE` writer - External Interrupt 4 Mode Registers"]
        pub type IRQ4MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ4MDE, crate::Safe>;
        impl<'a, REG> IRQ4MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4MDE::Rise)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4MDE::Fall)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 4 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ4EN {
            #[doc = "0: External Interrupt 4 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 4 Enabled"]
            En = 1,
        }
        impl From<IRQ4EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ4EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ4EN` reader - External Interrupt 4 Enable Bit"]
        pub type IRQ4EN_R = crate::BitReader<IRQ4EN>;
        impl IRQ4EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ4EN {
                match self.bits {
                    false => IRQ4EN::Dis,
                    true => IRQ4EN::En,
                }
            }
            #[doc = "External Interrupt 4 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ4EN::Dis
            }
            #[doc = "External Interrupt 4 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ4EN::En
            }
        }
        #[doc = "Field `IRQ4EN` writer - External Interrupt 4 Enable Bit"]
        pub type IRQ4EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ4EN>;
        impl<'a, REG> IRQ4EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 4 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4EN::Dis)
            }
            #[doc = "External Interrupt 4 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4EN::En)
            }
        }
        #[doc = "External Interrupt 5 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ5MDE {
            #[doc = "0: Rising Edge"]
            Rising = 0,
            #[doc = "1: Falling Edge"]
            Falling = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ5MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ5MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ5MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ5MDE {}
        #[doc = "Field `IRQ5MDE` reader - External Interrupt 5 Mode Registers"]
        pub type IRQ5MDE_R = crate::FieldReader<IRQ5MDE>;
        impl IRQ5MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ5MDE {
                match self.bits {
                    0 => IRQ5MDE::Rising,
                    1 => IRQ5MDE::Falling,
                    2 => IRQ5MDE::Riseorfall,
                    3 => IRQ5MDE::Highlevel,
                    4 => IRQ5MDE::Lowlevel,
                    5 => IRQ5MDE::Fallaux,
                    6 => IRQ5MDE::Riseorfallaux,
                    7 => IRQ5MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rising(&self) -> bool {
                *self == IRQ5MDE::Rising
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_falling(&self) -> bool {
                *self == IRQ5MDE::Falling
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ5MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ5MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ5MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ5MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ5MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ5MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ5MDE` writer - External Interrupt 5 Mode Registers"]
        pub type IRQ5MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ5MDE, crate::Safe>;
        impl<'a, REG> IRQ5MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rising(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5MDE::Rising)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn falling(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5MDE::Falling)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 5 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ5EN {
            #[doc = "0: External Interrupt 5 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 5 Enabled"]
            En = 1,
        }
        impl From<IRQ5EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ5EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ5EN` reader - External Interrupt 5 Enable Bit"]
        pub type IRQ5EN_R = crate::BitReader<IRQ5EN>;
        impl IRQ5EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ5EN {
                match self.bits {
                    false => IRQ5EN::Dis,
                    true => IRQ5EN::En,
                }
            }
            #[doc = "External Interrupt 5 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ5EN::Dis
            }
            #[doc = "External Interrupt 5 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ5EN::En
            }
        }
        #[doc = "Field `IRQ5EN` writer - External Interrupt 5 Enable Bit"]
        pub type IRQ5EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ5EN>;
        impl<'a, REG> IRQ5EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 5 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5EN::Dis)
            }
            #[doc = "External Interrupt 5 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5EN::En)
            }
        }
        #[doc = "External Interrupt 6 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ6MDE {
            #[doc = "0: Rising Edge"]
            Rise = 0,
            #[doc = "1: Falling Edge"]
            Fall = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ6MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ6MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ6MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ6MDE {}
        #[doc = "Field `IRQ6MDE` reader - External Interrupt 6 Mode Registers"]
        pub type IRQ6MDE_R = crate::FieldReader<IRQ6MDE>;
        impl IRQ6MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ6MDE {
                match self.bits {
                    0 => IRQ6MDE::Rise,
                    1 => IRQ6MDE::Fall,
                    2 => IRQ6MDE::Riseorfall,
                    3 => IRQ6MDE::Highlevel,
                    4 => IRQ6MDE::Lowlevel,
                    5 => IRQ6MDE::Fallaux,
                    6 => IRQ6MDE::Riseorfallaux,
                    7 => IRQ6MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IRQ6MDE::Rise
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IRQ6MDE::Fall
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ6MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ6MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ6MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ6MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ6MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ6MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ6MDE` writer - External Interrupt 6 Mode Registers"]
        pub type IRQ6MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ6MDE, crate::Safe>;
        impl<'a, REG> IRQ6MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6MDE::Rise)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6MDE::Fall)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 6 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ6EN {
            #[doc = "0: External Interrupt 6 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 6 Enabled"]
            En = 1,
        }
        impl From<IRQ6EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ6EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ6EN` reader - External Interrupt 6 Enable Bit"]
        pub type IRQ6EN_R = crate::BitReader<IRQ6EN>;
        impl IRQ6EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ6EN {
                match self.bits {
                    false => IRQ6EN::Dis,
                    true => IRQ6EN::En,
                }
            }
            #[doc = "External Interrupt 6 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ6EN::Dis
            }
            #[doc = "External Interrupt 6 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ6EN::En
            }
        }
        #[doc = "Field `IRQ6EN` writer - External Interrupt 6 Enable Bit"]
        pub type IRQ6EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ6EN>;
        impl<'a, REG> IRQ6EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 6 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6EN::Dis)
            }
            #[doc = "External Interrupt 6 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6EN::En)
            }
        }
        #[doc = "External Interrupt 7 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ7MDE {
            #[doc = "0: Rising Edge"]
            Rise = 0,
            #[doc = "1: Falling Edge"]
            Fall = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ7MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ7MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ7MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ7MDE {}
        #[doc = "Field `IRQ7MDE` reader - External Interrupt 7 Mode Registers"]
        pub type IRQ7MDE_R = crate::FieldReader<IRQ7MDE>;
        impl IRQ7MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ7MDE {
                match self.bits {
                    0 => IRQ7MDE::Rise,
                    1 => IRQ7MDE::Fall,
                    2 => IRQ7MDE::Riseorfall,
                    3 => IRQ7MDE::Highlevel,
                    4 => IRQ7MDE::Lowlevel,
                    5 => IRQ7MDE::Fallaux,
                    6 => IRQ7MDE::Riseorfallaux,
                    7 => IRQ7MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IRQ7MDE::Rise
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IRQ7MDE::Fall
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ7MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ7MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ7MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ7MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ7MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ7MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ7MDE` writer - External Interrupt 7 Mode Registers"]
        pub type IRQ7MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ7MDE, crate::Safe>;
        impl<'a, REG> IRQ7MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7MDE::Rise)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7MDE::Fall)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 7 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ7EN {
            #[doc = "0: External Interrupt 7 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 7 Enabled"]
            En = 1,
        }
        impl From<IRQ7EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ7EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ7EN` reader - External Interrupt 7 Enable Bit"]
        pub type IRQ7EN_R = crate::BitReader<IRQ7EN>;
        impl IRQ7EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ7EN {
                match self.bits {
                    false => IRQ7EN::Dis,
                    true => IRQ7EN::En,
                }
            }
            #[doc = "External Interrupt 7 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ7EN::Dis
            }
            #[doc = "External Interrupt 7 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ7EN::En
            }
        }
        #[doc = "Field `IRQ7EN` writer - External Interrupt 7 Enable Bit"]
        pub type IRQ7EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ7EN>;
        impl<'a, REG> IRQ7EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 7 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7EN::Dis)
            }
            #[doc = "External Interrupt 7 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7EN::En)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - External Interrupt 4 Mode Registers"]
            #[inline(always)]
            pub fn irq4mde(&self) -> IRQ4MDE_R {
                IRQ4MDE_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bit 3 - External Interrupt 4 Enable Bit"]
            #[inline(always)]
            pub fn irq4en(&self) -> IRQ4EN_R {
                IRQ4EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:6 - External Interrupt 5 Mode Registers"]
            #[inline(always)]
            pub fn irq5mde(&self) -> IRQ5MDE_R {
                IRQ5MDE_R::new(((self.bits >> 4) & 7) as u8)
            }
            #[doc = "Bit 7 - External Interrupt 5 Enable Bit"]
            #[inline(always)]
            pub fn irq5en(&self) -> IRQ5EN_R {
                IRQ5EN_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bits 8:10 - External Interrupt 6 Mode Registers"]
            #[inline(always)]
            pub fn irq6mde(&self) -> IRQ6MDE_R {
                IRQ6MDE_R::new(((self.bits >> 8) & 7) as u8)
            }
            #[doc = "Bit 11 - External Interrupt 6 Enable Bit"]
            #[inline(always)]
            pub fn irq6en(&self) -> IRQ6EN_R {
                IRQ6EN_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bits 12:14 - External Interrupt 7 Mode Registers"]
            #[inline(always)]
            pub fn irq7mde(&self) -> IRQ7MDE_R {
                IRQ7MDE_R::new(((self.bits >> 12) & 7) as u8)
            }
            #[doc = "Bit 15 - External Interrupt 7 Enable Bit"]
            #[inline(always)]
            pub fn irq7en(&self) -> IRQ7EN_R {
                IRQ7EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EI1CFG")
                    .field("irq4mde", &self.irq4mde())
                    .field("irq4en", &self.irq4en())
                    .field("irq5mde", &self.irq5mde())
                    .field("irq5en", &self.irq5en())
                    .field("irq6mde", &self.irq6mde())
                    .field("irq6en", &self.irq6en())
                    .field("irq7mde", &self.irq7mde())
                    .field("irq7en", &self.irq7en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:2 - External Interrupt 4 Mode Registers"]
            #[inline(always)]
            pub fn irq4mde(&mut self) -> IRQ4MDE_W<EI1CFGrs> {
                IRQ4MDE_W::new(self, 0)
            }
            #[doc = "Bit 3 - External Interrupt 4 Enable Bit"]
            #[inline(always)]
            pub fn irq4en(&mut self) -> IRQ4EN_W<EI1CFGrs> {
                IRQ4EN_W::new(self, 3)
            }
            #[doc = "Bits 4:6 - External Interrupt 5 Mode Registers"]
            #[inline(always)]
            pub fn irq5mde(&mut self) -> IRQ5MDE_W<EI1CFGrs> {
                IRQ5MDE_W::new(self, 4)
            }
            #[doc = "Bit 7 - External Interrupt 5 Enable Bit"]
            #[inline(always)]
            pub fn irq5en(&mut self) -> IRQ5EN_W<EI1CFGrs> {
                IRQ5EN_W::new(self, 7)
            }
            #[doc = "Bits 8:10 - External Interrupt 6 Mode Registers"]
            #[inline(always)]
            pub fn irq6mde(&mut self) -> IRQ6MDE_W<EI1CFGrs> {
                IRQ6MDE_W::new(self, 8)
            }
            #[doc = "Bit 11 - External Interrupt 6 Enable Bit"]
            #[inline(always)]
            pub fn irq6en(&mut self) -> IRQ6EN_W<EI1CFGrs> {
                IRQ6EN_W::new(self, 11)
            }
            #[doc = "Bits 12:14 - External Interrupt 7 Mode Registers"]
            #[inline(always)]
            pub fn irq7mde(&mut self) -> IRQ7MDE_W<EI1CFGrs> {
                IRQ7MDE_W::new(self, 12)
            }
            #[doc = "Bit 15 - External Interrupt 7 Enable Bit"]
            #[inline(always)]
            pub fn irq7en(&mut self) -> IRQ7EN_W<EI1CFGrs> {
                IRQ7EN_W::new(self, 15)
            }
        }
        #[doc = "External Interrupt Configuration 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ei1cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ei1cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:EI1CFG)"]
        pub struct EI1CFGrs;
        impl crate::RegisterSpec for EI1CFGrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ei1cfg::R`](R) reader structure"]
        impl crate::Readable for EI1CFGrs {}
        #[doc = "`write(|w| ..)` method takes [`ei1cfg::W`](W) writer structure"]
        impl crate::Writable for EI1CFGrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EI1CFG to value 0"]
        impl crate::Resettable for EI1CFGrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EI2CFG (rw) register accessor: External Interrupt Configuration 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ei2cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ei2cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:EI2CFG)\n\nFor information about available fields see [`mod@ei2cfg`]
module"]
    pub type EI2CFG = crate::Reg<ei2cfg::EI2CFGrs>;
    #[doc = "External Interrupt Configuration 2"]
    pub mod ei2cfg {
        #[doc = "Register `EI2CFG` reader"]
        pub type R = crate::R<EI2CFGrs>;
        #[doc = "Register `EI2CFG` writer"]
        pub type W = crate::W<EI2CFGrs>;
        #[doc = "External Interrupt 8 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ8MDE {
            #[doc = "0: Rising Edge"]
            Rise = 0,
            #[doc = "1: Falling Edge"]
            Fall = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ8MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ8MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ8MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ8MDE {}
        #[doc = "Field `IRQ8MDE` reader - External Interrupt 8 Mode Registers"]
        pub type IRQ8MDE_R = crate::FieldReader<IRQ8MDE>;
        impl IRQ8MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ8MDE {
                match self.bits {
                    0 => IRQ8MDE::Rise,
                    1 => IRQ8MDE::Fall,
                    2 => IRQ8MDE::Riseorfall,
                    3 => IRQ8MDE::Highlevel,
                    4 => IRQ8MDE::Lowlevel,
                    5 => IRQ8MDE::Fallaux,
                    6 => IRQ8MDE::Riseorfallaux,
                    7 => IRQ8MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IRQ8MDE::Rise
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IRQ8MDE::Fall
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ8MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ8MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ8MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ8MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ8MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ8MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ8MDE` writer - External Interrupt 8 Mode Registers"]
        pub type IRQ8MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ8MDE, crate::Safe>;
        impl<'a, REG> IRQ8MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8MDE::Rise)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8MDE::Fall)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 8 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ8EN {
            #[doc = "0: External Interrupt 8 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 8 Enabled"]
            En = 1,
        }
        impl From<IRQ8EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ8EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ8EN` reader - External Interrupt 8 Enable Bit"]
        pub type IRQ8EN_R = crate::BitReader<IRQ8EN>;
        impl IRQ8EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ8EN {
                match self.bits {
                    false => IRQ8EN::Dis,
                    true => IRQ8EN::En,
                }
            }
            #[doc = "External Interrupt 8 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ8EN::Dis
            }
            #[doc = "External Interrupt 8 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ8EN::En
            }
        }
        #[doc = "Field `IRQ8EN` writer - External Interrupt 8 Enable Bit"]
        pub type IRQ8EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ8EN>;
        impl<'a, REG> IRQ8EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 8 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8EN::Dis)
            }
            #[doc = "External Interrupt 8 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8EN::En)
            }
        }
        #[doc = "External Interrupt 8 Mode Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ9MDE {
            #[doc = "0: Rising Edge"]
            Rise = 0,
            #[doc = "1: Falling Edge"]
            Fall = 1,
            #[doc = "2: Rising or Falling Edge"]
            Riseorfall = 2,
            #[doc = "3: High Level"]
            Highlevel = 3,
            #[doc = "4: Low Level"]
            Lowlevel = 4,
            #[doc = "5: Falling Edge (same as 001)"]
            Fallaux = 5,
            #[doc = "6: Rising or Falling Edge (same as 010)"]
            Riseorfallaux = 6,
            #[doc = "7: High Level (same as 011)"]
            Highlevelaux = 7,
        }
        impl From<IRQ9MDE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ9MDE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ9MDE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ9MDE {}
        #[doc = "Field `IRQ9MDE` reader - External Interrupt 8 Mode Registers"]
        pub type IRQ9MDE_R = crate::FieldReader<IRQ9MDE>;
        impl IRQ9MDE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ9MDE {
                match self.bits {
                    0 => IRQ9MDE::Rise,
                    1 => IRQ9MDE::Fall,
                    2 => IRQ9MDE::Riseorfall,
                    3 => IRQ9MDE::Highlevel,
                    4 => IRQ9MDE::Lowlevel,
                    5 => IRQ9MDE::Fallaux,
                    6 => IRQ9MDE::Riseorfallaux,
                    7 => IRQ9MDE::Highlevelaux,
                    _ => unreachable!(),
                }
            }
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IRQ9MDE::Rise
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IRQ9MDE::Fall
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn is_riseorfall(&self) -> bool {
                *self == IRQ9MDE::Riseorfall
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == IRQ9MDE::Highlevel
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == IRQ9MDE::Lowlevel
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn is_fallaux(&self) -> bool {
                *self == IRQ9MDE::Fallaux
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn is_riseorfallaux(&self) -> bool {
                *self == IRQ9MDE::Riseorfallaux
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn is_highlevelaux(&self) -> bool {
                *self == IRQ9MDE::Highlevelaux
            }
        }
        #[doc = "Field `IRQ9MDE` writer - External Interrupt 8 Mode Registers"]
        pub type IRQ9MDE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQ9MDE, crate::Safe>;
        impl<'a, REG> IRQ9MDE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Rising Edge"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9MDE::Rise)
            }
            #[doc = "Falling Edge"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9MDE::Fall)
            }
            #[doc = "Rising or Falling Edge"]
            #[inline(always)]
            pub fn riseorfall(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9MDE::Riseorfall)
            }
            #[doc = "High Level"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9MDE::Highlevel)
            }
            #[doc = "Low Level"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9MDE::Lowlevel)
            }
            #[doc = "Falling Edge (same as 001)"]
            #[inline(always)]
            pub fn fallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9MDE::Fallaux)
            }
            #[doc = "Rising or Falling Edge (same as 010)"]
            #[inline(always)]
            pub fn riseorfallaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9MDE::Riseorfallaux)
            }
            #[doc = "High Level (same as 011)"]
            #[inline(always)]
            pub fn highlevelaux(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9MDE::Highlevelaux)
            }
        }
        #[doc = "External Interrupt 8 Enable Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ9EN {
            #[doc = "0: External Interrupt 8 Disabled"]
            Dis = 0,
            #[doc = "1: External Interrupt 8 Enabled"]
            En = 1,
        }
        impl From<IRQ9EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ9EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ9EN` reader - External Interrupt 8 Enable Bit"]
        pub type IRQ9EN_R = crate::BitReader<IRQ9EN>;
        impl IRQ9EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ9EN {
                match self.bits {
                    false => IRQ9EN::Dis,
                    true => IRQ9EN::En,
                }
            }
            #[doc = "External Interrupt 8 Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ9EN::Dis
            }
            #[doc = "External Interrupt 8 Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ9EN::En
            }
        }
        #[doc = "Field `IRQ9EN` writer - External Interrupt 8 Enable Bit"]
        pub type IRQ9EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ9EN>;
        impl<'a, REG> IRQ9EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "External Interrupt 8 Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9EN::Dis)
            }
            #[doc = "External Interrupt 8 Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9EN::En)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - External Interrupt 8 Mode Registers"]
            #[inline(always)]
            pub fn irq8mde(&self) -> IRQ8MDE_R {
                IRQ8MDE_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bit 3 - External Interrupt 8 Enable Bit"]
            #[inline(always)]
            pub fn irq8en(&self) -> IRQ8EN_R {
                IRQ8EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:6 - External Interrupt 8 Mode Registers"]
            #[inline(always)]
            pub fn irq9mde(&self) -> IRQ9MDE_R {
                IRQ9MDE_R::new(((self.bits >> 4) & 7) as u8)
            }
            #[doc = "Bit 7 - External Interrupt 8 Enable Bit"]
            #[inline(always)]
            pub fn irq9en(&self) -> IRQ9EN_R {
                IRQ9EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EI2CFG")
                    .field("irq8mde", &self.irq8mde())
                    .field("irq8en", &self.irq8en())
                    .field("irq9mde", &self.irq9mde())
                    .field("irq9en", &self.irq9en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:2 - External Interrupt 8 Mode Registers"]
            #[inline(always)]
            pub fn irq8mde(&mut self) -> IRQ8MDE_W<EI2CFGrs> {
                IRQ8MDE_W::new(self, 0)
            }
            #[doc = "Bit 3 - External Interrupt 8 Enable Bit"]
            #[inline(always)]
            pub fn irq8en(&mut self) -> IRQ8EN_W<EI2CFGrs> {
                IRQ8EN_W::new(self, 3)
            }
            #[doc = "Bits 4:6 - External Interrupt 8 Mode Registers"]
            #[inline(always)]
            pub fn irq9mde(&mut self) -> IRQ9MDE_W<EI2CFGrs> {
                IRQ9MDE_W::new(self, 4)
            }
            #[doc = "Bit 7 - External Interrupt 8 Enable Bit"]
            #[inline(always)]
            pub fn irq9en(&mut self) -> IRQ9EN_W<EI2CFGrs> {
                IRQ9EN_W::new(self, 7)
            }
        }
        #[doc = "External Interrupt Configuration 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ei2cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ei2cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:EI2CFG)"]
        pub struct EI2CFGrs;
        impl crate::RegisterSpec for EI2CFGrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ei2cfg::R`](R) reader structure"]
        impl crate::Readable for EI2CFGrs {}
        #[doc = "`write(|w| ..)` method takes [`ei2cfg::W`](W) writer structure"]
        impl crate::Writable for EI2CFGrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EI2CFG to value 0"]
        impl crate::Resettable for EI2CFGrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EICLR (rw) register accessor: External Interrupt Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`eiclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eiclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:EICLR)\n\nFor information about available fields see [`mod@eiclr`]
module"]
    pub type EICLR = crate::Reg<eiclr::EICLRrs>;
    #[doc = "External Interrupt Clear"]
    pub mod eiclr {
        #[doc = "Register `EICLR` reader"]
        pub type R = crate::R<EICLRrs>;
        #[doc = "Register `EICLR` writer"]
        pub type W = crate::W<EICLRrs>;
        #[doc = "External Interrupt 0\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ0 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ0> for bool {
            #[inline(always)]
            fn from(variant: IRQ0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ0` reader - External Interrupt 0"]
        pub type IRQ0_R = crate::BitReader<IRQ0>;
        impl IRQ0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ0 {
                match self.bits {
                    false => IRQ0::Notclr,
                    true => IRQ0::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ0::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ0::Clr
            }
        }
        #[doc = "Field `IRQ0` writer - External Interrupt 0"]
        pub type IRQ0_W<'a, REG> = crate::BitWriter<'a, REG, IRQ0>;
        impl<'a, REG> IRQ0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0::Clr)
            }
        }
        #[doc = "External Interrupt 1\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ1 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ1> for bool {
            #[inline(always)]
            fn from(variant: IRQ1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ1` reader - External Interrupt 1"]
        pub type IRQ1_R = crate::BitReader<IRQ1>;
        impl IRQ1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ1 {
                match self.bits {
                    false => IRQ1::Notclr,
                    true => IRQ1::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ1::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ1::Clr
            }
        }
        #[doc = "Field `IRQ1` writer - External Interrupt 1"]
        pub type IRQ1_W<'a, REG> = crate::BitWriter<'a, REG, IRQ1>;
        impl<'a, REG> IRQ1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1::Clr)
            }
        }
        #[doc = "External Interrupt 2\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ2 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ2> for bool {
            #[inline(always)]
            fn from(variant: IRQ2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ2` reader - External Interrupt 2"]
        pub type IRQ2_R = crate::BitReader<IRQ2>;
        impl IRQ2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ2 {
                match self.bits {
                    false => IRQ2::Notclr,
                    true => IRQ2::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ2::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ2::Clr
            }
        }
        #[doc = "Field `IRQ2` writer - External Interrupt 2"]
        pub type IRQ2_W<'a, REG> = crate::BitWriter<'a, REG, IRQ2>;
        impl<'a, REG> IRQ2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2::Clr)
            }
        }
        #[doc = "External Interrupt 3\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ3 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ3> for bool {
            #[inline(always)]
            fn from(variant: IRQ3) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ3` reader - External Interrupt 3"]
        pub type IRQ3_R = crate::BitReader<IRQ3>;
        impl IRQ3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ3 {
                match self.bits {
                    false => IRQ3::Notclr,
                    true => IRQ3::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ3::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ3::Clr
            }
        }
        #[doc = "Field `IRQ3` writer - External Interrupt 3"]
        pub type IRQ3_W<'a, REG> = crate::BitWriter<'a, REG, IRQ3>;
        impl<'a, REG> IRQ3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3::Clr)
            }
        }
        #[doc = "External Interrupt 4\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ4 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ4> for bool {
            #[inline(always)]
            fn from(variant: IRQ4) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ4` reader - External Interrupt 4"]
        pub type IRQ4_R = crate::BitReader<IRQ4>;
        impl IRQ4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ4 {
                match self.bits {
                    false => IRQ4::Notclr,
                    true => IRQ4::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ4::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ4::Clr
            }
        }
        #[doc = "Field `IRQ4` writer - External Interrupt 4"]
        pub type IRQ4_W<'a, REG> = crate::BitWriter<'a, REG, IRQ4>;
        impl<'a, REG> IRQ4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ4::Clr)
            }
        }
        #[doc = "External Interrupt 5\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ5 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ5> for bool {
            #[inline(always)]
            fn from(variant: IRQ5) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ5` reader - External Interrupt 5"]
        pub type IRQ5_R = crate::BitReader<IRQ5>;
        impl IRQ5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ5 {
                match self.bits {
                    false => IRQ5::Notclr,
                    true => IRQ5::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ5::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ5::Clr
            }
        }
        #[doc = "Field `IRQ5` writer - External Interrupt 5"]
        pub type IRQ5_W<'a, REG> = crate::BitWriter<'a, REG, IRQ5>;
        impl<'a, REG> IRQ5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ5::Clr)
            }
        }
        #[doc = "External Interrupt 6\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ6 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ6> for bool {
            #[inline(always)]
            fn from(variant: IRQ6) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ6` reader - External Interrupt 6"]
        pub type IRQ6_R = crate::BitReader<IRQ6>;
        impl IRQ6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ6 {
                match self.bits {
                    false => IRQ6::Notclr,
                    true => IRQ6::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ6::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ6::Clr
            }
        }
        #[doc = "Field `IRQ6` writer - External Interrupt 6"]
        pub type IRQ6_W<'a, REG> = crate::BitWriter<'a, REG, IRQ6>;
        impl<'a, REG> IRQ6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ6::Clr)
            }
        }
        #[doc = "External Interrupt 7\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ7 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ7> for bool {
            #[inline(always)]
            fn from(variant: IRQ7) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ7` reader - External Interrupt 7"]
        pub type IRQ7_R = crate::BitReader<IRQ7>;
        impl IRQ7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ7 {
                match self.bits {
                    false => IRQ7::Notclr,
                    true => IRQ7::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ7::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ7::Clr
            }
        }
        #[doc = "Field `IRQ7` writer - External Interrupt 7"]
        pub type IRQ7_W<'a, REG> = crate::BitWriter<'a, REG, IRQ7>;
        impl<'a, REG> IRQ7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ7::Clr)
            }
        }
        #[doc = "External Interrupt 8\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ8 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ8> for bool {
            #[inline(always)]
            fn from(variant: IRQ8) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ8` reader - External Interrupt 8"]
        pub type IRQ8_R = crate::BitReader<IRQ8>;
        impl IRQ8_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ8 {
                match self.bits {
                    false => IRQ8::Notclr,
                    true => IRQ8::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ8::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ8::Clr
            }
        }
        #[doc = "Field `IRQ8` writer - External Interrupt 8"]
        pub type IRQ8_W<'a, REG> = crate::BitWriter<'a, REG, IRQ8>;
        impl<'a, REG> IRQ8_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ8::Clr)
            }
        }
        #[doc = "External Interrupt 9\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ9 {
            #[doc = "0: Unknown"]
            Notclr = 0,
            #[doc = "1: Unknown"]
            Clr = 1,
        }
        impl From<IRQ9> for bool {
            #[inline(always)]
            fn from(variant: IRQ9) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IRQ9` reader - External Interrupt 9"]
        pub type IRQ9_R = crate::BitReader<IRQ9>;
        impl IRQ9_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ9 {
                match self.bits {
                    false => IRQ9::Notclr,
                    true => IRQ9::Clr,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_notclr(&self) -> bool {
                *self == IRQ9::Notclr
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_clr(&self) -> bool {
                *self == IRQ9::Clr
            }
        }
        #[doc = "Field `IRQ9` writer - External Interrupt 9"]
        pub type IRQ9_W<'a, REG> = crate::BitWriter<'a, REG, IRQ9>;
        impl<'a, REG> IRQ9_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn notclr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9::Notclr)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn clr(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ9::Clr)
            }
        }
        impl R {
            #[doc = "Bit 0 - External Interrupt 0"]
            #[inline(always)]
            pub fn irq0(&self) -> IRQ0_R {
                IRQ0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - External Interrupt 1"]
            #[inline(always)]
            pub fn irq1(&self) -> IRQ1_R {
                IRQ1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - External Interrupt 2"]
            #[inline(always)]
            pub fn irq2(&self) -> IRQ2_R {
                IRQ2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - External Interrupt 3"]
            #[inline(always)]
            pub fn irq3(&self) -> IRQ3_R {
                IRQ3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - External Interrupt 4"]
            #[inline(always)]
            pub fn irq4(&self) -> IRQ4_R {
                IRQ4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - External Interrupt 5"]
            #[inline(always)]
            pub fn irq5(&self) -> IRQ5_R {
                IRQ5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - External Interrupt 6"]
            #[inline(always)]
            pub fn irq6(&self) -> IRQ6_R {
                IRQ6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - External Interrupt 7"]
            #[inline(always)]
            pub fn irq7(&self) -> IRQ7_R {
                IRQ7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - External Interrupt 8"]
            #[inline(always)]
            pub fn irq8(&self) -> IRQ8_R {
                IRQ8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - External Interrupt 9"]
            #[inline(always)]
            pub fn irq9(&self) -> IRQ9_R {
                IRQ9_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EICLR")
                    .field("irq0", &self.irq0())
                    .field("irq1", &self.irq1())
                    .field("irq2", &self.irq2())
                    .field("irq3", &self.irq3())
                    .field("irq4", &self.irq4())
                    .field("irq5", &self.irq5())
                    .field("irq6", &self.irq6())
                    .field("irq7", &self.irq7())
                    .field("irq8", &self.irq8())
                    .field("irq9", &self.irq9())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - External Interrupt 0"]
            #[inline(always)]
            pub fn irq0(&mut self) -> IRQ0_W<EICLRrs> {
                IRQ0_W::new(self, 0)
            }
            #[doc = "Bit 1 - External Interrupt 1"]
            #[inline(always)]
            pub fn irq1(&mut self) -> IRQ1_W<EICLRrs> {
                IRQ1_W::new(self, 1)
            }
            #[doc = "Bit 2 - External Interrupt 2"]
            #[inline(always)]
            pub fn irq2(&mut self) -> IRQ2_W<EICLRrs> {
                IRQ2_W::new(self, 2)
            }
            #[doc = "Bit 3 - External Interrupt 3"]
            #[inline(always)]
            pub fn irq3(&mut self) -> IRQ3_W<EICLRrs> {
                IRQ3_W::new(self, 3)
            }
            #[doc = "Bit 4 - External Interrupt 4"]
            #[inline(always)]
            pub fn irq4(&mut self) -> IRQ4_W<EICLRrs> {
                IRQ4_W::new(self, 4)
            }
            #[doc = "Bit 5 - External Interrupt 5"]
            #[inline(always)]
            pub fn irq5(&mut self) -> IRQ5_W<EICLRrs> {
                IRQ5_W::new(self, 5)
            }
            #[doc = "Bit 6 - External Interrupt 6"]
            #[inline(always)]
            pub fn irq6(&mut self) -> IRQ6_W<EICLRrs> {
                IRQ6_W::new(self, 6)
            }
            #[doc = "Bit 7 - External Interrupt 7"]
            #[inline(always)]
            pub fn irq7(&mut self) -> IRQ7_W<EICLRrs> {
                IRQ7_W::new(self, 7)
            }
            #[doc = "Bit 8 - External Interrupt 8"]
            #[inline(always)]
            pub fn irq8(&mut self) -> IRQ8_W<EICLRrs> {
                IRQ8_W::new(self, 8)
            }
            #[doc = "Bit 9 - External Interrupt 9"]
            #[inline(always)]
            pub fn irq9(&mut self) -> IRQ9_W<EICLRrs> {
                IRQ9_W::new(self, 9)
            }
        }
        #[doc = "External Interrupt Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`eiclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eiclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:EICLR)"]
        pub struct EICLRrs;
        impl crate::RegisterSpec for EICLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`eiclr::R`](R) reader structure"]
        impl crate::Readable for EICLRrs {}
        #[doc = "`write(|w| ..)` method takes [`eiclr::W`](W) writer structure"]
        impl crate::Writable for EICLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EICLR to value 0"]
        impl crate::Resettable for EICLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RSTSTA (rw) register accessor: Reset Status\n\nYou can [`read`](crate::Reg::read) this register and get [`rststa::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rststa::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:RSTSTA)\n\nFor information about available fields see [`mod@rststa`]
module"]
    pub type RSTSTA = crate::Reg<rststa::RSTSTArs>;
    #[doc = "Reset Status"]
    pub mod rststa {
        #[doc = "Register `RSTSTA` reader"]
        pub type R = crate::R<RSTSTArs>;
        #[doc = "Register `RSTSTA` writer"]
        pub type W = crate::W<RSTSTArs>;
        #[doc = "Field `POR` reader - Power-on Reset"]
        pub type POR_R = crate::BitReader;
        #[doc = "Field `POR` writer - Power-on Reset"]
        pub type POR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EXTRST` reader - External Reset"]
        pub type EXTRST_R = crate::BitReader;
        #[doc = "Field `EXTRST` writer - External Reset"]
        pub type EXTRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDRST` reader - Watchdog Timeout"]
        pub type WDRST_R = crate::BitReader;
        #[doc = "Field `WDRST` writer - Watchdog Timeout"]
        pub type WDRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SWRST` reader - Software Reset"]
        pub type SWRST_R = crate::BitReader;
        #[doc = "Field `SWRST` writer - Software Reset"]
        pub type SWRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Power-on Reset"]
            #[inline(always)]
            pub fn por(&self) -> POR_R {
                POR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - External Reset"]
            #[inline(always)]
            pub fn extrst(&self) -> EXTRST_R {
                EXTRST_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Watchdog Timeout"]
            #[inline(always)]
            pub fn wdrst(&self) -> WDRST_R {
                WDRST_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SWRST_R {
                SWRST_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RSTSTA")
                    .field("por", &self.por())
                    .field("extrst", &self.extrst())
                    .field("wdrst", &self.wdrst())
                    .field("swrst", &self.swrst())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Power-on Reset"]
            #[inline(always)]
            pub fn por(&mut self) -> POR_W<RSTSTArs> {
                POR_W::new(self, 0)
            }
            #[doc = "Bit 1 - External Reset"]
            #[inline(always)]
            pub fn extrst(&mut self) -> EXTRST_W<RSTSTArs> {
                EXTRST_W::new(self, 1)
            }
            #[doc = "Bit 2 - Watchdog Timeout"]
            #[inline(always)]
            pub fn wdrst(&mut self) -> WDRST_W<RSTSTArs> {
                WDRST_W::new(self, 2)
            }
            #[doc = "Bit 3 - Software Reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> SWRST_W<RSTSTArs> {
                SWRST_W::new(self, 3)
            }
        }
        #[doc = "Reset Status\n\nYou can [`read`](crate::Reg::read) this register and get [`rststa::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rststa::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ALLON:RSTSTA)"]
        pub struct RSTSTArs;
        impl crate::RegisterSpec for RSTSTArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rststa::R`](R) reader structure"]
        impl crate::Readable for RSTSTArs {}
        #[doc = "`write(|w| ..)` method takes [`rststa::W`](W) writer structure"]
        impl crate::Writable for RSTSTArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RSTSTA to value 0"]
        impl crate::Resettable for RSTSTArs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA)"]
pub struct PLA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PLA {}
impl PLA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pla::RegisterBlock = 0x4000_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pla::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PLA {
    type Target = pla::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PLA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PLA").finish()
    }
}
#[doc = "Unknown"]
pub mod pla {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        elmxcon: [ELMXCON; 32],
        pla_clk: PLA_CLK,
        pla_irq0: PLA_IRQ0,
        pla_irq1: PLA_IRQ1,
        pla_adc: PLA_ADC,
        pla_din0: PLA_DIN0,
        _reserved6: [u8; 0x04],
        pla_dout0: PLA_DOUT0,
        pla_dout1: PLA_DOUT1,
        pla_lck: PLA_LCK,
        pla_irqtype: PLA_IRQTYPE,
    }
    impl RegisterBlock {
        #[doc = "0x00..0x80 - ELMx Configuration Registers"]
        #[inline(always)]
        pub const fn elmxcon(&self, n: usize) -> &ELMXCON {
            &self.elmxcon[n]
        }
        #[doc = "Iterator for array of:"]
        #[doc = "0x00..0x80 - ELMx Configuration Registers"]
        #[inline(always)]
        pub fn elmxcon_iter(&self) -> impl Iterator<Item = &ELMXCON> {
            self.elmxcon.iter()
        }
        #[doc = "0x80 - PLA Clock Select"]
        #[inline(always)]
        pub const fn pla_clk(&self) -> &PLA_CLK {
            &self.pla_clk
        }
        #[doc = "0x84 - Interrupt Register for Block 0"]
        #[inline(always)]
        pub const fn pla_irq0(&self) -> &PLA_IRQ0 {
            &self.pla_irq0
        }
        #[doc = "0x88 - Interrupt Register for Block1"]
        #[inline(always)]
        pub const fn pla_irq1(&self) -> &PLA_IRQ1 {
            &self.pla_irq1
        }
        #[doc = "0x8c - ADC Configuration Register"]
        #[inline(always)]
        pub const fn pla_adc(&self) -> &PLA_ADC {
            &self.pla_adc
        }
        #[doc = "0x90 - AMBA Bus Data Input for Block 0"]
        #[inline(always)]
        pub const fn pla_din0(&self) -> &PLA_DIN0 {
            &self.pla_din0
        }
        #[doc = "0x98 - AMBA Bus Data Output for Block 0"]
        #[inline(always)]
        pub const fn pla_dout0(&self) -> &PLA_DOUT0 {
            &self.pla_dout0
        }
        #[doc = "0x9c - AMBA Bus Data Output for Block1"]
        #[inline(always)]
        pub const fn pla_dout1(&self) -> &PLA_DOUT1 {
            &self.pla_dout1
        }
        #[doc = "0xa0 - Write Lock Register."]
        #[inline(always)]
        pub const fn pla_lck(&self) -> &PLA_LCK {
            &self.pla_lck
        }
        #[doc = "0xa4 - PLA Interrupt Request and DMA Request Type"]
        #[inline(always)]
        pub const fn pla_irqtype(&self) -> &PLA_IRQTYPE {
            &self.pla_irqtype
        }
    }
    #[doc = "ELMx Configuration Registers"]
    pub use self::elmxcon::ELMXCON;
    #[doc = r"Cluster"]
    #[doc = "ELMx Configuration Registers"]
    pub mod elmxcon {
        #[repr(C)]
        #[derive(Debug)]
        #[doc = "ELMx Configuration Registers"]
        #[doc(alias = "ELMxcon")]
        pub struct ELMXCON {
            pla_elem: PLA_ELEM,
        }
        impl ELMXCON {
            #[doc = "0x00 - ELEMx Configuration Register"]
            #[inline(always)]
            pub const fn pla_elem(&self) -> &PLA_ELEM {
                &self.pla_elem
            }
        }
        #[doc = "PLA_ELEM (rw) register accessor: ELEMx Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_elem::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_elem::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pla_elem`]
module"]
        pub type PLA_ELEM = crate::Reg<pla_elem::PLA_ELEMrs>;
        #[doc = "ELEMx Configuration Register"]
        pub mod pla_elem {
            #[doc = "Register `PLA_ELEM` reader"]
            pub type R = crate::R<PLA_ELEMrs>;
            #[doc = "Register `PLA_ELEM` writer"]
            pub type W = crate::W<PLA_ELEMrs>;
            #[doc = "Select or Bypass Flip-flop Output\n\nValue on reset: 0"]
            #[cfg_attr(feature = "defmt", derive(defmt::Format))]
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            pub enum MUX4 {
                #[doc = "0: FF Output"]
                Ff = 0,
                #[doc = "1: Bypass Output"]
                Bypass = 1,
            }
            impl From<MUX4> for bool {
                #[inline(always)]
                fn from(variant: MUX4) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Field `MUX4` reader - Select or Bypass Flip-flop Output"]
            pub type MUX4_R = crate::BitReader<MUX4>;
            impl MUX4_R {
                #[doc = "Get enumerated values variant"]
                #[inline(always)]
                pub const fn variant(&self) -> MUX4 {
                    match self.bits {
                        false => MUX4::Ff,
                        true => MUX4::Bypass,
                    }
                }
                #[doc = "FF Output"]
                #[inline(always)]
                pub fn is_ff(&self) -> bool {
                    *self == MUX4::Ff
                }
                #[doc = "Bypass Output"]
                #[inline(always)]
                pub fn is_bypass(&self) -> bool {
                    *self == MUX4::Bypass
                }
            }
            #[doc = "Field `MUX4` writer - Select or Bypass Flip-flop Output"]
            pub type MUX4_W<'a, REG> = crate::BitWriter<'a, REG, MUX4>;
            impl<'a, REG> MUX4_W<'a, REG>
            where
                REG: crate::Writable + crate::RegisterSpec,
            {
                #[doc = "FF Output"]
                #[inline(always)]
                pub fn ff(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX4::Ff)
                }
                #[doc = "Bypass Output"]
                #[inline(always)]
                pub fn bypass(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX4::Bypass)
                }
            }
            #[doc = "Configures Output\n\nValue on reset: 0"]
            #[cfg_attr(feature = "defmt", derive(defmt::Format))]
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            #[repr(u8)]
            pub enum TBL {
                #[doc = "0: 0."]
                Low = 0,
                #[doc = "1: NOR."]
                FunNor = 1,
                #[doc = "2: B and Not A."]
                Bandnota = 2,
                #[doc = "3: NOT A."]
                Nota = 3,
                #[doc = "4: A and Not B."]
                Aandnotb = 4,
                #[doc = "5: Not B."]
                Notb = 5,
                #[doc = "6: EXOR."]
                Exor = 6,
                #[doc = "7: NAND."]
                FunNand = 7,
                #[doc = "8: AND."]
                FunAnd = 8,
                #[doc = "9: EXNOR."]
                Exnor = 9,
                #[doc = "10: B."]
                B = 10,
                #[doc = "11: B or Not A."]
                Bornota = 11,
                #[doc = "12: A."]
                A = 12,
                #[doc = "13: A or Not B."]
                Aornotb = 13,
                #[doc = "14: OR"]
                FunOr = 14,
                #[doc = "15: 1."]
                High = 15,
            }
            impl From<TBL> for u8 {
                #[inline(always)]
                fn from(variant: TBL) -> Self {
                    variant as _
                }
            }
            impl crate::FieldSpec for TBL {
                type Ux = u8;
            }
            impl crate::IsEnum for TBL {}
            #[doc = "Field `TBL` reader - Configures Output"]
            pub type TBL_R = crate::FieldReader<TBL>;
            impl TBL_R {
                #[doc = "Get enumerated values variant"]
                #[inline(always)]
                pub const fn variant(&self) -> TBL {
                    match self.bits {
                        0 => TBL::Low,
                        1 => TBL::FunNor,
                        2 => TBL::Bandnota,
                        3 => TBL::Nota,
                        4 => TBL::Aandnotb,
                        5 => TBL::Notb,
                        6 => TBL::Exor,
                        7 => TBL::FunNand,
                        8 => TBL::FunAnd,
                        9 => TBL::Exnor,
                        10 => TBL::B,
                        11 => TBL::Bornota,
                        12 => TBL::A,
                        13 => TBL::Aornotb,
                        14 => TBL::FunOr,
                        15 => TBL::High,
                        _ => unreachable!(),
                    }
                }
                #[doc = "0."]
                #[inline(always)]
                pub fn is_low(&self) -> bool {
                    *self == TBL::Low
                }
                #[doc = "NOR."]
                #[inline(always)]
                pub fn is_fun_nor(&self) -> bool {
                    *self == TBL::FunNor
                }
                #[doc = "B and Not A."]
                #[inline(always)]
                pub fn is_bandnota(&self) -> bool {
                    *self == TBL::Bandnota
                }
                #[doc = "NOT A."]
                #[inline(always)]
                pub fn is_nota(&self) -> bool {
                    *self == TBL::Nota
                }
                #[doc = "A and Not B."]
                #[inline(always)]
                pub fn is_aandnotb(&self) -> bool {
                    *self == TBL::Aandnotb
                }
                #[doc = "Not B."]
                #[inline(always)]
                pub fn is_notb(&self) -> bool {
                    *self == TBL::Notb
                }
                #[doc = "EXOR."]
                #[inline(always)]
                pub fn is_exor(&self) -> bool {
                    *self == TBL::Exor
                }
                #[doc = "NAND."]
                #[inline(always)]
                pub fn is_fun_nand(&self) -> bool {
                    *self == TBL::FunNand
                }
                #[doc = "AND."]
                #[inline(always)]
                pub fn is_fun_and(&self) -> bool {
                    *self == TBL::FunAnd
                }
                #[doc = "EXNOR."]
                #[inline(always)]
                pub fn is_exnor(&self) -> bool {
                    *self == TBL::Exnor
                }
                #[doc = "B."]
                #[inline(always)]
                pub fn is_b(&self) -> bool {
                    *self == TBL::B
                }
                #[doc = "B or Not A."]
                #[inline(always)]
                pub fn is_bornota(&self) -> bool {
                    *self == TBL::Bornota
                }
                #[doc = "A."]
                #[inline(always)]
                pub fn is_a(&self) -> bool {
                    *self == TBL::A
                }
                #[doc = "A or Not B."]
                #[inline(always)]
                pub fn is_aornotb(&self) -> bool {
                    *self == TBL::Aornotb
                }
                #[doc = "OR"]
                #[inline(always)]
                pub fn is_fun_or(&self) -> bool {
                    *self == TBL::FunOr
                }
                #[doc = "1."]
                #[inline(always)]
                pub fn is_high(&self) -> bool {
                    *self == TBL::High
                }
            }
            #[doc = "Field `TBL` writer - Configures Output"]
            pub type TBL_W<'a, REG> = crate::FieldWriter<'a, REG, 4, TBL, crate::Safe>;
            impl<'a, REG> TBL_W<'a, REG>
            where
                REG: crate::Writable + crate::RegisterSpec,
                REG::Ux: From<u8>,
            {
                #[doc = "0."]
                #[inline(always)]
                pub fn low(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::Low)
                }
                #[doc = "NOR."]
                #[inline(always)]
                pub fn fun_nor(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::FunNor)
                }
                #[doc = "B and Not A."]
                #[inline(always)]
                pub fn bandnota(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::Bandnota)
                }
                #[doc = "NOT A."]
                #[inline(always)]
                pub fn nota(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::Nota)
                }
                #[doc = "A and Not B."]
                #[inline(always)]
                pub fn aandnotb(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::Aandnotb)
                }
                #[doc = "Not B."]
                #[inline(always)]
                pub fn notb(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::Notb)
                }
                #[doc = "EXOR."]
                #[inline(always)]
                pub fn exor(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::Exor)
                }
                #[doc = "NAND."]
                #[inline(always)]
                pub fn fun_nand(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::FunNand)
                }
                #[doc = "AND."]
                #[inline(always)]
                pub fn fun_and(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::FunAnd)
                }
                #[doc = "EXNOR."]
                #[inline(always)]
                pub fn exnor(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::Exnor)
                }
                #[doc = "B."]
                #[inline(always)]
                pub fn b(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::B)
                }
                #[doc = "B or Not A."]
                #[inline(always)]
                pub fn bornota(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::Bornota)
                }
                #[doc = "A."]
                #[inline(always)]
                pub fn a(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::A)
                }
                #[doc = "A or Not B."]
                #[inline(always)]
                pub fn aornotb(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::Aornotb)
                }
                #[doc = "OR"]
                #[inline(always)]
                pub fn fun_or(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::FunOr)
                }
                #[doc = "1."]
                #[inline(always)]
                pub fn high(self) -> &'a mut crate::W<REG> {
                    self.variant(TBL::High)
                }
            }
            #[doc = "Mux Between GPIO Bus Input or Odd Feedback Input\n\nValue on reset: 0"]
            #[cfg_attr(feature = "defmt", derive(defmt::Format))]
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            pub enum MUX3 {
                #[doc = "0: Odd Feedback Mux"]
                Odd = 0,
                #[doc = "1: GPIO Input"]
                Gpio = 1,
            }
            impl From<MUX3> for bool {
                #[inline(always)]
                fn from(variant: MUX3) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Field `MUX3` reader - Mux Between GPIO Bus Input or Odd Feedback Input"]
            pub type MUX3_R = crate::BitReader<MUX3>;
            impl MUX3_R {
                #[doc = "Get enumerated values variant"]
                #[inline(always)]
                pub const fn variant(&self) -> MUX3 {
                    match self.bits {
                        false => MUX3::Odd,
                        true => MUX3::Gpio,
                    }
                }
                #[doc = "Odd Feedback Mux"]
                #[inline(always)]
                pub fn is_odd(&self) -> bool {
                    *self == MUX3::Odd
                }
                #[doc = "GPIO Input"]
                #[inline(always)]
                pub fn is_gpio(&self) -> bool {
                    *self == MUX3::Gpio
                }
            }
            #[doc = "Field `MUX3` writer - Mux Between GPIO Bus Input or Odd Feedback Input"]
            pub type MUX3_W<'a, REG> = crate::BitWriter<'a, REG, MUX3>;
            impl<'a, REG> MUX3_W<'a, REG>
            where
                REG: crate::Writable + crate::RegisterSpec,
            {
                #[doc = "Odd Feedback Mux"]
                #[inline(always)]
                pub fn odd(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX3::Odd)
                }
                #[doc = "GPIO Input"]
                #[inline(always)]
                pub fn gpio(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX3::Gpio)
                }
            }
            #[doc = "Mux Between PLA_DINx Register/Block0 Output or Even Feedback\n\nValue on reset: 0"]
            #[cfg_attr(feature = "defmt", derive(defmt::Format))]
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            pub enum MUX2 {
                #[doc = "0: PLA_DINx Input"]
                Mmr = 0,
                #[doc = "1: Even Feedback Mux"]
                Even = 1,
            }
            impl From<MUX2> for bool {
                #[inline(always)]
                fn from(variant: MUX2) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Field `MUX2` reader - Mux Between PLA_DINx Register/Block0 Output or Even Feedback"]
            pub type MUX2_R = crate::BitReader<MUX2>;
            impl MUX2_R {
                #[doc = "Get enumerated values variant"]
                #[inline(always)]
                pub const fn variant(&self) -> MUX2 {
                    match self.bits {
                        false => MUX2::Mmr,
                        true => MUX2::Even,
                    }
                }
                #[doc = "PLA_DINx Input"]
                #[inline(always)]
                pub fn is_mmr(&self) -> bool {
                    *self == MUX2::Mmr
                }
                #[doc = "Even Feedback Mux"]
                #[inline(always)]
                pub fn is_even(&self) -> bool {
                    *self == MUX2::Even
                }
            }
            #[doc = "Field `MUX2` writer - Mux Between PLA_DINx Register/Block0 Output or Even Feedback"]
            pub type MUX2_W<'a, REG> = crate::BitWriter<'a, REG, MUX2>;
            impl<'a, REG> MUX2_W<'a, REG>
            where
                REG: crate::Writable + crate::RegisterSpec,
            {
                #[doc = "PLA_DINx Input"]
                #[inline(always)]
                pub fn mmr(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX2::Mmr)
                }
                #[doc = "Even Feedback Mux"]
                #[inline(always)]
                pub fn even(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX2::Even)
                }
            }
            #[doc = "Mux for Odd Element Feedback (In Respective Block)\n\nValue on reset: 0"]
            #[cfg_attr(feature = "defmt", derive(defmt::Format))]
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            #[repr(u8)]
            pub enum MUX1 {
                #[doc = "0: Feedback from Element 1"]
                Elem1 = 0,
                #[doc = "1: Feedback from Element 3"]
                Elem3 = 1,
                #[doc = "2: Feedback from Element 5"]
                Elem5 = 2,
                #[doc = "3: Feedback from Element 7"]
                Elem7 = 3,
                #[doc = "4: Feedback from Element 9"]
                Elem9 = 4,
                #[doc = "5: Feedback from Element 11"]
                Elem11 = 5,
                #[doc = "6: Feedback from Element 13"]
                Elem13 = 6,
                #[doc = "7: Feedback from Element 15"]
                Elem15 = 7,
            }
            impl From<MUX1> for u8 {
                #[inline(always)]
                fn from(variant: MUX1) -> Self {
                    variant as _
                }
            }
            impl crate::FieldSpec for MUX1 {
                type Ux = u8;
            }
            impl crate::IsEnum for MUX1 {}
            #[doc = "Field `MUX1` reader - Mux for Odd Element Feedback (In Respective Block)"]
            pub type MUX1_R = crate::FieldReader<MUX1>;
            impl MUX1_R {
                #[doc = "Get enumerated values variant"]
                #[inline(always)]
                pub const fn variant(&self) -> MUX1 {
                    match self.bits {
                        0 => MUX1::Elem1,
                        1 => MUX1::Elem3,
                        2 => MUX1::Elem5,
                        3 => MUX1::Elem7,
                        4 => MUX1::Elem9,
                        5 => MUX1::Elem11,
                        6 => MUX1::Elem13,
                        7 => MUX1::Elem15,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Feedback from Element 1"]
                #[inline(always)]
                pub fn is_elem1(&self) -> bool {
                    *self == MUX1::Elem1
                }
                #[doc = "Feedback from Element 3"]
                #[inline(always)]
                pub fn is_elem3(&self) -> bool {
                    *self == MUX1::Elem3
                }
                #[doc = "Feedback from Element 5"]
                #[inline(always)]
                pub fn is_elem5(&self) -> bool {
                    *self == MUX1::Elem5
                }
                #[doc = "Feedback from Element 7"]
                #[inline(always)]
                pub fn is_elem7(&self) -> bool {
                    *self == MUX1::Elem7
                }
                #[doc = "Feedback from Element 9"]
                #[inline(always)]
                pub fn is_elem9(&self) -> bool {
                    *self == MUX1::Elem9
                }
                #[doc = "Feedback from Element 11"]
                #[inline(always)]
                pub fn is_elem11(&self) -> bool {
                    *self == MUX1::Elem11
                }
                #[doc = "Feedback from Element 13"]
                #[inline(always)]
                pub fn is_elem13(&self) -> bool {
                    *self == MUX1::Elem13
                }
                #[doc = "Feedback from Element 15"]
                #[inline(always)]
                pub fn is_elem15(&self) -> bool {
                    *self == MUX1::Elem15
                }
            }
            #[doc = "Field `MUX1` writer - Mux for Odd Element Feedback (In Respective Block)"]
            pub type MUX1_W<'a, REG> = crate::FieldWriter<'a, REG, 3, MUX1, crate::Safe>;
            impl<'a, REG> MUX1_W<'a, REG>
            where
                REG: crate::Writable + crate::RegisterSpec,
                REG::Ux: From<u8>,
            {
                #[doc = "Feedback from Element 1"]
                #[inline(always)]
                pub fn elem1(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX1::Elem1)
                }
                #[doc = "Feedback from Element 3"]
                #[inline(always)]
                pub fn elem3(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX1::Elem3)
                }
                #[doc = "Feedback from Element 5"]
                #[inline(always)]
                pub fn elem5(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX1::Elem5)
                }
                #[doc = "Feedback from Element 7"]
                #[inline(always)]
                pub fn elem7(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX1::Elem7)
                }
                #[doc = "Feedback from Element 9"]
                #[inline(always)]
                pub fn elem9(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX1::Elem9)
                }
                #[doc = "Feedback from Element 11"]
                #[inline(always)]
                pub fn elem11(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX1::Elem11)
                }
                #[doc = "Feedback from Element 13"]
                #[inline(always)]
                pub fn elem13(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX1::Elem13)
                }
                #[doc = "Feedback from Element 15"]
                #[inline(always)]
                pub fn elem15(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX1::Elem15)
                }
            }
            #[doc = "Mux for Even Element Feedback(in Respective Block)\n\nValue on reset: 0"]
            #[cfg_attr(feature = "defmt", derive(defmt::Format))]
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            #[repr(u8)]
            pub enum MUX0 {
                #[doc = "0: Feedback from Element 0 (all Except Element 0) / Input from Other Block (Element 0 Only)"]
                Elem0 = 0,
                #[doc = "1: Feedback from Element 2"]
                Elem2 = 1,
                #[doc = "2: Feedback from Element 4"]
                Elem4 = 2,
                #[doc = "3: Feedback from Element 6"]
                Elem6 = 3,
                #[doc = "4: Feedback from Element 8"]
                Elem8 = 4,
                #[doc = "5: Feedback from Element 10"]
                Elem10 = 5,
                #[doc = "6: Feedback from Element 12"]
                Elem12 = 6,
                #[doc = "7: Feedback from Element 14"]
                Elem14 = 7,
            }
            impl From<MUX0> for u8 {
                #[inline(always)]
                fn from(variant: MUX0) -> Self {
                    variant as _
                }
            }
            impl crate::FieldSpec for MUX0 {
                type Ux = u8;
            }
            impl crate::IsEnum for MUX0 {}
            #[doc = "Field `MUX0` reader - Mux for Even Element Feedback(in Respective Block)"]
            pub type MUX0_R = crate::FieldReader<MUX0>;
            impl MUX0_R {
                #[doc = "Get enumerated values variant"]
                #[inline(always)]
                pub const fn variant(&self) -> MUX0 {
                    match self.bits {
                        0 => MUX0::Elem0,
                        1 => MUX0::Elem2,
                        2 => MUX0::Elem4,
                        3 => MUX0::Elem6,
                        4 => MUX0::Elem8,
                        5 => MUX0::Elem10,
                        6 => MUX0::Elem12,
                        7 => MUX0::Elem14,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Feedback from Element 0 (all Except Element 0) / Input from Other Block (Element 0 Only)"]
                #[inline(always)]
                pub fn is_elem0(&self) -> bool {
                    *self == MUX0::Elem0
                }
                #[doc = "Feedback from Element 2"]
                #[inline(always)]
                pub fn is_elem2(&self) -> bool {
                    *self == MUX0::Elem2
                }
                #[doc = "Feedback from Element 4"]
                #[inline(always)]
                pub fn is_elem4(&self) -> bool {
                    *self == MUX0::Elem4
                }
                #[doc = "Feedback from Element 6"]
                #[inline(always)]
                pub fn is_elem6(&self) -> bool {
                    *self == MUX0::Elem6
                }
                #[doc = "Feedback from Element 8"]
                #[inline(always)]
                pub fn is_elem8(&self) -> bool {
                    *self == MUX0::Elem8
                }
                #[doc = "Feedback from Element 10"]
                #[inline(always)]
                pub fn is_elem10(&self) -> bool {
                    *self == MUX0::Elem10
                }
                #[doc = "Feedback from Element 12"]
                #[inline(always)]
                pub fn is_elem12(&self) -> bool {
                    *self == MUX0::Elem12
                }
                #[doc = "Feedback from Element 14"]
                #[inline(always)]
                pub fn is_elem14(&self) -> bool {
                    *self == MUX0::Elem14
                }
            }
            #[doc = "Field `MUX0` writer - Mux for Even Element Feedback(in Respective Block)"]
            pub type MUX0_W<'a, REG> = crate::FieldWriter<'a, REG, 3, MUX0, crate::Safe>;
            impl<'a, REG> MUX0_W<'a, REG>
            where
                REG: crate::Writable + crate::RegisterSpec,
                REG::Ux: From<u8>,
            {
                #[doc = "Feedback from Element 0 (all Except Element 0) / Input from Other Block (Element 0 Only)"]
                #[inline(always)]
                pub fn elem0(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX0::Elem0)
                }
                #[doc = "Feedback from Element 2"]
                #[inline(always)]
                pub fn elem2(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX0::Elem2)
                }
                #[doc = "Feedback from Element 4"]
                #[inline(always)]
                pub fn elem4(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX0::Elem4)
                }
                #[doc = "Feedback from Element 6"]
                #[inline(always)]
                pub fn elem6(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX0::Elem6)
                }
                #[doc = "Feedback from Element 8"]
                #[inline(always)]
                pub fn elem8(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX0::Elem8)
                }
                #[doc = "Feedback from Element 10"]
                #[inline(always)]
                pub fn elem10(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX0::Elem10)
                }
                #[doc = "Feedback from Element 12"]
                #[inline(always)]
                pub fn elem12(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX0::Elem12)
                }
                #[doc = "Feedback from Element 14"]
                #[inline(always)]
                pub fn elem14(self) -> &'a mut crate::W<REG> {
                    self.variant(MUX0::Elem14)
                }
            }
            impl R {
                #[doc = "Bit 0 - Select or Bypass Flip-flop Output"]
                #[inline(always)]
                pub fn mux4(&self) -> MUX4_R {
                    MUX4_R::new((self.bits & 1) != 0)
                }
                #[doc = "Bits 1:4 - Configures Output"]
                #[inline(always)]
                pub fn tbl(&self) -> TBL_R {
                    TBL_R::new(((self.bits >> 1) & 0x0f) as u8)
                }
                #[doc = "Bit 5 - Mux Between GPIO Bus Input or Odd Feedback Input"]
                #[inline(always)]
                pub fn mux3(&self) -> MUX3_R {
                    MUX3_R::new(((self.bits >> 5) & 1) != 0)
                }
                #[doc = "Bit 6 - Mux Between PLA_DINx Register/Block0 Output or Even Feedback"]
                #[inline(always)]
                pub fn mux2(&self) -> MUX2_R {
                    MUX2_R::new(((self.bits >> 6) & 1) != 0)
                }
                #[doc = "Bits 7:9 - Mux for Odd Element Feedback (In Respective Block)"]
                #[inline(always)]
                pub fn mux1(&self) -> MUX1_R {
                    MUX1_R::new(((self.bits >> 7) & 7) as u8)
                }
                #[doc = "Bits 10:12 - Mux for Even Element Feedback(in Respective Block)"]
                #[inline(always)]
                pub fn mux0(&self) -> MUX0_R {
                    MUX0_R::new(((self.bits >> 10) & 7) as u8)
                }
            }
            impl core::fmt::Debug for R {
                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                    f.debug_struct("PLA_ELEM")
                        .field("mux4", &self.mux4())
                        .field("tbl", &self.tbl())
                        .field("mux3", &self.mux3())
                        .field("mux2", &self.mux2())
                        .field("mux1", &self.mux1())
                        .field("mux0", &self.mux0())
                        .finish()
                }
            }
            impl W {
                #[doc = "Bit 0 - Select or Bypass Flip-flop Output"]
                #[inline(always)]
                pub fn mux4(&mut self) -> MUX4_W<PLA_ELEMrs> {
                    MUX4_W::new(self, 0)
                }
                #[doc = "Bits 1:4 - Configures Output"]
                #[inline(always)]
                pub fn tbl(&mut self) -> TBL_W<PLA_ELEMrs> {
                    TBL_W::new(self, 1)
                }
                #[doc = "Bit 5 - Mux Between GPIO Bus Input or Odd Feedback Input"]
                #[inline(always)]
                pub fn mux3(&mut self) -> MUX3_W<PLA_ELEMrs> {
                    MUX3_W::new(self, 5)
                }
                #[doc = "Bit 6 - Mux Between PLA_DINx Register/Block0 Output or Even Feedback"]
                #[inline(always)]
                pub fn mux2(&mut self) -> MUX2_W<PLA_ELEMrs> {
                    MUX2_W::new(self, 6)
                }
                #[doc = "Bits 7:9 - Mux for Odd Element Feedback (In Respective Block)"]
                #[inline(always)]
                pub fn mux1(&mut self) -> MUX1_W<PLA_ELEMrs> {
                    MUX1_W::new(self, 7)
                }
                #[doc = "Bits 10:12 - Mux for Even Element Feedback(in Respective Block)"]
                #[inline(always)]
                pub fn mux0(&mut self) -> MUX0_W<PLA_ELEMrs> {
                    MUX0_W::new(self, 10)
                }
            }
            #[doc = "ELEMx Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_elem::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_elem::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct PLA_ELEMrs;
            impl crate::RegisterSpec for PLA_ELEMrs {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`pla_elem::R`](R) reader structure"]
            impl crate::Readable for PLA_ELEMrs {}
            #[doc = "`write(|w| ..)` method takes [`pla_elem::W`](W) writer structure"]
            impl crate::Writable for PLA_ELEMrs {
                type Safety = crate::Unsafe;
                const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            }
            #[doc = "`reset()` method sets PLA_ELEM to value 0"]
            impl crate::Resettable for PLA_ELEMrs {
                const RESET_VALUE: u32 = 0;
            }
        }
    }
    #[doc = "PLA_CLK (rw) register accessor: PLA Clock Select\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_clk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_clk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_CLK)\n\nFor information about available fields see [`mod@pla_clk`]
module"]
    pub type PLA_CLK = crate::Reg<pla_clk::PLA_CLKrs>;
    #[doc = "PLA Clock Select"]
    pub mod pla_clk {
        #[doc = "Register `PLA_CLK` reader"]
        pub type R = crate::R<PLA_CLKrs>;
        #[doc = "Register `PLA_CLK` writer"]
        pub type W = crate::W<PLA_CLKrs>;
        #[doc = "Clock Select for Block 0\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum BLOCK0 {
            #[doc = "0: GPIO Clock 0"]
            Placlk0 = 0,
            #[doc = "1: GPIO Clock 1"]
            Placlk1 = 1,
            #[doc = "2: GPIO Clock 2"]
            Placlk2 = 2,
            #[doc = "3: PCLK0"]
            Pclk0 = 3,
            #[doc = "4: MOSC (16 MHz)"]
            Mosc = 4,
            #[doc = "5: Timer 0"]
            T0 = 5,
            #[doc = "6: Timer 2"]
            T2 = 6,
            #[doc = "7: KOSC (32 KHz)"]
            Kosc = 7,
        }
        impl From<BLOCK0> for u8 {
            #[inline(always)]
            fn from(variant: BLOCK0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for BLOCK0 {
            type Ux = u8;
        }
        impl crate::IsEnum for BLOCK0 {}
        #[doc = "Field `BLOCK0` reader - Clock Select for Block 0"]
        pub type BLOCK0_R = crate::FieldReader<BLOCK0>;
        impl BLOCK0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BLOCK0 {
                match self.bits {
                    0 => BLOCK0::Placlk0,
                    1 => BLOCK0::Placlk1,
                    2 => BLOCK0::Placlk2,
                    3 => BLOCK0::Pclk0,
                    4 => BLOCK0::Mosc,
                    5 => BLOCK0::T0,
                    6 => BLOCK0::T2,
                    7 => BLOCK0::Kosc,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO Clock 0"]
            #[inline(always)]
            pub fn is_placlk0(&self) -> bool {
                *self == BLOCK0::Placlk0
            }
            #[doc = "GPIO Clock 1"]
            #[inline(always)]
            pub fn is_placlk1(&self) -> bool {
                *self == BLOCK0::Placlk1
            }
            #[doc = "GPIO Clock 2"]
            #[inline(always)]
            pub fn is_placlk2(&self) -> bool {
                *self == BLOCK0::Placlk2
            }
            #[doc = "PCLK0"]
            #[inline(always)]
            pub fn is_pclk0(&self) -> bool {
                *self == BLOCK0::Pclk0
            }
            #[doc = "MOSC (16 MHz)"]
            #[inline(always)]
            pub fn is_mosc(&self) -> bool {
                *self == BLOCK0::Mosc
            }
            #[doc = "Timer 0"]
            #[inline(always)]
            pub fn is_t0(&self) -> bool {
                *self == BLOCK0::T0
            }
            #[doc = "Timer 2"]
            #[inline(always)]
            pub fn is_t2(&self) -> bool {
                *self == BLOCK0::T2
            }
            #[doc = "KOSC (32 KHz)"]
            #[inline(always)]
            pub fn is_kosc(&self) -> bool {
                *self == BLOCK0::Kosc
            }
        }
        #[doc = "Field `BLOCK0` writer - Clock Select for Block 0"]
        pub type BLOCK0_W<'a, REG> = crate::FieldWriter<'a, REG, 3, BLOCK0, crate::Safe>;
        impl<'a, REG> BLOCK0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO Clock 0"]
            #[inline(always)]
            pub fn placlk0(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK0::Placlk0)
            }
            #[doc = "GPIO Clock 1"]
            #[inline(always)]
            pub fn placlk1(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK0::Placlk1)
            }
            #[doc = "GPIO Clock 2"]
            #[inline(always)]
            pub fn placlk2(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK0::Placlk2)
            }
            #[doc = "PCLK0"]
            #[inline(always)]
            pub fn pclk0(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK0::Pclk0)
            }
            #[doc = "MOSC (16 MHz)"]
            #[inline(always)]
            pub fn mosc(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK0::Mosc)
            }
            #[doc = "Timer 0"]
            #[inline(always)]
            pub fn t0(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK0::T0)
            }
            #[doc = "Timer 2"]
            #[inline(always)]
            pub fn t2(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK0::T2)
            }
            #[doc = "KOSC (32 KHz)"]
            #[inline(always)]
            pub fn kosc(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK0::Kosc)
            }
        }
        #[doc = "Clock Select for Block 1\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum BLOCK1 {
            #[doc = "0: GPIO Clock 0"]
            Placlk0 = 0,
            #[doc = "1: GPIO Clock 1"]
            Placlk1 = 1,
            #[doc = "2: GPIO Clock 2"]
            Placlk2 = 2,
            #[doc = "3: PCLK0"]
            Pclk0 = 3,
            #[doc = "4: MOSC (16 MHz)"]
            Mosc = 4,
            #[doc = "5: Timer 0"]
            T0 = 5,
            #[doc = "6: Timer 2"]
            T2 = 6,
            #[doc = "7: KOSC (32 KHz)"]
            Kosc = 7,
        }
        impl From<BLOCK1> for u8 {
            #[inline(always)]
            fn from(variant: BLOCK1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for BLOCK1 {
            type Ux = u8;
        }
        impl crate::IsEnum for BLOCK1 {}
        #[doc = "Field `BLOCK1` reader - Clock Select for Block 1"]
        pub type BLOCK1_R = crate::FieldReader<BLOCK1>;
        impl BLOCK1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BLOCK1 {
                match self.bits {
                    0 => BLOCK1::Placlk0,
                    1 => BLOCK1::Placlk1,
                    2 => BLOCK1::Placlk2,
                    3 => BLOCK1::Pclk0,
                    4 => BLOCK1::Mosc,
                    5 => BLOCK1::T0,
                    6 => BLOCK1::T2,
                    7 => BLOCK1::Kosc,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO Clock 0"]
            #[inline(always)]
            pub fn is_placlk0(&self) -> bool {
                *self == BLOCK1::Placlk0
            }
            #[doc = "GPIO Clock 1"]
            #[inline(always)]
            pub fn is_placlk1(&self) -> bool {
                *self == BLOCK1::Placlk1
            }
            #[doc = "GPIO Clock 2"]
            #[inline(always)]
            pub fn is_placlk2(&self) -> bool {
                *self == BLOCK1::Placlk2
            }
            #[doc = "PCLK0"]
            #[inline(always)]
            pub fn is_pclk0(&self) -> bool {
                *self == BLOCK1::Pclk0
            }
            #[doc = "MOSC (16 MHz)"]
            #[inline(always)]
            pub fn is_mosc(&self) -> bool {
                *self == BLOCK1::Mosc
            }
            #[doc = "Timer 0"]
            #[inline(always)]
            pub fn is_t0(&self) -> bool {
                *self == BLOCK1::T0
            }
            #[doc = "Timer 2"]
            #[inline(always)]
            pub fn is_t2(&self) -> bool {
                *self == BLOCK1::T2
            }
            #[doc = "KOSC (32 KHz)"]
            #[inline(always)]
            pub fn is_kosc(&self) -> bool {
                *self == BLOCK1::Kosc
            }
        }
        #[doc = "Field `BLOCK1` writer - Clock Select for Block 1"]
        pub type BLOCK1_W<'a, REG> = crate::FieldWriter<'a, REG, 3, BLOCK1, crate::Safe>;
        impl<'a, REG> BLOCK1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO Clock 0"]
            #[inline(always)]
            pub fn placlk0(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK1::Placlk0)
            }
            #[doc = "GPIO Clock 1"]
            #[inline(always)]
            pub fn placlk1(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK1::Placlk1)
            }
            #[doc = "GPIO Clock 2"]
            #[inline(always)]
            pub fn placlk2(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK1::Placlk2)
            }
            #[doc = "PCLK0"]
            #[inline(always)]
            pub fn pclk0(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK1::Pclk0)
            }
            #[doc = "MOSC (16 MHz)"]
            #[inline(always)]
            pub fn mosc(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK1::Mosc)
            }
            #[doc = "Timer 0"]
            #[inline(always)]
            pub fn t0(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK1::T0)
            }
            #[doc = "Timer 2"]
            #[inline(always)]
            pub fn t2(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK1::T2)
            }
            #[doc = "KOSC (32 KHz)"]
            #[inline(always)]
            pub fn kosc(self) -> &'a mut crate::W<REG> {
                self.variant(BLOCK1::Kosc)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Clock Select for Block 0"]
            #[inline(always)]
            pub fn block0(&self) -> BLOCK0_R {
                BLOCK0_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 4:6 - Clock Select for Block 1"]
            #[inline(always)]
            pub fn block1(&self) -> BLOCK1_R {
                BLOCK1_R::new(((self.bits >> 4) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLA_CLK")
                    .field("block0", &self.block0())
                    .field("block1", &self.block1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Clock Select for Block 0"]
            #[inline(always)]
            pub fn block0(&mut self) -> BLOCK0_W<PLA_CLKrs> {
                BLOCK0_W::new(self, 0)
            }
            #[doc = "Bits 4:6 - Clock Select for Block 1"]
            #[inline(always)]
            pub fn block1(&mut self) -> BLOCK1_W<PLA_CLKrs> {
                BLOCK1_W::new(self, 4)
            }
        }
        #[doc = "PLA Clock Select\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_clk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_clk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_CLK)"]
        pub struct PLA_CLKrs;
        impl crate::RegisterSpec for PLA_CLKrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pla_clk::R`](R) reader structure"]
        impl crate::Readable for PLA_CLKrs {}
        #[doc = "`write(|w| ..)` method takes [`pla_clk::W`](W) writer structure"]
        impl crate::Writable for PLA_CLKrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLA_CLK to value 0"]
        impl crate::Resettable for PLA_CLKrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PLA_IRQ0 (rw) register accessor: Interrupt Register for Block 0\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_irq0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_irq0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_IRQ0)\n\nFor information about available fields see [`mod@pla_irq0`]
module"]
    pub type PLA_IRQ0 = crate::Reg<pla_irq0::PLA_IRQ0rs>;
    #[doc = "Interrupt Register for Block 0"]
    pub mod pla_irq0 {
        #[doc = "Register `PLA_IRQ0` reader"]
        pub type R = crate::R<PLA_IRQ0rs>;
        #[doc = "Register `PLA_IRQ0` writer"]
        pub type W = crate::W<PLA_IRQ0rs>;
        #[doc = "Field `irq0_src` reader - IRQ0 Source Select"]
        pub type IRQ0_SRC_R = crate::FieldReader;
        #[doc = "Field `irq0_src` writer - IRQ0 Source Select"]
        pub type IRQ0_SRC_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        #[doc = "IRQ0 Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ0_EN {
            #[doc = "0: Disable IRQ0 Interrupt"]
            Dis = 0,
            #[doc = "1: Enable IRQ0 Interrupt"]
            En = 1,
        }
        impl From<IRQ0_EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ0_EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `irq0_en` reader - IRQ0 Enable"]
        pub type IRQ0_EN_R = crate::BitReader<IRQ0_EN>;
        impl IRQ0_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ0_EN {
                match self.bits {
                    false => IRQ0_EN::Dis,
                    true => IRQ0_EN::En,
                }
            }
            #[doc = "Disable IRQ0 Interrupt"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ0_EN::Dis
            }
            #[doc = "Enable IRQ0 Interrupt"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ0_EN::En
            }
        }
        #[doc = "Field `irq0_en` writer - IRQ0 Enable"]
        pub type IRQ0_EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ0_EN>;
        impl<'a, REG> IRQ0_EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable IRQ0 Interrupt"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0_EN::Dis)
            }
            #[doc = "Enable IRQ0 Interrupt"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0_EN::En)
            }
        }
        #[doc = "Field `irq1_src` reader - IRQ1 Source Select"]
        pub type IRQ1_SRC_R = crate::FieldReader;
        #[doc = "Field `irq1_src` writer - IRQ1 Source Select"]
        pub type IRQ1_SRC_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        #[doc = "IRQ1 Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ1_EN {
            #[doc = "0: Disable IRQ1 Interrupt"]
            Dis = 0,
            #[doc = "1: Enable IRQ1 Interrupt"]
            En = 1,
        }
        impl From<IRQ1_EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ1_EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `irq1_en` reader - IRQ1 Enable"]
        pub type IRQ1_EN_R = crate::BitReader<IRQ1_EN>;
        impl IRQ1_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ1_EN {
                match self.bits {
                    false => IRQ1_EN::Dis,
                    true => IRQ1_EN::En,
                }
            }
            #[doc = "Disable IRQ1 Interrupt"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ1_EN::Dis
            }
            #[doc = "Enable IRQ1 Interrupt"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ1_EN::En
            }
        }
        #[doc = "Field `irq1_en` writer - IRQ1 Enable"]
        pub type IRQ1_EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ1_EN>;
        impl<'a, REG> IRQ1_EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable IRQ1 Interrupt"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1_EN::Dis)
            }
            #[doc = "Enable IRQ1 Interrupt"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1_EN::En)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - IRQ0 Source Select"]
            #[inline(always)]
            pub fn irq0_src(&self) -> IRQ0_SRC_R {
                IRQ0_SRC_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bit 4 - IRQ0 Enable"]
            #[inline(always)]
            pub fn irq0_en(&self) -> IRQ0_EN_R {
                IRQ0_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 8:11 - IRQ1 Source Select"]
            #[inline(always)]
            pub fn irq1_src(&self) -> IRQ1_SRC_R {
                IRQ1_SRC_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 12 - IRQ1 Enable"]
            #[inline(always)]
            pub fn irq1_en(&self) -> IRQ1_EN_R {
                IRQ1_EN_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLA_IRQ0")
                    .field("irq0_src", &self.irq0_src())
                    .field("irq0_en", &self.irq0_en())
                    .field("irq1_src", &self.irq1_src())
                    .field("irq1_en", &self.irq1_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:3 - IRQ0 Source Select"]
            #[inline(always)]
            pub fn irq0_src(&mut self) -> IRQ0_SRC_W<PLA_IRQ0rs> {
                IRQ0_SRC_W::new(self, 0)
            }
            #[doc = "Bit 4 - IRQ0 Enable"]
            #[inline(always)]
            pub fn irq0_en(&mut self) -> IRQ0_EN_W<PLA_IRQ0rs> {
                IRQ0_EN_W::new(self, 4)
            }
            #[doc = "Bits 8:11 - IRQ1 Source Select"]
            #[inline(always)]
            pub fn irq1_src(&mut self) -> IRQ1_SRC_W<PLA_IRQ0rs> {
                IRQ1_SRC_W::new(self, 8)
            }
            #[doc = "Bit 12 - IRQ1 Enable"]
            #[inline(always)]
            pub fn irq1_en(&mut self) -> IRQ1_EN_W<PLA_IRQ0rs> {
                IRQ1_EN_W::new(self, 12)
            }
        }
        #[doc = "Interrupt Register for Block 0\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_irq0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_irq0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_IRQ0)"]
        pub struct PLA_IRQ0rs;
        impl crate::RegisterSpec for PLA_IRQ0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pla_irq0::R`](R) reader structure"]
        impl crate::Readable for PLA_IRQ0rs {}
        #[doc = "`write(|w| ..)` method takes [`pla_irq0::W`](W) writer structure"]
        impl crate::Writable for PLA_IRQ0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLA_IRQ0 to value 0"]
        impl crate::Resettable for PLA_IRQ0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PLA_IRQ1 (rw) register accessor: Interrupt Register for Block1\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_irq1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_irq1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_IRQ1)\n\nFor information about available fields see [`mod@pla_irq1`]
module"]
    pub type PLA_IRQ1 = crate::Reg<pla_irq1::PLA_IRQ1rs>;
    #[doc = "Interrupt Register for Block1"]
    pub mod pla_irq1 {
        #[doc = "Register `PLA_IRQ1` reader"]
        pub type R = crate::R<PLA_IRQ1rs>;
        #[doc = "Register `PLA_IRQ1` writer"]
        pub type W = crate::W<PLA_IRQ1rs>;
        #[doc = "Field `irq2_src` reader - IRQ2 Source Select"]
        pub type IRQ2_SRC_R = crate::FieldReader;
        #[doc = "Field `irq2_src` writer - IRQ2 Source Select"]
        pub type IRQ2_SRC_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        #[doc = "IRQ2 Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ2_EN {
            #[doc = "0: Disable IRQ2 Interrupt"]
            Dis = 0,
            #[doc = "1: Enable IRQ2 Interrupt"]
            En = 1,
        }
        impl From<IRQ2_EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ2_EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `irq2_en` reader - IRQ2 Enable"]
        pub type IRQ2_EN_R = crate::BitReader<IRQ2_EN>;
        impl IRQ2_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ2_EN {
                match self.bits {
                    false => IRQ2_EN::Dis,
                    true => IRQ2_EN::En,
                }
            }
            #[doc = "Disable IRQ2 Interrupt"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ2_EN::Dis
            }
            #[doc = "Enable IRQ2 Interrupt"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ2_EN::En
            }
        }
        #[doc = "Field `irq2_en` writer - IRQ2 Enable"]
        pub type IRQ2_EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ2_EN>;
        impl<'a, REG> IRQ2_EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable IRQ2 Interrupt"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2_EN::Dis)
            }
            #[doc = "Enable IRQ2 Interrupt"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2_EN::En)
            }
        }
        #[doc = "Field `irq3_src` reader - IRQ3 Source Select"]
        pub type IRQ3_SRC_R = crate::FieldReader;
        #[doc = "Field `irq3_src` writer - IRQ3 Source Select"]
        pub type IRQ3_SRC_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        #[doc = "IRQ3 Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRQ3_EN {
            #[doc = "0: Disable IRQ3 Interrupt"]
            Dis = 0,
            #[doc = "1: Enable IRQ3 Interrupt"]
            En = 1,
        }
        impl From<IRQ3_EN> for bool {
            #[inline(always)]
            fn from(variant: IRQ3_EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `irq3_en` reader - IRQ3 Enable"]
        pub type IRQ3_EN_R = crate::BitReader<IRQ3_EN>;
        impl IRQ3_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ3_EN {
                match self.bits {
                    false => IRQ3_EN::Dis,
                    true => IRQ3_EN::En,
                }
            }
            #[doc = "Disable IRQ3 Interrupt"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == IRQ3_EN::Dis
            }
            #[doc = "Enable IRQ3 Interrupt"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == IRQ3_EN::En
            }
        }
        #[doc = "Field `irq3_en` writer - IRQ3 Enable"]
        pub type IRQ3_EN_W<'a, REG> = crate::BitWriter<'a, REG, IRQ3_EN>;
        impl<'a, REG> IRQ3_EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable IRQ3 Interrupt"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3_EN::Dis)
            }
            #[doc = "Enable IRQ3 Interrupt"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3_EN::En)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - IRQ2 Source Select"]
            #[inline(always)]
            pub fn irq2_src(&self) -> IRQ2_SRC_R {
                IRQ2_SRC_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bit 4 - IRQ2 Enable"]
            #[inline(always)]
            pub fn irq2_en(&self) -> IRQ2_EN_R {
                IRQ2_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 8:11 - IRQ3 Source Select"]
            #[inline(always)]
            pub fn irq3_src(&self) -> IRQ3_SRC_R {
                IRQ3_SRC_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 12 - IRQ3 Enable"]
            #[inline(always)]
            pub fn irq3_en(&self) -> IRQ3_EN_R {
                IRQ3_EN_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLA_IRQ1")
                    .field("irq2_src", &self.irq2_src())
                    .field("irq2_en", &self.irq2_en())
                    .field("irq3_src", &self.irq3_src())
                    .field("irq3_en", &self.irq3_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:3 - IRQ2 Source Select"]
            #[inline(always)]
            pub fn irq2_src(&mut self) -> IRQ2_SRC_W<PLA_IRQ1rs> {
                IRQ2_SRC_W::new(self, 0)
            }
            #[doc = "Bit 4 - IRQ2 Enable"]
            #[inline(always)]
            pub fn irq2_en(&mut self) -> IRQ2_EN_W<PLA_IRQ1rs> {
                IRQ2_EN_W::new(self, 4)
            }
            #[doc = "Bits 8:11 - IRQ3 Source Select"]
            #[inline(always)]
            pub fn irq3_src(&mut self) -> IRQ3_SRC_W<PLA_IRQ1rs> {
                IRQ3_SRC_W::new(self, 8)
            }
            #[doc = "Bit 12 - IRQ3 Enable"]
            #[inline(always)]
            pub fn irq3_en(&mut self) -> IRQ3_EN_W<PLA_IRQ1rs> {
                IRQ3_EN_W::new(self, 12)
            }
        }
        #[doc = "Interrupt Register for Block1\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_irq1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_irq1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_IRQ1)"]
        pub struct PLA_IRQ1rs;
        impl crate::RegisterSpec for PLA_IRQ1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pla_irq1::R`](R) reader structure"]
        impl crate::Readable for PLA_IRQ1rs {}
        #[doc = "`write(|w| ..)` method takes [`pla_irq1::W`](W) writer structure"]
        impl crate::Writable for PLA_IRQ1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLA_IRQ1 to value 0"]
        impl crate::Resettable for PLA_IRQ1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PLA_ADC (rw) register accessor: ADC Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_adc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_adc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_ADC)\n\nFor information about available fields see [`mod@pla_adc`]
module"]
    pub type PLA_ADC = crate::Reg<pla_adc::PLA_ADCrs>;
    #[doc = "ADC Configuration Register"]
    pub mod pla_adc {
        #[doc = "Register `PLA_ADC` reader"]
        pub type R = crate::R<PLA_ADCrs>;
        #[doc = "Register `PLA_ADC` writer"]
        pub type W = crate::W<PLA_ADCrs>;
        #[doc = "Field `convst_src` reader - Element for ADC Start Convert Source"]
        pub type CONVST_SRC_R = crate::FieldReader;
        #[doc = "Field `convst_src` writer - Element for ADC Start Convert Source"]
        pub type CONVST_SRC_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        #[doc = "Bit to Enable ADC Start Convert from PLA\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CONVST_EN {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<CONVST_EN> for bool {
            #[inline(always)]
            fn from(variant: CONVST_EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `convst_en` reader - Bit to Enable ADC Start Convert from PLA"]
        pub type CONVST_EN_R = crate::BitReader<CONVST_EN>;
        impl CONVST_EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CONVST_EN {
                match self.bits {
                    false => CONVST_EN::Disable,
                    true => CONVST_EN::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == CONVST_EN::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == CONVST_EN::Enable
            }
        }
        #[doc = "Field `convst_en` writer - Bit to Enable ADC Start Convert from PLA"]
        pub type CONVST_EN_W<'a, REG> = crate::BitWriter<'a, REG, CONVST_EN>;
        impl<'a, REG> CONVST_EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(CONVST_EN::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(CONVST_EN::Enable)
            }
        }
        impl R {
            #[doc = "Bits 0:4 - Element for ADC Start Convert Source"]
            #[inline(always)]
            pub fn convst_src(&self) -> CONVST_SRC_R {
                CONVST_SRC_R::new((self.bits & 0x1f) as u8)
            }
            #[doc = "Bit 5 - Bit to Enable ADC Start Convert from PLA"]
            #[inline(always)]
            pub fn convst_en(&self) -> CONVST_EN_R {
                CONVST_EN_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLA_ADC")
                    .field("convst_src", &self.convst_src())
                    .field("convst_en", &self.convst_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:4 - Element for ADC Start Convert Source"]
            #[inline(always)]
            pub fn convst_src(&mut self) -> CONVST_SRC_W<PLA_ADCrs> {
                CONVST_SRC_W::new(self, 0)
            }
            #[doc = "Bit 5 - Bit to Enable ADC Start Convert from PLA"]
            #[inline(always)]
            pub fn convst_en(&mut self) -> CONVST_EN_W<PLA_ADCrs> {
                CONVST_EN_W::new(self, 5)
            }
        }
        #[doc = "ADC Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_adc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_adc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_ADC)"]
        pub struct PLA_ADCrs;
        impl crate::RegisterSpec for PLA_ADCrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pla_adc::R`](R) reader structure"]
        impl crate::Readable for PLA_ADCrs {}
        #[doc = "`write(|w| ..)` method takes [`pla_adc::W`](W) writer structure"]
        impl crate::Writable for PLA_ADCrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLA_ADC to value 0"]
        impl crate::Resettable for PLA_ADCrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PLA_DIN0 (rw) register accessor: AMBA Bus Data Input for Block 0\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_din0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_din0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_DIN0)\n\nFor information about available fields see [`mod@pla_din0`]
module"]
    pub type PLA_DIN0 = crate::Reg<pla_din0::PLA_DIN0rs>;
    #[doc = "AMBA Bus Data Input for Block 0"]
    pub mod pla_din0 {
        #[doc = "Register `PLA_DIN0` reader"]
        pub type R = crate::R<PLA_DIN0rs>;
        #[doc = "Register `PLA_DIN0` writer"]
        pub type W = crate::W<PLA_DIN0rs>;
        #[doc = "Field `DIN` reader - Input Bit to Element 15 to Element 0."]
        pub type DIN_R = crate::FieldReader<u16>;
        #[doc = "Field `DIN` writer - Input Bit to Element 15 to Element 0."]
        pub type DIN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Input Bit to Element 15 to Element 0."]
            #[inline(always)]
            pub fn din(&self) -> DIN_R {
                DIN_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLA_DIN0")
                    .field("din", &self.din())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Input Bit to Element 15 to Element 0."]
            #[inline(always)]
            pub fn din(&mut self) -> DIN_W<PLA_DIN0rs> {
                DIN_W::new(self, 0)
            }
        }
        #[doc = "AMBA Bus Data Input for Block 0\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_din0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_din0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_DIN0)"]
        pub struct PLA_DIN0rs;
        impl crate::RegisterSpec for PLA_DIN0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pla_din0::R`](R) reader structure"]
        impl crate::Readable for PLA_DIN0rs {}
        #[doc = "`write(|w| ..)` method takes [`pla_din0::W`](W) writer structure"]
        impl crate::Writable for PLA_DIN0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLA_DIN0 to value 0"]
        impl crate::Resettable for PLA_DIN0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PLA_DOUT0 (rw) register accessor: AMBA Bus Data Output for Block 0\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_dout0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_dout0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_DOUT0)\n\nFor information about available fields see [`mod@pla_dout0`]
module"]
    pub type PLA_DOUT0 = crate::Reg<pla_dout0::PLA_DOUT0rs>;
    #[doc = "AMBA Bus Data Output for Block 0"]
    pub mod pla_dout0 {
        #[doc = "Register `PLA_DOUT0` reader"]
        pub type R = crate::R<PLA_DOUT0rs>;
        #[doc = "Register `PLA_DOUT0` writer"]
        pub type W = crate::W<PLA_DOUT0rs>;
        #[doc = "Field `E0` reader - Output Bit from Element 0"]
        pub type E0_R = crate::BitReader;
        #[doc = "Field `E1` reader - Output Bit from Element 1"]
        pub type E1_R = crate::BitReader;
        #[doc = "Field `E2` reader - Output Bit from Element 2"]
        pub type E2_R = crate::BitReader;
        #[doc = "Field `E3` reader - Output Bit from Element 3"]
        pub type E3_R = crate::BitReader;
        #[doc = "Field `E4` reader - Output Bit from Element 4"]
        pub type E4_R = crate::BitReader;
        #[doc = "Field `E5` reader - Output Bit from Element 5"]
        pub type E5_R = crate::BitReader;
        #[doc = "Field `E6` reader - Output Bit from Element 6"]
        pub type E6_R = crate::BitReader;
        #[doc = "Field `E7` reader - Output Bit from Element 7"]
        pub type E7_R = crate::BitReader;
        #[doc = "Field `E8` reader - Output Bit from Element 8"]
        pub type E8_R = crate::BitReader;
        #[doc = "Field `E9` reader - Output Bit from Element 9"]
        pub type E9_R = crate::BitReader;
        #[doc = "Field `E10` reader - Output Bit from Element 10"]
        pub type E10_R = crate::BitReader;
        #[doc = "Field `E11` reader - Output Bit from Element 11"]
        pub type E11_R = crate::BitReader;
        #[doc = "Field `E12` reader - Output Bit from Element 12"]
        pub type E12_R = crate::BitReader;
        #[doc = "Field `E13` reader - Output Bit from Element 13"]
        pub type E13_R = crate::BitReader;
        #[doc = "Field `E14` reader - Output Bit from Element 14"]
        pub type E14_R = crate::BitReader;
        #[doc = "Field `E15` reader - Output Bit from Element 15"]
        pub type E15_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Output Bit from Element 0"]
            #[inline(always)]
            pub fn e0(&self) -> E0_R {
                E0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Output Bit from Element 1"]
            #[inline(always)]
            pub fn e1(&self) -> E1_R {
                E1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Output Bit from Element 2"]
            #[inline(always)]
            pub fn e2(&self) -> E2_R {
                E2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Output Bit from Element 3"]
            #[inline(always)]
            pub fn e3(&self) -> E3_R {
                E3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Output Bit from Element 4"]
            #[inline(always)]
            pub fn e4(&self) -> E4_R {
                E4_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Output Bit from Element 5"]
            #[inline(always)]
            pub fn e5(&self) -> E5_R {
                E5_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Output Bit from Element 6"]
            #[inline(always)]
            pub fn e6(&self) -> E6_R {
                E6_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Output Bit from Element 7"]
            #[inline(always)]
            pub fn e7(&self) -> E7_R {
                E7_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Output Bit from Element 8"]
            #[inline(always)]
            pub fn e8(&self) -> E8_R {
                E8_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Output Bit from Element 9"]
            #[inline(always)]
            pub fn e9(&self) -> E9_R {
                E9_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Output Bit from Element 10"]
            #[inline(always)]
            pub fn e10(&self) -> E10_R {
                E10_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Output Bit from Element 11"]
            #[inline(always)]
            pub fn e11(&self) -> E11_R {
                E11_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Output Bit from Element 12"]
            #[inline(always)]
            pub fn e12(&self) -> E12_R {
                E12_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Output Bit from Element 13"]
            #[inline(always)]
            pub fn e13(&self) -> E13_R {
                E13_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Output Bit from Element 14"]
            #[inline(always)]
            pub fn e14(&self) -> E14_R {
                E14_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Output Bit from Element 15"]
            #[inline(always)]
            pub fn e15(&self) -> E15_R {
                E15_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLA_DOUT0")
                    .field("e0", &self.e0())
                    .field("e1", &self.e1())
                    .field("e2", &self.e2())
                    .field("e3", &self.e3())
                    .field("e4", &self.e4())
                    .field("e5", &self.e5())
                    .field("e6", &self.e6())
                    .field("e7", &self.e7())
                    .field("e8", &self.e8())
                    .field("e9", &self.e9())
                    .field("e10", &self.e10())
                    .field("e11", &self.e11())
                    .field("e12", &self.e12())
                    .field("e13", &self.e13())
                    .field("e14", &self.e14())
                    .field("e15", &self.e15())
                    .finish()
            }
        }
        impl W {}
        #[doc = "AMBA Bus Data Output for Block 0\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_dout0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_dout0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_DOUT0)"]
        pub struct PLA_DOUT0rs;
        impl crate::RegisterSpec for PLA_DOUT0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pla_dout0::R`](R) reader structure"]
        impl crate::Readable for PLA_DOUT0rs {}
        #[doc = "`write(|w| ..)` method takes [`pla_dout0::W`](W) writer structure"]
        impl crate::Writable for PLA_DOUT0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLA_DOUT0 to value 0"]
        impl crate::Resettable for PLA_DOUT0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PLA_DOUT1 (rw) register accessor: AMBA Bus Data Output for Block1\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_dout1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_dout1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_DOUT1)\n\nFor information about available fields see [`mod@pla_dout1`]
module"]
    pub type PLA_DOUT1 = crate::Reg<pla_dout1::PLA_DOUT1rs>;
    #[doc = "AMBA Bus Data Output for Block1"]
    pub mod pla_dout1 {
        #[doc = "Register `PLA_DOUT1` reader"]
        pub type R = crate::R<PLA_DOUT1rs>;
        #[doc = "Register `PLA_DOUT1` writer"]
        pub type W = crate::W<PLA_DOUT1rs>;
        #[doc = "Field `E16` reader - Output Bit from Element 16"]
        pub type E16_R = crate::BitReader;
        #[doc = "Field `E17` reader - Output Bit from Element 17"]
        pub type E17_R = crate::BitReader;
        #[doc = "Field `E18` reader - Output Bit from Element 18"]
        pub type E18_R = crate::BitReader;
        #[doc = "Field `E19` reader - Output Bit from Element 19"]
        pub type E19_R = crate::BitReader;
        #[doc = "Field `E20` reader - Output Bit from Element 20"]
        pub type E20_R = crate::BitReader;
        #[doc = "Field `E21` reader - Output Bit from Element 21"]
        pub type E21_R = crate::BitReader;
        #[doc = "Field `E22` reader - Output Bit from Element 22"]
        pub type E22_R = crate::BitReader;
        #[doc = "Field `E23` reader - Output Bit from Element 23"]
        pub type E23_R = crate::BitReader;
        #[doc = "Field `E24` reader - Output Bit from Element 24"]
        pub type E24_R = crate::BitReader;
        #[doc = "Field `E25` reader - Output Bit from Element 25"]
        pub type E25_R = crate::BitReader;
        #[doc = "Field `E26` reader - Output Bit from Element 26"]
        pub type E26_R = crate::BitReader;
        #[doc = "Field `E27` reader - Output Bit from Element 27"]
        pub type E27_R = crate::BitReader;
        #[doc = "Field `E28` reader - Output Bit from Element 28"]
        pub type E28_R = crate::BitReader;
        #[doc = "Field `E29` reader - Output Bit from Element 29"]
        pub type E29_R = crate::BitReader;
        #[doc = "Field `E30` reader - Output Bit from Element 30"]
        pub type E30_R = crate::BitReader;
        #[doc = "Field `E31` reader - Output Bit from Element 31"]
        pub type E31_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Output Bit from Element 16"]
            #[inline(always)]
            pub fn e16(&self) -> E16_R {
                E16_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Output Bit from Element 17"]
            #[inline(always)]
            pub fn e17(&self) -> E17_R {
                E17_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Output Bit from Element 18"]
            #[inline(always)]
            pub fn e18(&self) -> E18_R {
                E18_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Output Bit from Element 19"]
            #[inline(always)]
            pub fn e19(&self) -> E19_R {
                E19_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Output Bit from Element 20"]
            #[inline(always)]
            pub fn e20(&self) -> E20_R {
                E20_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Output Bit from Element 21"]
            #[inline(always)]
            pub fn e21(&self) -> E21_R {
                E21_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Output Bit from Element 22"]
            #[inline(always)]
            pub fn e22(&self) -> E22_R {
                E22_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Output Bit from Element 23"]
            #[inline(always)]
            pub fn e23(&self) -> E23_R {
                E23_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Output Bit from Element 24"]
            #[inline(always)]
            pub fn e24(&self) -> E24_R {
                E24_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Output Bit from Element 25"]
            #[inline(always)]
            pub fn e25(&self) -> E25_R {
                E25_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Output Bit from Element 26"]
            #[inline(always)]
            pub fn e26(&self) -> E26_R {
                E26_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Output Bit from Element 27"]
            #[inline(always)]
            pub fn e27(&self) -> E27_R {
                E27_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Output Bit from Element 28"]
            #[inline(always)]
            pub fn e28(&self) -> E28_R {
                E28_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Output Bit from Element 29"]
            #[inline(always)]
            pub fn e29(&self) -> E29_R {
                E29_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Output Bit from Element 30"]
            #[inline(always)]
            pub fn e30(&self) -> E30_R {
                E30_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Output Bit from Element 31"]
            #[inline(always)]
            pub fn e31(&self) -> E31_R {
                E31_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLA_DOUT1")
                    .field("e16", &self.e16())
                    .field("e17", &self.e17())
                    .field("e18", &self.e18())
                    .field("e19", &self.e19())
                    .field("e20", &self.e20())
                    .field("e21", &self.e21())
                    .field("e22", &self.e22())
                    .field("e23", &self.e23())
                    .field("e24", &self.e24())
                    .field("e25", &self.e25())
                    .field("e26", &self.e26())
                    .field("e27", &self.e27())
                    .field("e28", &self.e28())
                    .field("e29", &self.e29())
                    .field("e30", &self.e30())
                    .field("e31", &self.e31())
                    .finish()
            }
        }
        impl W {}
        #[doc = "AMBA Bus Data Output for Block1\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_dout1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_dout1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_DOUT1)"]
        pub struct PLA_DOUT1rs;
        impl crate::RegisterSpec for PLA_DOUT1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pla_dout1::R`](R) reader structure"]
        impl crate::Readable for PLA_DOUT1rs {}
        #[doc = "`write(|w| ..)` method takes [`pla_dout1::W`](W) writer structure"]
        impl crate::Writable for PLA_DOUT1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLA_DOUT1 to value 0"]
        impl crate::Resettable for PLA_DOUT1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PLA_LCK (rw) register accessor: Write Lock Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_lck::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_lck::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_LCK)\n\nFor information about available fields see [`mod@pla_lck`]
module"]
    pub type PLA_LCK = crate::Reg<pla_lck::PLA_LCKrs>;
    #[doc = "Write Lock Register."]
    pub mod pla_lck {
        #[doc = "Register `PLA_LCK` reader"]
        pub type R = crate::R<PLA_LCKrs>;
        #[doc = "Register `PLA_LCK` writer"]
        pub type W = crate::W<PLA_LCKrs>;
        #[doc = "Set to Disable Writing to Registers\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LOCKED {
            #[doc = "0: Writing to Registers Allowed"]
            Dis = 0,
            #[doc = "1: Writing to Registers Disabled"]
            En = 1,
        }
        impl From<LOCKED> for bool {
            #[inline(always)]
            fn from(variant: LOCKED) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `LOCKED` reader - Set to Disable Writing to Registers"]
        pub type LOCKED_R = crate::BitReader<LOCKED>;
        impl LOCKED_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> LOCKED {
                match self.bits {
                    false => LOCKED::Dis,
                    true => LOCKED::En,
                }
            }
            #[doc = "Writing to Registers Allowed"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == LOCKED::Dis
            }
            #[doc = "Writing to Registers Disabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == LOCKED::En
            }
        }
        #[doc = "Field `LOCKED` writer - Set to Disable Writing to Registers"]
        pub type LOCKED_W<'a, REG> = crate::BitWriter<'a, REG, LOCKED>;
        impl<'a, REG> LOCKED_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Writing to Registers Allowed"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(LOCKED::Dis)
            }
            #[doc = "Writing to Registers Disabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(LOCKED::En)
            }
        }
        impl R {
            #[doc = "Bit 0 - Set to Disable Writing to Registers"]
            #[inline(always)]
            pub fn locked(&self) -> LOCKED_R {
                LOCKED_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLA_LCK")
                    .field("locked", &self.locked())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Set to Disable Writing to Registers"]
            #[inline(always)]
            pub fn locked(&mut self) -> LOCKED_W<PLA_LCKrs> {
                LOCKED_W::new(self, 0)
            }
        }
        #[doc = "Write Lock Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_lck::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_lck::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_LCK)"]
        pub struct PLA_LCKrs;
        impl crate::RegisterSpec for PLA_LCKrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pla_lck::R`](R) reader structure"]
        impl crate::Readable for PLA_LCKrs {}
        #[doc = "`write(|w| ..)` method takes [`pla_lck::W`](W) writer structure"]
        impl crate::Writable for PLA_LCKrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLA_LCK to value 0"]
        impl crate::Resettable for PLA_LCKrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PLA_IRQTYPE (rw) register accessor: PLA Interrupt Request and DMA Request Type\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_irqtype::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_irqtype::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_IRQTYPE)\n\nFor information about available fields see [`mod@pla_irqtype`]
module"]
    pub type PLA_IRQTYPE = crate::Reg<pla_irqtype::PLA_IRQTYPErs>;
    #[doc = "PLA Interrupt Request and DMA Request Type"]
    pub mod pla_irqtype {
        #[doc = "Register `PLA_IRQTYPE` reader"]
        pub type R = crate::R<PLA_IRQTYPErs>;
        #[doc = "Register `PLA_IRQTYPE` writer"]
        pub type W = crate::W<PLA_IRQTYPErs>;
        #[doc = "IRQ0 and DMA Request 0 Type\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ0_TYPE {
            #[doc = "0: High Level Trigger Interrupt and High Level Trigger DMA Request"]
            HighLevel = 0,
            #[doc = "1: Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            RisingEdge = 1,
            #[doc = "2: Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            LowLevel = 2,
            #[doc = "3: Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            FallingEdge = 3,
        }
        impl From<IRQ0_TYPE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ0_TYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ0_TYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ0_TYPE {}
        #[doc = "Field `irq0_type` reader - IRQ0 and DMA Request 0 Type"]
        pub type IRQ0_TYPE_R = crate::FieldReader<IRQ0_TYPE>;
        impl IRQ0_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ0_TYPE {
                match self.bits {
                    0 => IRQ0_TYPE::HighLevel,
                    1 => IRQ0_TYPE::RisingEdge,
                    2 => IRQ0_TYPE::LowLevel,
                    3 => IRQ0_TYPE::FallingEdge,
                    _ => unreachable!(),
                }
            }
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_high_level(&self) -> bool {
                *self == IRQ0_TYPE::HighLevel
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == IRQ0_TYPE::RisingEdge
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_low_level(&self) -> bool {
                *self == IRQ0_TYPE::LowLevel
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == IRQ0_TYPE::FallingEdge
            }
        }
        #[doc = "Field `irq0_type` writer - IRQ0 and DMA Request 0 Type"]
        pub type IRQ0_TYPE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, IRQ0_TYPE, crate::Safe>;
        impl<'a, REG> IRQ0_TYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn high_level(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0_TYPE::HighLevel)
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0_TYPE::RisingEdge)
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn low_level(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0_TYPE::LowLevel)
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ0_TYPE::FallingEdge)
            }
        }
        #[doc = "IRQ1 and DMA Request 1Type\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ1_TYPE {
            #[doc = "0: High Level Trigger Interrupt and High Level Trigger DMA Request"]
            HighLevel = 0,
            #[doc = "1: Rising Edge Trigger Interrupt and High Level Trigger DMA Request"]
            RisingEdge = 1,
            #[doc = "2: Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            LowLevel = 2,
            #[doc = "3: Falling Edge Trigger Interrupt and Low Level Trigger DMA Request"]
            FallingEdge = 3,
        }
        impl From<IRQ1_TYPE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ1_TYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ1_TYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ1_TYPE {}
        #[doc = "Field `irq1_type` reader - IRQ1 and DMA Request 1Type"]
        pub type IRQ1_TYPE_R = crate::FieldReader<IRQ1_TYPE>;
        impl IRQ1_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ1_TYPE {
                match self.bits {
                    0 => IRQ1_TYPE::HighLevel,
                    1 => IRQ1_TYPE::RisingEdge,
                    2 => IRQ1_TYPE::LowLevel,
                    3 => IRQ1_TYPE::FallingEdge,
                    _ => unreachable!(),
                }
            }
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_high_level(&self) -> bool {
                *self == IRQ1_TYPE::HighLevel
            }
            #[doc = "Rising Edge Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == IRQ1_TYPE::RisingEdge
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_low_level(&self) -> bool {
                *self == IRQ1_TYPE::LowLevel
            }
            #[doc = "Falling Edge Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == IRQ1_TYPE::FallingEdge
            }
        }
        #[doc = "Field `irq1_type` writer - IRQ1 and DMA Request 1Type"]
        pub type IRQ1_TYPE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, IRQ1_TYPE, crate::Safe>;
        impl<'a, REG> IRQ1_TYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn high_level(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1_TYPE::HighLevel)
            }
            #[doc = "Rising Edge Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1_TYPE::RisingEdge)
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn low_level(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1_TYPE::LowLevel)
            }
            #[doc = "Falling Edge Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ1_TYPE::FallingEdge)
            }
        }
        #[doc = "IRQ2 and DMA Request 2 Type\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ2_TYPE {
            #[doc = "0: High Level Trigger Interrupt and High Level Trigger DMA Request"]
            HighLevel = 0,
            #[doc = "1: Rising Edge Trigger Interrupt and High Level Trigger DMA Request"]
            RisingEdge = 1,
            #[doc = "2: Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            LowLevel = 2,
            #[doc = "3: Falling Edge Trigger Interrupt and Low Level Trigger DMA Request"]
            FallingEdge = 3,
        }
        impl From<IRQ2_TYPE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ2_TYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ2_TYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ2_TYPE {}
        #[doc = "Field `irq2_type` reader - IRQ2 and DMA Request 2 Type"]
        pub type IRQ2_TYPE_R = crate::FieldReader<IRQ2_TYPE>;
        impl IRQ2_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ2_TYPE {
                match self.bits {
                    0 => IRQ2_TYPE::HighLevel,
                    1 => IRQ2_TYPE::RisingEdge,
                    2 => IRQ2_TYPE::LowLevel,
                    3 => IRQ2_TYPE::FallingEdge,
                    _ => unreachable!(),
                }
            }
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_high_level(&self) -> bool {
                *self == IRQ2_TYPE::HighLevel
            }
            #[doc = "Rising Edge Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == IRQ2_TYPE::RisingEdge
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_low_level(&self) -> bool {
                *self == IRQ2_TYPE::LowLevel
            }
            #[doc = "Falling Edge Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == IRQ2_TYPE::FallingEdge
            }
        }
        #[doc = "Field `irq2_type` writer - IRQ2 and DMA Request 2 Type"]
        pub type IRQ2_TYPE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, IRQ2_TYPE, crate::Safe>;
        impl<'a, REG> IRQ2_TYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn high_level(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2_TYPE::HighLevel)
            }
            #[doc = "Rising Edge Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2_TYPE::RisingEdge)
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn low_level(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2_TYPE::LowLevel)
            }
            #[doc = "Falling Edge Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ2_TYPE::FallingEdge)
            }
        }
        #[doc = "IRQ3 and DMA Request 3 Type\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQ3_TYPE {
            #[doc = "0: High Level Trigger Interrupt and High Level Trigger DMA Request"]
            HighLevel = 0,
            #[doc = "1: Rising Edge Trigger Interrupt and High Level Trigger DMA Request"]
            RisingEdge = 1,
            #[doc = "2: Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            LowLevel = 2,
            #[doc = "3: Falling Edge Trigger Interrupt and Low Level Trigger DMA Request"]
            FallingEdge = 3,
        }
        impl From<IRQ3_TYPE> for u8 {
            #[inline(always)]
            fn from(variant: IRQ3_TYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQ3_TYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQ3_TYPE {}
        #[doc = "Field `irq3_type` reader - IRQ3 and DMA Request 3 Type"]
        pub type IRQ3_TYPE_R = crate::FieldReader<IRQ3_TYPE>;
        impl IRQ3_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQ3_TYPE {
                match self.bits {
                    0 => IRQ3_TYPE::HighLevel,
                    1 => IRQ3_TYPE::RisingEdge,
                    2 => IRQ3_TYPE::LowLevel,
                    3 => IRQ3_TYPE::FallingEdge,
                    _ => unreachable!(),
                }
            }
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_high_level(&self) -> bool {
                *self == IRQ3_TYPE::HighLevel
            }
            #[doc = "Rising Edge Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == IRQ3_TYPE::RisingEdge
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_low_level(&self) -> bool {
                *self == IRQ3_TYPE::LowLevel
            }
            #[doc = "Falling Edge Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == IRQ3_TYPE::FallingEdge
            }
        }
        #[doc = "Field `irq3_type` writer - IRQ3 and DMA Request 3 Type"]
        pub type IRQ3_TYPE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, IRQ3_TYPE, crate::Safe>;
        impl<'a, REG> IRQ3_TYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn high_level(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3_TYPE::HighLevel)
            }
            #[doc = "Rising Edge Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3_TYPE::RisingEdge)
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn low_level(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3_TYPE::LowLevel)
            }
            #[doc = "Falling Edge Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut crate::W<REG> {
                self.variant(IRQ3_TYPE::FallingEdge)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - IRQ0 and DMA Request 0 Type"]
            #[inline(always)]
            pub fn irq0_type(&self) -> IRQ0_TYPE_R {
                IRQ0_TYPE_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - IRQ1 and DMA Request 1Type"]
            #[inline(always)]
            pub fn irq1_type(&self) -> IRQ1_TYPE_R {
                IRQ1_TYPE_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - IRQ2 and DMA Request 2 Type"]
            #[inline(always)]
            pub fn irq2_type(&self) -> IRQ2_TYPE_R {
                IRQ2_TYPE_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - IRQ3 and DMA Request 3 Type"]
            #[inline(always)]
            pub fn irq3_type(&self) -> IRQ3_TYPE_R {
                IRQ3_TYPE_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLA_IRQTYPE")
                    .field("irq0_type", &self.irq0_type())
                    .field("irq1_type", &self.irq1_type())
                    .field("irq2_type", &self.irq2_type())
                    .field("irq3_type", &self.irq3_type())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - IRQ0 and DMA Request 0 Type"]
            #[inline(always)]
            pub fn irq0_type(&mut self) -> IRQ0_TYPE_W<PLA_IRQTYPErs> {
                IRQ0_TYPE_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - IRQ1 and DMA Request 1Type"]
            #[inline(always)]
            pub fn irq1_type(&mut self) -> IRQ1_TYPE_W<PLA_IRQTYPErs> {
                IRQ1_TYPE_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - IRQ2 and DMA Request 2 Type"]
            #[inline(always)]
            pub fn irq2_type(&mut self) -> IRQ2_TYPE_W<PLA_IRQTYPErs> {
                IRQ2_TYPE_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - IRQ3 and DMA Request 3 Type"]
            #[inline(always)]
            pub fn irq3_type(&mut self) -> IRQ3_TYPE_W<PLA_IRQTYPErs> {
                IRQ3_TYPE_W::new(self, 6)
            }
        }
        #[doc = "PLA Interrupt Request and DMA Request Type\n\nYou can [`read`](crate::Reg::read) this register and get [`pla_irqtype::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pla_irqtype::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLA:PLA_IRQTYPE)"]
        pub struct PLA_IRQTYPErs;
        impl crate::RegisterSpec for PLA_IRQTYPErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pla_irqtype::R`](R) reader structure"]
        impl crate::Readable for PLA_IRQTYPErs {}
        #[doc = "`write(|w| ..)` method takes [`pla_irqtype::W`](W) writer structure"]
        impl crate::Writable for PLA_IRQTYPErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLA_IRQTYPE to value 0"]
        impl crate::Resettable for PLA_IRQTYPErs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ)"]
pub struct DMAREQ {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMAREQ {}
impl DMAREQ {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmareq::RegisterBlock = 0x4000_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmareq::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DMAREQ {
    type Target = dmareq::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMAREQ {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAREQ").finish()
    }
}
#[doc = "Unknown"]
pub mod dmareq {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        reqen: REQEN,
        req0sel: REQ0SEL,
        req1sel: REQ1SEL,
        plareqen: PLAREQEN,
        gptreqen: GPTREQEN,
        gpt_req_type: GPT_REQ_TYPE,
    }
    impl RegisterBlock {
        #[doc = "0x00 - GPT/GPT32 and PLA DMA Request Enable"]
        #[inline(always)]
        pub const fn reqen(&self) -> &REQEN {
            &self.reqen
        }
        #[doc = "0x04 - GPT/GPT32 and PLA DMA Request 0 Select"]
        #[inline(always)]
        pub const fn req0sel(&self) -> &REQ0SEL {
            &self.req0sel
        }
        #[doc = "0x08 - GPT/GPT32 and PLA DMA Request 1 Select"]
        #[inline(always)]
        pub const fn req1sel(&self) -> &REQ1SEL {
            &self.req1sel
        }
        #[doc = "0x0c - PLA DMA Requests Enable"]
        #[inline(always)]
        pub const fn plareqen(&self) -> &PLAREQEN {
            &self.plareqen
        }
        #[doc = "0x10 - GPT/GPT32 DMA Requests Enable"]
        #[inline(always)]
        pub const fn gptreqen(&self) -> &GPTREQEN {
            &self.gptreqen
        }
        #[doc = "0x14 - GPT and GPT32 Require Type"]
        #[inline(always)]
        pub const fn gpt_req_type(&self) -> &GPT_REQ_TYPE {
            &self.gpt_req_type
        }
    }
    #[doc = "REQEN (rw) register accessor: GPT/GPT32 and PLA DMA Request Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`reqen::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reqen::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:REQEN)\n\nFor information about available fields see [`mod@reqen`]
module"]
    pub type REQEN = crate::Reg<reqen::REQENrs>;
    #[doc = "GPT/GPT32 and PLA DMA Request Enable"]
    pub mod reqen {
        #[doc = "Register `REQEN` reader"]
        pub type R = crate::R<REQENrs>;
        #[doc = "Register `REQEN` writer"]
        pub type W = crate::W<REQENrs>;
        #[doc = "Field `GPLA_DMA_EN0` reader - GPT/GPT32 and PLA DMA Request 0 Enable"]
        pub type GPLA_DMA_EN0_R = crate::BitReader;
        #[doc = "Field `GPLA_DMA_EN0` writer - GPT/GPT32 and PLA DMA Request 0 Enable"]
        pub type GPLA_DMA_EN0_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPLA_DMA_EN1` reader - GPT/GPT32 and PLA DMA Request 1 Enable"]
        pub type GPLA_DMA_EN1_R = crate::BitReader;
        #[doc = "Field `GPLA_DMA_EN1` writer - GPT/GPT32 and PLA DMA Request 1 Enable"]
        pub type GPLA_DMA_EN1_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - GPT/GPT32 and PLA DMA Request 0 Enable"]
            #[inline(always)]
            pub fn gpla_dma_en0(&self) -> GPLA_DMA_EN0_R {
                GPLA_DMA_EN0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - GPT/GPT32 and PLA DMA Request 1 Enable"]
            #[inline(always)]
            pub fn gpla_dma_en1(&self) -> GPLA_DMA_EN1_R {
                GPLA_DMA_EN1_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("REQEN")
                    .field("gpla_dma_en0", &self.gpla_dma_en0())
                    .field("gpla_dma_en1", &self.gpla_dma_en1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - GPT/GPT32 and PLA DMA Request 0 Enable"]
            #[inline(always)]
            pub fn gpla_dma_en0(&mut self) -> GPLA_DMA_EN0_W<REQENrs> {
                GPLA_DMA_EN0_W::new(self, 0)
            }
            #[doc = "Bit 1 - GPT/GPT32 and PLA DMA Request 1 Enable"]
            #[inline(always)]
            pub fn gpla_dma_en1(&mut self) -> GPLA_DMA_EN1_W<REQENrs> {
                GPLA_DMA_EN1_W::new(self, 1)
            }
        }
        #[doc = "GPT/GPT32 and PLA DMA Request Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`reqen::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`reqen::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:REQEN)"]
        pub struct REQENrs;
        impl crate::RegisterSpec for REQENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`reqen::R`](R) reader structure"]
        impl crate::Readable for REQENrs {}
        #[doc = "`write(|w| ..)` method takes [`reqen::W`](W) writer structure"]
        impl crate::Writable for REQENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets REQEN to value 0"]
        impl crate::Resettable for REQENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "REQ0SEL (rw) register accessor: GPT/GPT32 and PLA DMA Request 0 Select\n\nYou can [`read`](crate::Reg::read) this register and get [`req0sel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`req0sel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:REQ0SEL)\n\nFor information about available fields see [`mod@req0sel`]
module"]
    pub type REQ0SEL = crate::Reg<req0sel::REQ0SELrs>;
    #[doc = "GPT/GPT32 and PLA DMA Request 0 Select"]
    pub mod req0sel {
        #[doc = "Register `REQ0SEL` reader"]
        pub type R = crate::R<REQ0SELrs>;
        #[doc = "Register `REQ0SEL` writer"]
        pub type W = crate::W<REQ0SELrs>;
        #[doc = "GPT/GPT32 and PLA DMA Request 0 Source Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DMA_REQ0_SEL {
            #[doc = "0: PLA DMA Request 0"]
            PlaReq0 = 0,
            #[doc = "1: PLA DMA Request 1"]
            PlaReq1 = 1,
            #[doc = "2: PLA DMA Request 2"]
            PlaReq2 = 2,
            #[doc = "3: PLA DMA Request 3"]
            PlaReq3 = 3,
            #[doc = "4: GPT 0 DMA Request"]
            GptReq0 = 4,
            #[doc = "5: GPT 1 DMA Request"]
            GptReq1 = 5,
            #[doc = "6: GPT 2 DMA Request"]
            GptReq2 = 6,
            #[doc = "7: GPT32 0 DMA Request"]
            Gpt32Req0 = 7,
            #[doc = "8: GPT32 1 DMA Request"]
            Gpt32Req1 = 8,
        }
        impl From<DMA_REQ0_SEL> for u8 {
            #[inline(always)]
            fn from(variant: DMA_REQ0_SEL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DMA_REQ0_SEL {
            type Ux = u8;
        }
        impl crate::IsEnum for DMA_REQ0_SEL {}
        #[doc = "Field `DMA_REQ0_SEL` reader - GPT/GPT32 and PLA DMA Request 0 Source Select"]
        pub type DMA_REQ0_SEL_R = crate::FieldReader<DMA_REQ0_SEL>;
        impl DMA_REQ0_SEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DMA_REQ0_SEL> {
                match self.bits {
                    0 => Some(DMA_REQ0_SEL::PlaReq0),
                    1 => Some(DMA_REQ0_SEL::PlaReq1),
                    2 => Some(DMA_REQ0_SEL::PlaReq2),
                    3 => Some(DMA_REQ0_SEL::PlaReq3),
                    4 => Some(DMA_REQ0_SEL::GptReq0),
                    5 => Some(DMA_REQ0_SEL::GptReq1),
                    6 => Some(DMA_REQ0_SEL::GptReq2),
                    7 => Some(DMA_REQ0_SEL::Gpt32Req0),
                    8 => Some(DMA_REQ0_SEL::Gpt32Req1),
                    _ => None,
                }
            }
            #[doc = "PLA DMA Request 0"]
            #[inline(always)]
            pub fn is_pla_req0(&self) -> bool {
                *self == DMA_REQ0_SEL::PlaReq0
            }
            #[doc = "PLA DMA Request 1"]
            #[inline(always)]
            pub fn is_pla_req1(&self) -> bool {
                *self == DMA_REQ0_SEL::PlaReq1
            }
            #[doc = "PLA DMA Request 2"]
            #[inline(always)]
            pub fn is_pla_req2(&self) -> bool {
                *self == DMA_REQ0_SEL::PlaReq2
            }
            #[doc = "PLA DMA Request 3"]
            #[inline(always)]
            pub fn is_pla_req3(&self) -> bool {
                *self == DMA_REQ0_SEL::PlaReq3
            }
            #[doc = "GPT 0 DMA Request"]
            #[inline(always)]
            pub fn is_gpt_req0(&self) -> bool {
                *self == DMA_REQ0_SEL::GptReq0
            }
            #[doc = "GPT 1 DMA Request"]
            #[inline(always)]
            pub fn is_gpt_req1(&self) -> bool {
                *self == DMA_REQ0_SEL::GptReq1
            }
            #[doc = "GPT 2 DMA Request"]
            #[inline(always)]
            pub fn is_gpt_req2(&self) -> bool {
                *self == DMA_REQ0_SEL::GptReq2
            }
            #[doc = "GPT32 0 DMA Request"]
            #[inline(always)]
            pub fn is_gpt32_req0(&self) -> bool {
                *self == DMA_REQ0_SEL::Gpt32Req0
            }
            #[doc = "GPT32 1 DMA Request"]
            #[inline(always)]
            pub fn is_gpt32_req1(&self) -> bool {
                *self == DMA_REQ0_SEL::Gpt32Req1
            }
        }
        #[doc = "Field `DMA_REQ0_SEL` writer - GPT/GPT32 and PLA DMA Request 0 Source Select"]
        pub type DMA_REQ0_SEL_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DMA_REQ0_SEL>;
        impl<'a, REG> DMA_REQ0_SEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "PLA DMA Request 0"]
            #[inline(always)]
            pub fn pla_req0(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ0_SEL::PlaReq0)
            }
            #[doc = "PLA DMA Request 1"]
            #[inline(always)]
            pub fn pla_req1(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ0_SEL::PlaReq1)
            }
            #[doc = "PLA DMA Request 2"]
            #[inline(always)]
            pub fn pla_req2(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ0_SEL::PlaReq2)
            }
            #[doc = "PLA DMA Request 3"]
            #[inline(always)]
            pub fn pla_req3(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ0_SEL::PlaReq3)
            }
            #[doc = "GPT 0 DMA Request"]
            #[inline(always)]
            pub fn gpt_req0(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ0_SEL::GptReq0)
            }
            #[doc = "GPT 1 DMA Request"]
            #[inline(always)]
            pub fn gpt_req1(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ0_SEL::GptReq1)
            }
            #[doc = "GPT 2 DMA Request"]
            #[inline(always)]
            pub fn gpt_req2(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ0_SEL::GptReq2)
            }
            #[doc = "GPT32 0 DMA Request"]
            #[inline(always)]
            pub fn gpt32_req0(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ0_SEL::Gpt32Req0)
            }
            #[doc = "GPT32 1 DMA Request"]
            #[inline(always)]
            pub fn gpt32_req1(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ0_SEL::Gpt32Req1)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - GPT/GPT32 and PLA DMA Request 0 Source Select"]
            #[inline(always)]
            pub fn dma_req0_sel(&self) -> DMA_REQ0_SEL_R {
                DMA_REQ0_SEL_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("REQ0SEL")
                    .field("dma_req0_sel", &self.dma_req0_sel())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPT/GPT32 and PLA DMA Request 0 Source Select"]
            #[inline(always)]
            pub fn dma_req0_sel(&mut self) -> DMA_REQ0_SEL_W<REQ0SELrs> {
                DMA_REQ0_SEL_W::new(self, 0)
            }
        }
        #[doc = "GPT/GPT32 and PLA DMA Request 0 Select\n\nYou can [`read`](crate::Reg::read) this register and get [`req0sel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`req0sel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:REQ0SEL)"]
        pub struct REQ0SELrs;
        impl crate::RegisterSpec for REQ0SELrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`req0sel::R`](R) reader structure"]
        impl crate::Readable for REQ0SELrs {}
        #[doc = "`write(|w| ..)` method takes [`req0sel::W`](W) writer structure"]
        impl crate::Writable for REQ0SELrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets REQ0SEL to value 0"]
        impl crate::Resettable for REQ0SELrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "REQ1SEL (rw) register accessor: GPT/GPT32 and PLA DMA Request 1 Select\n\nYou can [`read`](crate::Reg::read) this register and get [`req1sel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`req1sel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:REQ1SEL)\n\nFor information about available fields see [`mod@req1sel`]
module"]
    pub type REQ1SEL = crate::Reg<req1sel::REQ1SELrs>;
    #[doc = "GPT/GPT32 and PLA DMA Request 1 Select"]
    pub mod req1sel {
        #[doc = "Register `REQ1SEL` reader"]
        pub type R = crate::R<REQ1SELrs>;
        #[doc = "Register `REQ1SEL` writer"]
        pub type W = crate::W<REQ1SELrs>;
        #[doc = "GPT/GPT32 and PLA DMA Request 1 Source Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DMA_REQ1_SEL {
            #[doc = "0: PLA DMA Request 0"]
            PlaReq0 = 0,
            #[doc = "1: PLA DMA Request 1"]
            PlaReq1 = 1,
            #[doc = "2: PLA DMA Request 2"]
            PlaReq2 = 2,
            #[doc = "3: PLA DMA Request 3"]
            PlaReq3 = 3,
            #[doc = "4: GPT 0 DMA Request"]
            GptReq0 = 4,
            #[doc = "5: GPT 1 DMA Request"]
            GptReq1 = 5,
            #[doc = "6: GPT 2 DMA Request"]
            GptReq2 = 6,
            #[doc = "7: GPT32 0 DMA Request"]
            Gpt32Req0 = 7,
            #[doc = "8: GPT32 1 DMA Request"]
            Gpt32Req1 = 8,
        }
        impl From<DMA_REQ1_SEL> for u8 {
            #[inline(always)]
            fn from(variant: DMA_REQ1_SEL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DMA_REQ1_SEL {
            type Ux = u8;
        }
        impl crate::IsEnum for DMA_REQ1_SEL {}
        #[doc = "Field `DMA_REQ1_SEL` reader - GPT/GPT32 and PLA DMA Request 1 Source Select"]
        pub type DMA_REQ1_SEL_R = crate::FieldReader<DMA_REQ1_SEL>;
        impl DMA_REQ1_SEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DMA_REQ1_SEL> {
                match self.bits {
                    0 => Some(DMA_REQ1_SEL::PlaReq0),
                    1 => Some(DMA_REQ1_SEL::PlaReq1),
                    2 => Some(DMA_REQ1_SEL::PlaReq2),
                    3 => Some(DMA_REQ1_SEL::PlaReq3),
                    4 => Some(DMA_REQ1_SEL::GptReq0),
                    5 => Some(DMA_REQ1_SEL::GptReq1),
                    6 => Some(DMA_REQ1_SEL::GptReq2),
                    7 => Some(DMA_REQ1_SEL::Gpt32Req0),
                    8 => Some(DMA_REQ1_SEL::Gpt32Req1),
                    _ => None,
                }
            }
            #[doc = "PLA DMA Request 0"]
            #[inline(always)]
            pub fn is_pla_req0(&self) -> bool {
                *self == DMA_REQ1_SEL::PlaReq0
            }
            #[doc = "PLA DMA Request 1"]
            #[inline(always)]
            pub fn is_pla_req1(&self) -> bool {
                *self == DMA_REQ1_SEL::PlaReq1
            }
            #[doc = "PLA DMA Request 2"]
            #[inline(always)]
            pub fn is_pla_req2(&self) -> bool {
                *self == DMA_REQ1_SEL::PlaReq2
            }
            #[doc = "PLA DMA Request 3"]
            #[inline(always)]
            pub fn is_pla_req3(&self) -> bool {
                *self == DMA_REQ1_SEL::PlaReq3
            }
            #[doc = "GPT 0 DMA Request"]
            #[inline(always)]
            pub fn is_gpt_req0(&self) -> bool {
                *self == DMA_REQ1_SEL::GptReq0
            }
            #[doc = "GPT 1 DMA Request"]
            #[inline(always)]
            pub fn is_gpt_req1(&self) -> bool {
                *self == DMA_REQ1_SEL::GptReq1
            }
            #[doc = "GPT 2 DMA Request"]
            #[inline(always)]
            pub fn is_gpt_req2(&self) -> bool {
                *self == DMA_REQ1_SEL::GptReq2
            }
            #[doc = "GPT32 0 DMA Request"]
            #[inline(always)]
            pub fn is_gpt32_req0(&self) -> bool {
                *self == DMA_REQ1_SEL::Gpt32Req0
            }
            #[doc = "GPT32 1 DMA Request"]
            #[inline(always)]
            pub fn is_gpt32_req1(&self) -> bool {
                *self == DMA_REQ1_SEL::Gpt32Req1
            }
        }
        #[doc = "Field `DMA_REQ1_SEL` writer - GPT/GPT32 and PLA DMA Request 1 Source Select"]
        pub type DMA_REQ1_SEL_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DMA_REQ1_SEL>;
        impl<'a, REG> DMA_REQ1_SEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "PLA DMA Request 0"]
            #[inline(always)]
            pub fn pla_req0(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ1_SEL::PlaReq0)
            }
            #[doc = "PLA DMA Request 1"]
            #[inline(always)]
            pub fn pla_req1(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ1_SEL::PlaReq1)
            }
            #[doc = "PLA DMA Request 2"]
            #[inline(always)]
            pub fn pla_req2(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ1_SEL::PlaReq2)
            }
            #[doc = "PLA DMA Request 3"]
            #[inline(always)]
            pub fn pla_req3(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ1_SEL::PlaReq3)
            }
            #[doc = "GPT 0 DMA Request"]
            #[inline(always)]
            pub fn gpt_req0(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ1_SEL::GptReq0)
            }
            #[doc = "GPT 1 DMA Request"]
            #[inline(always)]
            pub fn gpt_req1(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ1_SEL::GptReq1)
            }
            #[doc = "GPT 2 DMA Request"]
            #[inline(always)]
            pub fn gpt_req2(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ1_SEL::GptReq2)
            }
            #[doc = "GPT32 0 DMA Request"]
            #[inline(always)]
            pub fn gpt32_req0(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ1_SEL::Gpt32Req0)
            }
            #[doc = "GPT32 1 DMA Request"]
            #[inline(always)]
            pub fn gpt32_req1(self) -> &'a mut crate::W<REG> {
                self.variant(DMA_REQ1_SEL::Gpt32Req1)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - GPT/GPT32 and PLA DMA Request 1 Source Select"]
            #[inline(always)]
            pub fn dma_req1_sel(&self) -> DMA_REQ1_SEL_R {
                DMA_REQ1_SEL_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("REQ1SEL")
                    .field("dma_req1_sel", &self.dma_req1_sel())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:3 - GPT/GPT32 and PLA DMA Request 1 Source Select"]
            #[inline(always)]
            pub fn dma_req1_sel(&mut self) -> DMA_REQ1_SEL_W<REQ1SELrs> {
                DMA_REQ1_SEL_W::new(self, 0)
            }
        }
        #[doc = "GPT/GPT32 and PLA DMA Request 1 Select\n\nYou can [`read`](crate::Reg::read) this register and get [`req1sel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`req1sel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:REQ1SEL)"]
        pub struct REQ1SELrs;
        impl crate::RegisterSpec for REQ1SELrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`req1sel::R`](R) reader structure"]
        impl crate::Readable for REQ1SELrs {}
        #[doc = "`write(|w| ..)` method takes [`req1sel::W`](W) writer structure"]
        impl crate::Writable for REQ1SELrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets REQ1SEL to value 0"]
        impl crate::Resettable for REQ1SELrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PLAREQEN (rw) register accessor: PLA DMA Requests Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`plareqen::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`plareqen::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:PLAREQEN)\n\nFor information about available fields see [`mod@plareqen`]
module"]
    pub type PLAREQEN = crate::Reg<plareqen::PLAREQENrs>;
    #[doc = "PLA DMA Requests Enable"]
    pub mod plareqen {
        #[doc = "Register `PLAREQEN` reader"]
        pub type R = crate::R<PLAREQENrs>;
        #[doc = "Register `PLAREQEN` writer"]
        pub type W = crate::W<PLAREQENrs>;
        #[doc = "Field `PLA_DMA_REQ0_EN` reader - PLA DMA Request 0 Enable"]
        pub type PLA_DMA_REQ0_EN_R = crate::BitReader;
        #[doc = "Field `PLA_DMA_REQ0_EN` writer - PLA DMA Request 0 Enable"]
        pub type PLA_DMA_REQ0_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PLA_DMA_REQ1_EN` reader - PLA DMA Request 1 Enable"]
        pub type PLA_DMA_REQ1_EN_R = crate::BitReader;
        #[doc = "Field `PLA_DMA_REQ1_EN` writer - PLA DMA Request 1 Enable"]
        pub type PLA_DMA_REQ1_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PLA_DMA_REQ2_EN` reader - PLA DMA Request 2 Enable"]
        pub type PLA_DMA_REQ2_EN_R = crate::BitReader;
        #[doc = "Field `PLA_DMA_REQ2_EN` writer - PLA DMA Request 2 Enable"]
        pub type PLA_DMA_REQ2_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PLA_DMA_REQ3_EN` reader - PLA DMA Request 3 Enable"]
        pub type PLA_DMA_REQ3_EN_R = crate::BitReader;
        #[doc = "Field `PLA_DMA_REQ3_EN` writer - PLA DMA Request 3 Enable"]
        pub type PLA_DMA_REQ3_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - PLA DMA Request 0 Enable"]
            #[inline(always)]
            pub fn pla_dma_req0_en(&self) -> PLA_DMA_REQ0_EN_R {
                PLA_DMA_REQ0_EN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - PLA DMA Request 1 Enable"]
            #[inline(always)]
            pub fn pla_dma_req1_en(&self) -> PLA_DMA_REQ1_EN_R {
                PLA_DMA_REQ1_EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - PLA DMA Request 2 Enable"]
            #[inline(always)]
            pub fn pla_dma_req2_en(&self) -> PLA_DMA_REQ2_EN_R {
                PLA_DMA_REQ2_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - PLA DMA Request 3 Enable"]
            #[inline(always)]
            pub fn pla_dma_req3_en(&self) -> PLA_DMA_REQ3_EN_R {
                PLA_DMA_REQ3_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLAREQEN")
                    .field("pla_dma_req0_en", &self.pla_dma_req0_en())
                    .field("pla_dma_req1_en", &self.pla_dma_req1_en())
                    .field("pla_dma_req2_en", &self.pla_dma_req2_en())
                    .field("pla_dma_req3_en", &self.pla_dma_req3_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - PLA DMA Request 0 Enable"]
            #[inline(always)]
            pub fn pla_dma_req0_en(&mut self) -> PLA_DMA_REQ0_EN_W<PLAREQENrs> {
                PLA_DMA_REQ0_EN_W::new(self, 0)
            }
            #[doc = "Bit 1 - PLA DMA Request 1 Enable"]
            #[inline(always)]
            pub fn pla_dma_req1_en(&mut self) -> PLA_DMA_REQ1_EN_W<PLAREQENrs> {
                PLA_DMA_REQ1_EN_W::new(self, 1)
            }
            #[doc = "Bit 2 - PLA DMA Request 2 Enable"]
            #[inline(always)]
            pub fn pla_dma_req2_en(&mut self) -> PLA_DMA_REQ2_EN_W<PLAREQENrs> {
                PLA_DMA_REQ2_EN_W::new(self, 2)
            }
            #[doc = "Bit 3 - PLA DMA Request 3 Enable"]
            #[inline(always)]
            pub fn pla_dma_req3_en(&mut self) -> PLA_DMA_REQ3_EN_W<PLAREQENrs> {
                PLA_DMA_REQ3_EN_W::new(self, 3)
            }
        }
        #[doc = "PLA DMA Requests Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`plareqen::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`plareqen::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:PLAREQEN)"]
        pub struct PLAREQENrs;
        impl crate::RegisterSpec for PLAREQENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`plareqen::R`](R) reader structure"]
        impl crate::Readable for PLAREQENrs {}
        #[doc = "`write(|w| ..)` method takes [`plareqen::W`](W) writer structure"]
        impl crate::Writable for PLAREQENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLAREQEN to value 0"]
        impl crate::Resettable for PLAREQENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GPTREQEN (rw) register accessor: GPT/GPT32 DMA Requests Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gptreqen::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gptreqen::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:GPTREQEN)\n\nFor information about available fields see [`mod@gptreqen`]
module"]
    pub type GPTREQEN = crate::Reg<gptreqen::GPTREQENrs>;
    #[doc = "GPT/GPT32 DMA Requests Enable"]
    pub mod gptreqen {
        #[doc = "Register `GPTREQEN` reader"]
        pub type R = crate::R<GPTREQENrs>;
        #[doc = "Register `GPTREQEN` writer"]
        pub type W = crate::W<GPTREQENrs>;
        #[doc = "Field `GPT0DMAEN` reader - GPT 0 DMA Request Enable"]
        pub type GPT0DMAEN_R = crate::BitReader;
        #[doc = "Field `GPT0DMAEN` writer - GPT 0 DMA Request Enable"]
        pub type GPT0DMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPT1DMAEN` reader - GPT 1 DMA Request Enable"]
        pub type GPT1DMAEN_R = crate::BitReader;
        #[doc = "Field `GPT1DMAEN` writer - GPT 1 DMA Request Enable"]
        pub type GPT1DMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPT2DMAEN` reader - GPT 2 DMA Request Enable"]
        pub type GPT2DMAEN_R = crate::BitReader;
        #[doc = "Field `GPT2DMAEN` writer - GPT 2 DMA Request Enable"]
        pub type GPT2DMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPTH0DMAEN` reader - GPT32 0 DMA Request Enable"]
        pub type GPTH0DMAEN_R = crate::BitReader;
        #[doc = "Field `GPTH0DMAEN` writer - GPT32 0 DMA Request Enable"]
        pub type GPTH0DMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPTH1DMAEN` reader - GPT32 1 DMA Request Enable"]
        pub type GPTH1DMAEN_R = crate::BitReader;
        #[doc = "Field `GPTH1DMAEN` writer - GPT32 1 DMA Request Enable"]
        pub type GPTH1DMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - GPT 0 DMA Request Enable"]
            #[inline(always)]
            pub fn gpt0dmaen(&self) -> GPT0DMAEN_R {
                GPT0DMAEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - GPT 1 DMA Request Enable"]
            #[inline(always)]
            pub fn gpt1dmaen(&self) -> GPT1DMAEN_R {
                GPT1DMAEN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - GPT 2 DMA Request Enable"]
            #[inline(always)]
            pub fn gpt2dmaen(&self) -> GPT2DMAEN_R {
                GPT2DMAEN_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - GPT32 0 DMA Request Enable"]
            #[inline(always)]
            pub fn gpth0dmaen(&self) -> GPTH0DMAEN_R {
                GPTH0DMAEN_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - GPT32 1 DMA Request Enable"]
            #[inline(always)]
            pub fn gpth1dmaen(&self) -> GPTH1DMAEN_R {
                GPTH1DMAEN_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPTREQEN")
                    .field("gpt0dmaen", &self.gpt0dmaen())
                    .field("gpt1dmaen", &self.gpt1dmaen())
                    .field("gpt2dmaen", &self.gpt2dmaen())
                    .field("gpth0dmaen", &self.gpth0dmaen())
                    .field("gpth1dmaen", &self.gpth1dmaen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - GPT 0 DMA Request Enable"]
            #[inline(always)]
            pub fn gpt0dmaen(&mut self) -> GPT0DMAEN_W<GPTREQENrs> {
                GPT0DMAEN_W::new(self, 0)
            }
            #[doc = "Bit 1 - GPT 1 DMA Request Enable"]
            #[inline(always)]
            pub fn gpt1dmaen(&mut self) -> GPT1DMAEN_W<GPTREQENrs> {
                GPT1DMAEN_W::new(self, 1)
            }
            #[doc = "Bit 2 - GPT 2 DMA Request Enable"]
            #[inline(always)]
            pub fn gpt2dmaen(&mut self) -> GPT2DMAEN_W<GPTREQENrs> {
                GPT2DMAEN_W::new(self, 2)
            }
            #[doc = "Bit 3 - GPT32 0 DMA Request Enable"]
            #[inline(always)]
            pub fn gpth0dmaen(&mut self) -> GPTH0DMAEN_W<GPTREQENrs> {
                GPTH0DMAEN_W::new(self, 3)
            }
            #[doc = "Bit 4 - GPT32 1 DMA Request Enable"]
            #[inline(always)]
            pub fn gpth1dmaen(&mut self) -> GPTH1DMAEN_W<GPTREQENrs> {
                GPTH1DMAEN_W::new(self, 4)
            }
        }
        #[doc = "GPT/GPT32 DMA Requests Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gptreqen::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gptreqen::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:GPTREQEN)"]
        pub struct GPTREQENrs;
        impl crate::RegisterSpec for GPTREQENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gptreqen::R`](R) reader structure"]
        impl crate::Readable for GPTREQENrs {}
        #[doc = "`write(|w| ..)` method takes [`gptreqen::W`](W) writer structure"]
        impl crate::Writable for GPTREQENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GPTREQEN to value 0"]
        impl crate::Resettable for GPTREQENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GPT_REQ_TYPE (rw) register accessor: GPT and GPT32 Require Type\n\nYou can [`read`](crate::Reg::read) this register and get [`gpt_req_type::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gpt_req_type::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:GPT_REQ_TYPE)\n\nFor information about available fields see [`mod@gpt_req_type`]
module"]
    pub type GPT_REQ_TYPE = crate::Reg<gpt_req_type::GPT_REQ_TYPErs>;
    #[doc = "GPT and GPT32 Require Type"]
    pub mod gpt_req_type {
        #[doc = "Register `GPT_REQ_TYPE` reader"]
        pub type R = crate::R<GPT_REQ_TYPErs>;
        #[doc = "Register `GPT_REQ_TYPE` writer"]
        pub type W = crate::W<GPT_REQ_TYPErs>;
        #[doc = "GPT Req0 DMA Require Type\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum GPT_REQ0_TYPE {
            #[doc = "0: High Level Trigger Interrupt and High Level Trigger DMA Request"]
            HighLevel = 0,
            #[doc = "1: Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            RisingEdge = 1,
            #[doc = "2: Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            LowLevel = 2,
            #[doc = "3: Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            FallingEdge = 3,
        }
        impl From<GPT_REQ0_TYPE> for u8 {
            #[inline(always)]
            fn from(variant: GPT_REQ0_TYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for GPT_REQ0_TYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for GPT_REQ0_TYPE {}
        #[doc = "Field `GPT_REQ0_TYPE` reader - GPT Req0 DMA Require Type"]
        pub type GPT_REQ0_TYPE_R = crate::FieldReader<GPT_REQ0_TYPE>;
        impl GPT_REQ0_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GPT_REQ0_TYPE {
                match self.bits {
                    0 => GPT_REQ0_TYPE::HighLevel,
                    1 => GPT_REQ0_TYPE::RisingEdge,
                    2 => GPT_REQ0_TYPE::LowLevel,
                    3 => GPT_REQ0_TYPE::FallingEdge,
                    _ => unreachable!(),
                }
            }
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_high_level(&self) -> bool {
                *self == GPT_REQ0_TYPE::HighLevel
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == GPT_REQ0_TYPE::RisingEdge
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_low_level(&self) -> bool {
                *self == GPT_REQ0_TYPE::LowLevel
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == GPT_REQ0_TYPE::FallingEdge
            }
        }
        #[doc = "Field `GPT_REQ0_TYPE` writer - GPT Req0 DMA Require Type"]
        pub type GPT_REQ0_TYPE_W<'a, REG> =
            crate::FieldWriter<'a, REG, 2, GPT_REQ0_TYPE, crate::Safe>;
        impl<'a, REG> GPT_REQ0_TYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn high_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ0_TYPE::HighLevel)
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ0_TYPE::RisingEdge)
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn low_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ0_TYPE::LowLevel)
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ0_TYPE::FallingEdge)
            }
        }
        #[doc = "GPT Req1 DMA Require Type\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum GPT_REQ1_TYPE {
            #[doc = "0: High Level Trigger Interrupt and High Level Trigger DMA Request"]
            HighLevel = 0,
            #[doc = "1: Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            RisingEdge = 1,
            #[doc = "2: Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            LowLevel = 2,
            #[doc = "3: Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            FallingEdge = 3,
        }
        impl From<GPT_REQ1_TYPE> for u8 {
            #[inline(always)]
            fn from(variant: GPT_REQ1_TYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for GPT_REQ1_TYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for GPT_REQ1_TYPE {}
        #[doc = "Field `GPT_REQ1_TYPE` reader - GPT Req1 DMA Require Type"]
        pub type GPT_REQ1_TYPE_R = crate::FieldReader<GPT_REQ1_TYPE>;
        impl GPT_REQ1_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GPT_REQ1_TYPE {
                match self.bits {
                    0 => GPT_REQ1_TYPE::HighLevel,
                    1 => GPT_REQ1_TYPE::RisingEdge,
                    2 => GPT_REQ1_TYPE::LowLevel,
                    3 => GPT_REQ1_TYPE::FallingEdge,
                    _ => unreachable!(),
                }
            }
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_high_level(&self) -> bool {
                *self == GPT_REQ1_TYPE::HighLevel
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == GPT_REQ1_TYPE::RisingEdge
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_low_level(&self) -> bool {
                *self == GPT_REQ1_TYPE::LowLevel
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == GPT_REQ1_TYPE::FallingEdge
            }
        }
        #[doc = "Field `GPT_REQ1_TYPE` writer - GPT Req1 DMA Require Type"]
        pub type GPT_REQ1_TYPE_W<'a, REG> =
            crate::FieldWriter<'a, REG, 2, GPT_REQ1_TYPE, crate::Safe>;
        impl<'a, REG> GPT_REQ1_TYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn high_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ1_TYPE::HighLevel)
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ1_TYPE::RisingEdge)
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn low_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ1_TYPE::LowLevel)
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ1_TYPE::FallingEdge)
            }
        }
        #[doc = "GPT Req2 DMA Require Type\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum GPT_REQ2_TYPE {
            #[doc = "0: High Level Trigger Interrupt and High Level Trigger DMA Request"]
            HighLevel = 0,
            #[doc = "1: Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            RisingEdge = 1,
            #[doc = "2: Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            LowLevel = 2,
            #[doc = "3: Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            FallingEdge = 3,
        }
        impl From<GPT_REQ2_TYPE> for u8 {
            #[inline(always)]
            fn from(variant: GPT_REQ2_TYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for GPT_REQ2_TYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for GPT_REQ2_TYPE {}
        #[doc = "Field `GPT_REQ2_TYPE` reader - GPT Req2 DMA Require Type"]
        pub type GPT_REQ2_TYPE_R = crate::FieldReader<GPT_REQ2_TYPE>;
        impl GPT_REQ2_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GPT_REQ2_TYPE {
                match self.bits {
                    0 => GPT_REQ2_TYPE::HighLevel,
                    1 => GPT_REQ2_TYPE::RisingEdge,
                    2 => GPT_REQ2_TYPE::LowLevel,
                    3 => GPT_REQ2_TYPE::FallingEdge,
                    _ => unreachable!(),
                }
            }
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_high_level(&self) -> bool {
                *self == GPT_REQ2_TYPE::HighLevel
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == GPT_REQ2_TYPE::RisingEdge
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_low_level(&self) -> bool {
                *self == GPT_REQ2_TYPE::LowLevel
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == GPT_REQ2_TYPE::FallingEdge
            }
        }
        #[doc = "Field `GPT_REQ2_TYPE` writer - GPT Req2 DMA Require Type"]
        pub type GPT_REQ2_TYPE_W<'a, REG> =
            crate::FieldWriter<'a, REG, 2, GPT_REQ2_TYPE, crate::Safe>;
        impl<'a, REG> GPT_REQ2_TYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn high_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ2_TYPE::HighLevel)
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ2_TYPE::RisingEdge)
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn low_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ2_TYPE::LowLevel)
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT_REQ2_TYPE::FallingEdge)
            }
        }
        #[doc = "GPT32 Req0 DMA Require Type\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum GPT32_REQ0_TYPE {
            #[doc = "0: High Level Trigger Interrupt and High Level Trigger DMA Request"]
            HighLevel = 0,
            #[doc = "1: Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            RisingEdge = 1,
            #[doc = "2: Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            LowLevel = 2,
            #[doc = "3: Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            FallingEdge = 3,
        }
        impl From<GPT32_REQ0_TYPE> for u8 {
            #[inline(always)]
            fn from(variant: GPT32_REQ0_TYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for GPT32_REQ0_TYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for GPT32_REQ0_TYPE {}
        #[doc = "Field `GPT32_REQ0_TYPE` reader - GPT32 Req0 DMA Require Type"]
        pub type GPT32_REQ0_TYPE_R = crate::FieldReader<GPT32_REQ0_TYPE>;
        impl GPT32_REQ0_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GPT32_REQ0_TYPE {
                match self.bits {
                    0 => GPT32_REQ0_TYPE::HighLevel,
                    1 => GPT32_REQ0_TYPE::RisingEdge,
                    2 => GPT32_REQ0_TYPE::LowLevel,
                    3 => GPT32_REQ0_TYPE::FallingEdge,
                    _ => unreachable!(),
                }
            }
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_high_level(&self) -> bool {
                *self == GPT32_REQ0_TYPE::HighLevel
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == GPT32_REQ0_TYPE::RisingEdge
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_low_level(&self) -> bool {
                *self == GPT32_REQ0_TYPE::LowLevel
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == GPT32_REQ0_TYPE::FallingEdge
            }
        }
        #[doc = "Field `GPT32_REQ0_TYPE` writer - GPT32 Req0 DMA Require Type"]
        pub type GPT32_REQ0_TYPE_W<'a, REG> =
            crate::FieldWriter<'a, REG, 2, GPT32_REQ0_TYPE, crate::Safe>;
        impl<'a, REG> GPT32_REQ0_TYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn high_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT32_REQ0_TYPE::HighLevel)
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT32_REQ0_TYPE::RisingEdge)
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn low_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT32_REQ0_TYPE::LowLevel)
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT32_REQ0_TYPE::FallingEdge)
            }
        }
        #[doc = "GPT32 Req1 DMA Require Type\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum GPT32_REQ1_TYPE {
            #[doc = "0: High Level Trigger Interrupt and High Level Trigger DMA Request"]
            HighLevel = 0,
            #[doc = "1: Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            RisingEdge = 1,
            #[doc = "2: Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            LowLevel = 2,
            #[doc = "3: Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            FallingEdge = 3,
        }
        impl From<GPT32_REQ1_TYPE> for u8 {
            #[inline(always)]
            fn from(variant: GPT32_REQ1_TYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for GPT32_REQ1_TYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for GPT32_REQ1_TYPE {}
        #[doc = "Field `GPT32_REQ1_TYPE` reader - GPT32 Req1 DMA Require Type"]
        pub type GPT32_REQ1_TYPE_R = crate::FieldReader<GPT32_REQ1_TYPE>;
        impl GPT32_REQ1_TYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GPT32_REQ1_TYPE {
                match self.bits {
                    0 => GPT32_REQ1_TYPE::HighLevel,
                    1 => GPT32_REQ1_TYPE::RisingEdge,
                    2 => GPT32_REQ1_TYPE::LowLevel,
                    3 => GPT32_REQ1_TYPE::FallingEdge,
                    _ => unreachable!(),
                }
            }
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_high_level(&self) -> bool {
                *self == GPT32_REQ1_TYPE::HighLevel
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_rising_edge(&self) -> bool {
                *self == GPT32_REQ1_TYPE::RisingEdge
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn is_low_level(&self) -> bool {
                *self == GPT32_REQ1_TYPE::LowLevel
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn is_falling_edge(&self) -> bool {
                *self == GPT32_REQ1_TYPE::FallingEdge
            }
        }
        #[doc = "Field `GPT32_REQ1_TYPE` writer - GPT32 Req1 DMA Require Type"]
        pub type GPT32_REQ1_TYPE_W<'a, REG> =
            crate::FieldWriter<'a, REG, 2, GPT32_REQ1_TYPE, crate::Safe>;
        impl<'a, REG> GPT32_REQ1_TYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Level Trigger Interrupt and High Level Trigger DMA Request"]
            #[inline(always)]
            pub fn high_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT32_REQ1_TYPE::HighLevel)
            }
            #[doc = "Rising Edge Trigger Interrupt and Rising Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn rising_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT32_REQ1_TYPE::RisingEdge)
            }
            #[doc = "Low Level Trigger Interrupt and Low Level Trigger DMA Request"]
            #[inline(always)]
            pub fn low_level(self) -> &'a mut crate::W<REG> {
                self.variant(GPT32_REQ1_TYPE::LowLevel)
            }
            #[doc = "Falling Edge Trigger Interrupt and Falling Edge Trigger DMA Request"]
            #[inline(always)]
            pub fn falling_edge(self) -> &'a mut crate::W<REG> {
                self.variant(GPT32_REQ1_TYPE::FallingEdge)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - GPT Req0 DMA Require Type"]
            #[inline(always)]
            pub fn gpt_req0_type(&self) -> GPT_REQ0_TYPE_R {
                GPT_REQ0_TYPE_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - GPT Req1 DMA Require Type"]
            #[inline(always)]
            pub fn gpt_req1_type(&self) -> GPT_REQ1_TYPE_R {
                GPT_REQ1_TYPE_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - GPT Req2 DMA Require Type"]
            #[inline(always)]
            pub fn gpt_req2_type(&self) -> GPT_REQ2_TYPE_R {
                GPT_REQ2_TYPE_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - GPT32 Req0 DMA Require Type"]
            #[inline(always)]
            pub fn gpt32_req0_type(&self) -> GPT32_REQ0_TYPE_R {
                GPT32_REQ0_TYPE_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - GPT32 Req1 DMA Require Type"]
            #[inline(always)]
            pub fn gpt32_req1_type(&self) -> GPT32_REQ1_TYPE_R {
                GPT32_REQ1_TYPE_R::new(((self.bits >> 8) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GPT_REQ_TYPE")
                    .field("gpt_req0_type", &self.gpt_req0_type())
                    .field("gpt_req1_type", &self.gpt_req1_type())
                    .field("gpt_req2_type", &self.gpt_req2_type())
                    .field("gpt32_req0_type", &self.gpt32_req0_type())
                    .field("gpt32_req1_type", &self.gpt32_req1_type())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - GPT Req0 DMA Require Type"]
            #[inline(always)]
            pub fn gpt_req0_type(&mut self) -> GPT_REQ0_TYPE_W<GPT_REQ_TYPErs> {
                GPT_REQ0_TYPE_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - GPT Req1 DMA Require Type"]
            #[inline(always)]
            pub fn gpt_req1_type(&mut self) -> GPT_REQ1_TYPE_W<GPT_REQ_TYPErs> {
                GPT_REQ1_TYPE_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - GPT Req2 DMA Require Type"]
            #[inline(always)]
            pub fn gpt_req2_type(&mut self) -> GPT_REQ2_TYPE_W<GPT_REQ_TYPErs> {
                GPT_REQ2_TYPE_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - GPT32 Req0 DMA Require Type"]
            #[inline(always)]
            pub fn gpt32_req0_type(&mut self) -> GPT32_REQ0_TYPE_W<GPT_REQ_TYPErs> {
                GPT32_REQ0_TYPE_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - GPT32 Req1 DMA Require Type"]
            #[inline(always)]
            pub fn gpt32_req1_type(&mut self) -> GPT32_REQ1_TYPE_W<GPT_REQ_TYPErs> {
                GPT32_REQ1_TYPE_W::new(self, 8)
            }
        }
        #[doc = "GPT and GPT32 Require Type\n\nYou can [`read`](crate::Reg::read) this register and get [`gpt_req_type::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gpt_req_type::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMAREQ:GPT_REQ_TYPE)"]
        pub struct GPT_REQ_TYPErs;
        impl crate::RegisterSpec for GPT_REQ_TYPErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gpt_req_type::R`](R) reader structure"]
        impl crate::Readable for GPT_REQ_TYPErs {}
        #[doc = "`write(|w| ..)` method takes [`gpt_req_type::W`](W) writer structure"]
        impl crate::Writable for GPT_REQ_TYPErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GPT_REQ_TYPE to value 0"]
        impl crate::Resettable for GPT_REQ_TYPErs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0)"]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "Unknown"]
pub mod uart0 {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        rx: RX,
        ien: IEN,
        iir: IIR,
        lcr: LCR,
        mcr: MCR,
        lsr: LSR,
        msr: MSR,
        scr: SCR,
        fcr: FCR,
        fbr: FBR,
        div: DIV,
        lcr2: LCR2,
        ctl: CTL,
        rfc: RFC,
        tfc: TFC,
        rsc: RSC,
        acr: ACR,
        asrl: ASRL,
        asrh: ASRH,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Receive/transfer Buffer Register"]
        #[inline(always)]
        pub const fn rx(&self) -> &RX {
            &self.rx
        }
        #[doc = "0x04 - Interrupt Enable"]
        #[inline(always)]
        pub const fn ien(&self) -> &IEN {
            &self.ien
        }
        #[doc = "0x08 - Interrupt ID"]
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            &self.iir
        }
        #[doc = "0x0c - Line Control"]
        #[inline(always)]
        pub const fn lcr(&self) -> &LCR {
            &self.lcr
        }
        #[doc = "0x10 - Modem Control"]
        #[inline(always)]
        pub const fn mcr(&self) -> &MCR {
            &self.mcr
        }
        #[doc = "0x14 - Line Status"]
        #[inline(always)]
        pub const fn lsr(&self) -> &LSR {
            &self.lsr
        }
        #[doc = "0x18 - Modem Status"]
        #[inline(always)]
        pub const fn msr(&self) -> &MSR {
            &self.msr
        }
        #[doc = "0x1c - Scratch Buffer"]
        #[inline(always)]
        pub const fn scr(&self) -> &SCR {
            &self.scr
        }
        #[doc = "0x20 - FIFO Control"]
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            &self.fcr
        }
        #[doc = "0x24 - Fractional Baud Rate"]
        #[inline(always)]
        pub const fn fbr(&self) -> &FBR {
            &self.fbr
        }
        #[doc = "0x28 - Baudrate Divider"]
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
        #[doc = "0x2c - Second Line Control"]
        #[inline(always)]
        pub const fn lcr2(&self) -> &LCR2 {
            &self.lcr2
        }
        #[doc = "0x30 - UART Control Register"]
        #[inline(always)]
        pub const fn ctl(&self) -> &CTL {
            &self.ctl
        }
        #[doc = "0x34 - RX FIFO Byte Count"]
        #[inline(always)]
        pub const fn rfc(&self) -> &RFC {
            &self.rfc
        }
        #[doc = "0x38 - TX FIFO Byte Count"]
        #[inline(always)]
        pub const fn tfc(&self) -> &TFC {
            &self.tfc
        }
        #[doc = "0x3c - RS485 Half-duplex Control"]
        #[inline(always)]
        pub const fn rsc(&self) -> &RSC {
            &self.rsc
        }
        #[doc = "0x40 - Auto Baud Control"]
        #[inline(always)]
        pub const fn acr(&self) -> &ACR {
            &self.acr
        }
        #[doc = "0x44 - Auto Baud Status (Low)"]
        #[inline(always)]
        pub const fn asrl(&self) -> &ASRL {
            &self.asrl
        }
        #[doc = "0x48 - Auto Baud Status (High)"]
        #[inline(always)]
        pub const fn asrh(&self) -> &ASRH {
            &self.asrh
        }
    }
    #[doc = "RX (rw) register accessor: Receive/transfer Buffer Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:RX)\n\nFor information about available fields see [`mod@rx`]
module"]
    pub type RX = crate::Reg<rx::RXrs>;
    #[doc = "Receive/transfer Buffer Register"]
    pub mod rx {
        #[doc = "Register `RX` reader"]
        pub type R = crate::R<RXrs>;
        #[doc = "Register `RX` writer"]
        pub type W = crate::W<RXrs>;
        #[doc = "Field `RBR` reader - Receive Buffer Register"]
        pub type RBR_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Receive Buffer Register"]
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RX").field("rbr", &self.rbr()).finish()
            }
        }
        impl W {}
        #[doc = "Receive/transfer Buffer Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:RX)"]
        pub struct RXrs;
        impl crate::RegisterSpec for RXrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rx::R`](R) reader structure"]
        impl crate::Readable for RXrs {}
        #[doc = "`write(|w| ..)` method takes [`rx::W`](W) writer structure"]
        impl crate::Writable for RXrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RX to value 0"]
        impl crate::Resettable for RXrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "IEN (rw) register accessor: Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ien::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ien::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:IEN)\n\nFor information about available fields see [`mod@ien`]
module"]
    pub type IEN = crate::Reg<ien::IENrs>;
    #[doc = "Interrupt Enable"]
    pub mod ien {
        #[doc = "Register `IEN` reader"]
        pub type R = crate::R<IENrs>;
        #[doc = "Register `IEN` writer"]
        pub type W = crate::W<IENrs>;
        #[doc = "Receive Buffer Full Interrupt\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERBFI {
            #[doc = "0: Interrupt Disabled"]
            Dis = 0,
            #[doc = "1: Interrupt Enabled"]
            En = 1,
        }
        impl From<ERBFI> for bool {
            #[inline(always)]
            fn from(variant: ERBFI) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ERBFI` reader - Receive Buffer Full Interrupt"]
        pub type ERBFI_R = crate::BitReader<ERBFI>;
        impl ERBFI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ERBFI {
                match self.bits {
                    false => ERBFI::Dis,
                    true => ERBFI::En,
                }
            }
            #[doc = "Interrupt Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == ERBFI::Dis
            }
            #[doc = "Interrupt Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == ERBFI::En
            }
        }
        #[doc = "Field `ERBFI` writer - Receive Buffer Full Interrupt"]
        pub type ERBFI_W<'a, REG> = crate::BitWriter<'a, REG, ERBFI>;
        impl<'a, REG> ERBFI_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Interrupt Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(ERBFI::Dis)
            }
            #[doc = "Interrupt Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(ERBFI::En)
            }
        }
        #[doc = "Transmit Buffer Empty Interrupt\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ETBEI {
            #[doc = "0: Interrupt Disabled"]
            Dis = 0,
            #[doc = "1: Interrupt Enabled"]
            En = 1,
        }
        impl From<ETBEI> for bool {
            #[inline(always)]
            fn from(variant: ETBEI) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ETBEI` reader - Transmit Buffer Empty Interrupt"]
        pub type ETBEI_R = crate::BitReader<ETBEI>;
        impl ETBEI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ETBEI {
                match self.bits {
                    false => ETBEI::Dis,
                    true => ETBEI::En,
                }
            }
            #[doc = "Interrupt Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == ETBEI::Dis
            }
            #[doc = "Interrupt Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == ETBEI::En
            }
        }
        #[doc = "Field `ETBEI` writer - Transmit Buffer Empty Interrupt"]
        pub type ETBEI_W<'a, REG> = crate::BitWriter<'a, REG, ETBEI>;
        impl<'a, REG> ETBEI_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Interrupt Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(ETBEI::Dis)
            }
            #[doc = "Interrupt Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(ETBEI::En)
            }
        }
        #[doc = "Rx Status Interrupt\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ELSI {
            #[doc = "0: Interrupt Disabled"]
            Dis = 0,
            #[doc = "1: Interrupt Enabled"]
            En = 1,
        }
        impl From<ELSI> for bool {
            #[inline(always)]
            fn from(variant: ELSI) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ELSI` reader - Rx Status Interrupt"]
        pub type ELSI_R = crate::BitReader<ELSI>;
        impl ELSI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ELSI {
                match self.bits {
                    false => ELSI::Dis,
                    true => ELSI::En,
                }
            }
            #[doc = "Interrupt Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == ELSI::Dis
            }
            #[doc = "Interrupt Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == ELSI::En
            }
        }
        #[doc = "Field `ELSI` writer - Rx Status Interrupt"]
        pub type ELSI_W<'a, REG> = crate::BitWriter<'a, REG, ELSI>;
        impl<'a, REG> ELSI_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Interrupt Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(ELSI::Dis)
            }
            #[doc = "Interrupt Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(ELSI::En)
            }
        }
        #[doc = "Modem Status Interrupt\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EDSSI {
            #[doc = "0: Interrupt Disabled"]
            Dis = 0,
            #[doc = "1: Interrupt Enabled"]
            En = 1,
        }
        impl From<EDSSI> for bool {
            #[inline(always)]
            fn from(variant: EDSSI) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EDSSI` reader - Modem Status Interrupt"]
        pub type EDSSI_R = crate::BitReader<EDSSI>;
        impl EDSSI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> EDSSI {
                match self.bits {
                    false => EDSSI::Dis,
                    true => EDSSI::En,
                }
            }
            #[doc = "Interrupt Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == EDSSI::Dis
            }
            #[doc = "Interrupt Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == EDSSI::En
            }
        }
        #[doc = "Field `EDSSI` writer - Modem Status Interrupt"]
        pub type EDSSI_W<'a, REG> = crate::BitWriter<'a, REG, EDSSI>;
        impl<'a, REG> EDSSI_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Interrupt Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(EDSSI::Dis)
            }
            #[doc = "Interrupt Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(EDSSI::En)
            }
        }
        #[doc = "DMA Requests in Transmit Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EDMAT {
            #[doc = "0: DMA Requests are Disabled"]
            Dis = 0,
            #[doc = "1: DMA Requests are Enabled"]
            En = 1,
        }
        impl From<EDMAT> for bool {
            #[inline(always)]
            fn from(variant: EDMAT) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EDMAT` reader - DMA Requests in Transmit Mode"]
        pub type EDMAT_R = crate::BitReader<EDMAT>;
        impl EDMAT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> EDMAT {
                match self.bits {
                    false => EDMAT::Dis,
                    true => EDMAT::En,
                }
            }
            #[doc = "DMA Requests are Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == EDMAT::Dis
            }
            #[doc = "DMA Requests are Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == EDMAT::En
            }
        }
        #[doc = "Field `EDMAT` writer - DMA Requests in Transmit Mode"]
        pub type EDMAT_W<'a, REG> = crate::BitWriter<'a, REG, EDMAT>;
        impl<'a, REG> EDMAT_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DMA Requests are Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(EDMAT::Dis)
            }
            #[doc = "DMA Requests are Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(EDMAT::En)
            }
        }
        #[doc = "DMA Requests in Receive Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EDMAR {
            #[doc = "0: DMA Requests Disabled"]
            Dis = 0,
            #[doc = "1: DMA Requests Enabled"]
            En = 1,
        }
        impl From<EDMAR> for bool {
            #[inline(always)]
            fn from(variant: EDMAR) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EDMAR` reader - DMA Requests in Receive Mode"]
        pub type EDMAR_R = crate::BitReader<EDMAR>;
        impl EDMAR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> EDMAR {
                match self.bits {
                    false => EDMAR::Dis,
                    true => EDMAR::En,
                }
            }
            #[doc = "DMA Requests Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == EDMAR::Dis
            }
            #[doc = "DMA Requests Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == EDMAR::En
            }
        }
        #[doc = "Field `EDMAR` writer - DMA Requests in Receive Mode"]
        pub type EDMAR_W<'a, REG> = crate::BitWriter<'a, REG, EDMAR>;
        impl<'a, REG> EDMAR_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DMA Requests Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(EDMAR::Dis)
            }
            #[doc = "DMA Requests Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(EDMAR::En)
            }
        }
        impl R {
            #[doc = "Bit 0 - Receive Buffer Full Interrupt"]
            #[inline(always)]
            pub fn erbfi(&self) -> ERBFI_R {
                ERBFI_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Transmit Buffer Empty Interrupt"]
            #[inline(always)]
            pub fn etbei(&self) -> ETBEI_R {
                ETBEI_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Rx Status Interrupt"]
            #[inline(always)]
            pub fn elsi(&self) -> ELSI_R {
                ELSI_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Modem Status Interrupt"]
            #[inline(always)]
            pub fn edssi(&self) -> EDSSI_R {
                EDSSI_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - DMA Requests in Transmit Mode"]
            #[inline(always)]
            pub fn edmat(&self) -> EDMAT_R {
                EDMAT_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - DMA Requests in Receive Mode"]
            #[inline(always)]
            pub fn edmar(&self) -> EDMAR_R {
                EDMAR_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IEN")
                    .field("erbfi", &self.erbfi())
                    .field("etbei", &self.etbei())
                    .field("elsi", &self.elsi())
                    .field("edssi", &self.edssi())
                    .field("edmat", &self.edmat())
                    .field("edmar", &self.edmar())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Receive Buffer Full Interrupt"]
            #[inline(always)]
            pub fn erbfi(&mut self) -> ERBFI_W<IENrs> {
                ERBFI_W::new(self, 0)
            }
            #[doc = "Bit 1 - Transmit Buffer Empty Interrupt"]
            #[inline(always)]
            pub fn etbei(&mut self) -> ETBEI_W<IENrs> {
                ETBEI_W::new(self, 1)
            }
            #[doc = "Bit 2 - Rx Status Interrupt"]
            #[inline(always)]
            pub fn elsi(&mut self) -> ELSI_W<IENrs> {
                ELSI_W::new(self, 2)
            }
            #[doc = "Bit 3 - Modem Status Interrupt"]
            #[inline(always)]
            pub fn edssi(&mut self) -> EDSSI_W<IENrs> {
                EDSSI_W::new(self, 3)
            }
            #[doc = "Bit 4 - DMA Requests in Transmit Mode"]
            #[inline(always)]
            pub fn edmat(&mut self) -> EDMAT_W<IENrs> {
                EDMAT_W::new(self, 4)
            }
            #[doc = "Bit 5 - DMA Requests in Receive Mode"]
            #[inline(always)]
            pub fn edmar(&mut self) -> EDMAR_W<IENrs> {
                EDMAR_W::new(self, 5)
            }
        }
        #[doc = "Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ien::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ien::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:IEN)"]
        pub struct IENrs;
        impl crate::RegisterSpec for IENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ien::R`](R) reader structure"]
        impl crate::Readable for IENrs {}
        #[doc = "`write(|w| ..)` method takes [`ien::W`](W) writer structure"]
        impl crate::Writable for IENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets IEN to value 0"]
        impl crate::Resettable for IENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "IIR (rw) register accessor: Interrupt ID\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:IIR)\n\nFor information about available fields see [`mod@iir`]
module"]
    pub type IIR = crate::Reg<iir::IIRrs>;
    #[doc = "Interrupt ID"]
    pub mod iir {
        #[doc = "Register `IIR` reader"]
        pub type R = crate::R<IIRrs>;
        #[doc = "Register `IIR` writer"]
        pub type W = crate::W<IIRrs>;
        #[doc = "Field `NIRQ` reader - Interrupt Flag"]
        pub type NIRQ_R = crate::BitReader;
        #[doc = "Interrupt Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT {
            #[doc = "0: Modem Status Interrupt (Read MSR Register to Clear)"]
            Modemint = 0,
            #[doc = "1: Transmit Buffer Empty Interrupt (Write to Tx Register or Read IIR Register to Clear)"]
            Txemptyint = 1,
            #[doc = "2: Receive Buffer Full Interrupt (Read Rx Register to Clear)"]
            Rxfullint = 2,
            #[doc = "3: Receive Line Status Interrupt (Read LSR Register to Clear)"]
            Rxlineint = 3,
            #[doc = "6: Receive FIFO Time-out Interrupt (Read Rx Register to Clear)"]
            Rxtimeoutint = 6,
        }
        impl From<STAT> for u8 {
            #[inline(always)]
            fn from(variant: STAT) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for STAT {
            type Ux = u8;
        }
        impl crate::IsEnum for STAT {}
        #[doc = "Field `STAT` reader - Interrupt Status"]
        pub type STAT_R = crate::FieldReader<STAT>;
        impl STAT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<STAT> {
                match self.bits {
                    0 => Some(STAT::Modemint),
                    1 => Some(STAT::Txemptyint),
                    2 => Some(STAT::Rxfullint),
                    3 => Some(STAT::Rxlineint),
                    6 => Some(STAT::Rxtimeoutint),
                    _ => None,
                }
            }
            #[doc = "Modem Status Interrupt (Read MSR Register to Clear)"]
            #[inline(always)]
            pub fn is_modemint(&self) -> bool {
                *self == STAT::Modemint
            }
            #[doc = "Transmit Buffer Empty Interrupt (Write to Tx Register or Read IIR Register to Clear)"]
            #[inline(always)]
            pub fn is_txemptyint(&self) -> bool {
                *self == STAT::Txemptyint
            }
            #[doc = "Receive Buffer Full Interrupt (Read Rx Register to Clear)"]
            #[inline(always)]
            pub fn is_rxfullint(&self) -> bool {
                *self == STAT::Rxfullint
            }
            #[doc = "Receive Line Status Interrupt (Read LSR Register to Clear)"]
            #[inline(always)]
            pub fn is_rxlineint(&self) -> bool {
                *self == STAT::Rxlineint
            }
            #[doc = "Receive FIFO Time-out Interrupt (Read Rx Register to Clear)"]
            #[inline(always)]
            pub fn is_rxtimeoutint(&self) -> bool {
                *self == STAT::Rxtimeoutint
            }
        }
        #[doc = "FIFO Enabled\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FEND {
            #[doc = "0: FIFO Not Enabled, 16450 Mode"]
            Dis = 0,
            #[doc = "3: FIFO Enabled, 16550 Mode"]
            En = 3,
        }
        impl From<FEND> for u8 {
            #[inline(always)]
            fn from(variant: FEND) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for FEND {
            type Ux = u8;
        }
        impl crate::IsEnum for FEND {}
        #[doc = "Field `FEND` reader - FIFO Enabled"]
        pub type FEND_R = crate::FieldReader<FEND>;
        impl FEND_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<FEND> {
                match self.bits {
                    0 => Some(FEND::Dis),
                    3 => Some(FEND::En),
                    _ => None,
                }
            }
            #[doc = "FIFO Not Enabled, 16450 Mode"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == FEND::Dis
            }
            #[doc = "FIFO Enabled, 16550 Mode"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == FEND::En
            }
        }
        impl R {
            #[doc = "Bit 0 - Interrupt Flag"]
            #[inline(always)]
            pub fn nirq(&self) -> NIRQ_R {
                NIRQ_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:3 - Interrupt Status"]
            #[inline(always)]
            pub fn stat(&self) -> STAT_R {
                STAT_R::new(((self.bits >> 1) & 7) as u8)
            }
            #[doc = "Bits 6:7 - FIFO Enabled"]
            #[inline(always)]
            pub fn fend(&self) -> FEND_R {
                FEND_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IIR")
                    .field("nirq", &self.nirq())
                    .field("stat", &self.stat())
                    .field("fend", &self.fend())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Interrupt ID\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:IIR)"]
        pub struct IIRrs;
        impl crate::RegisterSpec for IIRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iir::R`](R) reader structure"]
        impl crate::Readable for IIRrs {}
        #[doc = "`write(|w| ..)` method takes [`iir::W`](W) writer structure"]
        impl crate::Writable for IIRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets IIR to value 0x01"]
        impl crate::Resettable for IIRrs {
            const RESET_VALUE: u32 = 0x01;
        }
    }
    #[doc = "LCR (rw) register accessor: Line Control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:LCR)\n\nFor information about available fields see [`mod@lcr`]
module"]
    pub type LCR = crate::Reg<lcr::LCRrs>;
    #[doc = "Line Control"]
    pub mod lcr {
        #[doc = "Register `LCR` reader"]
        pub type R = crate::R<LCRrs>;
        #[doc = "Register `LCR` writer"]
        pub type W = crate::W<LCRrs>;
        #[doc = "Word Length Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum WLS {
            #[doc = "0: 5 Bits"]
            Bits5 = 0,
            #[doc = "1: 6 Bits"]
            Bits6 = 1,
            #[doc = "2: 7 Bits"]
            Bits7 = 2,
            #[doc = "3: 8 Bits"]
            Bits8 = 3,
        }
        impl From<WLS> for u8 {
            #[inline(always)]
            fn from(variant: WLS) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for WLS {
            type Ux = u8;
        }
        impl crate::IsEnum for WLS {}
        #[doc = "Field `WLS` reader - Word Length Select"]
        pub type WLS_R = crate::FieldReader<WLS>;
        impl WLS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> WLS {
                match self.bits {
                    0 => WLS::Bits5,
                    1 => WLS::Bits6,
                    2 => WLS::Bits7,
                    3 => WLS::Bits8,
                    _ => unreachable!(),
                }
            }
            #[doc = "5 Bits"]
            #[inline(always)]
            pub fn is_bits5(&self) -> bool {
                *self == WLS::Bits5
            }
            #[doc = "6 Bits"]
            #[inline(always)]
            pub fn is_bits6(&self) -> bool {
                *self == WLS::Bits6
            }
            #[doc = "7 Bits"]
            #[inline(always)]
            pub fn is_bits7(&self) -> bool {
                *self == WLS::Bits7
            }
            #[doc = "8 Bits"]
            #[inline(always)]
            pub fn is_bits8(&self) -> bool {
                *self == WLS::Bits8
            }
        }
        #[doc = "Field `WLS` writer - Word Length Select"]
        pub type WLS_W<'a, REG> = crate::FieldWriter<'a, REG, 2, WLS, crate::Safe>;
        impl<'a, REG> WLS_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "5 Bits"]
            #[inline(always)]
            pub fn bits5(self) -> &'a mut crate::W<REG> {
                self.variant(WLS::Bits5)
            }
            #[doc = "6 Bits"]
            #[inline(always)]
            pub fn bits6(self) -> &'a mut crate::W<REG> {
                self.variant(WLS::Bits6)
            }
            #[doc = "7 Bits"]
            #[inline(always)]
            pub fn bits7(self) -> &'a mut crate::W<REG> {
                self.variant(WLS::Bits7)
            }
            #[doc = "8 Bits"]
            #[inline(always)]
            pub fn bits8(self) -> &'a mut crate::W<REG> {
                self.variant(WLS::Bits8)
            }
        }
        #[doc = "Stop Bit\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum STOPPED {
            #[doc = "0: Send 1 Stop Bit Regardless of the Word Length Select Bit"]
            Ontbit = 0,
            #[doc = "1: Send a Number of Stop Bits Based on the Word Length as Follows: WLS = 00, 1.5 Stop Bits Transmitted (5-bit Word Length) WLS = 01 or 10 or 11, 2 Stop Bits Transmitted (6 or 7 or 8-bit Word Length)"]
            Multibit = 1,
        }
        impl From<STOPPED> for bool {
            #[inline(always)]
            fn from(variant: STOPPED) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `STOPPED` reader - Stop Bit"]
        pub type STOPPED_R = crate::BitReader<STOPPED>;
        impl STOPPED_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> STOPPED {
                match self.bits {
                    false => STOPPED::Ontbit,
                    true => STOPPED::Multibit,
                }
            }
            #[doc = "Send 1 Stop Bit Regardless of the Word Length Select Bit"]
            #[inline(always)]
            pub fn is_ontbit(&self) -> bool {
                *self == STOPPED::Ontbit
            }
            #[doc = "Send a Number of Stop Bits Based on the Word Length as Follows: WLS = 00, 1.5 Stop Bits Transmitted (5-bit Word Length) WLS = 01 or 10 or 11, 2 Stop Bits Transmitted (6 or 7 or 8-bit Word Length)"]
            #[inline(always)]
            pub fn is_multibit(&self) -> bool {
                *self == STOPPED::Multibit
            }
        }
        #[doc = "Field `STOPPED` writer - Stop Bit"]
        pub type STOPPED_W<'a, REG> = crate::BitWriter<'a, REG, STOPPED>;
        impl<'a, REG> STOPPED_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Send 1 Stop Bit Regardless of the Word Length Select Bit"]
            #[inline(always)]
            pub fn ontbit(self) -> &'a mut crate::W<REG> {
                self.variant(STOPPED::Ontbit)
            }
            #[doc = "Send a Number of Stop Bits Based on the Word Length as Follows: WLS = 00, 1.5 Stop Bits Transmitted (5-bit Word Length) WLS = 01 or 10 or 11, 2 Stop Bits Transmitted (6 or 7 or 8-bit Word Length)"]
            #[inline(always)]
            pub fn multibit(self) -> &'a mut crate::W<REG> {
                self.variant(STOPPED::Multibit)
            }
        }
        #[doc = "Parity Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PEN {
            #[doc = "0: Parity Will Not Be Transmitted or Checked."]
            Dis = 0,
            #[doc = "1: Parity Will Be Transmitted and Checked."]
            En = 1,
        }
        impl From<PEN> for bool {
            #[inline(always)]
            fn from(variant: PEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PEN` reader - Parity Enable"]
        pub type PEN_R = crate::BitReader<PEN>;
        impl PEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PEN {
                match self.bits {
                    false => PEN::Dis,
                    true => PEN::En,
                }
            }
            #[doc = "Parity Will Not Be Transmitted or Checked."]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == PEN::Dis
            }
            #[doc = "Parity Will Be Transmitted and Checked."]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == PEN::En
            }
        }
        #[doc = "Field `PEN` writer - Parity Enable"]
        pub type PEN_W<'a, REG> = crate::BitWriter<'a, REG, PEN>;
        impl<'a, REG> PEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Parity Will Not Be Transmitted or Checked."]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(PEN::Dis)
            }
            #[doc = "Parity Will Be Transmitted and Checked."]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(PEN::En)
            }
        }
        #[doc = "Parity Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EPS {
            #[doc = "0: Odd Parity Will Be Transmitted and Checked."]
            Odd = 0,
            #[doc = "1: Even Parity Will Be Transmitted and Checked."]
            Even = 1,
        }
        impl From<EPS> for bool {
            #[inline(always)]
            fn from(variant: EPS) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EPS` reader - Parity Select"]
        pub type EPS_R = crate::BitReader<EPS>;
        impl EPS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> EPS {
                match self.bits {
                    false => EPS::Odd,
                    true => EPS::Even,
                }
            }
            #[doc = "Odd Parity Will Be Transmitted and Checked."]
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == EPS::Odd
            }
            #[doc = "Even Parity Will Be Transmitted and Checked."]
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == EPS::Even
            }
        }
        #[doc = "Field `EPS` writer - Parity Select"]
        pub type EPS_W<'a, REG> = crate::BitWriter<'a, REG, EPS>;
        impl<'a, REG> EPS_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Odd Parity Will Be Transmitted and Checked."]
            #[inline(always)]
            pub fn odd(self) -> &'a mut crate::W<REG> {
                self.variant(EPS::Odd)
            }
            #[doc = "Even Parity Will Be Transmitted and Checked."]
            #[inline(always)]
            pub fn even(self) -> &'a mut crate::W<REG> {
                self.variant(EPS::Even)
            }
        }
        #[doc = "Stick Parity\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SP {
            #[doc = "0: Parity Will Not Be Forced Based on Parity Select and Parity Enable Bits."]
            Stick = 0,
            #[doc = "1: Parity Forced Based on Parity Select and Parity Enable Bits."]
            Epspen = 1,
        }
        impl From<SP> for bool {
            #[inline(always)]
            fn from(variant: SP) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SP` reader - Stick Parity"]
        pub type SP_R = crate::BitReader<SP>;
        impl SP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SP {
                match self.bits {
                    false => SP::Stick,
                    true => SP::Epspen,
                }
            }
            #[doc = "Parity Will Not Be Forced Based on Parity Select and Parity Enable Bits."]
            #[inline(always)]
            pub fn is_stick(&self) -> bool {
                *self == SP::Stick
            }
            #[doc = "Parity Forced Based on Parity Select and Parity Enable Bits."]
            #[inline(always)]
            pub fn is_epspen(&self) -> bool {
                *self == SP::Epspen
            }
        }
        #[doc = "Field `SP` writer - Stick Parity"]
        pub type SP_W<'a, REG> = crate::BitWriter<'a, REG, SP>;
        impl<'a, REG> SP_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Parity Will Not Be Forced Based on Parity Select and Parity Enable Bits."]
            #[inline(always)]
            pub fn stick(self) -> &'a mut crate::W<REG> {
                self.variant(SP::Stick)
            }
            #[doc = "Parity Forced Based on Parity Select and Parity Enable Bits."]
            #[inline(always)]
            pub fn epspen(self) -> &'a mut crate::W<REG> {
                self.variant(SP::Epspen)
            }
        }
        #[doc = "Field `BRK` reader - Set Break"]
        pub type BRK_R = crate::BitReader;
        #[doc = "Field `BRK` writer - Set Break"]
        pub type BRK_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - Word Length Select"]
            #[inline(always)]
            pub fn wls(&self) -> WLS_R {
                WLS_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Stop Bit"]
            #[inline(always)]
            pub fn stopped(&self) -> STOPPED_R {
                STOPPED_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Parity Enable"]
            #[inline(always)]
            pub fn pen(&self) -> PEN_R {
                PEN_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Parity Select"]
            #[inline(always)]
            pub fn eps(&self) -> EPS_R {
                EPS_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Stick Parity"]
            #[inline(always)]
            pub fn sp(&self) -> SP_R {
                SP_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Set Break"]
            #[inline(always)]
            pub fn brk(&self) -> BRK_R {
                BRK_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LCR")
                    .field("wls", &self.wls())
                    .field("stopped", &self.stopped())
                    .field("pen", &self.pen())
                    .field("eps", &self.eps())
                    .field("sp", &self.sp())
                    .field("brk", &self.brk())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Word Length Select"]
            #[inline(always)]
            pub fn wls(&mut self) -> WLS_W<LCRrs> {
                WLS_W::new(self, 0)
            }
            #[doc = "Bit 2 - Stop Bit"]
            #[inline(always)]
            pub fn stopped(&mut self) -> STOPPED_W<LCRrs> {
                STOPPED_W::new(self, 2)
            }
            #[doc = "Bit 3 - Parity Enable"]
            #[inline(always)]
            pub fn pen(&mut self) -> PEN_W<LCRrs> {
                PEN_W::new(self, 3)
            }
            #[doc = "Bit 4 - Parity Select"]
            #[inline(always)]
            pub fn eps(&mut self) -> EPS_W<LCRrs> {
                EPS_W::new(self, 4)
            }
            #[doc = "Bit 5 - Stick Parity"]
            #[inline(always)]
            pub fn sp(&mut self) -> SP_W<LCRrs> {
                SP_W::new(self, 5)
            }
            #[doc = "Bit 6 - Set Break"]
            #[inline(always)]
            pub fn brk(&mut self) -> BRK_W<LCRrs> {
                BRK_W::new(self, 6)
            }
        }
        #[doc = "Line Control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:LCR)"]
        pub struct LCRrs;
        impl crate::RegisterSpec for LCRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lcr::R`](R) reader structure"]
        impl crate::Readable for LCRrs {}
        #[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"]
        impl crate::Writable for LCRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LCR to value 0"]
        impl crate::Resettable for LCRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MCR (rw) register accessor: Modem Control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:MCR)\n\nFor information about available fields see [`mod@mcr`]
module"]
    pub type MCR = crate::Reg<mcr::MCRrs>;
    #[doc = "Modem Control"]
    pub mod mcr {
        #[doc = "Register `MCR` reader"]
        pub type R = crate::R<MCRrs>;
        #[doc = "Register `MCR` writer"]
        pub type W = crate::W<MCRrs>;
        #[doc = "Data Terminal Ready\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTR {
            #[doc = "0: Force NDTR to a Logic 1"]
            Force1 = 0,
            #[doc = "1: Force NDTR to a Logic 0"]
            Force0 = 1,
        }
        impl From<DTR> for bool {
            #[inline(always)]
            fn from(variant: DTR) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DTR` reader - Data Terminal Ready"]
        pub type DTR_R = crate::BitReader<DTR>;
        impl DTR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DTR {
                match self.bits {
                    false => DTR::Force1,
                    true => DTR::Force0,
                }
            }
            #[doc = "Force NDTR to a Logic 1"]
            #[inline(always)]
            pub fn is_force1(&self) -> bool {
                *self == DTR::Force1
            }
            #[doc = "Force NDTR to a Logic 0"]
            #[inline(always)]
            pub fn is_force0(&self) -> bool {
                *self == DTR::Force0
            }
        }
        #[doc = "Field `DTR` writer - Data Terminal Ready"]
        pub type DTR_W<'a, REG> = crate::BitWriter<'a, REG, DTR>;
        impl<'a, REG> DTR_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Force NDTR to a Logic 1"]
            #[inline(always)]
            pub fn force1(self) -> &'a mut crate::W<REG> {
                self.variant(DTR::Force1)
            }
            #[doc = "Force NDTR to a Logic 0"]
            #[inline(always)]
            pub fn force0(self) -> &'a mut crate::W<REG> {
                self.variant(DTR::Force0)
            }
        }
        #[doc = "Request to Send\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RTS {
            #[doc = "0: Force NRTS to a Logic 1"]
            Force1 = 0,
            #[doc = "1: Force NRTS to a Logic 0"]
            Force0 = 1,
        }
        impl From<RTS> for bool {
            #[inline(always)]
            fn from(variant: RTS) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RTS` reader - Request to Send"]
        pub type RTS_R = crate::BitReader<RTS>;
        impl RTS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RTS {
                match self.bits {
                    false => RTS::Force1,
                    true => RTS::Force0,
                }
            }
            #[doc = "Force NRTS to a Logic 1"]
            #[inline(always)]
            pub fn is_force1(&self) -> bool {
                *self == RTS::Force1
            }
            #[doc = "Force NRTS to a Logic 0"]
            #[inline(always)]
            pub fn is_force0(&self) -> bool {
                *self == RTS::Force0
            }
        }
        #[doc = "Field `RTS` writer - Request to Send"]
        pub type RTS_W<'a, REG> = crate::BitWriter<'a, REG, RTS>;
        impl<'a, REG> RTS_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Force NRTS to a Logic 1"]
            #[inline(always)]
            pub fn force1(self) -> &'a mut crate::W<REG> {
                self.variant(RTS::Force1)
            }
            #[doc = "Force NRTS to a Logic 0"]
            #[inline(always)]
            pub fn force0(self) -> &'a mut crate::W<REG> {
                self.variant(RTS::Force0)
            }
        }
        #[doc = "Output 1\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OUT1 {
            #[doc = "0: Force NOUT1 to a Logic 1"]
            Force1 = 0,
            #[doc = "1: Force NOUT1 to a Logic 0"]
            Force0 = 1,
        }
        impl From<OUT1> for bool {
            #[inline(always)]
            fn from(variant: OUT1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OUT1` reader - Output 1"]
        pub type OUT1_R = crate::BitReader<OUT1>;
        impl OUT1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OUT1 {
                match self.bits {
                    false => OUT1::Force1,
                    true => OUT1::Force0,
                }
            }
            #[doc = "Force NOUT1 to a Logic 1"]
            #[inline(always)]
            pub fn is_force1(&self) -> bool {
                *self == OUT1::Force1
            }
            #[doc = "Force NOUT1 to a Logic 0"]
            #[inline(always)]
            pub fn is_force0(&self) -> bool {
                *self == OUT1::Force0
            }
        }
        #[doc = "Field `OUT1` writer - Output 1"]
        pub type OUT1_W<'a, REG> = crate::BitWriter<'a, REG, OUT1>;
        impl<'a, REG> OUT1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Force NOUT1 to a Logic 1"]
            #[inline(always)]
            pub fn force1(self) -> &'a mut crate::W<REG> {
                self.variant(OUT1::Force1)
            }
            #[doc = "Force NOUT1 to a Logic 0"]
            #[inline(always)]
            pub fn force0(self) -> &'a mut crate::W<REG> {
                self.variant(OUT1::Force0)
            }
        }
        #[doc = "Output 2\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OUT2 {
            #[doc = "0: Force NOUT2 to a Logic 1"]
            Force1 = 0,
            #[doc = "1: Force NOUT2 to a Logic 0"]
            Force0 = 1,
        }
        impl From<OUT2> for bool {
            #[inline(always)]
            fn from(variant: OUT2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OUT2` reader - Output 2"]
        pub type OUT2_R = crate::BitReader<OUT2>;
        impl OUT2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OUT2 {
                match self.bits {
                    false => OUT2::Force1,
                    true => OUT2::Force0,
                }
            }
            #[doc = "Force NOUT2 to a Logic 1"]
            #[inline(always)]
            pub fn is_force1(&self) -> bool {
                *self == OUT2::Force1
            }
            #[doc = "Force NOUT2 to a Logic 0"]
            #[inline(always)]
            pub fn is_force0(&self) -> bool {
                *self == OUT2::Force0
            }
        }
        #[doc = "Field `OUT2` writer - Output 2"]
        pub type OUT2_W<'a, REG> = crate::BitWriter<'a, REG, OUT2>;
        impl<'a, REG> OUT2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Force NOUT2 to a Logic 1"]
            #[inline(always)]
            pub fn force1(self) -> &'a mut crate::W<REG> {
                self.variant(OUT2::Force1)
            }
            #[doc = "Force NOUT2 to a Logic 0"]
            #[inline(always)]
            pub fn force0(self) -> &'a mut crate::W<REG> {
                self.variant(OUT2::Force0)
            }
        }
        #[doc = "Loop Back Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LOOPBACK {
            #[doc = "0: Normal Operation - Loopback Disabled"]
            Dis = 0,
            #[doc = "1: Loopback Enabled"]
            En = 1,
        }
        impl From<LOOPBACK> for bool {
            #[inline(always)]
            fn from(variant: LOOPBACK) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `LOOPBACK` reader - Loop Back Mode"]
        pub type LOOPBACK_R = crate::BitReader<LOOPBACK>;
        impl LOOPBACK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> LOOPBACK {
                match self.bits {
                    false => LOOPBACK::Dis,
                    true => LOOPBACK::En,
                }
            }
            #[doc = "Normal Operation - Loopback Disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == LOOPBACK::Dis
            }
            #[doc = "Loopback Enabled"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == LOOPBACK::En
            }
        }
        #[doc = "Field `LOOPBACK` writer - Loop Back Mode"]
        pub type LOOPBACK_W<'a, REG> = crate::BitWriter<'a, REG, LOOPBACK>;
        impl<'a, REG> LOOPBACK_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Normal Operation - Loopback Disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(LOOPBACK::Dis)
            }
            #[doc = "Loopback Enabled"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(LOOPBACK::En)
            }
        }
        impl R {
            #[doc = "Bit 0 - Data Terminal Ready"]
            #[inline(always)]
            pub fn dtr(&self) -> DTR_R {
                DTR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Request to Send"]
            #[inline(always)]
            pub fn rts(&self) -> RTS_R {
                RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Output 1"]
            #[inline(always)]
            pub fn out1(&self) -> OUT1_R {
                OUT1_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Output 2"]
            #[inline(always)]
            pub fn out2(&self) -> OUT2_R {
                OUT2_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Loop Back Mode"]
            #[inline(always)]
            pub fn loopback(&self) -> LOOPBACK_R {
                LOOPBACK_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MCR")
                    .field("dtr", &self.dtr())
                    .field("rts", &self.rts())
                    .field("out1", &self.out1())
                    .field("out2", &self.out2())
                    .field("loopback", &self.loopback())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Data Terminal Ready"]
            #[inline(always)]
            pub fn dtr(&mut self) -> DTR_W<MCRrs> {
                DTR_W::new(self, 0)
            }
            #[doc = "Bit 1 - Request to Send"]
            #[inline(always)]
            pub fn rts(&mut self) -> RTS_W<MCRrs> {
                RTS_W::new(self, 1)
            }
            #[doc = "Bit 2 - Output 1"]
            #[inline(always)]
            pub fn out1(&mut self) -> OUT1_W<MCRrs> {
                OUT1_W::new(self, 2)
            }
            #[doc = "Bit 3 - Output 2"]
            #[inline(always)]
            pub fn out2(&mut self) -> OUT2_W<MCRrs> {
                OUT2_W::new(self, 3)
            }
            #[doc = "Bit 4 - Loop Back Mode"]
            #[inline(always)]
            pub fn loopback(&mut self) -> LOOPBACK_W<MCRrs> {
                LOOPBACK_W::new(self, 4)
            }
        }
        #[doc = "Modem Control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:MCR)"]
        pub struct MCRrs;
        impl crate::RegisterSpec for MCRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mcr::R`](R) reader structure"]
        impl crate::Readable for MCRrs {}
        #[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"]
        impl crate::Writable for MCRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MCR to value 0"]
        impl crate::Resettable for MCRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "LSR (rw) register accessor: Line Status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:LSR)\n\nFor information about available fields see [`mod@lsr`]
module"]
    pub type LSR = crate::Reg<lsr::LSRrs>;
    #[doc = "Line Status"]
    pub mod lsr {
        #[doc = "Register `LSR` reader"]
        pub type R = crate::R<LSRrs>;
        #[doc = "Register `LSR` writer"]
        pub type W = crate::W<LSRrs>;
        #[doc = "Data Ready\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DR {
            #[doc = "0: Rx Register Does Not Contain New Receive Data."]
            Notready = 0,
            #[doc = "1: Rx Register Contains Receive Data That Should Be Read."]
            Ready = 1,
        }
        impl From<DR> for bool {
            #[inline(always)]
            fn from(variant: DR) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DR` reader - Data Ready"]
        pub type DR_R = crate::BitReader<DR>;
        impl DR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DR {
                match self.bits {
                    false => DR::Notready,
                    true => DR::Ready,
                }
            }
            #[doc = "Rx Register Does Not Contain New Receive Data."]
            #[inline(always)]
            pub fn is_notready(&self) -> bool {
                *self == DR::Notready
            }
            #[doc = "Rx Register Contains Receive Data That Should Be Read."]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == DR::Ready
            }
        }
        #[doc = "Overrun Error\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OE {
            #[doc = "0: Receive Data Has Not Been Overwritten."]
            Okay = 0,
            #[doc = "1: Receive Data Was Overwritten by New Data Before Rx Register Was Read."]
            Overwritten = 1,
        }
        impl From<OE> for bool {
            #[inline(always)]
            fn from(variant: OE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OE` reader - Overrun Error"]
        pub type OE_R = crate::BitReader<OE>;
        impl OE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OE {
                match self.bits {
                    false => OE::Okay,
                    true => OE::Overwritten,
                }
            }
            #[doc = "Receive Data Has Not Been Overwritten."]
            #[inline(always)]
            pub fn is_okay(&self) -> bool {
                *self == OE::Okay
            }
            #[doc = "Receive Data Was Overwritten by New Data Before Rx Register Was Read."]
            #[inline(always)]
            pub fn is_overwritten(&self) -> bool {
                *self == OE::Overwritten
            }
        }
        #[doc = "Parity Error\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PE {
            #[doc = "0: No Parity Error Was Detected."]
            Noerr = 0,
            #[doc = "1: A Parity Error Occurred on a Received Word."]
            Errors = 1,
        }
        impl From<PE> for bool {
            #[inline(always)]
            fn from(variant: PE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PE` reader - Parity Error"]
        pub type PE_R = crate::BitReader<PE>;
        impl PE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PE {
                match self.bits {
                    false => PE::Noerr,
                    true => PE::Errors,
                }
            }
            #[doc = "No Parity Error Was Detected."]
            #[inline(always)]
            pub fn is_noerr(&self) -> bool {
                *self == PE::Noerr
            }
            #[doc = "A Parity Error Occurred on a Received Word."]
            #[inline(always)]
            pub fn is_errors(&self) -> bool {
                *self == PE::Errors
            }
        }
        #[doc = "Framing Error\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FE {
            #[doc = "0: No Invalid Stop Bit Was Detected."]
            Okay = 0,
            #[doc = "1: An Invalid Stop Bit Was Detected on a Received Word."]
            Invalidstop = 1,
        }
        impl From<FE> for bool {
            #[inline(always)]
            fn from(variant: FE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FE` reader - Framing Error"]
        pub type FE_R = crate::BitReader<FE>;
        impl FE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FE {
                match self.bits {
                    false => FE::Okay,
                    true => FE::Invalidstop,
                }
            }
            #[doc = "No Invalid Stop Bit Was Detected."]
            #[inline(always)]
            pub fn is_okay(&self) -> bool {
                *self == FE::Okay
            }
            #[doc = "An Invalid Stop Bit Was Detected on a Received Word."]
            #[inline(always)]
            pub fn is_invalidstop(&self) -> bool {
                *self == FE::Invalidstop
            }
        }
        #[doc = "Field `BI` reader - Break Indicator"]
        pub type BI_R = crate::BitReader;
        #[doc = "Transmit Register Empty\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum THRE {
            #[doc = "0: Tx Register Has Been Written to and Contains Data to Be Transmitted. Care Should Be Taken Not to Overwrite Its Value."]
            Notempty = 0,
            #[doc = "1: Tx Register is Empty and It is Safe to Write New Data to Tx Register the Previous Data May Not Have Been Transmitted Yet and Can Still Be Present in the Shift Register."]
            Empty = 1,
        }
        impl From<THRE> for bool {
            #[inline(always)]
            fn from(variant: THRE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `THRE` reader - Transmit Register Empty"]
        pub type THRE_R = crate::BitReader<THRE>;
        impl THRE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> THRE {
                match self.bits {
                    false => THRE::Notempty,
                    true => THRE::Empty,
                }
            }
            #[doc = "Tx Register Has Been Written to and Contains Data to Be Transmitted. Care Should Be Taken Not to Overwrite Its Value."]
            #[inline(always)]
            pub fn is_notempty(&self) -> bool {
                *self == THRE::Notempty
            }
            #[doc = "Tx Register is Empty and It is Safe to Write New Data to Tx Register the Previous Data May Not Have Been Transmitted Yet and Can Still Be Present in the Shift Register."]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == THRE::Empty
            }
        }
        #[doc = "Transmit and Shift Register Empty Status\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TEMT {
            #[doc = "0: Tx Register Has Been Written to and Contains Data to Be Transmitted. Care Should Be Taken Not to Overwrite Its Value."]
            Notempty = 0,
            #[doc = "1: Tx Register and the Transmit Shift Register are Empty and It is Safe to Write New Data to the Tx Register. Data Has Been Transmitted."]
            Empty = 1,
        }
        impl From<TEMT> for bool {
            #[inline(always)]
            fn from(variant: TEMT) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TEMT` reader - Transmit and Shift Register Empty Status"]
        pub type TEMT_R = crate::BitReader<TEMT>;
        impl TEMT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TEMT {
                match self.bits {
                    false => TEMT::Notempty,
                    true => TEMT::Empty,
                }
            }
            #[doc = "Tx Register Has Been Written to and Contains Data to Be Transmitted. Care Should Be Taken Not to Overwrite Its Value."]
            #[inline(always)]
            pub fn is_notempty(&self) -> bool {
                *self == TEMT::Notempty
            }
            #[doc = "Tx Register and the Transmit Shift Register are Empty and It is Safe to Write New Data to the Tx Register. Data Has Been Transmitted."]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TEMT::Empty
            }
        }
        #[doc = "Field `FIFOERR` reader - FIFO Error"]
        pub type FIFOERR_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Data Ready"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Overrun Error"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Parity Error"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Framing Error"]
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Break Indicator"]
            #[inline(always)]
            pub fn bi(&self) -> BI_R {
                BI_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Transmit Register Empty"]
            #[inline(always)]
            pub fn thre(&self) -> THRE_R {
                THRE_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Transmit and Shift Register Empty Status"]
            #[inline(always)]
            pub fn temt(&self) -> TEMT_R {
                TEMT_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - FIFO Error"]
            #[inline(always)]
            pub fn fifoerr(&self) -> FIFOERR_R {
                FIFOERR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LSR")
                    .field("dr", &self.dr())
                    .field("oe", &self.oe())
                    .field("pe", &self.pe())
                    .field("fe", &self.fe())
                    .field("bi", &self.bi())
                    .field("thre", &self.thre())
                    .field("temt", &self.temt())
                    .field("fifoerr", &self.fifoerr())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Line Status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:LSR)"]
        pub struct LSRrs;
        impl crate::RegisterSpec for LSRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lsr::R`](R) reader structure"]
        impl crate::Readable for LSRrs {}
        #[doc = "`write(|w| ..)` method takes [`lsr::W`](W) writer structure"]
        impl crate::Writable for LSRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LSR to value 0x60"]
        impl crate::Resettable for LSRrs {
            const RESET_VALUE: u32 = 0x60;
        }
    }
    #[doc = "MSR (rw) register accessor: Modem Status\n\nYou can [`read`](crate::Reg::read) this register and get [`msr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`msr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:MSR)\n\nFor information about available fields see [`mod@msr`]
module"]
    pub type MSR = crate::Reg<msr::MSRrs>;
    #[doc = "Modem Status"]
    pub mod msr {
        #[doc = "Register `MSR` reader"]
        pub type R = crate::R<MSRrs>;
        #[doc = "Register `MSR` writer"]
        pub type W = crate::W<MSRrs>;
        #[doc = "Delta CTS\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DCTS {
            #[doc = "0: Clear to Send Bit Has Not Changed State Since MSR Register Was Last Read"]
            Nochange = 0,
            #[doc = "1: Clear to Send Bit Changed State Since MSR Register Last Read"]
            Changed = 1,
        }
        impl From<DCTS> for bool {
            #[inline(always)]
            fn from(variant: DCTS) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DCTS` reader - Delta CTS"]
        pub type DCTS_R = crate::BitReader<DCTS>;
        impl DCTS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DCTS {
                match self.bits {
                    false => DCTS::Nochange,
                    true => DCTS::Changed,
                }
            }
            #[doc = "Clear to Send Bit Has Not Changed State Since MSR Register Was Last Read"]
            #[inline(always)]
            pub fn is_nochange(&self) -> bool {
                *self == DCTS::Nochange
            }
            #[doc = "Clear to Send Bit Changed State Since MSR Register Last Read"]
            #[inline(always)]
            pub fn is_changed(&self) -> bool {
                *self == DCTS::Changed
            }
        }
        #[doc = "Delta DSR\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DDSR {
            #[doc = "0: Data Set Ready Bit Has Not Changed State Since MSR Register Was Last Read"]
            Nochange = 0,
            #[doc = "1: Data Set Ready Bit Changed State Since MSR Register Last Read"]
            Changed = 1,
        }
        impl From<DDSR> for bool {
            #[inline(always)]
            fn from(variant: DDSR) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DDSR` reader - Delta DSR"]
        pub type DDSR_R = crate::BitReader<DDSR>;
        impl DDSR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DDSR {
                match self.bits {
                    false => DDSR::Nochange,
                    true => DDSR::Changed,
                }
            }
            #[doc = "Data Set Ready Bit Has Not Changed State Since MSR Register Was Last Read"]
            #[inline(always)]
            pub fn is_nochange(&self) -> bool {
                *self == DDSR::Nochange
            }
            #[doc = "Data Set Ready Bit Changed State Since MSR Register Last Read"]
            #[inline(always)]
            pub fn is_changed(&self) -> bool {
                *self == DDSR::Changed
            }
        }
        #[doc = "Trailing Edge RI\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TERI {
            #[doc = "0: Ring Indicator Bit Has Not Changed from 0 to 1 Since MSR Register Last Read"]
            Notchanged = 0,
            #[doc = "1: Ring Indicator Bit Changed from 0 to 1 Since MSR Register Last Read"]
            Changed = 1,
        }
        impl From<TERI> for bool {
            #[inline(always)]
            fn from(variant: TERI) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TERI` reader - Trailing Edge RI"]
        pub type TERI_R = crate::BitReader<TERI>;
        impl TERI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TERI {
                match self.bits {
                    false => TERI::Notchanged,
                    true => TERI::Changed,
                }
            }
            #[doc = "Ring Indicator Bit Has Not Changed from 0 to 1 Since MSR Register Last Read"]
            #[inline(always)]
            pub fn is_notchanged(&self) -> bool {
                *self == TERI::Notchanged
            }
            #[doc = "Ring Indicator Bit Changed from 0 to 1 Since MSR Register Last Read"]
            #[inline(always)]
            pub fn is_changed(&self) -> bool {
                *self == TERI::Changed
            }
        }
        #[doc = "Delta DCD\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DDCD {
            #[doc = "0: Data Carrier Detect Bit Has Not Changed State Since MSR Register Was Last Read"]
            Nochange = 0,
            #[doc = "1: Data Carrier Detect Bit Changed State Since MSR Register Last Read"]
            Changed = 1,
        }
        impl From<DDCD> for bool {
            #[inline(always)]
            fn from(variant: DDCD) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DDCD` reader - Delta DCD"]
        pub type DDCD_R = crate::BitReader<DDCD>;
        impl DDCD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DDCD {
                match self.bits {
                    false => DDCD::Nochange,
                    true => DDCD::Changed,
                }
            }
            #[doc = "Data Carrier Detect Bit Has Not Changed State Since MSR Register Was Last Read"]
            #[inline(always)]
            pub fn is_nochange(&self) -> bool {
                *self == DDCD::Nochange
            }
            #[doc = "Data Carrier Detect Bit Changed State Since MSR Register Last Read"]
            #[inline(always)]
            pub fn is_changed(&self) -> bool {
                *self == DDCD::Changed
            }
        }
        #[doc = "Clear to Send\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTS {
            #[doc = "0: NCTS is Currently Logic High"]
            High = 0,
            #[doc = "1: NCTS is Currently Logic Low"]
            Low = 1,
        }
        impl From<CTS> for bool {
            #[inline(always)]
            fn from(variant: CTS) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CTS` reader - Clear to Send"]
        pub type CTS_R = crate::BitReader<CTS>;
        impl CTS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CTS {
                match self.bits {
                    false => CTS::High,
                    true => CTS::Low,
                }
            }
            #[doc = "NCTS is Currently Logic High"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == CTS::High
            }
            #[doc = "NCTS is Currently Logic Low"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == CTS::Low
            }
        }
        #[doc = "Data Set Ready\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DSR {
            #[doc = "0: NDSR is Currently Logic High"]
            High = 0,
            #[doc = "1: NDSR is Currently Logic Low"]
            Low = 1,
        }
        impl From<DSR> for bool {
            #[inline(always)]
            fn from(variant: DSR) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DSR` reader - Data Set Ready"]
        pub type DSR_R = crate::BitReader<DSR>;
        impl DSR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DSR {
                match self.bits {
                    false => DSR::High,
                    true => DSR::Low,
                }
            }
            #[doc = "NDSR is Currently Logic High"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == DSR::High
            }
            #[doc = "NDSR is Currently Logic Low"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == DSR::Low
            }
        }
        #[doc = "Ring Indicator\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RI {
            #[doc = "0: NRI is Currently Logic High."]
            High = 0,
            #[doc = "1: NRI is Currently Logic Low."]
            Low = 1,
        }
        impl From<RI> for bool {
            #[inline(always)]
            fn from(variant: RI) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RI` reader - Ring Indicator"]
        pub type RI_R = crate::BitReader<RI>;
        impl RI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RI {
                match self.bits {
                    false => RI::High,
                    true => RI::Low,
                }
            }
            #[doc = "NRI is Currently Logic High."]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == RI::High
            }
            #[doc = "NRI is Currently Logic Low."]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == RI::Low
            }
        }
        #[doc = "Data Carrier Detect\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DCD {
            #[doc = "0: NDCD is Currently Logic High."]
            High = 0,
            #[doc = "1: NDCD is Currently Logic Low."]
            Low = 1,
        }
        impl From<DCD> for bool {
            #[inline(always)]
            fn from(variant: DCD) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DCD` reader - Data Carrier Detect"]
        pub type DCD_R = crate::BitReader<DCD>;
        impl DCD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DCD {
                match self.bits {
                    false => DCD::High,
                    true => DCD::Low,
                }
            }
            #[doc = "NDCD is Currently Logic High."]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == DCD::High
            }
            #[doc = "NDCD is Currently Logic Low."]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == DCD::Low
            }
        }
        impl R {
            #[doc = "Bit 0 - Delta CTS"]
            #[inline(always)]
            pub fn dcts(&self) -> DCTS_R {
                DCTS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Delta DSR"]
            #[inline(always)]
            pub fn ddsr(&self) -> DDSR_R {
                DDSR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Trailing Edge RI"]
            #[inline(always)]
            pub fn teri(&self) -> TERI_R {
                TERI_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Delta DCD"]
            #[inline(always)]
            pub fn ddcd(&self) -> DDCD_R {
                DDCD_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Clear to Send"]
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Data Set Ready"]
            #[inline(always)]
            pub fn dsr(&self) -> DSR_R {
                DSR_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Ring Indicator"]
            #[inline(always)]
            pub fn ri(&self) -> RI_R {
                RI_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Data Carrier Detect"]
            #[inline(always)]
            pub fn dcd(&self) -> DCD_R {
                DCD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MSR")
                    .field("dcts", &self.dcts())
                    .field("ddsr", &self.ddsr())
                    .field("teri", &self.teri())
                    .field("ddcd", &self.ddcd())
                    .field("cts", &self.cts())
                    .field("dsr", &self.dsr())
                    .field("ri", &self.ri())
                    .field("dcd", &self.dcd())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Modem Status\n\nYou can [`read`](crate::Reg::read) this register and get [`msr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`msr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:MSR)"]
        pub struct MSRrs;
        impl crate::RegisterSpec for MSRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`msr::R`](R) reader structure"]
        impl crate::Readable for MSRrs {}
        #[doc = "`write(|w| ..)` method takes [`msr::W`](W) writer structure"]
        impl crate::Writable for MSRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MSR to value 0"]
        impl crate::Resettable for MSRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SCR (rw) register accessor: Scratch Buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`scr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:SCR)\n\nFor information about available fields see [`mod@scr`]
module"]
    pub type SCR = crate::Reg<scr::SCRrs>;
    #[doc = "Scratch Buffer"]
    pub mod scr {
        #[doc = "Register `SCR` reader"]
        pub type R = crate::R<SCRrs>;
        #[doc = "Register `SCR` writer"]
        pub type W = crate::W<SCRrs>;
        #[doc = "Field `SCR` reader - Scratch"]
        pub type SCR_R = crate::FieldReader;
        #[doc = "Field `SCR` writer - Scratch"]
        pub type SCR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Scratch"]
            #[inline(always)]
            pub fn scr(&self) -> SCR_R {
                SCR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SCR").field("scr", &self.scr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Scratch"]
            #[inline(always)]
            pub fn scr(&mut self) -> SCR_W<SCRrs> {
                SCR_W::new(self, 0)
            }
        }
        #[doc = "Scratch Buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`scr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:SCR)"]
        pub struct SCRrs;
        impl crate::RegisterSpec for SCRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`scr::R`](R) reader structure"]
        impl crate::Readable for SCRrs {}
        #[doc = "`write(|w| ..)` method takes [`scr::W`](W) writer structure"]
        impl crate::Writable for SCRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SCR to value 0"]
        impl crate::Resettable for SCRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FCR (rw) register accessor: FIFO Control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:FCR)\n\nFor information about available fields see [`mod@fcr`]
module"]
    pub type FCR = crate::Reg<fcr::FCRrs>;
    #[doc = "FIFO Control"]
    pub mod fcr {
        #[doc = "Register `FCR` reader"]
        pub type R = crate::R<FCRrs>;
        #[doc = "Register `FCR` writer"]
        pub type W = crate::W<FCRrs>;
        #[doc = "Field `FIFOEN` reader - FIFO Enable as to Work in 16550 Mode"]
        pub type FIFOEN_R = crate::BitReader;
        #[doc = "Field `FIFOEN` writer - FIFO Enable as to Work in 16550 Mode"]
        pub type FIFOEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RFCLR` writer - Clear RX FIFO"]
        pub type RFCLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TFCLR` writer - Clear TX FIFO"]
        pub type TFCLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "FIFO DMA Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FDMAMD {
            #[doc = "0: In DMA Mode 0, RX DMA Request Will Be Asserted Whenever There's Data in RBR or RX FIFO and De-assert Whenever RBR or RX FIFO is Empty; TX DMA Request Will Be Asserted Whenever THR or TX FIFO is Empty and De-assert Whenever Data Written To."]
            Mode0 = 0,
            #[doc = "1: In DMA Mode 1, RX DMA Request Will Be Asserted Whenever RX FIFO Trig Level or Time Out Reached and De-assert Thereafter When RX FIFO is Empty; TX DMA Request Will Be Asserted Whenever TX FIFO is Empty and De-assert Thereafter When TX FIFO is Completely Filled up Full."]
            Mode1 = 1,
        }
        impl From<FDMAMD> for bool {
            #[inline(always)]
            fn from(variant: FDMAMD) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FDMAMD` reader - FIFO DMA Mode"]
        pub type FDMAMD_R = crate::BitReader<FDMAMD>;
        impl FDMAMD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FDMAMD {
                match self.bits {
                    false => FDMAMD::Mode0,
                    true => FDMAMD::Mode1,
                }
            }
            #[doc = "In DMA Mode 0, RX DMA Request Will Be Asserted Whenever There's Data in RBR or RX FIFO and De-assert Whenever RBR or RX FIFO is Empty; TX DMA Request Will Be Asserted Whenever THR or TX FIFO is Empty and De-assert Whenever Data Written To."]
            #[inline(always)]
            pub fn is_mode0(&self) -> bool {
                *self == FDMAMD::Mode0
            }
            #[doc = "In DMA Mode 1, RX DMA Request Will Be Asserted Whenever RX FIFO Trig Level or Time Out Reached and De-assert Thereafter When RX FIFO is Empty; TX DMA Request Will Be Asserted Whenever TX FIFO is Empty and De-assert Thereafter When TX FIFO is Completely Filled up Full."]
            #[inline(always)]
            pub fn is_mode1(&self) -> bool {
                *self == FDMAMD::Mode1
            }
        }
        #[doc = "Field `FDMAMD` writer - FIFO DMA Mode"]
        pub type FDMAMD_W<'a, REG> = crate::BitWriter<'a, REG, FDMAMD>;
        impl<'a, REG> FDMAMD_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "In DMA Mode 0, RX DMA Request Will Be Asserted Whenever There's Data in RBR or RX FIFO and De-assert Whenever RBR or RX FIFO is Empty; TX DMA Request Will Be Asserted Whenever THR or TX FIFO is Empty and De-assert Whenever Data Written To."]
            #[inline(always)]
            pub fn mode0(self) -> &'a mut crate::W<REG> {
                self.variant(FDMAMD::Mode0)
            }
            #[doc = "In DMA Mode 1, RX DMA Request Will Be Asserted Whenever RX FIFO Trig Level or Time Out Reached and De-assert Thereafter When RX FIFO is Empty; TX DMA Request Will Be Asserted Whenever TX FIFO is Empty and De-assert Thereafter When TX FIFO is Completely Filled up Full."]
            #[inline(always)]
            pub fn mode1(self) -> &'a mut crate::W<REG> {
                self.variant(FDMAMD::Mode1)
            }
        }
        #[doc = "RX FIFO Trig Level\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum RFTRIG {
            #[doc = "0: 1 Byte to Trig RX Interrupt"]
            Byte1 = 0,
            #[doc = "1: 4 Byte to Trig RX Interrupt"]
            Byte4 = 1,
            #[doc = "2: 8 Byte to Trig RX Interrupt"]
            Byte8 = 2,
            #[doc = "3: 14 Byte to Trig RX Interrupt"]
            Byte14 = 3,
        }
        impl From<RFTRIG> for u8 {
            #[inline(always)]
            fn from(variant: RFTRIG) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for RFTRIG {
            type Ux = u8;
        }
        impl crate::IsEnum for RFTRIG {}
        #[doc = "Field `RFTRIG` reader - RX FIFO Trig Level"]
        pub type RFTRIG_R = crate::FieldReader<RFTRIG>;
        impl RFTRIG_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RFTRIG {
                match self.bits {
                    0 => RFTRIG::Byte1,
                    1 => RFTRIG::Byte4,
                    2 => RFTRIG::Byte8,
                    3 => RFTRIG::Byte14,
                    _ => unreachable!(),
                }
            }
            #[doc = "1 Byte to Trig RX Interrupt"]
            #[inline(always)]
            pub fn is_byte1(&self) -> bool {
                *self == RFTRIG::Byte1
            }
            #[doc = "4 Byte to Trig RX Interrupt"]
            #[inline(always)]
            pub fn is_byte4(&self) -> bool {
                *self == RFTRIG::Byte4
            }
            #[doc = "8 Byte to Trig RX Interrupt"]
            #[inline(always)]
            pub fn is_byte8(&self) -> bool {
                *self == RFTRIG::Byte8
            }
            #[doc = "14 Byte to Trig RX Interrupt"]
            #[inline(always)]
            pub fn is_byte14(&self) -> bool {
                *self == RFTRIG::Byte14
            }
        }
        #[doc = "Field `RFTRIG` writer - RX FIFO Trig Level"]
        pub type RFTRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2, RFTRIG, crate::Safe>;
        impl<'a, REG> RFTRIG_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "1 Byte to Trig RX Interrupt"]
            #[inline(always)]
            pub fn byte1(self) -> &'a mut crate::W<REG> {
                self.variant(RFTRIG::Byte1)
            }
            #[doc = "4 Byte to Trig RX Interrupt"]
            #[inline(always)]
            pub fn byte4(self) -> &'a mut crate::W<REG> {
                self.variant(RFTRIG::Byte4)
            }
            #[doc = "8 Byte to Trig RX Interrupt"]
            #[inline(always)]
            pub fn byte8(self) -> &'a mut crate::W<REG> {
                self.variant(RFTRIG::Byte8)
            }
            #[doc = "14 Byte to Trig RX Interrupt"]
            #[inline(always)]
            pub fn byte14(self) -> &'a mut crate::W<REG> {
                self.variant(RFTRIG::Byte14)
            }
        }
        impl R {
            #[doc = "Bit 0 - FIFO Enable as to Work in 16550 Mode"]
            #[inline(always)]
            pub fn fifoen(&self) -> FIFOEN_R {
                FIFOEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 3 - FIFO DMA Mode"]
            #[inline(always)]
            pub fn fdmamd(&self) -> FDMAMD_R {
                FDMAMD_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 6:7 - RX FIFO Trig Level"]
            #[inline(always)]
            pub fn rftrig(&self) -> RFTRIG_R {
                RFTRIG_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FCR")
                    .field("fifoen", &self.fifoen())
                    .field("fdmamd", &self.fdmamd())
                    .field("rftrig", &self.rftrig())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - FIFO Enable as to Work in 16550 Mode"]
            #[inline(always)]
            pub fn fifoen(&mut self) -> FIFOEN_W<FCRrs> {
                FIFOEN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Clear RX FIFO"]
            #[inline(always)]
            pub fn rfclr(&mut self) -> RFCLR_W<FCRrs> {
                RFCLR_W::new(self, 1)
            }
            #[doc = "Bit 2 - Clear TX FIFO"]
            #[inline(always)]
            pub fn tfclr(&mut self) -> TFCLR_W<FCRrs> {
                TFCLR_W::new(self, 2)
            }
            #[doc = "Bit 3 - FIFO DMA Mode"]
            #[inline(always)]
            pub fn fdmamd(&mut self) -> FDMAMD_W<FCRrs> {
                FDMAMD_W::new(self, 3)
            }
            #[doc = "Bits 6:7 - RX FIFO Trig Level"]
            #[inline(always)]
            pub fn rftrig(&mut self) -> RFTRIG_W<FCRrs> {
                RFTRIG_W::new(self, 6)
            }
        }
        #[doc = "FIFO Control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:FCR)"]
        pub struct FCRrs;
        impl crate::RegisterSpec for FCRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fcr::R`](R) reader structure"]
        impl crate::Readable for FCRrs {}
        #[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"]
        impl crate::Writable for FCRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FCR to value 0"]
        impl crate::Resettable for FCRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FBR (rw) register accessor: Fractional Baud Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`fbr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fbr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:FBR)\n\nFor information about available fields see [`mod@fbr`]
module"]
    pub type FBR = crate::Reg<fbr::FBRrs>;
    #[doc = "Fractional Baud Rate"]
    pub mod fbr {
        #[doc = "Register `FBR` reader"]
        pub type R = crate::R<FBRrs>;
        #[doc = "Register `FBR` writer"]
        pub type W = crate::W<FBRrs>;
        #[doc = "Field `DIVN` reader - Fractional Baud Rate N Divide Bits 0 to 2047"]
        pub type DIVN_R = crate::FieldReader<u16>;
        #[doc = "Field `DIVN` writer - Fractional Baud Rate N Divide Bits 0 to 2047"]
        pub type DIVN_W<'a, REG> = crate::FieldWriter<'a, REG, 11, u16, crate::Safe>;
        #[doc = "Field `DIVM` reader - Fractional Baud Rate M Divide Bits 1 to 3"]
        pub type DIVM_R = crate::FieldReader;
        #[doc = "Field `DIVM` writer - Fractional Baud Rate M Divide Bits 1 to 3"]
        pub type DIVM_W<'a, REG> = crate::FieldWriter<'a, REG, 2, u8, crate::Safe>;
        #[doc = "Field `FBEN` reader - Fractional Baud Rate Generator Enable"]
        pub type FBEN_R = crate::BitReader;
        #[doc = "Field `FBEN` writer - Fractional Baud Rate Generator Enable"]
        pub type FBEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:10 - Fractional Baud Rate N Divide Bits 0 to 2047"]
            #[inline(always)]
            pub fn divn(&self) -> DIVN_R {
                DIVN_R::new((self.bits & 0x07ff) as u16)
            }
            #[doc = "Bits 11:12 - Fractional Baud Rate M Divide Bits 1 to 3"]
            #[inline(always)]
            pub fn divm(&self) -> DIVM_R {
                DIVM_R::new(((self.bits >> 11) & 3) as u8)
            }
            #[doc = "Bit 15 - Fractional Baud Rate Generator Enable"]
            #[inline(always)]
            pub fn fben(&self) -> FBEN_R {
                FBEN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FBR")
                    .field("divn", &self.divn())
                    .field("divm", &self.divm())
                    .field("fben", &self.fben())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:10 - Fractional Baud Rate N Divide Bits 0 to 2047"]
            #[inline(always)]
            pub fn divn(&mut self) -> DIVN_W<FBRrs> {
                DIVN_W::new(self, 0)
            }
            #[doc = "Bits 11:12 - Fractional Baud Rate M Divide Bits 1 to 3"]
            #[inline(always)]
            pub fn divm(&mut self) -> DIVM_W<FBRrs> {
                DIVM_W::new(self, 11)
            }
            #[doc = "Bit 15 - Fractional Baud Rate Generator Enable"]
            #[inline(always)]
            pub fn fben(&mut self) -> FBEN_W<FBRrs> {
                FBEN_W::new(self, 15)
            }
        }
        #[doc = "Fractional Baud Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`fbr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fbr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:FBR)"]
        pub struct FBRrs;
        impl crate::RegisterSpec for FBRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fbr::R`](R) reader structure"]
        impl crate::Readable for FBRrs {}
        #[doc = "`write(|w| ..)` method takes [`fbr::W`](W) writer structure"]
        impl crate::Writable for FBRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FBR to value 0"]
        impl crate::Resettable for FBRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DIV (rw) register accessor: Baudrate Divider\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:DIV)\n\nFor information about available fields see [`mod@div`]
module"]
    pub type DIV = crate::Reg<div::DIVrs>;
    #[doc = "Baudrate Divider"]
    pub mod div {
        #[doc = "Register `DIV` reader"]
        pub type R = crate::R<DIVrs>;
        #[doc = "Register `DIV` writer"]
        pub type W = crate::W<DIVrs>;
        #[doc = "Field `DIV` reader - Baud Rate Divider"]
        pub type DIV_R = crate::FieldReader<u16>;
        #[doc = "Field `DIV` writer - Baud Rate Divider"]
        pub type DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Baud Rate Divider"]
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIV").field("div", &self.div()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Baud Rate Divider"]
            #[inline(always)]
            pub fn div(&mut self) -> DIV_W<DIVrs> {
                DIV_W::new(self, 0)
            }
        }
        #[doc = "Baudrate Divider\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:DIV)"]
        pub struct DIVrs;
        impl crate::RegisterSpec for DIVrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`div::R`](R) reader structure"]
        impl crate::Readable for DIVrs {}
        #[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"]
        impl crate::Writable for DIVrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DIV to value 0"]
        impl crate::Resettable for DIVrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "LCR2 (rw) register accessor: Second Line Control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:LCR2)\n\nFor information about available fields see [`mod@lcr2`]
module"]
    pub type LCR2 = crate::Reg<lcr2::LCR2rs>;
    #[doc = "Second Line Control"]
    pub mod lcr2 {
        #[doc = "Register `LCR2` reader"]
        pub type R = crate::R<LCR2rs>;
        #[doc = "Register `LCR2` writer"]
        pub type W = crate::W<LCR2rs>;
        #[doc = "Over Sample Rate\n\nValue on reset: 2"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OSR {
            #[doc = "0: Over Sample by 4"]
            Osr4 = 0,
            #[doc = "1: Over Sample by 8"]
            Osr8 = 1,
            #[doc = "2: Over Sample by 16"]
            Osr16 = 2,
            #[doc = "3: Over Sample by 32"]
            Osr32 = 3,
        }
        impl From<OSR> for u8 {
            #[inline(always)]
            fn from(variant: OSR) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for OSR {
            type Ux = u8;
        }
        impl crate::IsEnum for OSR {}
        #[doc = "Field `OSR` reader - Over Sample Rate"]
        pub type OSR_R = crate::FieldReader<OSR>;
        impl OSR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OSR {
                match self.bits {
                    0 => OSR::Osr4,
                    1 => OSR::Osr8,
                    2 => OSR::Osr16,
                    3 => OSR::Osr32,
                    _ => unreachable!(),
                }
            }
            #[doc = "Over Sample by 4"]
            #[inline(always)]
            pub fn is_osr4(&self) -> bool {
                *self == OSR::Osr4
            }
            #[doc = "Over Sample by 8"]
            #[inline(always)]
            pub fn is_osr8(&self) -> bool {
                *self == OSR::Osr8
            }
            #[doc = "Over Sample by 16"]
            #[inline(always)]
            pub fn is_osr16(&self) -> bool {
                *self == OSR::Osr16
            }
            #[doc = "Over Sample by 32"]
            #[inline(always)]
            pub fn is_osr32(&self) -> bool {
                *self == OSR::Osr32
            }
        }
        #[doc = "Field `OSR` writer - Over Sample Rate"]
        pub type OSR_W<'a, REG> = crate::FieldWriter<'a, REG, 2, OSR, crate::Safe>;
        impl<'a, REG> OSR_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Over Sample by 4"]
            #[inline(always)]
            pub fn osr4(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::Osr4)
            }
            #[doc = "Over Sample by 8"]
            #[inline(always)]
            pub fn osr8(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::Osr8)
            }
            #[doc = "Over Sample by 16"]
            #[inline(always)]
            pub fn osr16(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::Osr16)
            }
            #[doc = "Over Sample by 32"]
            #[inline(always)]
            pub fn osr32(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::Osr32)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Over Sample Rate"]
            #[inline(always)]
            pub fn osr(&self) -> OSR_R {
                OSR_R::new((self.bits & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LCR2").field("osr", &self.osr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Over Sample Rate"]
            #[inline(always)]
            pub fn osr(&mut self) -> OSR_W<LCR2rs> {
                OSR_W::new(self, 0)
            }
        }
        #[doc = "Second Line Control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:LCR2)"]
        pub struct LCR2rs;
        impl crate::RegisterSpec for LCR2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lcr2::R`](R) reader structure"]
        impl crate::Readable for LCR2rs {}
        #[doc = "`write(|w| ..)` method takes [`lcr2::W`](W) writer structure"]
        impl crate::Writable for LCR2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LCR2 to value 0x02"]
        impl crate::Resettable for LCR2rs {
            const RESET_VALUE: u32 = 0x02;
        }
    }
    #[doc = "CTL (rw) register accessor: UART Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:CTL)\n\nFor information about available fields see [`mod@ctl`]
module"]
    pub type CTL = crate::Reg<ctl::CTLrs>;
    #[doc = "UART Control Register"]
    pub mod ctl {
        #[doc = "Register `CTL` reader"]
        pub type R = crate::R<CTLrs>;
        #[doc = "Register `CTL` writer"]
        pub type W = crate::W<CTLrs>;
        #[doc = "Force UCLK on\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FORCECLK {
            #[doc = "0: UCLK Automatically Gated"]
            Gateuclk = 0,
            #[doc = "1: UCLK Always Working"]
            Uclken = 1,
        }
        impl From<FORCECLK> for bool {
            #[inline(always)]
            fn from(variant: FORCECLK) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FORCECLK` reader - Force UCLK on"]
        pub type FORCECLK_R = crate::BitReader<FORCECLK>;
        impl FORCECLK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FORCECLK {
                match self.bits {
                    false => FORCECLK::Gateuclk,
                    true => FORCECLK::Uclken,
                }
            }
            #[doc = "UCLK Automatically Gated"]
            #[inline(always)]
            pub fn is_gateuclk(&self) -> bool {
                *self == FORCECLK::Gateuclk
            }
            #[doc = "UCLK Always Working"]
            #[inline(always)]
            pub fn is_uclken(&self) -> bool {
                *self == FORCECLK::Uclken
            }
        }
        #[doc = "Field `FORCECLK` writer - Force UCLK on"]
        pub type FORCECLK_W<'a, REG> = crate::BitWriter<'a, REG, FORCECLK>;
        impl<'a, REG> FORCECLK_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "UCLK Automatically Gated"]
            #[inline(always)]
            pub fn gateuclk(self) -> &'a mut crate::W<REG> {
                self.variant(FORCECLK::Gateuclk)
            }
            #[doc = "UCLK Always Working"]
            #[inline(always)]
            pub fn uclken(self) -> &'a mut crate::W<REG> {
                self.variant(FORCECLK::Uclken)
            }
        }
        #[doc = "Invert Receiver Line\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXINV {
            #[doc = "0: Don't Invert Receiver Line (idling High)"]
            En000 = 0,
            #[doc = "1: Invert Receiver Line (idling Low)"]
            En001 = 1,
        }
        impl From<RXINV> for bool {
            #[inline(always)]
            fn from(variant: RXINV) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RXINV` reader - Invert Receiver Line"]
        pub type RXINV_R = crate::BitReader<RXINV>;
        impl RXINV_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RXINV {
                match self.bits {
                    false => RXINV::En000,
                    true => RXINV::En001,
                }
            }
            #[doc = "Don't Invert Receiver Line (idling High)"]
            #[inline(always)]
            pub fn is_en000(&self) -> bool {
                *self == RXINV::En000
            }
            #[doc = "Invert Receiver Line (idling Low)"]
            #[inline(always)]
            pub fn is_en001(&self) -> bool {
                *self == RXINV::En001
            }
        }
        #[doc = "Field `RXINV` writer - Invert Receiver Line"]
        pub type RXINV_W<'a, REG> = crate::BitWriter<'a, REG, RXINV>;
        impl<'a, REG> RXINV_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Don't Invert Receiver Line (idling High)"]
            #[inline(always)]
            pub fn en000(self) -> &'a mut crate::W<REG> {
                self.variant(RXINV::En000)
            }
            #[doc = "Invert Receiver Line (idling Low)"]
            #[inline(always)]
            pub fn en001(self) -> &'a mut crate::W<REG> {
                self.variant(RXINV::En001)
            }
        }
        #[doc = "Field `REV` reader - UART Revision ID"]
        pub type REV_R = crate::FieldReader;
        impl R {
            #[doc = "Bit 1 - Force UCLK on"]
            #[inline(always)]
            pub fn forceclk(&self) -> FORCECLK_R {
                FORCECLK_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 4 - Invert Receiver Line"]
            #[inline(always)]
            pub fn rxinv(&self) -> RXINV_R {
                RXINV_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 8:15 - UART Revision ID"]
            #[inline(always)]
            pub fn rev(&self) -> REV_R {
                REV_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CTL")
                    .field("forceclk", &self.forceclk())
                    .field("rxinv", &self.rxinv())
                    .field("rev", &self.rev())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 1 - Force UCLK on"]
            #[inline(always)]
            pub fn forceclk(&mut self) -> FORCECLK_W<CTLrs> {
                FORCECLK_W::new(self, 1)
            }
            #[doc = "Bit 4 - Invert Receiver Line"]
            #[inline(always)]
            pub fn rxinv(&mut self) -> RXINV_W<CTLrs> {
                RXINV_W::new(self, 4)
            }
        }
        #[doc = "UART Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:CTL)"]
        pub struct CTLrs;
        impl crate::RegisterSpec for CTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctl::R`](R) reader structure"]
        impl crate::Readable for CTLrs {}
        #[doc = "`write(|w| ..)` method takes [`ctl::W`](W) writer structure"]
        impl crate::Writable for CTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CTL to value 0x0100"]
        impl crate::Resettable for CTLrs {
            const RESET_VALUE: u32 = 0x0100;
        }
    }
    #[doc = "RFC (rw) register accessor: RX FIFO Byte Count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rfc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:RFC)\n\nFor information about available fields see [`mod@rfc`]
module"]
    pub type RFC = crate::Reg<rfc::RFCrs>;
    #[doc = "RX FIFO Byte Count"]
    pub mod rfc {
        #[doc = "Register `RFC` reader"]
        pub type R = crate::R<RFCrs>;
        #[doc = "Register `RFC` writer"]
        pub type W = crate::W<RFCrs>;
        #[doc = "Field `RFC` reader - Current RX FIFO Data Bytes"]
        pub type RFC_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:4 - Current RX FIFO Data Bytes"]
            #[inline(always)]
            pub fn rfc(&self) -> RFC_R {
                RFC_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RFC").field("rfc", &self.rfc()).finish()
            }
        }
        impl W {}
        #[doc = "RX FIFO Byte Count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rfc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:RFC)"]
        pub struct RFCrs;
        impl crate::RegisterSpec for RFCrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rfc::R`](R) reader structure"]
        impl crate::Readable for RFCrs {}
        #[doc = "`write(|w| ..)` method takes [`rfc::W`](W) writer structure"]
        impl crate::Writable for RFCrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RFC to value 0"]
        impl crate::Resettable for RFCrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "TFC (rw) register accessor: TX FIFO Byte Count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tfc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:TFC)\n\nFor information about available fields see [`mod@tfc`]
module"]
    pub type TFC = crate::Reg<tfc::TFCrs>;
    #[doc = "TX FIFO Byte Count"]
    pub mod tfc {
        #[doc = "Register `TFC` reader"]
        pub type R = crate::R<TFCrs>;
        #[doc = "Register `TFC` writer"]
        pub type W = crate::W<TFCrs>;
        #[doc = "Field `TFC` reader - Current TX FIFO Data Bytes"]
        pub type TFC_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:4 - Current TX FIFO Data Bytes"]
            #[inline(always)]
            pub fn tfc(&self) -> TFC_R {
                TFC_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TFC").field("tfc", &self.tfc()).finish()
            }
        }
        impl W {}
        #[doc = "TX FIFO Byte Count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tfc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:TFC)"]
        pub struct TFCrs;
        impl crate::RegisterSpec for TFCrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tfc::R`](R) reader structure"]
        impl crate::Readable for TFCrs {}
        #[doc = "`write(|w| ..)` method takes [`tfc::W`](W) writer structure"]
        impl crate::Writable for TFCrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TFC to value 0"]
        impl crate::Resettable for TFCrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RSC (rw) register accessor: RS485 Half-duplex Control\n\nYou can [`read`](crate::Reg::read) this register and get [`rsc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rsc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:RSC)\n\nFor information about available fields see [`mod@rsc`]
module"]
    pub type RSC = crate::Reg<rsc::RSCrs>;
    #[doc = "RS485 Half-duplex Control"]
    pub mod rsc {
        #[doc = "Register `RSC` reader"]
        pub type R = crate::R<RSCrs>;
        #[doc = "Register `RSC` writer"]
        pub type W = crate::W<RSCrs>;
        #[doc = "SOUT_EN Polarity\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OENP {
            #[doc = "0: High Active"]
            Highactive = 0,
            #[doc = "1: Low Active"]
            Lowactive = 1,
        }
        impl From<OENP> for bool {
            #[inline(always)]
            fn from(variant: OENP) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OENP` reader - SOUT_EN Polarity"]
        pub type OENP_R = crate::BitReader<OENP>;
        impl OENP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OENP {
                match self.bits {
                    false => OENP::Highactive,
                    true => OENP::Lowactive,
                }
            }
            #[doc = "High Active"]
            #[inline(always)]
            pub fn is_highactive(&self) -> bool {
                *self == OENP::Highactive
            }
            #[doc = "Low Active"]
            #[inline(always)]
            pub fn is_lowactive(&self) -> bool {
                *self == OENP::Lowactive
            }
        }
        #[doc = "Field `OENP` writer - SOUT_EN Polarity"]
        pub type OENP_W<'a, REG> = crate::BitWriter<'a, REG, OENP>;
        impl<'a, REG> OENP_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "High Active"]
            #[inline(always)]
            pub fn highactive(self) -> &'a mut crate::W<REG> {
                self.variant(OENP::Highactive)
            }
            #[doc = "Low Active"]
            #[inline(always)]
            pub fn lowactive(self) -> &'a mut crate::W<REG> {
                self.variant(OENP::Lowactive)
            }
        }
        #[doc = "SOUT_EN De-assert Before Full Stop Bit(s)\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OENSP {
            #[doc = "0: SOUT_EN De-assert Same Time as Full Stop Bit(s)"]
            Fullbit = 0,
            #[doc = "1: SOUT_EN De-assert Half-bit Earlier Than Full Stop Bit(s)"]
            Halfbit = 1,
        }
        impl From<OENSP> for bool {
            #[inline(always)]
            fn from(variant: OENSP) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OENSP` reader - SOUT_EN De-assert Before Full Stop Bit(s)"]
        pub type OENSP_R = crate::BitReader<OENSP>;
        impl OENSP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OENSP {
                match self.bits {
                    false => OENSP::Fullbit,
                    true => OENSP::Halfbit,
                }
            }
            #[doc = "SOUT_EN De-assert Same Time as Full Stop Bit(s)"]
            #[inline(always)]
            pub fn is_fullbit(&self) -> bool {
                *self == OENSP::Fullbit
            }
            #[doc = "SOUT_EN De-assert Half-bit Earlier Than Full Stop Bit(s)"]
            #[inline(always)]
            pub fn is_halfbit(&self) -> bool {
                *self == OENSP::Halfbit
            }
        }
        #[doc = "Field `OENSP` writer - SOUT_EN De-assert Before Full Stop Bit(s)"]
        pub type OENSP_W<'a, REG> = crate::BitWriter<'a, REG, OENSP>;
        impl<'a, REG> OENSP_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SOUT_EN De-assert Same Time as Full Stop Bit(s)"]
            #[inline(always)]
            pub fn fullbit(self) -> &'a mut crate::W<REG> {
                self.variant(OENSP::Fullbit)
            }
            #[doc = "SOUT_EN De-assert Half-bit Earlier Than Full Stop Bit(s)"]
            #[inline(always)]
            pub fn halfbit(self) -> &'a mut crate::W<REG> {
                self.variant(OENSP::Halfbit)
            }
        }
        #[doc = "Field `DISRX` reader - Disable RX When Transmitting"]
        pub type DISRX_R = crate::BitReader;
        #[doc = "Field `DISRX` writer - Disable RX When Transmitting"]
        pub type DISRX_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DISTX` reader - Hold off TX When Receiving"]
        pub type DISTX_R = crate::BitReader;
        #[doc = "Field `DISTX` writer - Hold off TX When Receiving"]
        pub type DISTX_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - SOUT_EN Polarity"]
            #[inline(always)]
            pub fn oenp(&self) -> OENP_R {
                OENP_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - SOUT_EN De-assert Before Full Stop Bit(s)"]
            #[inline(always)]
            pub fn oensp(&self) -> OENSP_R {
                OENSP_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Disable RX When Transmitting"]
            #[inline(always)]
            pub fn disrx(&self) -> DISRX_R {
                DISRX_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Hold off TX When Receiving"]
            #[inline(always)]
            pub fn distx(&self) -> DISTX_R {
                DISTX_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RSC")
                    .field("oenp", &self.oenp())
                    .field("oensp", &self.oensp())
                    .field("disrx", &self.disrx())
                    .field("distx", &self.distx())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - SOUT_EN Polarity"]
            #[inline(always)]
            pub fn oenp(&mut self) -> OENP_W<RSCrs> {
                OENP_W::new(self, 0)
            }
            #[doc = "Bit 1 - SOUT_EN De-assert Before Full Stop Bit(s)"]
            #[inline(always)]
            pub fn oensp(&mut self) -> OENSP_W<RSCrs> {
                OENSP_W::new(self, 1)
            }
            #[doc = "Bit 2 - Disable RX When Transmitting"]
            #[inline(always)]
            pub fn disrx(&mut self) -> DISRX_W<RSCrs> {
                DISRX_W::new(self, 2)
            }
            #[doc = "Bit 3 - Hold off TX When Receiving"]
            #[inline(always)]
            pub fn distx(&mut self) -> DISTX_W<RSCrs> {
                DISTX_W::new(self, 3)
            }
        }
        #[doc = "RS485 Half-duplex Control\n\nYou can [`read`](crate::Reg::read) this register and get [`rsc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rsc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:RSC)"]
        pub struct RSCrs;
        impl crate::RegisterSpec for RSCrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rsc::R`](R) reader structure"]
        impl crate::Readable for RSCrs {}
        #[doc = "`write(|w| ..)` method takes [`rsc::W`](W) writer structure"]
        impl crate::Writable for RSCrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RSC to value 0"]
        impl crate::Resettable for RSCrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ACR (rw) register accessor: Auto Baud Control\n\nYou can [`read`](crate::Reg::read) this register and get [`acr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:ACR)\n\nFor information about available fields see [`mod@acr`]
module"]
    pub type ACR = crate::Reg<acr::ACRrs>;
    #[doc = "Auto Baud Control"]
    pub mod acr {
        #[doc = "Register `ACR` reader"]
        pub type R = crate::R<ACRrs>;
        #[doc = "Register `ACR` writer"]
        pub type W = crate::W<ACRrs>;
        #[doc = "Field `ABE` reader - Auto Baud Enable"]
        pub type ABE_R = crate::BitReader;
        #[doc = "Field `ABE` writer - Auto Baud Enable"]
        pub type ABE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DNIEN` reader - Enable Done Interrupt"]
        pub type DNIEN_R = crate::BitReader;
        #[doc = "Field `DNIEN` writer - Enable Done Interrupt"]
        pub type DNIEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TOIEN` reader - Enable Time-out Interrupt"]
        pub type TOIEN_R = crate::BitReader;
        #[doc = "Field `TOIEN` writer - Enable Time-out Interrupt"]
        pub type TOIEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Starting Edge Count\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SEC {
            #[doc = "0: First Edge (always the Falling Edge of START Bit)"]
            First = 0,
            #[doc = "1: Second Edge"]
            Second = 1,
            #[doc = "2: Third Edge"]
            Third = 2,
            #[doc = "3: Fourth Edge"]
            Fourth = 3,
            #[doc = "4: Fifth Edge"]
            Fifth = 4,
            #[doc = "5: Sixth Edge"]
            Sixth = 5,
            #[doc = "6: Seventh Edge"]
            Seventh = 6,
            #[doc = "7: Eighth Edge"]
            Eighth = 7,
        }
        impl From<SEC> for u8 {
            #[inline(always)]
            fn from(variant: SEC) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for SEC {
            type Ux = u8;
        }
        impl crate::IsEnum for SEC {}
        #[doc = "Field `SEC` reader - Starting Edge Count"]
        pub type SEC_R = crate::FieldReader<SEC>;
        impl SEC_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SEC {
                match self.bits {
                    0 => SEC::First,
                    1 => SEC::Second,
                    2 => SEC::Third,
                    3 => SEC::Fourth,
                    4 => SEC::Fifth,
                    5 => SEC::Sixth,
                    6 => SEC::Seventh,
                    7 => SEC::Eighth,
                    _ => unreachable!(),
                }
            }
            #[doc = "First Edge (always the Falling Edge of START Bit)"]
            #[inline(always)]
            pub fn is_first(&self) -> bool {
                *self == SEC::First
            }
            #[doc = "Second Edge"]
            #[inline(always)]
            pub fn is_second(&self) -> bool {
                *self == SEC::Second
            }
            #[doc = "Third Edge"]
            #[inline(always)]
            pub fn is_third(&self) -> bool {
                *self == SEC::Third
            }
            #[doc = "Fourth Edge"]
            #[inline(always)]
            pub fn is_fourth(&self) -> bool {
                *self == SEC::Fourth
            }
            #[doc = "Fifth Edge"]
            #[inline(always)]
            pub fn is_fifth(&self) -> bool {
                *self == SEC::Fifth
            }
            #[doc = "Sixth Edge"]
            #[inline(always)]
            pub fn is_sixth(&self) -> bool {
                *self == SEC::Sixth
            }
            #[doc = "Seventh Edge"]
            #[inline(always)]
            pub fn is_seventh(&self) -> bool {
                *self == SEC::Seventh
            }
            #[doc = "Eighth Edge"]
            #[inline(always)]
            pub fn is_eighth(&self) -> bool {
                *self == SEC::Eighth
            }
        }
        #[doc = "Field `SEC` writer - Starting Edge Count"]
        pub type SEC_W<'a, REG> = crate::FieldWriter<'a, REG, 3, SEC, crate::Safe>;
        impl<'a, REG> SEC_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "First Edge (always the Falling Edge of START Bit)"]
            #[inline(always)]
            pub fn first(self) -> &'a mut crate::W<REG> {
                self.variant(SEC::First)
            }
            #[doc = "Second Edge"]
            #[inline(always)]
            pub fn second(self) -> &'a mut crate::W<REG> {
                self.variant(SEC::Second)
            }
            #[doc = "Third Edge"]
            #[inline(always)]
            pub fn third(self) -> &'a mut crate::W<REG> {
                self.variant(SEC::Third)
            }
            #[doc = "Fourth Edge"]
            #[inline(always)]
            pub fn fourth(self) -> &'a mut crate::W<REG> {
                self.variant(SEC::Fourth)
            }
            #[doc = "Fifth Edge"]
            #[inline(always)]
            pub fn fifth(self) -> &'a mut crate::W<REG> {
                self.variant(SEC::Fifth)
            }
            #[doc = "Sixth Edge"]
            #[inline(always)]
            pub fn sixth(self) -> &'a mut crate::W<REG> {
                self.variant(SEC::Sixth)
            }
            #[doc = "Seventh Edge"]
            #[inline(always)]
            pub fn seventh(self) -> &'a mut crate::W<REG> {
                self.variant(SEC::Seventh)
            }
            #[doc = "Eighth Edge"]
            #[inline(always)]
            pub fn eighth(self) -> &'a mut crate::W<REG> {
                self.variant(SEC::Eighth)
            }
        }
        #[doc = "Ending Edge Count\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EEC {
            #[doc = "0: First Edge"]
            First = 0,
            #[doc = "1: Second Edge"]
            Second = 1,
            #[doc = "2: Third Edge"]
            Third = 2,
            #[doc = "3: Fourth Edge"]
            Fourth = 3,
            #[doc = "4: Fifth Edge"]
            Fifth = 4,
            #[doc = "5: Sixth Edge"]
            Sixth = 5,
            #[doc = "6: Seventh Edge"]
            Seventh = 6,
            #[doc = "7: Eighth Edge"]
            Eighth = 7,
            #[doc = "8: Ninth Edge"]
            Ninth = 8,
        }
        impl From<EEC> for u8 {
            #[inline(always)]
            fn from(variant: EEC) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for EEC {
            type Ux = u8;
        }
        impl crate::IsEnum for EEC {}
        #[doc = "Field `EEC` reader - Ending Edge Count"]
        pub type EEC_R = crate::FieldReader<EEC>;
        impl EEC_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<EEC> {
                match self.bits {
                    0 => Some(EEC::First),
                    1 => Some(EEC::Second),
                    2 => Some(EEC::Third),
                    3 => Some(EEC::Fourth),
                    4 => Some(EEC::Fifth),
                    5 => Some(EEC::Sixth),
                    6 => Some(EEC::Seventh),
                    7 => Some(EEC::Eighth),
                    8 => Some(EEC::Ninth),
                    _ => None,
                }
            }
            #[doc = "First Edge"]
            #[inline(always)]
            pub fn is_first(&self) -> bool {
                *self == EEC::First
            }
            #[doc = "Second Edge"]
            #[inline(always)]
            pub fn is_second(&self) -> bool {
                *self == EEC::Second
            }
            #[doc = "Third Edge"]
            #[inline(always)]
            pub fn is_third(&self) -> bool {
                *self == EEC::Third
            }
            #[doc = "Fourth Edge"]
            #[inline(always)]
            pub fn is_fourth(&self) -> bool {
                *self == EEC::Fourth
            }
            #[doc = "Fifth Edge"]
            #[inline(always)]
            pub fn is_fifth(&self) -> bool {
                *self == EEC::Fifth
            }
            #[doc = "Sixth Edge"]
            #[inline(always)]
            pub fn is_sixth(&self) -> bool {
                *self == EEC::Sixth
            }
            #[doc = "Seventh Edge"]
            #[inline(always)]
            pub fn is_seventh(&self) -> bool {
                *self == EEC::Seventh
            }
            #[doc = "Eighth Edge"]
            #[inline(always)]
            pub fn is_eighth(&self) -> bool {
                *self == EEC::Eighth
            }
            #[doc = "Ninth Edge"]
            #[inline(always)]
            pub fn is_ninth(&self) -> bool {
                *self == EEC::Ninth
            }
        }
        #[doc = "Field `EEC` writer - Ending Edge Count"]
        pub type EEC_W<'a, REG> = crate::FieldWriter<'a, REG, 4, EEC>;
        impl<'a, REG> EEC_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "First Edge"]
            #[inline(always)]
            pub fn first(self) -> &'a mut crate::W<REG> {
                self.variant(EEC::First)
            }
            #[doc = "Second Edge"]
            #[inline(always)]
            pub fn second(self) -> &'a mut crate::W<REG> {
                self.variant(EEC::Second)
            }
            #[doc = "Third Edge"]
            #[inline(always)]
            pub fn third(self) -> &'a mut crate::W<REG> {
                self.variant(EEC::Third)
            }
            #[doc = "Fourth Edge"]
            #[inline(always)]
            pub fn fourth(self) -> &'a mut crate::W<REG> {
                self.variant(EEC::Fourth)
            }
            #[doc = "Fifth Edge"]
            #[inline(always)]
            pub fn fifth(self) -> &'a mut crate::W<REG> {
                self.variant(EEC::Fifth)
            }
            #[doc = "Sixth Edge"]
            #[inline(always)]
            pub fn sixth(self) -> &'a mut crate::W<REG> {
                self.variant(EEC::Sixth)
            }
            #[doc = "Seventh Edge"]
            #[inline(always)]
            pub fn seventh(self) -> &'a mut crate::W<REG> {
                self.variant(EEC::Seventh)
            }
            #[doc = "Eighth Edge"]
            #[inline(always)]
            pub fn eighth(self) -> &'a mut crate::W<REG> {
                self.variant(EEC::Eighth)
            }
            #[doc = "Ninth Edge"]
            #[inline(always)]
            pub fn ninth(self) -> &'a mut crate::W<REG> {
                self.variant(EEC::Ninth)
            }
        }
        impl R {
            #[doc = "Bit 0 - Auto Baud Enable"]
            #[inline(always)]
            pub fn abe(&self) -> ABE_R {
                ABE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Enable Done Interrupt"]
            #[inline(always)]
            pub fn dnien(&self) -> DNIEN_R {
                DNIEN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Enable Time-out Interrupt"]
            #[inline(always)]
            pub fn toien(&self) -> TOIEN_R {
                TOIEN_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 4:6 - Starting Edge Count"]
            #[inline(always)]
            pub fn sec(&self) -> SEC_R {
                SEC_R::new(((self.bits >> 4) & 7) as u8)
            }
            #[doc = "Bits 8:11 - Ending Edge Count"]
            #[inline(always)]
            pub fn eec(&self) -> EEC_R {
                EEC_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ACR")
                    .field("abe", &self.abe())
                    .field("dnien", &self.dnien())
                    .field("toien", &self.toien())
                    .field("sec", &self.sec())
                    .field("eec", &self.eec())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Auto Baud Enable"]
            #[inline(always)]
            pub fn abe(&mut self) -> ABE_W<ACRrs> {
                ABE_W::new(self, 0)
            }
            #[doc = "Bit 1 - Enable Done Interrupt"]
            #[inline(always)]
            pub fn dnien(&mut self) -> DNIEN_W<ACRrs> {
                DNIEN_W::new(self, 1)
            }
            #[doc = "Bit 2 - Enable Time-out Interrupt"]
            #[inline(always)]
            pub fn toien(&mut self) -> TOIEN_W<ACRrs> {
                TOIEN_W::new(self, 2)
            }
            #[doc = "Bits 4:6 - Starting Edge Count"]
            #[inline(always)]
            pub fn sec(&mut self) -> SEC_W<ACRrs> {
                SEC_W::new(self, 4)
            }
            #[doc = "Bits 8:11 - Ending Edge Count"]
            #[inline(always)]
            pub fn eec(&mut self) -> EEC_W<ACRrs> {
                EEC_W::new(self, 8)
            }
        }
        #[doc = "Auto Baud Control\n\nYou can [`read`](crate::Reg::read) this register and get [`acr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:ACR)"]
        pub struct ACRrs;
        impl crate::RegisterSpec for ACRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`acr::R`](R) reader structure"]
        impl crate::Readable for ACRrs {}
        #[doc = "`write(|w| ..)` method takes [`acr::W`](W) writer structure"]
        impl crate::Writable for ACRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ACR to value 0"]
        impl crate::Resettable for ACRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ASRL (rw) register accessor: Auto Baud Status (Low)\n\nYou can [`read`](crate::Reg::read) this register and get [`asrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`asrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:ASRL)\n\nFor information about available fields see [`mod@asrl`]
module"]
    pub type ASRL = crate::Reg<asrl::ASRLrs>;
    #[doc = "Auto Baud Status (Low)"]
    pub mod asrl {
        #[doc = "Register `ASRL` reader"]
        pub type R = crate::R<ASRLrs>;
        #[doc = "Register `ASRL` writer"]
        pub type W = crate::W<ASRLrs>;
        #[doc = "Field `DONE` reader - Auto Baud Done Successfully"]
        pub type DONE_R = crate::BitReader;
        #[doc = "Field `BRKTO` reader - Timed Out Due to Long Time Break Condition"]
        pub type BRKTO_R = crate::BitReader;
        #[doc = "Field `NSETO` reader - Timed Out Due to No Valid Start Edge Found"]
        pub type NSETO_R = crate::BitReader;
        #[doc = "Field `NEETO` reader - Timed Out Due to No Valid Ending Edge Found"]
        pub type NEETO_R = crate::BitReader;
        #[doc = "Field `CNT` reader - Auto Baud Counter Value"]
        pub type CNT_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bit 0 - Auto Baud Done Successfully"]
            #[inline(always)]
            pub fn done(&self) -> DONE_R {
                DONE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Timed Out Due to Long Time Break Condition"]
            #[inline(always)]
            pub fn brkto(&self) -> BRKTO_R {
                BRKTO_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Timed Out Due to No Valid Start Edge Found"]
            #[inline(always)]
            pub fn nseto(&self) -> NSETO_R {
                NSETO_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Timed Out Due to No Valid Ending Edge Found"]
            #[inline(always)]
            pub fn neeto(&self) -> NEETO_R {
                NEETO_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:15 - Auto Baud Counter Value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ASRL")
                    .field("done", &self.done())
                    .field("brkto", &self.brkto())
                    .field("nseto", &self.nseto())
                    .field("neeto", &self.neeto())
                    .field("cnt", &self.cnt())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Auto Baud Status (Low)\n\nYou can [`read`](crate::Reg::read) this register and get [`asrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`asrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:ASRL)"]
        pub struct ASRLrs;
        impl crate::RegisterSpec for ASRLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`asrl::R`](R) reader structure"]
        impl crate::Readable for ASRLrs {}
        #[doc = "`write(|w| ..)` method takes [`asrl::W`](W) writer structure"]
        impl crate::Writable for ASRLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ASRL to value 0"]
        impl crate::Resettable for ASRLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ASRH (rw) register accessor: Auto Baud Status (High)\n\nYou can [`read`](crate::Reg::read) this register and get [`asrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`asrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:ASRH)\n\nFor information about available fields see [`mod@asrh`]
module"]
    pub type ASRH = crate::Reg<asrh::ASRHrs>;
    #[doc = "Auto Baud Status (High)"]
    pub mod asrh {
        #[doc = "Register `ASRH` reader"]
        pub type R = crate::R<ASRHrs>;
        #[doc = "Register `ASRH` writer"]
        pub type W = crate::W<ASRHrs>;
        #[doc = "Field `CNT` reader - Auto Baud Counter Value"]
        pub type CNT_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Auto Baud Counter Value"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ASRH").field("cnt", &self.cnt()).finish()
            }
        }
        impl W {}
        #[doc = "Auto Baud Status (High)\n\nYou can [`read`](crate::Reg::read) this register and get [`asrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`asrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0:ASRH)"]
        pub struct ASRHrs;
        impl crate::RegisterSpec for ASRHrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`asrh::R`](R) reader structure"]
        impl crate::Readable for ASRHrs {}
        #[doc = "`write(|w| ..)` method takes [`asrh::W`](W) writer structure"]
        impl crate::Writable for ASRHrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ASRH to value 0"]
        impl crate::Resettable for ASRHrs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#UART0)"]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4002_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART1 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
#[doc = "Unknown"]
pub use self::uart0 as uart1;
#[doc = "Some Description."]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0)"]
pub struct I2C0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C0 {}
impl I2C0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4002_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2C0 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C0").finish()
    }
}
#[doc = "Some Description."]
pub mod i2c0 {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        mctl: MCTL,
        mstat: MSTAT,
        mrx: MRX,
        mtx: MTX,
        mrxcnt: MRXCNT,
        mcrxcnt: MCRXCNT,
        addr0: ADDR0,
        addr1: ADDR1,
        byt: BYT,
        div: DIV,
        sctl: SCTL,
        sstat: SSTAT,
        srx: SRX,
        stx: STX,
        alt: ALT,
        id0: ID0,
        id1: ID1,
        id2: ID2,
        id3: ID3,
        stat: STAT,
        shctl: SHCTL,
        tctl: TCTL,
        astretch_scl: ASTRETCH_SCL,
        idfsta: IDFSTA,
        slv_addr1: SLV_ADDR1,
        slv_addr2: SLV_ADDR2,
        sstat2: SSTAT2,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Master Control"]
        #[inline(always)]
        pub const fn mctl(&self) -> &MCTL {
            &self.mctl
        }
        #[doc = "0x04 - Master Status"]
        #[inline(always)]
        pub const fn mstat(&self) -> &MSTAT {
            &self.mstat
        }
        #[doc = "0x08 - Master Receive Data"]
        #[inline(always)]
        pub const fn mrx(&self) -> &MRX {
            &self.mrx
        }
        #[doc = "0x0c - Master Transmit Data"]
        #[inline(always)]
        pub const fn mtx(&self) -> &MTX {
            &self.mtx
        }
        #[doc = "0x10 - Master Receive Data Count"]
        #[inline(always)]
        pub const fn mrxcnt(&self) -> &MRXCNT {
            &self.mrxcnt
        }
        #[doc = "0x14 - Master Current Receive Data Count"]
        #[inline(always)]
        pub const fn mcrxcnt(&self) -> &MCRXCNT {
            &self.mcrxcnt
        }
        #[doc = "0x18 - 1st Master Address Byte"]
        #[inline(always)]
        pub const fn addr0(&self) -> &ADDR0 {
            &self.addr0
        }
        #[doc = "0x1c - 2nd Master Address Byte"]
        #[inline(always)]
        pub const fn addr1(&self) -> &ADDR1 {
            &self.addr1
        }
        #[doc = "0x20 - Start Byte"]
        #[inline(always)]
        pub const fn byt(&self) -> &BYT {
            &self.byt
        }
        #[doc = "0x24 - Serial Clock Period Divisor"]
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
        #[doc = "0x28 - Slave Control"]
        #[inline(always)]
        pub const fn sctl(&self) -> &SCTL {
            &self.sctl
        }
        #[doc = "0x2c - Slave I2C Status/Error/IRQ"]
        #[inline(always)]
        pub const fn sstat(&self) -> &SSTAT {
            &self.sstat
        }
        #[doc = "0x30 - Slave Receive"]
        #[inline(always)]
        pub const fn srx(&self) -> &SRX {
            &self.srx
        }
        #[doc = "0x34 - Slave Transmit"]
        #[inline(always)]
        pub const fn stx(&self) -> &STX {
            &self.stx
        }
        #[doc = "0x38 - Hardware General Call ID"]
        #[inline(always)]
        pub const fn alt(&self) -> &ALT {
            &self.alt
        }
        #[doc = "0x3c - 1st Slave Address Device ID"]
        #[inline(always)]
        pub const fn id0(&self) -> &ID0 {
            &self.id0
        }
        #[doc = "0x40 - 2nd Slave Address Device ID"]
        #[inline(always)]
        pub const fn id1(&self) -> &ID1 {
            &self.id1
        }
        #[doc = "0x44 - 3rd Slave Address Device ID"]
        #[inline(always)]
        pub const fn id2(&self) -> &ID2 {
            &self.id2
        }
        #[doc = "0x48 - 4th Slave Address Device ID"]
        #[inline(always)]
        pub const fn id3(&self) -> &ID3 {
            &self.id3
        }
        #[doc = "0x4c - Master and Slave FIFO Status"]
        #[inline(always)]
        pub const fn stat(&self) -> &STAT {
            &self.stat
        }
        #[doc = "0x50 - Shared Control"]
        #[inline(always)]
        pub const fn shctl(&self) -> &SHCTL {
            &self.shctl
        }
        #[doc = "0x54 - Timing Control Register"]
        #[inline(always)]
        pub const fn tctl(&self) -> &TCTL {
            &self.tctl
        }
        #[doc = "0x58 - Automatic Stretch SCL Register"]
        #[inline(always)]
        pub const fn astretch_scl(&self) -> &ASTRETCH_SCL {
            &self.astretch_scl
        }
        #[doc = "0x5c - ID FIFO Status Register"]
        #[inline(always)]
        pub const fn idfsta(&self) -> &IDFSTA {
            &self.idfsta
        }
        #[doc = "0x60 - Slave 10 Bits Address 1st Byte."]
        #[inline(always)]
        pub const fn slv_addr1(&self) -> &SLV_ADDR1 {
            &self.slv_addr1
        }
        #[doc = "0x64 - Slave 10 Bits Address 2nd Byte."]
        #[inline(always)]
        pub const fn slv_addr2(&self) -> &SLV_ADDR2 {
            &self.slv_addr2
        }
        #[doc = "0x68 - Slave I2C Status/IRQ 2"]
        #[inline(always)]
        pub const fn sstat2(&self) -> &SSTAT2 {
            &self.sstat2
        }
    }
    #[doc = "MCTL (rw) register accessor: Master Control\n\nYou can [`read`](crate::Reg::read) this register and get [`mctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MCTL)\n\nFor information about available fields see [`mod@mctl`]
module"]
    pub type MCTL = crate::Reg<mctl::MCTLrs>;
    #[doc = "Master Control"]
    pub mod mctl {
        #[doc = "Register `MCTL` reader"]
        pub type R = crate::R<MCTLrs>;
        #[doc = "Register `MCTL` writer"]
        pub type W = crate::W<MCTLrs>;
        #[doc = "Field `MASEN` reader - Master Enable"]
        pub type MASEN_R = crate::BitReader;
        #[doc = "Field `MASEN` writer - Master Enable"]
        pub type MASEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COMPETE` reader - Start Back-off Disable"]
        pub type COMPETE_R = crate::BitReader;
        #[doc = "Field `COMPETE` writer - Start Back-off Disable"]
        pub type COMPETE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LOOPBACK` reader - Internal Loopback Enable"]
        pub type LOOPBACK_R = crate::BitReader;
        #[doc = "Field `LOOPBACK` writer - Internal Loopback Enable"]
        pub type LOOPBACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENMRX` reader - Receive Request Interrupt Enable"]
        pub type IENMRX_R = crate::BitReader;
        #[doc = "Field `IENMRX` writer - Receive Request Interrupt Enable"]
        pub type IENMRX_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENMTX` reader - Transmit Request Interrupt Enable."]
        pub type IENMTX_R = crate::BitReader;
        #[doc = "Field `IENMTX` writer - Transmit Request Interrupt Enable."]
        pub type IENMTX_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENALOST` reader - Arbitration Lost Interrupt Enable"]
        pub type IENALOST_R = crate::BitReader;
        #[doc = "Field `IENALOST` writer - Arbitration Lost Interrupt Enable"]
        pub type IENALOST_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENACK` reader - ACK Not Received Interrupt Enable"]
        pub type IENACK_R = crate::BitReader;
        #[doc = "Field `IENACK` writer - ACK Not Received Interrupt Enable"]
        pub type IENACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENCMP` reader - Transaction Completed (Or Stop Detected) Interrupt Enable"]
        pub type IENCMP_R = crate::BitReader;
        #[doc = "Field `IENCMP` writer - Transaction Completed (Or Stop Detected) Interrupt Enable"]
        pub type IENCMP_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MXMITDEC` reader - Decrement Master TX FIFO Status When Transmitted One Byte"]
        pub type MXMITDEC_R = crate::BitReader;
        #[doc = "Field `MXMITDEC` writer - Decrement Master TX FIFO Status When Transmitted One Byte"]
        pub type MXMITDEC_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MRXDMA` writer - Enable Master Rx DMA Request"]
        pub type MRXDMA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MTXDMA` writer - Enable Master Tx DMA Request"]
        pub type MTXDMA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BUS_CLR_EN` reader - Bus-Clear Enable"]
        pub type BUS_CLR_EN_R = crate::BitReader;
        #[doc = "Field `BUS_CLR_EN` writer - Bus-Clear Enable"]
        pub type BUS_CLR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PRESTOP_BUS_CLR` reader - Prestop Bus-Clear"]
        pub type PRESTOP_BUS_CLR_R = crate::BitReader;
        #[doc = "Field `PRESTOP_BUS_CLR` writer - Prestop Bus-Clear"]
        pub type PRESTOP_BUS_CLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Master Enable"]
            #[inline(always)]
            pub fn masen(&self) -> MASEN_R {
                MASEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Start Back-off Disable"]
            #[inline(always)]
            pub fn compete(&self) -> COMPETE_R {
                COMPETE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Internal Loopback Enable"]
            #[inline(always)]
            pub fn loopback(&self) -> LOOPBACK_R {
                LOOPBACK_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - Receive Request Interrupt Enable"]
            #[inline(always)]
            pub fn ienmrx(&self) -> IENMRX_R {
                IENMRX_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Transmit Request Interrupt Enable."]
            #[inline(always)]
            pub fn ienmtx(&self) -> IENMTX_R {
                IENMTX_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Arbitration Lost Interrupt Enable"]
            #[inline(always)]
            pub fn ienalost(&self) -> IENALOST_R {
                IENALOST_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - ACK Not Received Interrupt Enable"]
            #[inline(always)]
            pub fn ienack(&self) -> IENACK_R {
                IENACK_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Transaction Completed (Or Stop Detected) Interrupt Enable"]
            #[inline(always)]
            pub fn iencmp(&self) -> IENCMP_R {
                IENCMP_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Decrement Master TX FIFO Status When Transmitted One Byte"]
            #[inline(always)]
            pub fn mxmitdec(&self) -> MXMITDEC_R {
                MXMITDEC_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 12 - Bus-Clear Enable"]
            #[inline(always)]
            pub fn bus_clr_en(&self) -> BUS_CLR_EN_R {
                BUS_CLR_EN_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Prestop Bus-Clear"]
            #[inline(always)]
            pub fn prestop_bus_clr(&self) -> PRESTOP_BUS_CLR_R {
                PRESTOP_BUS_CLR_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MCTL")
                    .field("masen", &self.masen())
                    .field("compete", &self.compete())
                    .field("loopback", &self.loopback())
                    .field("ienmrx", &self.ienmrx())
                    .field("ienmtx", &self.ienmtx())
                    .field("ienalost", &self.ienalost())
                    .field("ienack", &self.ienack())
                    .field("iencmp", &self.iencmp())
                    .field("mxmitdec", &self.mxmitdec())
                    .field("bus_clr_en", &self.bus_clr_en())
                    .field("prestop_bus_clr", &self.prestop_bus_clr())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Master Enable"]
            #[inline(always)]
            pub fn masen(&mut self) -> MASEN_W<MCTLrs> {
                MASEN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Start Back-off Disable"]
            #[inline(always)]
            pub fn compete(&mut self) -> COMPETE_W<MCTLrs> {
                COMPETE_W::new(self, 1)
            }
            #[doc = "Bit 2 - Internal Loopback Enable"]
            #[inline(always)]
            pub fn loopback(&mut self) -> LOOPBACK_W<MCTLrs> {
                LOOPBACK_W::new(self, 2)
            }
            #[doc = "Bit 4 - Receive Request Interrupt Enable"]
            #[inline(always)]
            pub fn ienmrx(&mut self) -> IENMRX_W<MCTLrs> {
                IENMRX_W::new(self, 4)
            }
            #[doc = "Bit 5 - Transmit Request Interrupt Enable."]
            #[inline(always)]
            pub fn ienmtx(&mut self) -> IENMTX_W<MCTLrs> {
                IENMTX_W::new(self, 5)
            }
            #[doc = "Bit 6 - Arbitration Lost Interrupt Enable"]
            #[inline(always)]
            pub fn ienalost(&mut self) -> IENALOST_W<MCTLrs> {
                IENALOST_W::new(self, 6)
            }
            #[doc = "Bit 7 - ACK Not Received Interrupt Enable"]
            #[inline(always)]
            pub fn ienack(&mut self) -> IENACK_W<MCTLrs> {
                IENACK_W::new(self, 7)
            }
            #[doc = "Bit 8 - Transaction Completed (Or Stop Detected) Interrupt Enable"]
            #[inline(always)]
            pub fn iencmp(&mut self) -> IENCMP_W<MCTLrs> {
                IENCMP_W::new(self, 8)
            }
            #[doc = "Bit 9 - Decrement Master TX FIFO Status When Transmitted One Byte"]
            #[inline(always)]
            pub fn mxmitdec(&mut self) -> MXMITDEC_W<MCTLrs> {
                MXMITDEC_W::new(self, 9)
            }
            #[doc = "Bit 10 - Enable Master Rx DMA Request"]
            #[inline(always)]
            pub fn mrxdma(&mut self) -> MRXDMA_W<MCTLrs> {
                MRXDMA_W::new(self, 10)
            }
            #[doc = "Bit 11 - Enable Master Tx DMA Request"]
            #[inline(always)]
            pub fn mtxdma(&mut self) -> MTXDMA_W<MCTLrs> {
                MTXDMA_W::new(self, 11)
            }
            #[doc = "Bit 12 - Bus-Clear Enable"]
            #[inline(always)]
            pub fn bus_clr_en(&mut self) -> BUS_CLR_EN_W<MCTLrs> {
                BUS_CLR_EN_W::new(self, 12)
            }
            #[doc = "Bit 13 - Prestop Bus-Clear"]
            #[inline(always)]
            pub fn prestop_bus_clr(&mut self) -> PRESTOP_BUS_CLR_W<MCTLrs> {
                PRESTOP_BUS_CLR_W::new(self, 13)
            }
        }
        #[doc = "Master Control\n\nYou can [`read`](crate::Reg::read) this register and get [`mctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MCTL)"]
        pub struct MCTLrs;
        impl crate::RegisterSpec for MCTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mctl::R`](R) reader structure"]
        impl crate::Readable for MCTLrs {}
        #[doc = "`write(|w| ..)` method takes [`mctl::W`](W) writer structure"]
        impl crate::Writable for MCTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MCTL to value 0"]
        impl crate::Resettable for MCTLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MSTAT (rw) register accessor: Master Status\n\nYou can [`read`](crate::Reg::read) this register and get [`mstat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mstat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MSTAT)\n\nFor information about available fields see [`mod@mstat`]
module"]
    pub type MSTAT = crate::Reg<mstat::MSTATrs>;
    #[doc = "Master Status"]
    pub mod mstat {
        #[doc = "Register `MSTAT` reader"]
        pub type R = crate::R<MSTATrs>;
        #[doc = "Register `MSTAT` writer"]
        pub type W = crate::W<MSTATrs>;
        #[doc = "Field `MTXFSTA` reader - Master Transmit FIFO Status"]
        pub type MTXFSTA_R = crate::FieldReader;
        #[doc = "Field `MTXREQ` reader - Master Transmit Interrupt Bit"]
        pub type MTXREQ_R = crate::BitReader;
        #[doc = "Field `MTXREQ` writer - Master Transmit Interrupt Bit"]
        pub type MTXREQ_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MRXREQ` reader - Master Receive Request"]
        pub type MRXREQ_R = crate::BitReader;
        #[doc = "Field `NACKADDR` reader - ACK Not Received in Response to an Address"]
        pub type NACKADDR_R = crate::BitReader;
        #[doc = "Field `ALOST` reader - Arbitration Lost"]
        pub type ALOST_R = crate::BitReader;
        #[doc = "Field `MBUSY` reader - Master Busy"]
        pub type MBUSY_R = crate::BitReader;
        #[doc = "Field `NACKDATA` reader - ACK Not Received in Response to Data Write"]
        pub type NACKDATA_R = crate::BitReader;
        #[doc = "Field `TCOMP` reader - Transaction Complete or Stop Detected"]
        pub type TCOMP_R = crate::BitReader;
        #[doc = "Field `MRXOF` reader - Master Receive FIFO Overflow"]
        pub type MRXOF_R = crate::BitReader;
        #[doc = "Field `LINEBUSY` reader - Line is Busy"]
        pub type LINEBUSY_R = crate::BitReader;
        #[doc = "Field `MSTOP` reader - STOP Driven by This I2C Master"]
        pub type MSTOP_R = crate::BitReader;
        #[doc = "Field `MTXUFLOW` reader - Master Transmit Underflow"]
        pub type MTXUFLOW_R = crate::BitReader;
        #[doc = "Field `SDA_FILTERED` reader - State of SDA Line"]
        pub type SDA_FILTERED_R = crate::BitReader;
        #[doc = "Field `SCL_FILTERED` reader - State of SCL Line"]
        pub type SCL_FILTERED_R = crate::BitReader;
        #[doc = "Field `MSTR_HS_MODE` reader - Master High Speed Mode Flag"]
        pub type MSTR_HS_MODE_R = crate::BitReader;
        impl R {
            #[doc = "Bits 0:1 - Master Transmit FIFO Status"]
            #[inline(always)]
            pub fn mtxfsta(&self) -> MTXFSTA_R {
                MTXFSTA_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Master Transmit Interrupt Bit"]
            #[inline(always)]
            pub fn mtxreq(&self) -> MTXREQ_R {
                MTXREQ_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Master Receive Request"]
            #[inline(always)]
            pub fn mrxreq(&self) -> MRXREQ_R {
                MRXREQ_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - ACK Not Received in Response to an Address"]
            #[inline(always)]
            pub fn nackaddr(&self) -> NACKADDR_R {
                NACKADDR_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Arbitration Lost"]
            #[inline(always)]
            pub fn alost(&self) -> ALOST_R {
                ALOST_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Master Busy"]
            #[inline(always)]
            pub fn mbusy(&self) -> MBUSY_R {
                MBUSY_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - ACK Not Received in Response to Data Write"]
            #[inline(always)]
            pub fn nackdata(&self) -> NACKDATA_R {
                NACKDATA_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Transaction Complete or Stop Detected"]
            #[inline(always)]
            pub fn tcomp(&self) -> TCOMP_R {
                TCOMP_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Master Receive FIFO Overflow"]
            #[inline(always)]
            pub fn mrxof(&self) -> MRXOF_R {
                MRXOF_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Line is Busy"]
            #[inline(always)]
            pub fn linebusy(&self) -> LINEBUSY_R {
                LINEBUSY_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - STOP Driven by This I2C Master"]
            #[inline(always)]
            pub fn mstop(&self) -> MSTOP_R {
                MSTOP_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Master Transmit Underflow"]
            #[inline(always)]
            pub fn mtxuflow(&self) -> MTXUFLOW_R {
                MTXUFLOW_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - State of SDA Line"]
            #[inline(always)]
            pub fn sda_filtered(&self) -> SDA_FILTERED_R {
                SDA_FILTERED_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - State of SCL Line"]
            #[inline(always)]
            pub fn scl_filtered(&self) -> SCL_FILTERED_R {
                SCL_FILTERED_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Master High Speed Mode Flag"]
            #[inline(always)]
            pub fn mstr_hs_mode(&self) -> MSTR_HS_MODE_R {
                MSTR_HS_MODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MSTAT")
                    .field("mtxfsta", &self.mtxfsta())
                    .field("mtxreq", &self.mtxreq())
                    .field("mrxreq", &self.mrxreq())
                    .field("nackaddr", &self.nackaddr())
                    .field("alost", &self.alost())
                    .field("mbusy", &self.mbusy())
                    .field("nackdata", &self.nackdata())
                    .field("tcomp", &self.tcomp())
                    .field("mrxof", &self.mrxof())
                    .field("linebusy", &self.linebusy())
                    .field("mstop", &self.mstop())
                    .field("mtxuflow", &self.mtxuflow())
                    .field("sda_filtered", &self.sda_filtered())
                    .field("scl_filtered", &self.scl_filtered())
                    .field("mstr_hs_mode", &self.mstr_hs_mode())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 2 - Master Transmit Interrupt Bit"]
            #[inline(always)]
            pub fn mtxreq(&mut self) -> MTXREQ_W<MSTATrs> {
                MTXREQ_W::new(self, 2)
            }
        }
        #[doc = "Master Status\n\nYou can [`read`](crate::Reg::read) this register and get [`mstat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mstat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MSTAT)"]
        pub struct MSTATrs;
        impl crate::RegisterSpec for MSTATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mstat::R`](R) reader structure"]
        impl crate::Readable for MSTATrs {}
        #[doc = "`write(|w| ..)` method takes [`mstat::W`](W) writer structure"]
        impl crate::Writable for MSTATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MSTAT to value 0x6000"]
        impl crate::Resettable for MSTATrs {
            const RESET_VALUE: u32 = 0x6000;
        }
    }
    #[doc = "MRX (rw) register accessor: Master Receive Data\n\nYou can [`read`](crate::Reg::read) this register and get [`mrx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mrx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MRX)\n\nFor information about available fields see [`mod@mrx`]
module"]
    pub type MRX = crate::Reg<mrx::MRXrs>;
    #[doc = "Master Receive Data"]
    pub mod mrx {
        #[doc = "Register `MRX` reader"]
        pub type R = crate::R<MRXrs>;
        #[doc = "Register `MRX` writer"]
        pub type W = crate::W<MRXrs>;
        #[doc = "Field `ICMRX` reader - Master Receive Register"]
        pub type ICMRX_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Master Receive Register"]
            #[inline(always)]
            pub fn icmrx(&self) -> ICMRX_R {
                ICMRX_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MRX").field("icmrx", &self.icmrx()).finish()
            }
        }
        impl W {}
        #[doc = "Master Receive Data\n\nYou can [`read`](crate::Reg::read) this register and get [`mrx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mrx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MRX)"]
        pub struct MRXrs;
        impl crate::RegisterSpec for MRXrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mrx::R`](R) reader structure"]
        impl crate::Readable for MRXrs {}
        #[doc = "`write(|w| ..)` method takes [`mrx::W`](W) writer structure"]
        impl crate::Writable for MRXrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MRX to value 0"]
        impl crate::Resettable for MRXrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MTX (rw) register accessor: Master Transmit Data\n\nYou can [`read`](crate::Reg::read) this register and get [`mtx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MTX)\n\nFor information about available fields see [`mod@mtx`]
module"]
    pub type MTX = crate::Reg<mtx::MTXrs>;
    #[doc = "Master Transmit Data"]
    pub mod mtx {
        #[doc = "Register `MTX` reader"]
        pub type R = crate::R<MTXrs>;
        #[doc = "Register `MTX` writer"]
        pub type W = crate::W<MTXrs>;
        #[doc = "Field `I2CMRX` reader - Master Transmit Register"]
        pub type I2CMRX_R = crate::FieldReader;
        #[doc = "Field `I2CMRX` writer - Master Transmit Register"]
        pub type I2CMRX_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Master Transmit Register"]
            #[inline(always)]
            pub fn i2cmrx(&self) -> I2CMRX_R {
                I2CMRX_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MTX")
                    .field("i2cmrx", &self.i2cmrx())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Master Transmit Register"]
            #[inline(always)]
            pub fn i2cmrx(&mut self) -> I2CMRX_W<MTXrs> {
                I2CMRX_W::new(self, 0)
            }
        }
        #[doc = "Master Transmit Data\n\nYou can [`read`](crate::Reg::read) this register and get [`mtx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MTX)"]
        pub struct MTXrs;
        impl crate::RegisterSpec for MTXrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mtx::R`](R) reader structure"]
        impl crate::Readable for MTXrs {}
        #[doc = "`write(|w| ..)` method takes [`mtx::W`](W) writer structure"]
        impl crate::Writable for MTXrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MTX to value 0"]
        impl crate::Resettable for MTXrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MRXCNT (rw) register accessor: Master Receive Data Count\n\nYou can [`read`](crate::Reg::read) this register and get [`mrxcnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mrxcnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MRXCNT)\n\nFor information about available fields see [`mod@mrxcnt`]
module"]
    pub type MRXCNT = crate::Reg<mrxcnt::MRXCNTrs>;
    #[doc = "Master Receive Data Count"]
    pub mod mrxcnt {
        #[doc = "Register `MRXCNT` reader"]
        pub type R = crate::R<MRXCNTrs>;
        #[doc = "Register `MRXCNT` writer"]
        pub type W = crate::W<MRXCNTrs>;
        #[doc = "Field `COUNT` reader - Receive Count"]
        pub type COUNT_R = crate::FieldReader;
        #[doc = "Field `COUNT` writer - Receive Count"]
        pub type COUNT_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        #[doc = "Field `EXTEND` reader - Extended Read"]
        pub type EXTEND_R = crate::BitReader;
        #[doc = "Field `EXTEND` writer - Extended Read"]
        pub type EXTEND_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:7 - Receive Count"]
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 8 - Extended Read"]
            #[inline(always)]
            pub fn extend(&self) -> EXTEND_R {
                EXTEND_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MRXCNT")
                    .field("count", &self.count())
                    .field("extend", &self.extend())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Receive Count"]
            #[inline(always)]
            pub fn count(&mut self) -> COUNT_W<MRXCNTrs> {
                COUNT_W::new(self, 0)
            }
            #[doc = "Bit 8 - Extended Read"]
            #[inline(always)]
            pub fn extend(&mut self) -> EXTEND_W<MRXCNTrs> {
                EXTEND_W::new(self, 8)
            }
        }
        #[doc = "Master Receive Data Count\n\nYou can [`read`](crate::Reg::read) this register and get [`mrxcnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mrxcnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MRXCNT)"]
        pub struct MRXCNTrs;
        impl crate::RegisterSpec for MRXCNTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mrxcnt::R`](R) reader structure"]
        impl crate::Readable for MRXCNTrs {}
        #[doc = "`write(|w| ..)` method takes [`mrxcnt::W`](W) writer structure"]
        impl crate::Writable for MRXCNTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MRXCNT to value 0"]
        impl crate::Resettable for MRXCNTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MCRXCNT (rw) register accessor: Master Current Receive Data Count\n\nYou can [`read`](crate::Reg::read) this register and get [`mcrxcnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcrxcnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MCRXCNT)\n\nFor information about available fields see [`mod@mcrxcnt`]
module"]
    pub type MCRXCNT = crate::Reg<mcrxcnt::MCRXCNTrs>;
    #[doc = "Master Current Receive Data Count"]
    pub mod mcrxcnt {
        #[doc = "Register `MCRXCNT` reader"]
        pub type R = crate::R<MCRXCNTrs>;
        #[doc = "Register `MCRXCNT` writer"]
        pub type W = crate::W<MCRXCNTrs>;
        #[doc = "Field `COUNT` reader - Current Receive Count"]
        pub type COUNT_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Current Receive Count"]
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MCRXCNT")
                    .field("count", &self.count())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Master Current Receive Data Count\n\nYou can [`read`](crate::Reg::read) this register and get [`mcrxcnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcrxcnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:MCRXCNT)"]
        pub struct MCRXCNTrs;
        impl crate::RegisterSpec for MCRXCNTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mcrxcnt::R`](R) reader structure"]
        impl crate::Readable for MCRXCNTrs {}
        #[doc = "`write(|w| ..)` method takes [`mcrxcnt::W`](W) writer structure"]
        impl crate::Writable for MCRXCNTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MCRXCNT to value 0"]
        impl crate::Resettable for MCRXCNTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADDR0 (rw) register accessor: 1st Master Address Byte\n\nYou can [`read`](crate::Reg::read) this register and get [`addr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ADDR0)\n\nFor information about available fields see [`mod@addr0`]
module"]
    pub type ADDR0 = crate::Reg<addr0::ADDR0rs>;
    #[doc = "1st Master Address Byte"]
    pub mod addr0 {
        #[doc = "Register `ADDR0` reader"]
        pub type R = crate::R<ADDR0rs>;
        #[doc = "Register `ADDR0` writer"]
        pub type W = crate::W<ADDR0rs>;
        #[doc = "Field `ADR1` reader - Address Byte 1"]
        pub type ADR1_R = crate::FieldReader;
        #[doc = "Field `ADR1` writer - Address Byte 1"]
        pub type ADR1_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Address Byte 1"]
            #[inline(always)]
            pub fn adr1(&self) -> ADR1_R {
                ADR1_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADDR0").field("adr1", &self.adr1()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Address Byte 1"]
            #[inline(always)]
            pub fn adr1(&mut self) -> ADR1_W<ADDR0rs> {
                ADR1_W::new(self, 0)
            }
        }
        #[doc = "1st Master Address Byte\n\nYou can [`read`](crate::Reg::read) this register and get [`addr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ADDR0)"]
        pub struct ADDR0rs;
        impl crate::RegisterSpec for ADDR0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`addr0::R`](R) reader structure"]
        impl crate::Readable for ADDR0rs {}
        #[doc = "`write(|w| ..)` method takes [`addr0::W`](W) writer structure"]
        impl crate::Writable for ADDR0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADDR0 to value 0"]
        impl crate::Resettable for ADDR0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADDR1 (rw) register accessor: 2nd Master Address Byte\n\nYou can [`read`](crate::Reg::read) this register and get [`addr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ADDR1)\n\nFor information about available fields see [`mod@addr1`]
module"]
    pub type ADDR1 = crate::Reg<addr1::ADDR1rs>;
    #[doc = "2nd Master Address Byte"]
    pub mod addr1 {
        #[doc = "Register `ADDR1` reader"]
        pub type R = crate::R<ADDR1rs>;
        #[doc = "Register `ADDR1` writer"]
        pub type W = crate::W<ADDR1rs>;
        #[doc = "Field `ADR2` reader - Address Byte 2"]
        pub type ADR2_R = crate::FieldReader;
        #[doc = "Field `ADR2` writer - Address Byte 2"]
        pub type ADR2_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Address Byte 2"]
            #[inline(always)]
            pub fn adr2(&self) -> ADR2_R {
                ADR2_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADDR1").field("adr2", &self.adr2()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Address Byte 2"]
            #[inline(always)]
            pub fn adr2(&mut self) -> ADR2_W<ADDR1rs> {
                ADR2_W::new(self, 0)
            }
        }
        #[doc = "2nd Master Address Byte\n\nYou can [`read`](crate::Reg::read) this register and get [`addr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`addr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ADDR1)"]
        pub struct ADDR1rs;
        impl crate::RegisterSpec for ADDR1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`addr1::R`](R) reader structure"]
        impl crate::Readable for ADDR1rs {}
        #[doc = "`write(|w| ..)` method takes [`addr1::W`](W) writer structure"]
        impl crate::Writable for ADDR1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADDR1 to value 0"]
        impl crate::Resettable for ADDR1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "BYT (rw) register accessor: Start Byte\n\nYou can [`read`](crate::Reg::read) this register and get [`byt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`byt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:BYT)\n\nFor information about available fields see [`mod@byt`]
module"]
    pub type BYT = crate::Reg<byt::BYTrs>;
    #[doc = "Start Byte"]
    pub mod byt {
        #[doc = "Register `BYT` reader"]
        pub type R = crate::R<BYTrs>;
        #[doc = "Register `BYT` writer"]
        pub type W = crate::W<BYTrs>;
        #[doc = "Field `SBYTE` reader - Start Byte"]
        pub type SBYTE_R = crate::FieldReader;
        #[doc = "Field `SBYTE` writer - Start Byte"]
        pub type SBYTE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Start Byte"]
            #[inline(always)]
            pub fn sbyte(&self) -> SBYTE_R {
                SBYTE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BYT").field("sbyte", &self.sbyte()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Start Byte"]
            #[inline(always)]
            pub fn sbyte(&mut self) -> SBYTE_W<BYTrs> {
                SBYTE_W::new(self, 0)
            }
        }
        #[doc = "Start Byte\n\nYou can [`read`](crate::Reg::read) this register and get [`byt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`byt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:BYT)"]
        pub struct BYTrs;
        impl crate::RegisterSpec for BYTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`byt::R`](R) reader structure"]
        impl crate::Readable for BYTrs {}
        #[doc = "`write(|w| ..)` method takes [`byt::W`](W) writer structure"]
        impl crate::Writable for BYTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets BYT to value 0"]
        impl crate::Resettable for BYTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DIV (rw) register accessor: Serial Clock Period Divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:DIV)\n\nFor information about available fields see [`mod@div`]
module"]
    pub type DIV = crate::Reg<div::DIVrs>;
    #[doc = "Serial Clock Period Divisor"]
    pub mod div {
        #[doc = "Register `DIV` reader"]
        pub type R = crate::R<DIVrs>;
        #[doc = "Register `DIV` writer"]
        pub type W = crate::W<DIVrs>;
        #[doc = "Field `LOW` reader - Serial Clock Low Time"]
        pub type LOW_R = crate::FieldReader;
        #[doc = "Field `LOW` writer - Serial Clock Low Time"]
        pub type LOW_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        #[doc = "Field `HIGH` reader - Serial Clock High Time"]
        pub type HIGH_R = crate::FieldReader;
        #[doc = "Field `HIGH` writer - Serial Clock High Time"]
        pub type HIGH_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Serial Clock Low Time"]
            #[inline(always)]
            pub fn low(&self) -> LOW_R {
                LOW_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - Serial Clock High Time"]
            #[inline(always)]
            pub fn high(&self) -> HIGH_R {
                HIGH_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIV")
                    .field("low", &self.low())
                    .field("high", &self.high())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Serial Clock Low Time"]
            #[inline(always)]
            pub fn low(&mut self) -> LOW_W<DIVrs> {
                LOW_W::new(self, 0)
            }
            #[doc = "Bits 8:15 - Serial Clock High Time"]
            #[inline(always)]
            pub fn high(&mut self) -> HIGH_W<DIVrs> {
                HIGH_W::new(self, 8)
            }
        }
        #[doc = "Serial Clock Period Divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:DIV)"]
        pub struct DIVrs;
        impl crate::RegisterSpec for DIVrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`div::R`](R) reader structure"]
        impl crate::Readable for DIVrs {}
        #[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"]
        impl crate::Writable for DIVrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DIV to value 0xc6c7"]
        impl crate::Resettable for DIVrs {
            const RESET_VALUE: u32 = 0xc6c7;
        }
    }
    #[doc = "SCTL (rw) register accessor: Slave Control\n\nYou can [`read`](crate::Reg::read) this register and get [`sctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SCTL)\n\nFor information about available fields see [`mod@sctl`]
module"]
    pub type SCTL = crate::Reg<sctl::SCTLrs>;
    #[doc = "Slave Control"]
    pub mod sctl {
        #[doc = "Register `SCTL` reader"]
        pub type R = crate::R<SCTLrs>;
        #[doc = "Register `SCTL` writer"]
        pub type W = crate::W<SCTLrs>;
        #[doc = "Field `SLVEN` reader - Slave Enable"]
        pub type SLVEN_R = crate::BitReader;
        #[doc = "Field `SLVEN` writer - Slave Enable"]
        pub type SLVEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADR10EN` reader - Enabled 10-bit Addressing"]
        pub type ADR10EN_R = crate::BitReader;
        #[doc = "Field `ADR10EN` writer - Enabled 10-bit Addressing"]
        pub type ADR10EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GCEN` reader - General Call Enable"]
        pub type GCEN_R = crate::BitReader;
        #[doc = "Field `GCEN` writer - General Call Enable"]
        pub type GCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HGCEN` reader - Hardware General Call Enable"]
        pub type HGCEN_R = crate::BitReader;
        #[doc = "Field `HGCEN` writer - Hardware General Call Enable"]
        pub type HGCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GCSBCLR` writer - General Call Status Bit Clear"]
        pub type GCSBCLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EARLYTXR` reader - Early Transmit Request Mode"]
        pub type EARLYTXR_R = crate::BitReader;
        #[doc = "Field `EARLYTXR` writer - Early Transmit Request Mode"]
        pub type EARLYTXR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `NACK` reader - NACK Next Communication"]
        pub type NACK_R = crate::BitReader;
        #[doc = "Field `NACK` writer - NACK Next Communication"]
        pub type NACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENSTOP` reader - Stop Condition Detected Interrupt Enable"]
        pub type IENSTOP_R = crate::BitReader;
        #[doc = "Field `IENSTOP` writer - Stop Condition Detected Interrupt Enable"]
        pub type IENSTOP_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENSRX` reader - Slave Receive Request Interrupt Enable"]
        pub type IENSRX_R = crate::BitReader;
        #[doc = "Field `IENSRX` writer - Slave Receive Request Interrupt Enable"]
        pub type IENSRX_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENSTX` reader - Slave Transmit Request Interrupt Enable"]
        pub type IENSTX_R = crate::BitReader;
        #[doc = "Field `IENSTX` writer - Slave Transmit Request Interrupt Enable"]
        pub type IENSTX_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SXMITDEC` reader - Decrement Slave Tx FIFO Status When Transmitted a Byte"]
        pub type SXMITDEC_R = crate::BitReader;
        #[doc = "Field `SXMITDEC` writer - Decrement Slave Tx FIFO Status When Transmitted a Byte"]
        pub type SXMITDEC_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENREPST` reader - Repeated Start Interrupt Enable"]
        pub type IENREPST_R = crate::BitReader;
        #[doc = "Field `IENREPST` writer - Repeated Start Interrupt Enable"]
        pub type IENREPST_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SRXDMA` reader - Enable Slave Rx DMA Request"]
        pub type SRXDMA_R = crate::BitReader;
        #[doc = "Field `SRXDMA` writer - Enable Slave Rx DMA Request"]
        pub type SRXDMA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STXDMA` reader - Enable Slave Tx DMA Request"]
        pub type STXDMA_R = crate::BitReader;
        #[doc = "Field `STXDMA` writer - Enable Slave Tx DMA Request"]
        pub type STXDMA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ID_FIFO_EN` reader - ID FIFO Enable"]
        pub type ID_FIFO_EN_R = crate::BitReader;
        #[doc = "Field `ID_FIFO_EN` writer - ID FIFO Enable"]
        pub type ID_FIFO_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Slave Enable"]
            #[inline(always)]
            pub fn slven(&self) -> SLVEN_R {
                SLVEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Enabled 10-bit Addressing"]
            #[inline(always)]
            pub fn adr10en(&self) -> ADR10EN_R {
                ADR10EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - General Call Enable"]
            #[inline(always)]
            pub fn gcen(&self) -> GCEN_R {
                GCEN_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Hardware General Call Enable"]
            #[inline(always)]
            pub fn hgcen(&self) -> HGCEN_R {
                HGCEN_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 5 - Early Transmit Request Mode"]
            #[inline(always)]
            pub fn earlytxr(&self) -> EARLYTXR_R {
                EARLYTXR_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 7 - NACK Next Communication"]
            #[inline(always)]
            pub fn nack(&self) -> NACK_R {
                NACK_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Stop Condition Detected Interrupt Enable"]
            #[inline(always)]
            pub fn ienstop(&self) -> IENSTOP_R {
                IENSTOP_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Slave Receive Request Interrupt Enable"]
            #[inline(always)]
            pub fn iensrx(&self) -> IENSRX_R {
                IENSRX_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Slave Transmit Request Interrupt Enable"]
            #[inline(always)]
            pub fn ienstx(&self) -> IENSTX_R {
                IENSTX_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Decrement Slave Tx FIFO Status When Transmitted a Byte"]
            #[inline(always)]
            pub fn sxmitdec(&self) -> SXMITDEC_R {
                SXMITDEC_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Repeated Start Interrupt Enable"]
            #[inline(always)]
            pub fn ienrepst(&self) -> IENREPST_R {
                IENREPST_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Enable Slave Rx DMA Request"]
            #[inline(always)]
            pub fn srxdma(&self) -> SRXDMA_R {
                SRXDMA_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Enable Slave Tx DMA Request"]
            #[inline(always)]
            pub fn stxdma(&self) -> STXDMA_R {
                STXDMA_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - ID FIFO Enable"]
            #[inline(always)]
            pub fn id_fifo_en(&self) -> ID_FIFO_EN_R {
                ID_FIFO_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SCTL")
                    .field("slven", &self.slven())
                    .field("adr10en", &self.adr10en())
                    .field("gcen", &self.gcen())
                    .field("hgcen", &self.hgcen())
                    .field("earlytxr", &self.earlytxr())
                    .field("nack", &self.nack())
                    .field("ienstop", &self.ienstop())
                    .field("iensrx", &self.iensrx())
                    .field("ienstx", &self.ienstx())
                    .field("sxmitdec", &self.sxmitdec())
                    .field("ienrepst", &self.ienrepst())
                    .field("srxdma", &self.srxdma())
                    .field("stxdma", &self.stxdma())
                    .field("id_fifo_en", &self.id_fifo_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Slave Enable"]
            #[inline(always)]
            pub fn slven(&mut self) -> SLVEN_W<SCTLrs> {
                SLVEN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Enabled 10-bit Addressing"]
            #[inline(always)]
            pub fn adr10en(&mut self) -> ADR10EN_W<SCTLrs> {
                ADR10EN_W::new(self, 1)
            }
            #[doc = "Bit 2 - General Call Enable"]
            #[inline(always)]
            pub fn gcen(&mut self) -> GCEN_W<SCTLrs> {
                GCEN_W::new(self, 2)
            }
            #[doc = "Bit 3 - Hardware General Call Enable"]
            #[inline(always)]
            pub fn hgcen(&mut self) -> HGCEN_W<SCTLrs> {
                HGCEN_W::new(self, 3)
            }
            #[doc = "Bit 4 - General Call Status Bit Clear"]
            #[inline(always)]
            pub fn gcsbclr(&mut self) -> GCSBCLR_W<SCTLrs> {
                GCSBCLR_W::new(self, 4)
            }
            #[doc = "Bit 5 - Early Transmit Request Mode"]
            #[inline(always)]
            pub fn earlytxr(&mut self) -> EARLYTXR_W<SCTLrs> {
                EARLYTXR_W::new(self, 5)
            }
            #[doc = "Bit 7 - NACK Next Communication"]
            #[inline(always)]
            pub fn nack(&mut self) -> NACK_W<SCTLrs> {
                NACK_W::new(self, 7)
            }
            #[doc = "Bit 8 - Stop Condition Detected Interrupt Enable"]
            #[inline(always)]
            pub fn ienstop(&mut self) -> IENSTOP_W<SCTLrs> {
                IENSTOP_W::new(self, 8)
            }
            #[doc = "Bit 9 - Slave Receive Request Interrupt Enable"]
            #[inline(always)]
            pub fn iensrx(&mut self) -> IENSRX_W<SCTLrs> {
                IENSRX_W::new(self, 9)
            }
            #[doc = "Bit 10 - Slave Transmit Request Interrupt Enable"]
            #[inline(always)]
            pub fn ienstx(&mut self) -> IENSTX_W<SCTLrs> {
                IENSTX_W::new(self, 10)
            }
            #[doc = "Bit 11 - Decrement Slave Tx FIFO Status When Transmitted a Byte"]
            #[inline(always)]
            pub fn sxmitdec(&mut self) -> SXMITDEC_W<SCTLrs> {
                SXMITDEC_W::new(self, 11)
            }
            #[doc = "Bit 12 - Repeated Start Interrupt Enable"]
            #[inline(always)]
            pub fn ienrepst(&mut self) -> IENREPST_W<SCTLrs> {
                IENREPST_W::new(self, 12)
            }
            #[doc = "Bit 13 - Enable Slave Rx DMA Request"]
            #[inline(always)]
            pub fn srxdma(&mut self) -> SRXDMA_W<SCTLrs> {
                SRXDMA_W::new(self, 13)
            }
            #[doc = "Bit 14 - Enable Slave Tx DMA Request"]
            #[inline(always)]
            pub fn stxdma(&mut self) -> STXDMA_W<SCTLrs> {
                STXDMA_W::new(self, 14)
            }
            #[doc = "Bit 15 - ID FIFO Enable"]
            #[inline(always)]
            pub fn id_fifo_en(&mut self) -> ID_FIFO_EN_W<SCTLrs> {
                ID_FIFO_EN_W::new(self, 15)
            }
        }
        #[doc = "Slave Control\n\nYou can [`read`](crate::Reg::read) this register and get [`sctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SCTL)"]
        pub struct SCTLrs;
        impl crate::RegisterSpec for SCTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sctl::R`](R) reader structure"]
        impl crate::Readable for SCTLrs {}
        #[doc = "`write(|w| ..)` method takes [`sctl::W`](W) writer structure"]
        impl crate::Writable for SCTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SCTL to value 0"]
        impl crate::Resettable for SCTLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SSTAT (rw) register accessor: Slave I2C Status/Error/IRQ\n\nYou can [`read`](crate::Reg::read) this register and get [`sstat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sstat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SSTAT)\n\nFor information about available fields see [`mod@sstat`]
module"]
    pub type SSTAT = crate::Reg<sstat::SSTATrs>;
    #[doc = "Slave I2C Status/Error/IRQ"]
    pub mod sstat {
        #[doc = "Register `SSTAT` reader"]
        pub type R = crate::R<SSTATrs>;
        #[doc = "Register `SSTAT` writer"]
        pub type W = crate::W<SSTATrs>;
        #[doc = "Field `STXFSEREQ` reader - Slave Tx FIFO Status or Early Request"]
        pub type STXFSEREQ_R = crate::BitReader;
        #[doc = "Field `STXFSEREQ` writer - Slave Tx FIFO Status or Early Request"]
        pub type STXFSEREQ_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STXUR` reader - Slave Transmit FIFO Underflow"]
        pub type STXUR_R = crate::BitReader;
        #[doc = "Field `STXREQ` reader - Slave Transmit Interrupt Bit"]
        pub type STXREQ_R = crate::BitReader;
        #[doc = "Field `SRXREQ` reader - Slave Receive Request"]
        pub type SRXREQ_R = crate::BitReader;
        #[doc = "Field `SRXOF` reader - Slave Receive FIFO Overflow"]
        pub type SRXOF_R = crate::BitReader;
        #[doc = "Field `NOACK` reader - Ack Not Generated by the Slave"]
        pub type NOACK_R = crate::BitReader;
        #[doc = "Field `SBUSY` reader - Slave Busy"]
        pub type SBUSY_R = crate::BitReader;
        #[doc = "Field `GCINT` reader - General Call Interrupt"]
        pub type GCINT_R = crate::BitReader;
        #[doc = "General ID\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum GCID {
            #[doc = "0: No general call"]
            None = 0,
            #[doc = "1: General call Reset and Program Address"]
            Resetprogaddr = 1,
            #[doc = "2: General Call Program Address"]
            Progaddr = 2,
            #[doc = "3: General Call Matching Alternative ID"]
            Matchid = 3,
        }
        impl From<GCID> for u8 {
            #[inline(always)]
            fn from(variant: GCID) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for GCID {
            type Ux = u8;
        }
        impl crate::IsEnum for GCID {}
        #[doc = "Field `GCID` reader - General ID"]
        pub type GCID_R = crate::FieldReader<GCID>;
        impl GCID_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GCID {
                match self.bits {
                    0 => GCID::None,
                    1 => GCID::Resetprogaddr,
                    2 => GCID::Progaddr,
                    3 => GCID::Matchid,
                    _ => unreachable!(),
                }
            }
            #[doc = "No general call"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == GCID::None
            }
            #[doc = "General call Reset and Program Address"]
            #[inline(always)]
            pub fn is_resetprogaddr(&self) -> bool {
                *self == GCID::Resetprogaddr
            }
            #[doc = "General Call Program Address"]
            #[inline(always)]
            pub fn is_progaddr(&self) -> bool {
                *self == GCID::Progaddr
            }
            #[doc = "General Call Matching Alternative ID"]
            #[inline(always)]
            pub fn is_matchid(&self) -> bool {
                *self == GCID::Matchid
            }
        }
        #[doc = "Field `STOP` reader - Stop After Start and Matching Address"]
        pub type STOP_R = crate::BitReader;
        #[doc = "Device ID Matched\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IDMAT {
            #[doc = "0: Received Address Matched ID Register 0"]
            Id0 = 0,
            #[doc = "1: Received Address Matched ID Register 1"]
            Id1 = 1,
            #[doc = "2: Received Address Matched ID Register 2"]
            Id2 = 2,
            #[doc = "3: Received Address Matched ID Register 3"]
            Id3 = 3,
        }
        impl From<IDMAT> for u8 {
            #[inline(always)]
            fn from(variant: IDMAT) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IDMAT {
            type Ux = u8;
        }
        impl crate::IsEnum for IDMAT {}
        #[doc = "Field `IDMAT` reader - Device ID Matched"]
        pub type IDMAT_R = crate::FieldReader<IDMAT>;
        impl IDMAT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IDMAT {
                match self.bits {
                    0 => IDMAT::Id0,
                    1 => IDMAT::Id1,
                    2 => IDMAT::Id2,
                    3 => IDMAT::Id3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Received Address Matched ID Register 0"]
            #[inline(always)]
            pub fn is_id0(&self) -> bool {
                *self == IDMAT::Id0
            }
            #[doc = "Received Address Matched ID Register 1"]
            #[inline(always)]
            pub fn is_id1(&self) -> bool {
                *self == IDMAT::Id1
            }
            #[doc = "Received Address Matched ID Register 2"]
            #[inline(always)]
            pub fn is_id2(&self) -> bool {
                *self == IDMAT::Id2
            }
            #[doc = "Received Address Matched ID Register 3"]
            #[inline(always)]
            pub fn is_id3(&self) -> bool {
                *self == IDMAT::Id3
            }
        }
        #[doc = "Field `REPSTART` reader - Repeated Start and Matching Address"]
        pub type REPSTART_R = crate::BitReader;
        #[doc = "Field `START` reader - Start and Matching Address"]
        pub type START_R = crate::BitReader;
        #[doc = "Field `SLV_HS_MODE` reader - Slave High Speed Mode Flag"]
        pub type SLV_HS_MODE_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Slave Tx FIFO Status or Early Request"]
            #[inline(always)]
            pub fn stxfsereq(&self) -> STXFSEREQ_R {
                STXFSEREQ_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Slave Transmit FIFO Underflow"]
            #[inline(always)]
            pub fn stxur(&self) -> STXUR_R {
                STXUR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Slave Transmit Interrupt Bit"]
            #[inline(always)]
            pub fn stxreq(&self) -> STXREQ_R {
                STXREQ_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Slave Receive Request"]
            #[inline(always)]
            pub fn srxreq(&self) -> SRXREQ_R {
                SRXREQ_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Slave Receive FIFO Overflow"]
            #[inline(always)]
            pub fn srxof(&self) -> SRXOF_R {
                SRXOF_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Ack Not Generated by the Slave"]
            #[inline(always)]
            pub fn noack(&self) -> NOACK_R {
                NOACK_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Slave Busy"]
            #[inline(always)]
            pub fn sbusy(&self) -> SBUSY_R {
                SBUSY_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - General Call Interrupt"]
            #[inline(always)]
            pub fn gcint(&self) -> GCINT_R {
                GCINT_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bits 8:9 - General ID"]
            #[inline(always)]
            pub fn gcid(&self) -> GCID_R {
                GCID_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bit 10 - Stop After Start and Matching Address"]
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bits 11:12 - Device ID Matched"]
            #[inline(always)]
            pub fn idmat(&self) -> IDMAT_R {
                IDMAT_R::new(((self.bits >> 11) & 3) as u8)
            }
            #[doc = "Bit 13 - Repeated Start and Matching Address"]
            #[inline(always)]
            pub fn repstart(&self) -> REPSTART_R {
                REPSTART_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Start and Matching Address"]
            #[inline(always)]
            pub fn start(&self) -> START_R {
                START_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Slave High Speed Mode Flag"]
            #[inline(always)]
            pub fn slv_hs_mode(&self) -> SLV_HS_MODE_R {
                SLV_HS_MODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SSTAT")
                    .field("stxfsereq", &self.stxfsereq())
                    .field("stxur", &self.stxur())
                    .field("stxreq", &self.stxreq())
                    .field("srxreq", &self.srxreq())
                    .field("srxof", &self.srxof())
                    .field("noack", &self.noack())
                    .field("sbusy", &self.sbusy())
                    .field("gcint", &self.gcint())
                    .field("gcid", &self.gcid())
                    .field("stop", &self.stop())
                    .field("idmat", &self.idmat())
                    .field("repstart", &self.repstart())
                    .field("start", &self.start())
                    .field("slv_hs_mode", &self.slv_hs_mode())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Slave Tx FIFO Status or Early Request"]
            #[inline(always)]
            pub fn stxfsereq(&mut self) -> STXFSEREQ_W<SSTATrs> {
                STXFSEREQ_W::new(self, 0)
            }
        }
        #[doc = "Slave I2C Status/Error/IRQ\n\nYou can [`read`](crate::Reg::read) this register and get [`sstat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sstat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SSTAT)"]
        pub struct SSTATrs;
        impl crate::RegisterSpec for SSTATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sstat::R`](R) reader structure"]
        impl crate::Readable for SSTATrs {}
        #[doc = "`write(|w| ..)` method takes [`sstat::W`](W) writer structure"]
        impl crate::Writable for SSTATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SSTAT to value 0x01"]
        impl crate::Resettable for SSTATrs {
            const RESET_VALUE: u32 = 0x01;
        }
    }
    #[doc = "SRX (rw) register accessor: Slave Receive\n\nYou can [`read`](crate::Reg::read) this register and get [`srx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SRX)\n\nFor information about available fields see [`mod@srx`]
module"]
    pub type SRX = crate::Reg<srx::SRXrs>;
    #[doc = "Slave Receive"]
    pub mod srx {
        #[doc = "Register `SRX` reader"]
        pub type R = crate::R<SRXrs>;
        #[doc = "Register `SRX` writer"]
        pub type W = crate::W<SRXrs>;
        #[doc = "Field `I2CSRX` reader - Slave Receive Register"]
        pub type I2CSRX_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Slave Receive Register"]
            #[inline(always)]
            pub fn i2csrx(&self) -> I2CSRX_R {
                I2CSRX_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRX")
                    .field("i2csrx", &self.i2csrx())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Slave Receive\n\nYou can [`read`](crate::Reg::read) this register and get [`srx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SRX)"]
        pub struct SRXrs;
        impl crate::RegisterSpec for SRXrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srx::R`](R) reader structure"]
        impl crate::Readable for SRXrs {}
        #[doc = "`write(|w| ..)` method takes [`srx::W`](W) writer structure"]
        impl crate::Writable for SRXrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRX to value 0"]
        impl crate::Resettable for SRXrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "STX (rw) register accessor: Slave Transmit\n\nYou can [`read`](crate::Reg::read) this register and get [`stx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:STX)\n\nFor information about available fields see [`mod@stx`]
module"]
    pub type STX = crate::Reg<stx::STXrs>;
    #[doc = "Slave Transmit"]
    pub mod stx {
        #[doc = "Register `STX` reader"]
        pub type R = crate::R<STXrs>;
        #[doc = "Register `STX` writer"]
        pub type W = crate::W<STXrs>;
        #[doc = "Field `I2CSTX` reader - Slave Transmit Register"]
        pub type I2CSTX_R = crate::FieldReader;
        #[doc = "Field `I2CSTX` writer - Slave Transmit Register"]
        pub type I2CSTX_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        #[doc = "ID FIFO Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ID_SEL {
            #[doc = "0: Select Address Matched ID Register 0"]
            Fifo0 = 0,
            #[doc = "1: Select Address Matched ID Register 1"]
            Fifo1 = 1,
            #[doc = "2: Select Address Matched ID Register 2"]
            Fifo2 = 2,
            #[doc = "3: Select Address Matched ID Register 3"]
            Fifo3 = 3,
        }
        impl From<ID_SEL> for u8 {
            #[inline(always)]
            fn from(variant: ID_SEL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ID_SEL {
            type Ux = u8;
        }
        impl crate::IsEnum for ID_SEL {}
        #[doc = "Field `ID_SEL` reader - ID FIFO Selection"]
        pub type ID_SEL_R = crate::FieldReader<ID_SEL>;
        impl ID_SEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ID_SEL {
                match self.bits {
                    0 => ID_SEL::Fifo0,
                    1 => ID_SEL::Fifo1,
                    2 => ID_SEL::Fifo2,
                    3 => ID_SEL::Fifo3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Select Address Matched ID Register 0"]
            #[inline(always)]
            pub fn is_fifo0(&self) -> bool {
                *self == ID_SEL::Fifo0
            }
            #[doc = "Select Address Matched ID Register 1"]
            #[inline(always)]
            pub fn is_fifo1(&self) -> bool {
                *self == ID_SEL::Fifo1
            }
            #[doc = "Select Address Matched ID Register 2"]
            #[inline(always)]
            pub fn is_fifo2(&self) -> bool {
                *self == ID_SEL::Fifo2
            }
            #[doc = "Select Address Matched ID Register 3"]
            #[inline(always)]
            pub fn is_fifo3(&self) -> bool {
                *self == ID_SEL::Fifo3
            }
        }
        #[doc = "Field `ID_SEL` writer - ID FIFO Selection"]
        pub type ID_SEL_W<'a, REG> = crate::FieldWriter<'a, REG, 2, ID_SEL, crate::Safe>;
        impl<'a, REG> ID_SEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Select Address Matched ID Register 0"]
            #[inline(always)]
            pub fn fifo0(self) -> &'a mut crate::W<REG> {
                self.variant(ID_SEL::Fifo0)
            }
            #[doc = "Select Address Matched ID Register 1"]
            #[inline(always)]
            pub fn fifo1(self) -> &'a mut crate::W<REG> {
                self.variant(ID_SEL::Fifo1)
            }
            #[doc = "Select Address Matched ID Register 2"]
            #[inline(always)]
            pub fn fifo2(self) -> &'a mut crate::W<REG> {
                self.variant(ID_SEL::Fifo2)
            }
            #[doc = "Select Address Matched ID Register 3"]
            #[inline(always)]
            pub fn fifo3(self) -> &'a mut crate::W<REG> {
                self.variant(ID_SEL::Fifo3)
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Slave Transmit Register"]
            #[inline(always)]
            pub fn i2cstx(&self) -> I2CSTX_R {
                I2CSTX_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:9 - ID FIFO Selection"]
            #[inline(always)]
            pub fn id_sel(&self) -> ID_SEL_R {
                ID_SEL_R::new(((self.bits >> 8) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STX")
                    .field("i2cstx", &self.i2cstx())
                    .field("id_sel", &self.id_sel())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slave Transmit Register"]
            #[inline(always)]
            pub fn i2cstx(&mut self) -> I2CSTX_W<STXrs> {
                I2CSTX_W::new(self, 0)
            }
            #[doc = "Bits 8:9 - ID FIFO Selection"]
            #[inline(always)]
            pub fn id_sel(&mut self) -> ID_SEL_W<STXrs> {
                ID_SEL_W::new(self, 8)
            }
        }
        #[doc = "Slave Transmit\n\nYou can [`read`](crate::Reg::read) this register and get [`stx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:STX)"]
        pub struct STXrs;
        impl crate::RegisterSpec for STXrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`stx::R`](R) reader structure"]
        impl crate::Readable for STXrs {}
        #[doc = "`write(|w| ..)` method takes [`stx::W`](W) writer structure"]
        impl crate::Writable for STXrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STX to value 0"]
        impl crate::Resettable for STXrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ALT (rw) register accessor: Hardware General Call ID\n\nYou can [`read`](crate::Reg::read) this register and get [`alt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ALT)\n\nFor information about available fields see [`mod@alt`]
module"]
    pub type ALT = crate::Reg<alt::ALTrs>;
    #[doc = "Hardware General Call ID"]
    pub mod alt {
        #[doc = "Register `ALT` reader"]
        pub type R = crate::R<ALTrs>;
        #[doc = "Register `ALT` writer"]
        pub type W = crate::W<ALTrs>;
        #[doc = "Field `ALT` reader - Slave Alt"]
        pub type ALT_R = crate::FieldReader;
        #[doc = "Field `ALT` writer - Slave Alt"]
        pub type ALT_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slave Alt"]
            #[inline(always)]
            pub fn alt(&self) -> ALT_R {
                ALT_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ALT").field("alt", &self.alt()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slave Alt"]
            #[inline(always)]
            pub fn alt(&mut self) -> ALT_W<ALTrs> {
                ALT_W::new(self, 0)
            }
        }
        #[doc = "Hardware General Call ID\n\nYou can [`read`](crate::Reg::read) this register and get [`alt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ALT)"]
        pub struct ALTrs;
        impl crate::RegisterSpec for ALTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`alt::R`](R) reader structure"]
        impl crate::Readable for ALTrs {}
        #[doc = "`write(|w| ..)` method takes [`alt::W`](W) writer structure"]
        impl crate::Writable for ALTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ALT to value 0"]
        impl crate::Resettable for ALTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ID0 (rw) register accessor: 1st Slave Address Device ID\n\nYou can [`read`](crate::Reg::read) this register and get [`id0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`id0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ID0)\n\nFor information about available fields see [`mod@id0`]
module"]
    pub type ID0 = crate::Reg<id0::ID0rs>;
    #[doc = "1st Slave Address Device ID"]
    pub mod id0 {
        #[doc = "Register `ID0` reader"]
        pub type R = crate::R<ID0rs>;
        #[doc = "Register `ID0` writer"]
        pub type W = crate::W<ID0rs>;
        #[doc = "Field `ID0` reader - Slave Device ID 0"]
        pub type ID0_R = crate::FieldReader;
        #[doc = "Field `ID0` writer - Slave Device ID 0"]
        pub type ID0_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slave Device ID 0"]
            #[inline(always)]
            pub fn id0(&self) -> ID0_R {
                ID0_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ID0").field("id0", &self.id0()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slave Device ID 0"]
            #[inline(always)]
            pub fn id0(&mut self) -> ID0_W<ID0rs> {
                ID0_W::new(self, 0)
            }
        }
        #[doc = "1st Slave Address Device ID\n\nYou can [`read`](crate::Reg::read) this register and get [`id0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`id0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ID0)"]
        pub struct ID0rs;
        impl crate::RegisterSpec for ID0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`id0::R`](R) reader structure"]
        impl crate::Readable for ID0rs {}
        #[doc = "`write(|w| ..)` method takes [`id0::W`](W) writer structure"]
        impl crate::Writable for ID0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ID0 to value 0"]
        impl crate::Resettable for ID0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ID1 (rw) register accessor: 2nd Slave Address Device ID\n\nYou can [`read`](crate::Reg::read) this register and get [`id1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`id1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ID1)\n\nFor information about available fields see [`mod@id1`]
module"]
    pub type ID1 = crate::Reg<id1::ID1rs>;
    #[doc = "2nd Slave Address Device ID"]
    pub mod id1 {
        #[doc = "Register `ID1` reader"]
        pub type R = crate::R<ID1rs>;
        #[doc = "Register `ID1` writer"]
        pub type W = crate::W<ID1rs>;
        #[doc = "Field `ID1` reader - Slave Device ID 1"]
        pub type ID1_R = crate::FieldReader;
        #[doc = "Field `ID1` writer - Slave Device ID 1"]
        pub type ID1_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slave Device ID 1"]
            #[inline(always)]
            pub fn id1(&self) -> ID1_R {
                ID1_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ID1").field("id1", &self.id1()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slave Device ID 1"]
            #[inline(always)]
            pub fn id1(&mut self) -> ID1_W<ID1rs> {
                ID1_W::new(self, 0)
            }
        }
        #[doc = "2nd Slave Address Device ID\n\nYou can [`read`](crate::Reg::read) this register and get [`id1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`id1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ID1)"]
        pub struct ID1rs;
        impl crate::RegisterSpec for ID1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`id1::R`](R) reader structure"]
        impl crate::Readable for ID1rs {}
        #[doc = "`write(|w| ..)` method takes [`id1::W`](W) writer structure"]
        impl crate::Writable for ID1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ID1 to value 0"]
        impl crate::Resettable for ID1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ID2 (rw) register accessor: 3rd Slave Address Device ID\n\nYou can [`read`](crate::Reg::read) this register and get [`id2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`id2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ID2)\n\nFor information about available fields see [`mod@id2`]
module"]
    pub type ID2 = crate::Reg<id2::ID2rs>;
    #[doc = "3rd Slave Address Device ID"]
    pub mod id2 {
        #[doc = "Register `ID2` reader"]
        pub type R = crate::R<ID2rs>;
        #[doc = "Register `ID2` writer"]
        pub type W = crate::W<ID2rs>;
        #[doc = "Field `ID2` reader - Slave Device ID 2"]
        pub type ID2_R = crate::FieldReader;
        #[doc = "Field `ID2` writer - Slave Device ID 2"]
        pub type ID2_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slave Device ID 2"]
            #[inline(always)]
            pub fn id2(&self) -> ID2_R {
                ID2_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ID2").field("id2", &self.id2()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slave Device ID 2"]
            #[inline(always)]
            pub fn id2(&mut self) -> ID2_W<ID2rs> {
                ID2_W::new(self, 0)
            }
        }
        #[doc = "3rd Slave Address Device ID\n\nYou can [`read`](crate::Reg::read) this register and get [`id2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`id2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ID2)"]
        pub struct ID2rs;
        impl crate::RegisterSpec for ID2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`id2::R`](R) reader structure"]
        impl crate::Readable for ID2rs {}
        #[doc = "`write(|w| ..)` method takes [`id2::W`](W) writer structure"]
        impl crate::Writable for ID2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ID2 to value 0"]
        impl crate::Resettable for ID2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ID3 (rw) register accessor: 4th Slave Address Device ID\n\nYou can [`read`](crate::Reg::read) this register and get [`id3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`id3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ID3)\n\nFor information about available fields see [`mod@id3`]
module"]
    pub type ID3 = crate::Reg<id3::ID3rs>;
    #[doc = "4th Slave Address Device ID"]
    pub mod id3 {
        #[doc = "Register `ID3` reader"]
        pub type R = crate::R<ID3rs>;
        #[doc = "Register `ID3` writer"]
        pub type W = crate::W<ID3rs>;
        #[doc = "Field `ID3` reader - Slave Device ID 3"]
        pub type ID3_R = crate::FieldReader;
        #[doc = "Field `ID3` writer - Slave Device ID 3"]
        pub type ID3_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slave Device ID 3"]
            #[inline(always)]
            pub fn id3(&self) -> ID3_R {
                ID3_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ID3").field("id3", &self.id3()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slave Device ID 3"]
            #[inline(always)]
            pub fn id3(&mut self) -> ID3_W<ID3rs> {
                ID3_W::new(self, 0)
            }
        }
        #[doc = "4th Slave Address Device ID\n\nYou can [`read`](crate::Reg::read) this register and get [`id3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`id3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ID3)"]
        pub struct ID3rs;
        impl crate::RegisterSpec for ID3rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`id3::R`](R) reader structure"]
        impl crate::Readable for ID3rs {}
        #[doc = "`write(|w| ..)` method takes [`id3::W`](W) writer structure"]
        impl crate::Writable for ID3rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ID3 to value 0"]
        impl crate::Resettable for ID3rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "STAT (rw) register accessor: Master and Slave FIFO Status\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:STAT)\n\nFor information about available fields see [`mod@stat`]
module"]
    pub type STAT = crate::Reg<stat::STATrs>;
    #[doc = "Master and Slave FIFO Status"]
    pub mod stat {
        #[doc = "Register `STAT` reader"]
        pub type R = crate::R<STATrs>;
        #[doc = "Register `STAT` writer"]
        pub type W = crate::W<STATrs>;
        #[doc = "Slave Transmit FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STXFSTA {
            #[doc = "0: FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Bytes in the FIFO"]
            One = 1,
            #[doc = "2: 2 Bytes in the FIFO"]
            Two = 2,
        }
        impl From<STXFSTA> for u8 {
            #[inline(always)]
            fn from(variant: STXFSTA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for STXFSTA {
            type Ux = u8;
        }
        impl crate::IsEnum for STXFSTA {}
        #[doc = "Field `STXFSTA` reader - Slave Transmit FIFO Status"]
        pub type STXFSTA_R = crate::FieldReader<STXFSTA>;
        impl STXFSTA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> STXFSTA {
                match self.bits {
                    0 => STXFSTA::Empty,
                    1 => STXFSTA::One,
                    2 => STXFSTA::Two,
                    _ => unreachable!(),
                }
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == STXFSTA::Empty
            }
            #[doc = "1 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == STXFSTA::One
            }
            #[doc = "2 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == STXFSTA::Two
            }
        }
        #[doc = "Slave Receive FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SRXFSTA {
            #[doc = "0: FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Bytes in the FIFO"]
            One = 1,
            #[doc = "2: 2 Bytes in the FIFO"]
            Two = 2,
        }
        impl From<SRXFSTA> for u8 {
            #[inline(always)]
            fn from(variant: SRXFSTA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for SRXFSTA {
            type Ux = u8;
        }
        impl crate::IsEnum for SRXFSTA {}
        #[doc = "Field `SRXFSTA` reader - Slave Receive FIFO Status"]
        pub type SRXFSTA_R = crate::FieldReader<SRXFSTA>;
        impl SRXFSTA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SRXFSTA {
                match self.bits {
                    0 => SRXFSTA::Empty,
                    1 => SRXFSTA::One,
                    2 => SRXFSTA::Two,
                    _ => unreachable!(),
                }
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == SRXFSTA::Empty
            }
            #[doc = "1 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == SRXFSTA::One
            }
            #[doc = "2 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == SRXFSTA::Two
            }
        }
        #[doc = "Master Transmit FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MTXSFA {
            #[doc = "0: FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Bytes in the FIFO"]
            One = 1,
            #[doc = "2: 2 Bytes in the FIFO"]
            Two = 2,
        }
        impl From<MTXSFA> for u8 {
            #[inline(always)]
            fn from(variant: MTXSFA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for MTXSFA {
            type Ux = u8;
        }
        impl crate::IsEnum for MTXSFA {}
        #[doc = "Field `MTXSFA` reader - Master Transmit FIFO Status"]
        pub type MTXSFA_R = crate::FieldReader<MTXSFA>;
        impl MTXSFA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MTXSFA {
                match self.bits {
                    0 => MTXSFA::Empty,
                    1 => MTXSFA::One,
                    2 => MTXSFA::Two,
                    _ => unreachable!(),
                }
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == MTXSFA::Empty
            }
            #[doc = "1 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == MTXSFA::One
            }
            #[doc = "2 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == MTXSFA::Two
            }
        }
        #[doc = "Master Receive FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MRXFSTA {
            #[doc = "0: FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Bytes In The FIFO"]
            One = 1,
            #[doc = "2: 2 Bytes in the FIFO"]
            Two = 2,
        }
        impl From<MRXFSTA> for u8 {
            #[inline(always)]
            fn from(variant: MRXFSTA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for MRXFSTA {
            type Ux = u8;
        }
        impl crate::IsEnum for MRXFSTA {}
        #[doc = "Field `MRXFSTA` reader - Master Receive FIFO Status"]
        pub type MRXFSTA_R = crate::FieldReader<MRXFSTA>;
        impl MRXFSTA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MRXFSTA {
                match self.bits {
                    0 => MRXFSTA::Empty,
                    1 => MRXFSTA::One,
                    2 => MRXFSTA::Two,
                    _ => unreachable!(),
                }
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == MRXFSTA::Empty
            }
            #[doc = "1 Bytes In The FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == MRXFSTA::One
            }
            #[doc = "2 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == MRXFSTA::Two
            }
        }
        #[doc = "Field `SFLUSH` writer - Flush the Slave Transmit FIFO"]
        pub type SFLUSH_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MFLUSH` writer - Flush the Master Transmit FIFO"]
        pub type MFLUSH_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STX_FLUSH_ALL` reader - Flush All the Slave Transmit ID FIFOs."]
        pub type STX_FLUSH_ALL_R = crate::BitReader;
        #[doc = "Field `STX_FLUSH_ALL` writer - Flush All the Slave Transmit ID FIFOs."]
        pub type STX_FLUSH_ALL_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - Slave Transmit FIFO Status"]
            #[inline(always)]
            pub fn stxfsta(&self) -> STXFSTA_R {
                STXFSTA_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Slave Receive FIFO Status"]
            #[inline(always)]
            pub fn srxfsta(&self) -> SRXFSTA_R {
                SRXFSTA_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Master Transmit FIFO Status"]
            #[inline(always)]
            pub fn mtxsfa(&self) -> MTXSFA_R {
                MTXSFA_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Master Receive FIFO Status"]
            #[inline(always)]
            pub fn mrxfsta(&self) -> MRXFSTA_R {
                MRXFSTA_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bit 10 - Flush All the Slave Transmit ID FIFOs."]
            #[inline(always)]
            pub fn stx_flush_all(&self) -> STX_FLUSH_ALL_R {
                STX_FLUSH_ALL_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STAT")
                    .field("stxfsta", &self.stxfsta())
                    .field("srxfsta", &self.srxfsta())
                    .field("mtxsfa", &self.mtxsfa())
                    .field("mrxfsta", &self.mrxfsta())
                    .field("stx_flush_all", &self.stx_flush_all())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 8 - Flush the Slave Transmit FIFO"]
            #[inline(always)]
            pub fn sflush(&mut self) -> SFLUSH_W<STATrs> {
                SFLUSH_W::new(self, 8)
            }
            #[doc = "Bit 9 - Flush the Master Transmit FIFO"]
            #[inline(always)]
            pub fn mflush(&mut self) -> MFLUSH_W<STATrs> {
                MFLUSH_W::new(self, 9)
            }
            #[doc = "Bit 10 - Flush All the Slave Transmit ID FIFOs."]
            #[inline(always)]
            pub fn stx_flush_all(&mut self) -> STX_FLUSH_ALL_W<STATrs> {
                STX_FLUSH_ALL_W::new(self, 10)
            }
        }
        #[doc = "Master and Slave FIFO Status\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:STAT)"]
        pub struct STATrs;
        impl crate::RegisterSpec for STATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`stat::R`](R) reader structure"]
        impl crate::Readable for STATrs {}
        #[doc = "`write(|w| ..)` method takes [`stat::W`](W) writer structure"]
        impl crate::Writable for STATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STAT to value 0"]
        impl crate::Resettable for STATrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SHCTL (rw) register accessor: Shared Control\n\nYou can [`read`](crate::Reg::read) this register and get [`shctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`shctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SHCTL)\n\nFor information about available fields see [`mod@shctl`]
module"]
    pub type SHCTL = crate::Reg<shctl::SHCTLrs>;
    #[doc = "Shared Control"]
    pub mod shctl {
        #[doc = "Register `SHCTL` reader"]
        pub type R = crate::R<SHCTLrs>;
        #[doc = "Register `SHCTL` writer"]
        pub type W = crate::W<SHCTLrs>;
        #[doc = "Field `RESET` writer - Reset START STOP Detect Circuit"]
        pub type RESET_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADR_BUSY` reader - ADR Busy Flag"]
        pub type ADR_BUSY_R = crate::BitReader;
        #[doc = "Field `SDA_DLY` reader - Delay Between SDAOUT and SDAOEN"]
        pub type SDA_DLY_R = crate::FieldReader;
        #[doc = "Field `SDA_DLY` writer - Delay Between SDAOUT and SDAOEN"]
        pub type SDA_DLY_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        #[doc = "Field `SCL_DLY` reader - Delay Between SCLOUT and SCLOEN"]
        pub type SCL_DLY_R = crate::FieldReader;
        #[doc = "Field `SCL_DLY` writer - Delay Between SCLOUT and SCLOEN"]
        pub type SCL_DLY_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        impl R {
            #[doc = "Bit 6 - ADR Busy Flag"]
            #[inline(always)]
            pub fn adr_busy(&self) -> ADR_BUSY_R {
                ADR_BUSY_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bits 8:11 - Delay Between SDAOUT and SDAOEN"]
            #[inline(always)]
            pub fn sda_dly(&self) -> SDA_DLY_R {
                SDA_DLY_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - Delay Between SCLOUT and SCLOEN"]
            #[inline(always)]
            pub fn scl_dly(&self) -> SCL_DLY_R {
                SCL_DLY_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SHCTL")
                    .field("adr_busy", &self.adr_busy())
                    .field("sda_dly", &self.sda_dly())
                    .field("scl_dly", &self.scl_dly())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Reset START STOP Detect Circuit"]
            #[inline(always)]
            pub fn reset(&mut self) -> RESET_W<SHCTLrs> {
                RESET_W::new(self, 0)
            }
            #[doc = "Bits 8:11 - Delay Between SDAOUT and SDAOEN"]
            #[inline(always)]
            pub fn sda_dly(&mut self) -> SDA_DLY_W<SHCTLrs> {
                SDA_DLY_W::new(self, 8)
            }
            #[doc = "Bits 12:15 - Delay Between SCLOUT and SCLOEN"]
            #[inline(always)]
            pub fn scl_dly(&mut self) -> SCL_DLY_W<SHCTLrs> {
                SCL_DLY_W::new(self, 12)
            }
        }
        #[doc = "Shared Control\n\nYou can [`read`](crate::Reg::read) this register and get [`shctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`shctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SHCTL)"]
        pub struct SHCTLrs;
        impl crate::RegisterSpec for SHCTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`shctl::R`](R) reader structure"]
        impl crate::Readable for SHCTLrs {}
        #[doc = "`write(|w| ..)` method takes [`shctl::W`](W) writer structure"]
        impl crate::Writable for SHCTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SHCTL to value 0"]
        impl crate::Resettable for SHCTLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "TCTL (rw) register accessor: Timing Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:TCTL)\n\nFor information about available fields see [`mod@tctl`]
module"]
    pub type TCTL = crate::Reg<tctl::TCTLrs>;
    #[doc = "Timing Control Register"]
    pub mod tctl {
        #[doc = "Register `TCTL` reader"]
        pub type R = crate::R<TCTLrs>;
        #[doc = "Register `TCTL` writer"]
        pub type W = crate::W<TCTLrs>;
        #[doc = "Field `THDATIN` reader - Data in Hold Start"]
        pub type THDATIN_R = crate::FieldReader;
        #[doc = "Field `THDATIN` writer - Data in Hold Start"]
        pub type THDATIN_W<'a, REG> = crate::FieldWriter<'a, REG, 6, u8, crate::Safe>;
        #[doc = "Field `FILTEROFF` reader - Input Filter Control"]
        pub type FILTEROFF_R = crate::BitReader;
        #[doc = "Field `FILTEROFF` writer - Input Filter Control"]
        pub type FILTEROFF_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PRE_DIV` reader - Presale Divide Counter for SCK DIV"]
        pub type PRE_DIV_R = crate::FieldReader;
        #[doc = "Field `PRE_DIV` writer - Presale Divide Counter for SCK DIV"]
        pub type PRE_DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 3, u8, crate::Safe>;
        #[doc = "Field `FILTER_TICKS` reader - SCK & SDA Gglitch Filter Ticks."]
        pub type FILTER_TICKS_R = crate::FieldReader;
        #[doc = "Field `FILTER_TICKS` writer - SCK & SDA Gglitch Filter Ticks."]
        pub type FILTER_TICKS_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:5 - Data in Hold Start"]
            #[inline(always)]
            pub fn thdatin(&self) -> THDATIN_R {
                THDATIN_R::new((self.bits & 0x3f) as u8)
            }
            #[doc = "Bit 8 - Input Filter Control"]
            #[inline(always)]
            pub fn filteroff(&self) -> FILTEROFF_R {
                FILTEROFF_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bits 9:11 - Presale Divide Counter for SCK DIV"]
            #[inline(always)]
            pub fn pre_div(&self) -> PRE_DIV_R {
                PRE_DIV_R::new(((self.bits >> 9) & 7) as u8)
            }
            #[doc = "Bits 12:15 - SCK & SDA Gglitch Filter Ticks."]
            #[inline(always)]
            pub fn filter_ticks(&self) -> FILTER_TICKS_R {
                FILTER_TICKS_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TCTL")
                    .field("thdatin", &self.thdatin())
                    .field("filteroff", &self.filteroff())
                    .field("pre_div", &self.pre_div())
                    .field("filter_ticks", &self.filter_ticks())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:5 - Data in Hold Start"]
            #[inline(always)]
            pub fn thdatin(&mut self) -> THDATIN_W<TCTLrs> {
                THDATIN_W::new(self, 0)
            }
            #[doc = "Bit 8 - Input Filter Control"]
            #[inline(always)]
            pub fn filteroff(&mut self) -> FILTEROFF_W<TCTLrs> {
                FILTEROFF_W::new(self, 8)
            }
            #[doc = "Bits 9:11 - Presale Divide Counter for SCK DIV"]
            #[inline(always)]
            pub fn pre_div(&mut self) -> PRE_DIV_W<TCTLrs> {
                PRE_DIV_W::new(self, 9)
            }
            #[doc = "Bits 12:15 - SCK & SDA Gglitch Filter Ticks."]
            #[inline(always)]
            pub fn filter_ticks(&mut self) -> FILTER_TICKS_W<TCTLrs> {
                FILTER_TICKS_W::new(self, 12)
            }
        }
        #[doc = "Timing Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:TCTL)"]
        pub struct TCTLrs;
        impl crate::RegisterSpec for TCTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tctl::R`](R) reader structure"]
        impl crate::Readable for TCTLrs {}
        #[doc = "`write(|w| ..)` method takes [`tctl::W`](W) writer structure"]
        impl crate::Writable for TCTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TCTL to value 0x0205"]
        impl crate::Resettable for TCTLrs {
            const RESET_VALUE: u32 = 0x0205;
        }
    }
    #[doc = "ASTRETCH_SCL (rw) register accessor: Automatic Stretch SCL Register\n\nYou can [`read`](crate::Reg::read) this register and get [`astretch_scl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`astretch_scl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ASTRETCH_SCL)\n\nFor information about available fields see [`mod@astretch_scl`]
module"]
    pub type ASTRETCH_SCL = crate::Reg<astretch_scl::ASTRETCH_SCLrs>;
    #[doc = "Automatic Stretch SCL Register"]
    pub mod astretch_scl {
        #[doc = "Register `ASTRETCH_SCL` reader"]
        pub type R = crate::R<ASTRETCH_SCLrs>;
        #[doc = "Register `ASTRETCH_SCL` writer"]
        pub type W = crate::W<ASTRETCH_SCLrs>;
        #[doc = "Field `stretch_mode_mas` reader - Master Automatic Stretch Mode"]
        pub type STRETCH_MODE_MAS_R = crate::FieldReader;
        #[doc = "Field `stretch_mode_mas` writer - Master Automatic Stretch Mode"]
        pub type STRETCH_MODE_MAS_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        #[doc = "Field `strecth_mode_slv` reader - Slave Automatic Stretch Mode"]
        pub type STRECTH_MODE_SLV_R = crate::FieldReader;
        #[doc = "Field `strecth_mode_slv` writer - Slave Automatic Stretch Mode"]
        pub type STRECTH_MODE_SLV_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        #[doc = "Field `timeout_sscl_mas` reader - Master Automatic Stretch Timeout"]
        pub type TIMEOUT_SSCL_MAS_R = crate::BitReader;
        #[doc = "Field `timeout_sscl_slv` reader - Slave Automatic Stretch Timeout"]
        pub type TIMEOUT_SSCL_SLV_R = crate::BitReader;
        #[doc = "Field `MAN_RLS_EN` reader - Manual Release Stretch Enable"]
        pub type MAN_RLS_EN_R = crate::BitReader;
        #[doc = "Field `MAN_RLS_EN` writer - Manual Release Stretch Enable"]
        pub type MAN_RLS_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `sscl_after_ack` reader - Slave RX Stretch After ACK Mode"]
        pub type SSCL_AFTER_ACK_R = crate::BitReader;
        #[doc = "Field `sscl_after_ack` writer - Slave RX Stretch After ACK Mode"]
        pub type SSCL_AFTER_ACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SSCL_RLS` reader - Slave Manual Clear Stretch"]
        pub type SSCL_RLS_R = crate::BitReader;
        #[doc = "Field `SSCL_RLS` writer - Slave Manual Clear Stretch"]
        pub type SSCL_RLS_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `addr_ack_ien` reader - Slave ADDRESS ACK Interruption Enable"]
        pub type ADDR_ACK_IEN_R = crate::BitReader;
        #[doc = "Field `addr_ack_ien` writer - Slave ADDRESS ACK Interruption Enable"]
        pub type ADDR_ACK_IEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `sscl_irq_ien` reader - Slave Stretch Interruption Enable"]
        pub type SSCL_IRQ_IEN_R = crate::BitReader;
        #[doc = "Field `sscl_irq_ien` writer - Slave Stretch Interruption Enable"]
        pub type SSCL_IRQ_IEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `clr_addr_ack_irq` writer - Write Clear the Address ACK IRQ."]
        pub type CLR_ADDR_ACK_IRQ_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:3 - Master Automatic Stretch Mode"]
            #[inline(always)]
            pub fn stretch_mode_mas(&self) -> STRETCH_MODE_MAS_R {
                STRETCH_MODE_MAS_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Slave Automatic Stretch Mode"]
            #[inline(always)]
            pub fn strecth_mode_slv(&self) -> STRECTH_MODE_SLV_R {
                STRECTH_MODE_SLV_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bit 8 - Master Automatic Stretch Timeout"]
            #[inline(always)]
            pub fn timeout_sscl_mas(&self) -> TIMEOUT_SSCL_MAS_R {
                TIMEOUT_SSCL_MAS_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Slave Automatic Stretch Timeout"]
            #[inline(always)]
            pub fn timeout_sscl_slv(&self) -> TIMEOUT_SSCL_SLV_R {
                TIMEOUT_SSCL_SLV_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Manual Release Stretch Enable"]
            #[inline(always)]
            pub fn man_rls_en(&self) -> MAN_RLS_EN_R {
                MAN_RLS_EN_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Slave RX Stretch After ACK Mode"]
            #[inline(always)]
            pub fn sscl_after_ack(&self) -> SSCL_AFTER_ACK_R {
                SSCL_AFTER_ACK_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Slave Manual Clear Stretch"]
            #[inline(always)]
            pub fn sscl_rls(&self) -> SSCL_RLS_R {
                SSCL_RLS_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Slave ADDRESS ACK Interruption Enable"]
            #[inline(always)]
            pub fn addr_ack_ien(&self) -> ADDR_ACK_IEN_R {
                ADDR_ACK_IEN_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Slave Stretch Interruption Enable"]
            #[inline(always)]
            pub fn sscl_irq_ien(&self) -> SSCL_IRQ_IEN_R {
                SSCL_IRQ_IEN_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ASTRETCH_SCL")
                    .field("stretch_mode_mas", &self.stretch_mode_mas())
                    .field("strecth_mode_slv", &self.strecth_mode_slv())
                    .field("timeout_sscl_mas", &self.timeout_sscl_mas())
                    .field("timeout_sscl_slv", &self.timeout_sscl_slv())
                    .field("man_rls_en", &self.man_rls_en())
                    .field("sscl_after_ack", &self.sscl_after_ack())
                    .field("sscl_rls", &self.sscl_rls())
                    .field("addr_ack_ien", &self.addr_ack_ien())
                    .field("sscl_irq_ien", &self.sscl_irq_ien())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Master Automatic Stretch Mode"]
            #[inline(always)]
            pub fn stretch_mode_mas(&mut self) -> STRETCH_MODE_MAS_W<ASTRETCH_SCLrs> {
                STRETCH_MODE_MAS_W::new(self, 0)
            }
            #[doc = "Bits 4:7 - Slave Automatic Stretch Mode"]
            #[inline(always)]
            pub fn strecth_mode_slv(&mut self) -> STRECTH_MODE_SLV_W<ASTRETCH_SCLrs> {
                STRECTH_MODE_SLV_W::new(self, 4)
            }
            #[doc = "Bit 10 - Manual Release Stretch Enable"]
            #[inline(always)]
            pub fn man_rls_en(&mut self) -> MAN_RLS_EN_W<ASTRETCH_SCLrs> {
                MAN_RLS_EN_W::new(self, 10)
            }
            #[doc = "Bit 11 - Slave RX Stretch After ACK Mode"]
            #[inline(always)]
            pub fn sscl_after_ack(&mut self) -> SSCL_AFTER_ACK_W<ASTRETCH_SCLrs> {
                SSCL_AFTER_ACK_W::new(self, 11)
            }
            #[doc = "Bit 12 - Slave Manual Clear Stretch"]
            #[inline(always)]
            pub fn sscl_rls(&mut self) -> SSCL_RLS_W<ASTRETCH_SCLrs> {
                SSCL_RLS_W::new(self, 12)
            }
            #[doc = "Bit 13 - Slave ADDRESS ACK Interruption Enable"]
            #[inline(always)]
            pub fn addr_ack_ien(&mut self) -> ADDR_ACK_IEN_W<ASTRETCH_SCLrs> {
                ADDR_ACK_IEN_W::new(self, 13)
            }
            #[doc = "Bit 14 - Slave Stretch Interruption Enable"]
            #[inline(always)]
            pub fn sscl_irq_ien(&mut self) -> SSCL_IRQ_IEN_W<ASTRETCH_SCLrs> {
                SSCL_IRQ_IEN_W::new(self, 14)
            }
            #[doc = "Bit 15 - Write Clear the Address ACK IRQ."]
            #[inline(always)]
            pub fn clr_addr_ack_irq(&mut self) -> CLR_ADDR_ACK_IRQ_W<ASTRETCH_SCLrs> {
                CLR_ADDR_ACK_IRQ_W::new(self, 15)
            }
        }
        #[doc = "Automatic Stretch SCL Register\n\nYou can [`read`](crate::Reg::read) this register and get [`astretch_scl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`astretch_scl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:ASTRETCH_SCL)"]
        pub struct ASTRETCH_SCLrs;
        impl crate::RegisterSpec for ASTRETCH_SCLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`astretch_scl::R`](R) reader structure"]
        impl crate::Readable for ASTRETCH_SCLrs {}
        #[doc = "`write(|w| ..)` method takes [`astretch_scl::W`](W) writer structure"]
        impl crate::Writable for ASTRETCH_SCLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ASTRETCH_SCL to value 0"]
        impl crate::Resettable for ASTRETCH_SCLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "IDFSTA (rw) register accessor: ID FIFO Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`idfsta::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idfsta::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:IDFSTA)\n\nFor information about available fields see [`mod@idfsta`]
module"]
    pub type IDFSTA = crate::Reg<idfsta::IDFSTArs>;
    #[doc = "ID FIFO Status Register"]
    pub mod idfsta {
        #[doc = "Register `IDFSTA` reader"]
        pub type R = crate::R<IDFSTArs>;
        #[doc = "Register `IDFSTA` writer"]
        pub type W = crate::W<IDFSTArs>;
        #[doc = "Slave Transmit ID0 FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STX0FSTA {
            #[doc = "0: FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Bytes in the FIFO"]
            One = 1,
            #[doc = "2: 2 Bytes in the FIFO"]
            Two = 2,
        }
        impl From<STX0FSTA> for u8 {
            #[inline(always)]
            fn from(variant: STX0FSTA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for STX0FSTA {
            type Ux = u8;
        }
        impl crate::IsEnum for STX0FSTA {}
        #[doc = "Field `STX0FSTA` reader - Slave Transmit ID0 FIFO Status"]
        pub type STX0FSTA_R = crate::FieldReader<STX0FSTA>;
        impl STX0FSTA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> STX0FSTA {
                match self.bits {
                    0 => STX0FSTA::Empty,
                    1 => STX0FSTA::One,
                    2 => STX0FSTA::Two,
                    _ => unreachable!(),
                }
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == STX0FSTA::Empty
            }
            #[doc = "1 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == STX0FSTA::One
            }
            #[doc = "2 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == STX0FSTA::Two
            }
        }
        #[doc = "Slave Transmit ID1 FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STX1FSTA {
            #[doc = "0: FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Bytes in the FIFO"]
            One = 1,
            #[doc = "2: 2 Bytes in the FIFO"]
            Two = 2,
        }
        impl From<STX1FSTA> for u8 {
            #[inline(always)]
            fn from(variant: STX1FSTA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for STX1FSTA {
            type Ux = u8;
        }
        impl crate::IsEnum for STX1FSTA {}
        #[doc = "Field `STX1FSTA` reader - Slave Transmit ID1 FIFO Status"]
        pub type STX1FSTA_R = crate::FieldReader<STX1FSTA>;
        impl STX1FSTA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> STX1FSTA {
                match self.bits {
                    0 => STX1FSTA::Empty,
                    1 => STX1FSTA::One,
                    2 => STX1FSTA::Two,
                    _ => unreachable!(),
                }
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == STX1FSTA::Empty
            }
            #[doc = "1 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == STX1FSTA::One
            }
            #[doc = "2 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == STX1FSTA::Two
            }
        }
        #[doc = "Slave Transmit ID2 FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STX2FSTA {
            #[doc = "0: FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Bytes in the FIFO"]
            One = 1,
            #[doc = "2: 2 Bytes in the FIFO"]
            Two = 2,
        }
        impl From<STX2FSTA> for u8 {
            #[inline(always)]
            fn from(variant: STX2FSTA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for STX2FSTA {
            type Ux = u8;
        }
        impl crate::IsEnum for STX2FSTA {}
        #[doc = "Field `STX2FSTA` reader - Slave Transmit ID2 FIFO Status"]
        pub type STX2FSTA_R = crate::FieldReader<STX2FSTA>;
        impl STX2FSTA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> STX2FSTA {
                match self.bits {
                    0 => STX2FSTA::Empty,
                    1 => STX2FSTA::One,
                    2 => STX2FSTA::Two,
                    _ => unreachable!(),
                }
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == STX2FSTA::Empty
            }
            #[doc = "1 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == STX2FSTA::One
            }
            #[doc = "2 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == STX2FSTA::Two
            }
        }
        #[doc = "Slave Transmit ID3 FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STX3FSTA {
            #[doc = "0: FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Bytes in the FIFO"]
            One = 1,
            #[doc = "2: 2 Bytes in the FIFO"]
            Two = 2,
        }
        impl From<STX3FSTA> for u8 {
            #[inline(always)]
            fn from(variant: STX3FSTA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for STX3FSTA {
            type Ux = u8;
        }
        impl crate::IsEnum for STX3FSTA {}
        #[doc = "Field `STX3FSTA` reader - Slave Transmit ID3 FIFO Status"]
        pub type STX3FSTA_R = crate::FieldReader<STX3FSTA>;
        impl STX3FSTA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> STX3FSTA {
                match self.bits {
                    0 => STX3FSTA::Empty,
                    1 => STX3FSTA::One,
                    2 => STX3FSTA::Two,
                    _ => unreachable!(),
                }
            }
            #[doc = "FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == STX3FSTA::Empty
            }
            #[doc = "1 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == STX3FSTA::One
            }
            #[doc = "2 Bytes in the FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == STX3FSTA::Two
            }
        }
        #[doc = "Field `SFLUSH0` writer - Flush the Slave Transmit ID0 FIFO"]
        pub type SFLUSH0_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SFLUSH1` writer - Flush the Slave Transmit ID1 FIFO"]
        pub type SFLUSH1_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SFLUSH2` writer - Flush the Slave Transmit ID2 FIFO"]
        pub type SFLUSH2_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SFLUSH3` writer - Flush the Slave Transmit ID3 FIFO"]
        pub type SFLUSH3_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STX0UR` reader - Slave Transmit ID0 FIFO Underflow"]
        pub type STX0UR_R = crate::BitReader;
        #[doc = "Field `STX1UR` reader - Slave Transmit ID1 FIFO Underflow"]
        pub type STX1UR_R = crate::BitReader;
        #[doc = "Field `STX2UR` reader - Slave Transmit ID2 FIFO Underflow"]
        pub type STX2UR_R = crate::BitReader;
        #[doc = "Field `STX3UR` reader - Slave Transmit ID3 FIFO Underflow"]
        pub type STX3UR_R = crate::BitReader;
        impl R {
            #[doc = "Bits 0:1 - Slave Transmit ID0 FIFO Status"]
            #[inline(always)]
            pub fn stx0fsta(&self) -> STX0FSTA_R {
                STX0FSTA_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Slave Transmit ID1 FIFO Status"]
            #[inline(always)]
            pub fn stx1fsta(&self) -> STX1FSTA_R {
                STX1FSTA_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Slave Transmit ID2 FIFO Status"]
            #[inline(always)]
            pub fn stx2fsta(&self) -> STX2FSTA_R {
                STX2FSTA_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Slave Transmit ID3 FIFO Status"]
            #[inline(always)]
            pub fn stx3fsta(&self) -> STX3FSTA_R {
                STX3FSTA_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bit 12 - Slave Transmit ID0 FIFO Underflow"]
            #[inline(always)]
            pub fn stx0ur(&self) -> STX0UR_R {
                STX0UR_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Slave Transmit ID1 FIFO Underflow"]
            #[inline(always)]
            pub fn stx1ur(&self) -> STX1UR_R {
                STX1UR_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Slave Transmit ID2 FIFO Underflow"]
            #[inline(always)]
            pub fn stx2ur(&self) -> STX2UR_R {
                STX2UR_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Slave Transmit ID3 FIFO Underflow"]
            #[inline(always)]
            pub fn stx3ur(&self) -> STX3UR_R {
                STX3UR_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IDFSTA")
                    .field("stx0fsta", &self.stx0fsta())
                    .field("stx1fsta", &self.stx1fsta())
                    .field("stx2fsta", &self.stx2fsta())
                    .field("stx3fsta", &self.stx3fsta())
                    .field("stx0ur", &self.stx0ur())
                    .field("stx1ur", &self.stx1ur())
                    .field("stx2ur", &self.stx2ur())
                    .field("stx3ur", &self.stx3ur())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 8 - Flush the Slave Transmit ID0 FIFO"]
            #[inline(always)]
            pub fn sflush0(&mut self) -> SFLUSH0_W<IDFSTArs> {
                SFLUSH0_W::new(self, 8)
            }
            #[doc = "Bit 9 - Flush the Slave Transmit ID1 FIFO"]
            #[inline(always)]
            pub fn sflush1(&mut self) -> SFLUSH1_W<IDFSTArs> {
                SFLUSH1_W::new(self, 9)
            }
            #[doc = "Bit 10 - Flush the Slave Transmit ID2 FIFO"]
            #[inline(always)]
            pub fn sflush2(&mut self) -> SFLUSH2_W<IDFSTArs> {
                SFLUSH2_W::new(self, 10)
            }
            #[doc = "Bit 11 - Flush the Slave Transmit ID3 FIFO"]
            #[inline(always)]
            pub fn sflush3(&mut self) -> SFLUSH3_W<IDFSTArs> {
                SFLUSH3_W::new(self, 11)
            }
        }
        #[doc = "ID FIFO Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`idfsta::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idfsta::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:IDFSTA)"]
        pub struct IDFSTArs;
        impl crate::RegisterSpec for IDFSTArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`idfsta::R`](R) reader structure"]
        impl crate::Readable for IDFSTArs {}
        #[doc = "`write(|w| ..)` method takes [`idfsta::W`](W) writer structure"]
        impl crate::Writable for IDFSTArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets IDFSTA to value 0"]
        impl crate::Resettable for IDFSTArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SLV_ADDR1 (rw) register accessor: Slave 10 Bits Address 1st Byte.\n\nYou can [`read`](crate::Reg::read) this register and get [`slv_addr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slv_addr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SLV_ADDR1)\n\nFor information about available fields see [`mod@slv_addr1`]
module"]
    pub type SLV_ADDR1 = crate::Reg<slv_addr1::SLV_ADDR1rs>;
    #[doc = "Slave 10 Bits Address 1st Byte."]
    pub mod slv_addr1 {
        #[doc = "Register `SLV_ADDR1` reader"]
        pub type R = crate::R<SLV_ADDR1rs>;
        #[doc = "Register `SLV_ADDR1` writer"]
        pub type W = crate::W<SLV_ADDR1rs>;
        #[doc = "Field `SLV_ADR1` reader - Slave 10 Bits Address 1st Byte"]
        pub type SLV_ADR1_R = crate::FieldReader;
        #[doc = "Field `SLV_ADR1` writer - Slave 10 Bits Address 1st Byte"]
        pub type SLV_ADR1_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slave 10 Bits Address 1st Byte"]
            #[inline(always)]
            pub fn slv_adr1(&self) -> SLV_ADR1_R {
                SLV_ADR1_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SLV_ADDR1")
                    .field("slv_adr1", &self.slv_adr1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slave 10 Bits Address 1st Byte"]
            #[inline(always)]
            pub fn slv_adr1(&mut self) -> SLV_ADR1_W<SLV_ADDR1rs> {
                SLV_ADR1_W::new(self, 0)
            }
        }
        #[doc = "Slave 10 Bits Address 1st Byte.\n\nYou can [`read`](crate::Reg::read) this register and get [`slv_addr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slv_addr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SLV_ADDR1)"]
        pub struct SLV_ADDR1rs;
        impl crate::RegisterSpec for SLV_ADDR1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`slv_addr1::R`](R) reader structure"]
        impl crate::Readable for SLV_ADDR1rs {}
        #[doc = "`write(|w| ..)` method takes [`slv_addr1::W`](W) writer structure"]
        impl crate::Writable for SLV_ADDR1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SLV_ADDR1 to value 0"]
        impl crate::Resettable for SLV_ADDR1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SLV_ADDR2 (rw) register accessor: Slave 10 Bits Address 2nd Byte.\n\nYou can [`read`](crate::Reg::read) this register and get [`slv_addr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slv_addr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SLV_ADDR2)\n\nFor information about available fields see [`mod@slv_addr2`]
module"]
    pub type SLV_ADDR2 = crate::Reg<slv_addr2::SLV_ADDR2rs>;
    #[doc = "Slave 10 Bits Address 2nd Byte."]
    pub mod slv_addr2 {
        #[doc = "Register `SLV_ADDR2` reader"]
        pub type R = crate::R<SLV_ADDR2rs>;
        #[doc = "Register `SLV_ADDR2` writer"]
        pub type W = crate::W<SLV_ADDR2rs>;
        #[doc = "Field `SLV_ADR2` reader - Slave 10 Bit Address 2nd Byte"]
        pub type SLV_ADR2_R = crate::FieldReader;
        #[doc = "Field `SLV_ADR2` writer - Slave 10 Bit Address 2nd Byte"]
        pub type SLV_ADR2_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slave 10 Bit Address 2nd Byte"]
            #[inline(always)]
            pub fn slv_adr2(&self) -> SLV_ADR2_R {
                SLV_ADR2_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SLV_ADDR2")
                    .field("slv_adr2", &self.slv_adr2())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slave 10 Bit Address 2nd Byte"]
            #[inline(always)]
            pub fn slv_adr2(&mut self) -> SLV_ADR2_W<SLV_ADDR2rs> {
                SLV_ADR2_W::new(self, 0)
            }
        }
        #[doc = "Slave 10 Bits Address 2nd Byte.\n\nYou can [`read`](crate::Reg::read) this register and get [`slv_addr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slv_addr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SLV_ADDR2)"]
        pub struct SLV_ADDR2rs;
        impl crate::RegisterSpec for SLV_ADDR2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`slv_addr2::R`](R) reader structure"]
        impl crate::Readable for SLV_ADDR2rs {}
        #[doc = "`write(|w| ..)` method takes [`slv_addr2::W`](W) writer structure"]
        impl crate::Writable for SLV_ADDR2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SLV_ADDR2 to value 0"]
        impl crate::Resettable for SLV_ADDR2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SSTAT2 (rw) register accessor: Slave I2C Status/IRQ 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sstat2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sstat2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SSTAT2)\n\nFor information about available fields see [`mod@sstat2`]
module"]
    pub type SSTAT2 = crate::Reg<sstat2::SSTAT2rs>;
    #[doc = "Slave I2C Status/IRQ 2"]
    pub mod sstat2 {
        #[doc = "Register `SSTAT2` reader"]
        pub type R = crate::R<SSTAT2rs>;
        #[doc = "Register `SSTAT2` writer"]
        pub type W = crate::W<SSTAT2rs>;
        #[doc = "Field `sscl_irq` reader - Stretch Interruption State."]
        pub type SSCL_IRQ_R = crate::BitReader;
        #[doc = "Field `addr_ack_irq` reader - Slave ADDR ACK Interruption State."]
        pub type ADDR_ACK_IRQ_R = crate::BitReader;
        #[doc = "Field `rw_direction` reader - Slave I2C RW Direction."]
        pub type RW_DIRECTION_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Stretch Interruption State."]
            #[inline(always)]
            pub fn sscl_irq(&self) -> SSCL_IRQ_R {
                SSCL_IRQ_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Slave ADDR ACK Interruption State."]
            #[inline(always)]
            pub fn addr_ack_irq(&self) -> ADDR_ACK_IRQ_R {
                ADDR_ACK_IRQ_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Slave I2C RW Direction."]
            #[inline(always)]
            pub fn rw_direction(&self) -> RW_DIRECTION_R {
                RW_DIRECTION_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SSTAT2")
                    .field("sscl_irq", &self.sscl_irq())
                    .field("addr_ack_irq", &self.addr_ack_irq())
                    .field("rw_direction", &self.rw_direction())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Slave I2C Status/IRQ 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sstat2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sstat2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0:SSTAT2)"]
        pub struct SSTAT2rs;
        impl crate::RegisterSpec for SSTAT2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sstat2::R`](R) reader structure"]
        impl crate::Readable for SSTAT2rs {}
        #[doc = "`write(|w| ..)` method takes [`sstat2::W`](W) writer structure"]
        impl crate::Writable for SSTAT2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SSTAT2 to value 0"]
        impl crate::Resettable for SSTAT2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Some Description."]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0)"]
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4002_0c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2C1 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C1").finish()
    }
}
#[doc = "Some Description."]
pub use self::i2c0 as i2c1;
#[doc = "Some Description."]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#I2C0)"]
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x4002_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2C2 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C2").finish()
    }
}
#[doc = "Some Description."]
pub use self::i2c0 as i2c2;
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO)"]
pub struct MDIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MDIO {}
impl MDIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mdio::RegisterBlock = 0x4002_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mdio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MDIO {
    type Target = mdio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MDIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MDIO").finish()
    }
}
#[doc = "Unknown"]
pub mod mdio {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        mdcon: MDCON,
        mdfrm: MDFRM,
        mdrxd: MDRXD,
        mdadr: MDADR,
        mdtxd: MDTXD,
        mdphy: MDPHY,
        mdsta: MDSTA,
        mdien: MDIEN,
        mdpin: MDPIN,
        _reserved9: [u8; 0x04],
        dmaen: DMAEN,
        mdtestcon: MDTESTCON,
    }
    impl RegisterBlock {
        #[doc = "0x00 - MDIO Block Control"]
        #[inline(always)]
        pub const fn mdcon(&self) -> &MDCON {
            &self.mdcon
        }
        #[doc = "0x04 - MDIO Received Frame Control Information"]
        #[inline(always)]
        pub const fn mdfrm(&self) -> &MDFRM {
            &self.mdfrm
        }
        #[doc = "0x08 - MDIO Received Data"]
        #[inline(always)]
        pub const fn mdrxd(&self) -> &MDRXD {
            &self.mdrxd
        }
        #[doc = "0x0c - MDIO Received Address"]
        #[inline(always)]
        pub const fn mdadr(&self) -> &MDADR {
            &self.mdadr
        }
        #[doc = "0x10 - MDIO Data for Transmission"]
        #[inline(always)]
        pub const fn mdtxd(&self) -> &MDTXD {
            &self.mdtxd
        }
        #[doc = "0x14 - MDIO PHYADDR Software Values and Selection and DEVADD"]
        #[inline(always)]
        pub const fn mdphy(&self) -> &MDPHY {
            &self.mdphy
        }
        #[doc = "0x18 - MDIO Progress Signaling Through Frame"]
        #[inline(always)]
        pub const fn mdsta(&self) -> &MDSTA {
            &self.mdsta
        }
        #[doc = "0x1c - MDIO Interrupt Enables"]
        #[inline(always)]
        pub const fn mdien(&self) -> &MDIEN {
            &self.mdien
        }
        #[doc = "0x20 - MDIO Read PHYADDR Pins"]
        #[inline(always)]
        pub const fn mdpin(&self) -> &MDPIN {
            &self.mdpin
        }
        #[doc = "0x28 - MDIO DMA Enable"]
        #[inline(always)]
        pub const fn dmaen(&self) -> &DMAEN {
            &self.dmaen
        }
        #[doc = "0x2c - MDIO Test Controller Protected by Test Key"]
        #[inline(always)]
        pub const fn mdtestcon(&self) -> &MDTESTCON {
            &self.mdtestcon
        }
    }
    #[doc = "MDCON (rw) register accessor: MDIO Block Control\n\nYou can [`read`](crate::Reg::read) this register and get [`mdcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDCON)\n\nFor information about available fields see [`mod@mdcon`]
module"]
    pub type MDCON = crate::Reg<mdcon::MDCONrs>;
    #[doc = "MDIO Block Control"]
    pub mod mdcon {
        #[doc = "Register `MDCON` reader"]
        pub type R = crate::R<MDCONrs>;
        #[doc = "Register `MDCON` writer"]
        pub type W = crate::W<MDCONrs>;
        #[doc = "Write 1 to Reset MDIO Block.\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MD_RST {
            #[doc = "0: Reset MDIO"]
            Rstinactive = 0,
            #[doc = "1: Reset MDIO"]
            Rstactive = 1,
        }
        impl From<MD_RST> for bool {
            #[inline(always)]
            fn from(variant: MD_RST) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MD_RST` writer - Write 1 to Reset MDIO Block."]
        pub type MD_RST_W<'a, REG> = crate::BitWriter<'a, REG, MD_RST>;
        impl<'a, REG> MD_RST_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Reset MDIO"]
            #[inline(always)]
            pub fn rstinactive(self) -> &'a mut crate::W<REG> {
                self.variant(MD_RST::Rstinactive)
            }
            #[doc = "Reset MDIO"]
            #[inline(always)]
            pub fn rstactive(self) -> &'a mut crate::W<REG> {
                self.variant(MD_RST::Rstactive)
            }
        }
        #[doc = "Enable PHY Address Bit Width\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MD_PHM {
            #[doc = "0: 5bits PHYADD is active"]
            En5bit = 0,
            #[doc = "1: 3bits PHYADD is active, two MSBS are ignored"]
            En3bits = 1,
        }
        impl From<MD_PHM> for bool {
            #[inline(always)]
            fn from(variant: MD_PHM) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MD_PHM` reader - Enable PHY Address Bit Width"]
        pub type MD_PHM_R = crate::BitReader<MD_PHM>;
        impl MD_PHM_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MD_PHM {
                match self.bits {
                    false => MD_PHM::En5bit,
                    true => MD_PHM::En3bits,
                }
            }
            #[doc = "5bits PHYADD is active"]
            #[inline(always)]
            pub fn is_en_5bit(&self) -> bool {
                *self == MD_PHM::En5bit
            }
            #[doc = "3bits PHYADD is active, two MSBS are ignored"]
            #[inline(always)]
            pub fn is_en_3bits(&self) -> bool {
                *self == MD_PHM::En3bits
            }
        }
        #[doc = "Field `MD_PHM` writer - Enable PHY Address Bit Width"]
        pub type MD_PHM_W<'a, REG> = crate::BitWriter<'a, REG, MD_PHM>;
        impl<'a, REG> MD_PHM_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "5bits PHYADD is active"]
            #[inline(always)]
            pub fn en_5bit(self) -> &'a mut crate::W<REG> {
                self.variant(MD_PHM::En5bit)
            }
            #[doc = "3bits PHYADD is active, two MSBS are ignored"]
            #[inline(always)]
            pub fn en_3bits(self) -> &'a mut crate::W<REG> {
                self.variant(MD_PHM::En3bits)
            }
        }
        #[doc = "Enable Open-drain or Push-pull of MDIO Drive\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MD_DRV {
            #[doc = "0: MDIO Drive Open Drain."]
            MdDrvOd = 0,
            #[doc = "1: MDIO Drive Push-pull."]
            MdDrvPp = 1,
        }
        impl From<MD_DRV> for bool {
            #[inline(always)]
            fn from(variant: MD_DRV) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MD_DRV` reader - Enable Open-drain or Push-pull of MDIO Drive"]
        pub type MD_DRV_R = crate::BitReader<MD_DRV>;
        impl MD_DRV_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MD_DRV {
                match self.bits {
                    false => MD_DRV::MdDrvOd,
                    true => MD_DRV::MdDrvPp,
                }
            }
            #[doc = "MDIO Drive Open Drain."]
            #[inline(always)]
            pub fn is_md_drv_od(&self) -> bool {
                *self == MD_DRV::MdDrvOd
            }
            #[doc = "MDIO Drive Push-pull."]
            #[inline(always)]
            pub fn is_md_drv_pp(&self) -> bool {
                *self == MD_DRV::MdDrvPp
            }
        }
        #[doc = "Field `MD_DRV` writer - Enable Open-drain or Push-pull of MDIO Drive"]
        pub type MD_DRV_W<'a, REG> = crate::BitWriter<'a, REG, MD_DRV>;
        impl<'a, REG> MD_DRV_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "MDIO Drive Open Drain."]
            #[inline(always)]
            pub fn md_drv_od(self) -> &'a mut crate::W<REG> {
                self.variant(MD_DRV::MdDrvOd)
            }
            #[doc = "MDIO Drive Push-pull."]
            #[inline(always)]
            pub fn md_drv_pp(self) -> &'a mut crate::W<REG> {
                self.variant(MD_DRV::MdDrvPp)
            }
        }
        #[doc = "Field `MD_EN` reader - MD Enable"]
        pub type MD_EN_R = crate::BitReader;
        #[doc = "Field `MD_EN` writer - MD Enable"]
        pub type MD_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 1 - Enable PHY Address Bit Width"]
            #[inline(always)]
            pub fn md_phm(&self) -> MD_PHM_R {
                MD_PHM_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Enable Open-drain or Push-pull of MDIO Drive"]
            #[inline(always)]
            pub fn md_drv(&self) -> MD_DRV_R {
                MD_DRV_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 8 - MD Enable"]
            #[inline(always)]
            pub fn md_en(&self) -> MD_EN_R {
                MD_EN_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDCON")
                    .field("md_phm", &self.md_phm())
                    .field("md_drv", &self.md_drv())
                    .field("md_en", &self.md_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Write 1 to Reset MDIO Block."]
            #[inline(always)]
            pub fn md_rst(&mut self) -> MD_RST_W<MDCONrs> {
                MD_RST_W::new(self, 0)
            }
            #[doc = "Bit 1 - Enable PHY Address Bit Width"]
            #[inline(always)]
            pub fn md_phm(&mut self) -> MD_PHM_W<MDCONrs> {
                MD_PHM_W::new(self, 1)
            }
            #[doc = "Bit 2 - Enable Open-drain or Push-pull of MDIO Drive"]
            #[inline(always)]
            pub fn md_drv(&mut self) -> MD_DRV_W<MDCONrs> {
                MD_DRV_W::new(self, 2)
            }
            #[doc = "Bit 8 - MD Enable"]
            #[inline(always)]
            pub fn md_en(&mut self) -> MD_EN_W<MDCONrs> {
                MD_EN_W::new(self, 8)
            }
        }
        #[doc = "MDIO Block Control\n\nYou can [`read`](crate::Reg::read) this register and get [`mdcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDCON)"]
        pub struct MDCONrs;
        impl crate::RegisterSpec for MDCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdcon::R`](R) reader structure"]
        impl crate::Readable for MDCONrs {}
        #[doc = "`write(|w| ..)` method takes [`mdcon::W`](W) writer structure"]
        impl crate::Writable for MDCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDCON to value 0"]
        impl crate::Resettable for MDCONrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MDFRM (rw) register accessor: MDIO Received Frame Control Information\n\nYou can [`read`](crate::Reg::read) this register and get [`mdfrm::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdfrm::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDFRM)\n\nFor information about available fields see [`mod@mdfrm`]
module"]
    pub type MDFRM = crate::Reg<mdfrm::MDFRMrs>;
    #[doc = "MDIO Received Frame Control Information"]
    pub mod mdfrm {
        #[doc = "Register `MDFRM` reader"]
        pub type R = crate::R<MDFRMrs>;
        #[doc = "Register `MDFRM` writer"]
        pub type W = crate::W<MDFRMrs>;
        #[doc = "Received OP\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MD_OP {
            #[doc = "0: Address Frame."]
            MdOpAdf = 0,
            #[doc = "1: Write Frame."]
            MdOpWrf = 1,
            #[doc = "2: PostReadIncAdd Frame."]
            MdOpIncf = 2,
            #[doc = "3: Read Frame."]
            MdOpRdf = 3,
        }
        impl From<MD_OP> for u8 {
            #[inline(always)]
            fn from(variant: MD_OP) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for MD_OP {
            type Ux = u8;
        }
        impl crate::IsEnum for MD_OP {}
        #[doc = "Field `MD_OP` reader - Received OP"]
        pub type MD_OP_R = crate::FieldReader<MD_OP>;
        impl MD_OP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MD_OP {
                match self.bits {
                    0 => MD_OP::MdOpAdf,
                    1 => MD_OP::MdOpWrf,
                    2 => MD_OP::MdOpIncf,
                    3 => MD_OP::MdOpRdf,
                    _ => unreachable!(),
                }
            }
            #[doc = "Address Frame."]
            #[inline(always)]
            pub fn is_md_op_adf(&self) -> bool {
                *self == MD_OP::MdOpAdf
            }
            #[doc = "Write Frame."]
            #[inline(always)]
            pub fn is_md_op_wrf(&self) -> bool {
                *self == MD_OP::MdOpWrf
            }
            #[doc = "PostReadIncAdd Frame."]
            #[inline(always)]
            pub fn is_md_op_incf(&self) -> bool {
                *self == MD_OP::MdOpIncf
            }
            #[doc = "Read Frame."]
            #[inline(always)]
            pub fn is_md_op_rdf(&self) -> bool {
                *self == MD_OP::MdOpRdf
            }
        }
        #[doc = "Field `MD_PHY` reader - Received PHYADR."]
        pub type MD_PHY_R = crate::FieldReader;
        #[doc = "Field `MD_DEV` reader - Received DEVADD"]
        pub type MD_DEV_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:1 - Received OP"]
            #[inline(always)]
            pub fn md_op(&self) -> MD_OP_R {
                MD_OP_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:6 - Received PHYADR."]
            #[inline(always)]
            pub fn md_phy(&self) -> MD_PHY_R {
                MD_PHY_R::new(((self.bits >> 2) & 0x1f) as u8)
            }
            #[doc = "Bits 7:11 - Received DEVADD"]
            #[inline(always)]
            pub fn md_dev(&self) -> MD_DEV_R {
                MD_DEV_R::new(((self.bits >> 7) & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDFRM")
                    .field("md_op", &self.md_op())
                    .field("md_phy", &self.md_phy())
                    .field("md_dev", &self.md_dev())
                    .finish()
            }
        }
        impl W {}
        #[doc = "MDIO Received Frame Control Information\n\nYou can [`read`](crate::Reg::read) this register and get [`mdfrm::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdfrm::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDFRM)"]
        pub struct MDFRMrs;
        impl crate::RegisterSpec for MDFRMrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdfrm::R`](R) reader structure"]
        impl crate::Readable for MDFRMrs {}
        #[doc = "`write(|w| ..)` method takes [`mdfrm::W`](W) writer structure"]
        impl crate::Writable for MDFRMrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDFRM to value 0"]
        impl crate::Resettable for MDFRMrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MDRXD (rw) register accessor: MDIO Received Data\n\nYou can [`read`](crate::Reg::read) this register and get [`mdrxd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdrxd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDRXD)\n\nFor information about available fields see [`mod@mdrxd`]
module"]
    pub type MDRXD = crate::Reg<mdrxd::MDRXDrs>;
    #[doc = "MDIO Received Data"]
    pub mod mdrxd {
        #[doc = "Register `MDRXD` reader"]
        pub type R = crate::R<MDRXDrs>;
        #[doc = "Register `MDRXD` writer"]
        pub type W = crate::W<MDRXDrs>;
        #[doc = "Field `MD_RXD` reader - Received Data"]
        pub type MD_RXD_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - Received Data"]
            #[inline(always)]
            pub fn md_rxd(&self) -> MD_RXD_R {
                MD_RXD_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDRXD")
                    .field("md_rxd", &self.md_rxd())
                    .finish()
            }
        }
        impl W {}
        #[doc = "MDIO Received Data\n\nYou can [`read`](crate::Reg::read) this register and get [`mdrxd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdrxd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDRXD)"]
        pub struct MDRXDrs;
        impl crate::RegisterSpec for MDRXDrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdrxd::R`](R) reader structure"]
        impl crate::Readable for MDRXDrs {}
        #[doc = "`write(|w| ..)` method takes [`mdrxd::W`](W) writer structure"]
        impl crate::Writable for MDRXDrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDRXD to value 0"]
        impl crate::Resettable for MDRXDrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MDADR (rw) register accessor: MDIO Received Address\n\nYou can [`read`](crate::Reg::read) this register and get [`mdadr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdadr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDADR)\n\nFor information about available fields see [`mod@mdadr`]
module"]
    pub type MDADR = crate::Reg<mdadr::MDADRrs>;
    #[doc = "MDIO Received Address"]
    pub mod mdadr {
        #[doc = "Register `MDADR` reader"]
        pub type R = crate::R<MDADRrs>;
        #[doc = "Register `MDADR` writer"]
        pub type W = crate::W<MDADRrs>;
        #[doc = "Field `MD_ADR` reader - Received Address"]
        pub type MD_ADR_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - Received Address"]
            #[inline(always)]
            pub fn md_adr(&self) -> MD_ADR_R {
                MD_ADR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDADR")
                    .field("md_adr", &self.md_adr())
                    .finish()
            }
        }
        impl W {}
        #[doc = "MDIO Received Address\n\nYou can [`read`](crate::Reg::read) this register and get [`mdadr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdadr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDADR)"]
        pub struct MDADRrs;
        impl crate::RegisterSpec for MDADRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdadr::R`](R) reader structure"]
        impl crate::Readable for MDADRrs {}
        #[doc = "`write(|w| ..)` method takes [`mdadr::W`](W) writer structure"]
        impl crate::Writable for MDADRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDADR to value 0"]
        impl crate::Resettable for MDADRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MDTXD (rw) register accessor: MDIO Data for Transmission\n\nYou can [`read`](crate::Reg::read) this register and get [`mdtxd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdtxd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDTXD)\n\nFor information about available fields see [`mod@mdtxd`]
module"]
    pub type MDTXD = crate::Reg<mdtxd::MDTXDrs>;
    #[doc = "MDIO Data for Transmission"]
    pub mod mdtxd {
        #[doc = "Register `MDTXD` reader"]
        pub type R = crate::R<MDTXDrs>;
        #[doc = "Register `MDTXD` writer"]
        pub type W = crate::W<MDTXDrs>;
        #[doc = "Field `MD_TXD` reader - TX Data"]
        pub type MD_TXD_R = crate::FieldReader<u16>;
        #[doc = "Field `MD_TXD` writer - TX Data"]
        pub type MD_TXD_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - TX Data"]
            #[inline(always)]
            pub fn md_txd(&self) -> MD_TXD_R {
                MD_TXD_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDTXD")
                    .field("md_txd", &self.md_txd())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - TX Data"]
            #[inline(always)]
            pub fn md_txd(&mut self) -> MD_TXD_W<MDTXDrs> {
                MD_TXD_W::new(self, 0)
            }
        }
        #[doc = "MDIO Data for Transmission\n\nYou can [`read`](crate::Reg::read) this register and get [`mdtxd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdtxd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDTXD)"]
        pub struct MDTXDrs;
        impl crate::RegisterSpec for MDTXDrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdtxd::R`](R) reader structure"]
        impl crate::Readable for MDTXDrs {}
        #[doc = "`write(|w| ..)` method takes [`mdtxd::W`](W) writer structure"]
        impl crate::Writable for MDTXDrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDTXD to value 0"]
        impl crate::Resettable for MDTXDrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MDPHY (rw) register accessor: MDIO PHYADDR Software Values and Selection and DEVADD\n\nYou can [`read`](crate::Reg::read) this register and get [`mdphy::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdphy::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDPHY)\n\nFor information about available fields see [`mod@mdphy`]
module"]
    pub type MDPHY = crate::Reg<mdphy::MDPHYrs>;
    #[doc = "MDIO PHYADDR Software Values and Selection and DEVADD"]
    pub mod mdphy {
        #[doc = "Register `MDPHY` reader"]
        pub type R = crate::R<MDPHYrs>;
        #[doc = "Register `MDPHY` writer"]
        pub type W = crate::W<MDPHYrs>;
        #[doc = "Field `MD_PHYSW` reader - Software Provided PHYADR"]
        pub type MD_PHYSW_R = crate::FieldReader;
        #[doc = "Field `MD_PHYSW` writer - Software Provided PHYADR"]
        pub type MD_PHYSW_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        #[doc = "Field `MD_PHYSEL` reader - Selects Expected PHYADR Bits"]
        pub type MD_PHYSEL_R = crate::FieldReader;
        #[doc = "Field `MD_PHYSEL` writer - Selects Expected PHYADR Bits"]
        pub type MD_PHYSEL_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        #[doc = "Field `MD_DEVADD` reader - Expected DEVADD"]
        pub type MD_DEVADD_R = crate::FieldReader;
        #[doc = "Field `MD_DEVADD` writer - Expected DEVADD"]
        pub type MD_DEVADD_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:4 - Software Provided PHYADR"]
            #[inline(always)]
            pub fn md_physw(&self) -> MD_PHYSW_R {
                MD_PHYSW_R::new((self.bits & 0x1f) as u8)
            }
            #[doc = "Bits 5:9 - Selects Expected PHYADR Bits"]
            #[inline(always)]
            pub fn md_physel(&self) -> MD_PHYSEL_R {
                MD_PHYSEL_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            #[doc = "Bits 10:14 - Expected DEVADD"]
            #[inline(always)]
            pub fn md_devadd(&self) -> MD_DEVADD_R {
                MD_DEVADD_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDPHY")
                    .field("md_physw", &self.md_physw())
                    .field("md_physel", &self.md_physel())
                    .field("md_devadd", &self.md_devadd())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:4 - Software Provided PHYADR"]
            #[inline(always)]
            pub fn md_physw(&mut self) -> MD_PHYSW_W<MDPHYrs> {
                MD_PHYSW_W::new(self, 0)
            }
            #[doc = "Bits 5:9 - Selects Expected PHYADR Bits"]
            #[inline(always)]
            pub fn md_physel(&mut self) -> MD_PHYSEL_W<MDPHYrs> {
                MD_PHYSEL_W::new(self, 5)
            }
            #[doc = "Bits 10:14 - Expected DEVADD"]
            #[inline(always)]
            pub fn md_devadd(&mut self) -> MD_DEVADD_W<MDPHYrs> {
                MD_DEVADD_W::new(self, 10)
            }
        }
        #[doc = "MDIO PHYADDR Software Values and Selection and DEVADD\n\nYou can [`read`](crate::Reg::read) this register and get [`mdphy::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdphy::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDPHY)"]
        pub struct MDPHYrs;
        impl crate::RegisterSpec for MDPHYrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdphy::R`](R) reader structure"]
        impl crate::Readable for MDPHYrs {}
        #[doc = "`write(|w| ..)` method takes [`mdphy::W`](W) writer structure"]
        impl crate::Writable for MDPHYrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDPHY to value 0x0400"]
        impl crate::Resettable for MDPHYrs {
            const RESET_VALUE: u32 = 0x0400;
        }
    }
    #[doc = "MDSTA (rw) register accessor: MDIO Progress Signaling Through Frame\n\nYou can [`read`](crate::Reg::read) this register and get [`mdsta::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdsta::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDSTA)\n\nFor information about available fields see [`mod@mdsta`]
module"]
    pub type MDSTA = crate::Reg<mdsta::MDSTArs>;
    #[doc = "MDIO Progress Signaling Through Frame"]
    pub mod mdsta {
        #[doc = "Register `MDSTA` reader"]
        pub type R = crate::R<MDSTArs>;
        #[doc = "Register `MDSTA` writer"]
        pub type W = crate::W<MDSTArs>;
        #[doc = "Field `MD_WRF` reader - Write Frame Status"]
        pub type MD_WRF_R = crate::BitReader;
        #[doc = "Field `MD_ADRF` reader - Address Frame Status"]
        pub type MD_ADRF_R = crate::BitReader;
        #[doc = "Field `MD_INCF` reader - Post Read Increment Address Frame Status"]
        pub type MD_INCF_R = crate::BitReader;
        #[doc = "Field `MD_RDF` reader - Read Frame Status"]
        pub type MD_RDF_R = crate::BitReader;
        #[doc = "Field `MD_DEVM` reader - Device Address Matching Status"]
        pub type MD_DEVM_R = crate::BitReader;
        #[doc = "Field `MD_DEVN` reader - Device Address None Match Status"]
        pub type MD_DEVN_R = crate::BitReader;
        #[doc = "Field `MD_PHYM` reader - PHY Address Matching Status"]
        pub type MD_PHYM_R = crate::BitReader;
        #[doc = "Field `MD_PHYN` reader - PHY Address Non Matching Status"]
        pub type MD_PHYN_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Write Frame Status"]
            #[inline(always)]
            pub fn md_wrf(&self) -> MD_WRF_R {
                MD_WRF_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Address Frame Status"]
            #[inline(always)]
            pub fn md_adrf(&self) -> MD_ADRF_R {
                MD_ADRF_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Post Read Increment Address Frame Status"]
            #[inline(always)]
            pub fn md_incf(&self) -> MD_INCF_R {
                MD_INCF_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Read Frame Status"]
            #[inline(always)]
            pub fn md_rdf(&self) -> MD_RDF_R {
                MD_RDF_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Device Address Matching Status"]
            #[inline(always)]
            pub fn md_devm(&self) -> MD_DEVM_R {
                MD_DEVM_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Device Address None Match Status"]
            #[inline(always)]
            pub fn md_devn(&self) -> MD_DEVN_R {
                MD_DEVN_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - PHY Address Matching Status"]
            #[inline(always)]
            pub fn md_phym(&self) -> MD_PHYM_R {
                MD_PHYM_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - PHY Address Non Matching Status"]
            #[inline(always)]
            pub fn md_phyn(&self) -> MD_PHYN_R {
                MD_PHYN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDSTA")
                    .field("md_wrf", &self.md_wrf())
                    .field("md_adrf", &self.md_adrf())
                    .field("md_incf", &self.md_incf())
                    .field("md_rdf", &self.md_rdf())
                    .field("md_devm", &self.md_devm())
                    .field("md_devn", &self.md_devn())
                    .field("md_phym", &self.md_phym())
                    .field("md_phyn", &self.md_phyn())
                    .finish()
            }
        }
        impl W {}
        #[doc = "MDIO Progress Signaling Through Frame\n\nYou can [`read`](crate::Reg::read) this register and get [`mdsta::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdsta::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDSTA)"]
        pub struct MDSTArs;
        impl crate::RegisterSpec for MDSTArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdsta::R`](R) reader structure"]
        impl crate::Readable for MDSTArs {}
        #[doc = "`write(|w| ..)` method takes [`mdsta::W`](W) writer structure"]
        impl crate::Writable for MDSTArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDSTA to value 0"]
        impl crate::Resettable for MDSTArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MDIEN (rw) register accessor: MDIO Interrupt Enables\n\nYou can [`read`](crate::Reg::read) this register and get [`mdien::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdien::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDIEN)\n\nFor information about available fields see [`mod@mdien`]
module"]
    pub type MDIEN = crate::Reg<mdien::MDIENrs>;
    #[doc = "MDIO Interrupt Enables"]
    pub mod mdien {
        #[doc = "Register `MDIEN` reader"]
        pub type R = crate::R<MDIENrs>;
        #[doc = "Register `MDIEN` writer"]
        pub type W = crate::W<MDIENrs>;
        #[doc = "Field `MD_WRFI` reader - Interrupt Enable for MD_WRF"]
        pub type MD_WRFI_R = crate::BitReader;
        #[doc = "Field `MD_WRFI` writer - Interrupt Enable for MD_WRF"]
        pub type MD_WRFI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MD_ADRI` reader - Interrupt Enable for MD_ADRF"]
        pub type MD_ADRI_R = crate::BitReader;
        #[doc = "Field `MD_ADRI` writer - Interrupt Enable for MD_ADRF"]
        pub type MD_ADRI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MD_INCFI` reader - Interrupt Enable for MD_INCF"]
        pub type MD_INCFI_R = crate::BitReader;
        #[doc = "Field `MD_INCFI` writer - Interrupt Enable for MD_INCF"]
        pub type MD_INCFI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MD_RDFI` reader - Interrupt Enable for MD_RDF"]
        pub type MD_RDFI_R = crate::BitReader;
        #[doc = "Field `MD_RDFI` writer - Interrupt Enable for MD_RDF"]
        pub type MD_RDFI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MD_DEVMI` reader - Interrupt Enable for MD_DEVM"]
        pub type MD_DEVMI_R = crate::BitReader;
        #[doc = "Field `MD_DEVMI` writer - Interrupt Enable for MD_DEVM"]
        pub type MD_DEVMI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MD_DEVNI` reader - Interrupt Enable for MD_DEVN"]
        pub type MD_DEVNI_R = crate::BitReader;
        #[doc = "Field `MD_DEVNI` writer - Interrupt Enable for MD_DEVN"]
        pub type MD_DEVNI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MD_PHYMI` reader - Interrupt Enable for MD_PHYM"]
        pub type MD_PHYMI_R = crate::BitReader;
        #[doc = "Field `MD_PHYMI` writer - Interrupt Enable for MD_PHYM"]
        pub type MD_PHYMI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MD_PHYNI` reader - Interrupt Enable for MD_PHYN"]
        pub type MD_PHYNI_R = crate::BitReader;
        #[doc = "Field `MD_PHYNI` writer - Interrupt Enable for MD_PHYN"]
        pub type MD_PHYNI_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Interrupt Enable for MD_WRF"]
            #[inline(always)]
            pub fn md_wrfi(&self) -> MD_WRFI_R {
                MD_WRFI_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Interrupt Enable for MD_ADRF"]
            #[inline(always)]
            pub fn md_adri(&self) -> MD_ADRI_R {
                MD_ADRI_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Interrupt Enable for MD_INCF"]
            #[inline(always)]
            pub fn md_incfi(&self) -> MD_INCFI_R {
                MD_INCFI_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Interrupt Enable for MD_RDF"]
            #[inline(always)]
            pub fn md_rdfi(&self) -> MD_RDFI_R {
                MD_RDFI_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Interrupt Enable for MD_DEVM"]
            #[inline(always)]
            pub fn md_devmi(&self) -> MD_DEVMI_R {
                MD_DEVMI_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Interrupt Enable for MD_DEVN"]
            #[inline(always)]
            pub fn md_devni(&self) -> MD_DEVNI_R {
                MD_DEVNI_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Interrupt Enable for MD_PHYM"]
            #[inline(always)]
            pub fn md_phymi(&self) -> MD_PHYMI_R {
                MD_PHYMI_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Interrupt Enable for MD_PHYN"]
            #[inline(always)]
            pub fn md_phyni(&self) -> MD_PHYNI_R {
                MD_PHYNI_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDIEN")
                    .field("md_wrfi", &self.md_wrfi())
                    .field("md_adri", &self.md_adri())
                    .field("md_incfi", &self.md_incfi())
                    .field("md_rdfi", &self.md_rdfi())
                    .field("md_devmi", &self.md_devmi())
                    .field("md_devni", &self.md_devni())
                    .field("md_phymi", &self.md_phymi())
                    .field("md_phyni", &self.md_phyni())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Interrupt Enable for MD_WRF"]
            #[inline(always)]
            pub fn md_wrfi(&mut self) -> MD_WRFI_W<MDIENrs> {
                MD_WRFI_W::new(self, 0)
            }
            #[doc = "Bit 1 - Interrupt Enable for MD_ADRF"]
            #[inline(always)]
            pub fn md_adri(&mut self) -> MD_ADRI_W<MDIENrs> {
                MD_ADRI_W::new(self, 1)
            }
            #[doc = "Bit 2 - Interrupt Enable for MD_INCF"]
            #[inline(always)]
            pub fn md_incfi(&mut self) -> MD_INCFI_W<MDIENrs> {
                MD_INCFI_W::new(self, 2)
            }
            #[doc = "Bit 3 - Interrupt Enable for MD_RDF"]
            #[inline(always)]
            pub fn md_rdfi(&mut self) -> MD_RDFI_W<MDIENrs> {
                MD_RDFI_W::new(self, 3)
            }
            #[doc = "Bit 4 - Interrupt Enable for MD_DEVM"]
            #[inline(always)]
            pub fn md_devmi(&mut self) -> MD_DEVMI_W<MDIENrs> {
                MD_DEVMI_W::new(self, 4)
            }
            #[doc = "Bit 5 - Interrupt Enable for MD_DEVN"]
            #[inline(always)]
            pub fn md_devni(&mut self) -> MD_DEVNI_W<MDIENrs> {
                MD_DEVNI_W::new(self, 5)
            }
            #[doc = "Bit 6 - Interrupt Enable for MD_PHYM"]
            #[inline(always)]
            pub fn md_phymi(&mut self) -> MD_PHYMI_W<MDIENrs> {
                MD_PHYMI_W::new(self, 6)
            }
            #[doc = "Bit 7 - Interrupt Enable for MD_PHYN"]
            #[inline(always)]
            pub fn md_phyni(&mut self) -> MD_PHYNI_W<MDIENrs> {
                MD_PHYNI_W::new(self, 7)
            }
        }
        #[doc = "MDIO Interrupt Enables\n\nYou can [`read`](crate::Reg::read) this register and get [`mdien::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdien::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDIEN)"]
        pub struct MDIENrs;
        impl crate::RegisterSpec for MDIENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdien::R`](R) reader structure"]
        impl crate::Readable for MDIENrs {}
        #[doc = "`write(|w| ..)` method takes [`mdien::W`](W) writer structure"]
        impl crate::Writable for MDIENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDIEN to value 0"]
        impl crate::Resettable for MDIENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MDPIN (rw) register accessor: MDIO Read PHYADDR Pins\n\nYou can [`read`](crate::Reg::read) this register and get [`mdpin::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdpin::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDPIN)\n\nFor information about available fields see [`mod@mdpin`]
module"]
    pub type MDPIN = crate::Reg<mdpin::MDPINrs>;
    #[doc = "MDIO Read PHYADDR Pins"]
    pub mod mdpin {
        #[doc = "Register `MDPIN` reader"]
        pub type R = crate::R<MDPINrs>;
        #[doc = "Register `MDPIN` writer"]
        pub type W = crate::W<MDPINrs>;
        #[doc = "Field `MD_PIN` reader - PRTADR Pins"]
        pub type MD_PIN_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:4 - PRTADR Pins"]
            #[inline(always)]
            pub fn md_pin(&self) -> MD_PIN_R {
                MD_PIN_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDPIN")
                    .field("md_pin", &self.md_pin())
                    .finish()
            }
        }
        impl W {}
        #[doc = "MDIO Read PHYADDR Pins\n\nYou can [`read`](crate::Reg::read) this register and get [`mdpin::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdpin::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDPIN)"]
        pub struct MDPINrs;
        impl crate::RegisterSpec for MDPINrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdpin::R`](R) reader structure"]
        impl crate::Readable for MDPINrs {}
        #[doc = "`write(|w| ..)` method takes [`mdpin::W`](W) writer structure"]
        impl crate::Writable for MDPINrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDPIN to value 0"]
        impl crate::Resettable for MDPINrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DMAEN (rw) register accessor: MDIO DMA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`dmaen::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmaen::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:DMAEN)\n\nFor information about available fields see [`mod@dmaen`]
module"]
    pub type DMAEN = crate::Reg<dmaen::DMAENrs>;
    #[doc = "MDIO DMA Enable"]
    pub mod dmaen {
        #[doc = "Register `DMAEN` reader"]
        pub type R = crate::R<DMAENrs>;
        #[doc = "Register `DMAEN` writer"]
        pub type W = crate::W<DMAENrs>;
        #[doc = "Field `RD_DATA` reader - Read Data"]
        pub type RD_DATA_R = crate::BitReader;
        #[doc = "Field `RD_DATA` writer - Read Data"]
        pub type RD_DATA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `INCRD_DATA` reader - Increment Read Data"]
        pub type INCRD_DATA_R = crate::BitReader;
        #[doc = "Field `INCRD_DATA` writer - Increment Read Data"]
        pub type INCRD_DATA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WR_ADR` reader - Write Address"]
        pub type WR_ADR_R = crate::BitReader;
        #[doc = "Field `WR_ADR` writer - Write Address"]
        pub type WR_ADR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WR_DATA` reader - Write Data"]
        pub type WR_DATA_R = crate::BitReader;
        #[doc = "Field `WR_DATA` writer - Write Data"]
        pub type WR_DATA_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Read Data"]
            #[inline(always)]
            pub fn rd_data(&self) -> RD_DATA_R {
                RD_DATA_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Increment Read Data"]
            #[inline(always)]
            pub fn incrd_data(&self) -> INCRD_DATA_R {
                INCRD_DATA_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Write Address"]
            #[inline(always)]
            pub fn wr_adr(&self) -> WR_ADR_R {
                WR_ADR_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Write Data"]
            #[inline(always)]
            pub fn wr_data(&self) -> WR_DATA_R {
                WR_DATA_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DMAEN")
                    .field("rd_data", &self.rd_data())
                    .field("incrd_data", &self.incrd_data())
                    .field("wr_adr", &self.wr_adr())
                    .field("wr_data", &self.wr_data())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Read Data"]
            #[inline(always)]
            pub fn rd_data(&mut self) -> RD_DATA_W<DMAENrs> {
                RD_DATA_W::new(self, 0)
            }
            #[doc = "Bit 1 - Increment Read Data"]
            #[inline(always)]
            pub fn incrd_data(&mut self) -> INCRD_DATA_W<DMAENrs> {
                INCRD_DATA_W::new(self, 1)
            }
            #[doc = "Bit 2 - Write Address"]
            #[inline(always)]
            pub fn wr_adr(&mut self) -> WR_ADR_W<DMAENrs> {
                WR_ADR_W::new(self, 2)
            }
            #[doc = "Bit 3 - Write Data"]
            #[inline(always)]
            pub fn wr_data(&mut self) -> WR_DATA_W<DMAENrs> {
                WR_DATA_W::new(self, 3)
            }
        }
        #[doc = "MDIO DMA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`dmaen::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmaen::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:DMAEN)"]
        pub struct DMAENrs;
        impl crate::RegisterSpec for DMAENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dmaen::R`](R) reader structure"]
        impl crate::Readable for DMAENrs {}
        #[doc = "`write(|w| ..)` method takes [`dmaen::W`](W) writer structure"]
        impl crate::Writable for DMAENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DMAEN to value 0"]
        impl crate::Resettable for DMAENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MDTESTCON (rw) register accessor: MDIO Test Controller Protected by Test Key\n\nYou can [`read`](crate::Reg::read) this register and get [`mdtestcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdtestcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDTESTCON)\n\nFor information about available fields see [`mod@mdtestcon`]
module"]
    pub type MDTESTCON = crate::Reg<mdtestcon::MDTESTCONrs>;
    #[doc = "MDIO Test Controller Protected by Test Key"]
    pub mod mdtestcon {
        #[doc = "Register `MDTESTCON` reader"]
        pub type R = crate::R<MDTESTCONrs>;
        #[doc = "Register `MDTESTCON` writer"]
        pub type W = crate::W<MDTESTCONrs>;
        #[doc = "Field `TA_0_value` reader - Output Value During First Bit of OP"]
        pub type TA_0_VALUE_R = crate::BitReader;
        #[doc = "Field `TA_0_value` writer - Output Value During First Bit of OP"]
        pub type TA_0_VALUE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TA_1_value` reader - Output Value During Second Bit of OP"]
        pub type TA_1_VALUE_R = crate::BitReader;
        #[doc = "Field `TA_1_value` writer - Output Value During Second Bit of OP"]
        pub type TA_1_VALUE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `En_TA_output` reader - Enable Output Different During OP Phase"]
        pub type EN_TA_OUTPUT_R = crate::BitReader;
        #[doc = "Field `En_TA_output` writer - Enable Output Different During OP Phase"]
        pub type EN_TA_OUTPUT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 11 - Output Value During First Bit of OP"]
            #[inline(always)]
            pub fn ta_0_value(&self) -> TA_0_VALUE_R {
                TA_0_VALUE_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Output Value During Second Bit of OP"]
            #[inline(always)]
            pub fn ta_1_value(&self) -> TA_1_VALUE_R {
                TA_1_VALUE_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Enable Output Different During OP Phase"]
            #[inline(always)]
            pub fn en_ta_output(&self) -> EN_TA_OUTPUT_R {
                EN_TA_OUTPUT_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MDTESTCON")
                    .field("ta_0_value", &self.ta_0_value())
                    .field("ta_1_value", &self.ta_1_value())
                    .field("en_ta_output", &self.en_ta_output())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 11 - Output Value During First Bit of OP"]
            #[inline(always)]
            pub fn ta_0_value(&mut self) -> TA_0_VALUE_W<MDTESTCONrs> {
                TA_0_VALUE_W::new(self, 11)
            }
            #[doc = "Bit 12 - Output Value During Second Bit of OP"]
            #[inline(always)]
            pub fn ta_1_value(&mut self) -> TA_1_VALUE_W<MDTESTCONrs> {
                TA_1_VALUE_W::new(self, 12)
            }
            #[doc = "Bit 13 - Enable Output Different During OP Phase"]
            #[inline(always)]
            pub fn en_ta_output(&mut self) -> EN_TA_OUTPUT_W<MDTESTCONrs> {
                EN_TA_OUTPUT_W::new(self, 13)
            }
        }
        #[doc = "MDIO Test Controller Protected by Test Key\n\nYou can [`read`](crate::Reg::read) this register and get [`mdtestcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mdtestcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#MDIO:MDTESTCON)"]
        pub struct MDTESTCONrs;
        impl crate::RegisterSpec for MDTESTCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mdtestcon::R`](R) reader structure"]
        impl crate::Readable for MDTESTCONrs {}
        #[doc = "`write(|w| ..)` method takes [`mdtestcon::W`](W) writer structure"]
        impl crate::Writable for MDTESTCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MDTESTCON to value 0x0800"]
        impl crate::Resettable for MDTESTCONrs {
            const RESET_VALUE: u32 = 0x0800;
        }
    }
}
#[doc = "Serial Peripheral Interface"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0)"]
pub struct D2D0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for D2D0 {}
impl D2D0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const d2d0::RegisterBlock = 0x4002_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const d2d0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for D2D0 {
    type Target = d2d0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for D2D0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("D2D0").finish()
    }
}
#[doc = "Serial Peripheral Interface"]
pub mod d2d0 {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        stat: STAT,
        rx: RX,
        tx: TX,
        div: DIV,
        ctl: CTL,
        ien: IEN,
        cnt: CNT,
        dma: DMA,
        fifostat: FIFOSTAT,
        rdctl: RDCTL,
        flowctl: FLOWCTL,
        waittmr: WAITTMR,
        _reserved12: [u8; 0x04],
        csoverride: CSOVERRIDE,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Status"]
        #[inline(always)]
        pub const fn stat(&self) -> &STAT {
            &self.stat
        }
        #[doc = "0x04 - Receive"]
        #[inline(always)]
        pub const fn rx(&self) -> &RX {
            &self.rx
        }
        #[doc = "0x08 - Transmit"]
        #[inline(always)]
        pub const fn tx(&self) -> &TX {
            &self.tx
        }
        #[doc = "0x0c - SPI Baud Rate Selection"]
        #[inline(always)]
        pub const fn div(&self) -> &DIV {
            &self.div
        }
        #[doc = "0x10 - SPI Configuration 1"]
        #[inline(always)]
        pub const fn ctl(&self) -> &CTL {
            &self.ctl
        }
        #[doc = "0x14 - SPI Configuration 2"]
        #[inline(always)]
        pub const fn ien(&self) -> &IEN {
            &self.ien
        }
        #[doc = "0x18 - Transfer Byte Count"]
        #[inline(always)]
        pub const fn cnt(&self) -> &CNT {
            &self.cnt
        }
        #[doc = "0x1c - SPI DMA Enable"]
        #[inline(always)]
        pub const fn dma(&self) -> &DMA {
            &self.dma
        }
        #[doc = "0x20 - FIFO Status"]
        #[inline(always)]
        pub const fn fifostat(&self) -> &FIFOSTAT {
            &self.fifostat
        }
        #[doc = "0x24 - Read Control"]
        #[inline(always)]
        pub const fn rdctl(&self) -> &RDCTL {
            &self.rdctl
        }
        #[doc = "0x28 - Flow Control"]
        #[inline(always)]
        pub const fn flowctl(&self) -> &FLOWCTL {
            &self.flowctl
        }
        #[doc = "0x2c - Wait Timer for Flow Control"]
        #[inline(always)]
        pub const fn waittmr(&self) -> &WAITTMR {
            &self.waittmr
        }
        #[doc = "0x34 - Chip-Select Override"]
        #[inline(always)]
        pub const fn csoverride(&self) -> &CSOVERRIDE {
            &self.csoverride
        }
    }
    #[doc = "STAT (rw) register accessor: Status\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:STAT)\n\nFor information about available fields see [`mod@stat`]
module"]
    pub type STAT = crate::Reg<stat::STATrs>;
    #[doc = "Status"]
    pub mod stat {
        #[doc = "Register `STAT` reader"]
        pub type R = crate::R<STATrs>;
        #[doc = "Register `STAT` writer"]
        pub type W = crate::W<STATrs>;
        #[doc = "Field `IRQ` reader - SPI Interrupt Status"]
        pub type IRQ_R = crate::BitReader;
        #[doc = "Field `XFRDONE` reader - SPI Transfer Completion"]
        pub type XFRDONE_R = crate::BitReader;
        #[doc = "Field `XFRDONE` writer - SPI Transfer Completion"]
        pub type XFRDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXEMPTY` reader - SPI Tx FIFO Empty Interrupt"]
        pub type TXEMPTY_R = crate::BitReader;
        #[doc = "Field `TXEMPTY` writer - SPI Tx FIFO Empty Interrupt"]
        pub type TXEMPTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXDONE` reader - SPI Tx Done in Read Command Mode"]
        pub type TXDONE_R = crate::BitReader;
        #[doc = "Field `TXDONE` writer - SPI Tx Done in Read Command Mode"]
        pub type TXDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXUNDR` reader - SPI Tx FIFO Underflow"]
        pub type TXUNDR_R = crate::BitReader;
        #[doc = "Field `TXUNDR` writer - SPI Tx FIFO Underflow"]
        pub type TXUNDR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXIRQ` reader - SPI Tx IRQ"]
        pub type TXIRQ_R = crate::BitReader;
        #[doc = "Field `TXIRQ` writer - SPI Tx IRQ"]
        pub type TXIRQ_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RXIRQ` reader - SPI Rx IRQ"]
        pub type RXIRQ_R = crate::BitReader;
        #[doc = "Field `RXIRQ` writer - SPI Rx IRQ"]
        pub type RXIRQ_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RXOVR` reader - SPI Rx FIFO Overflow"]
        pub type RXOVR_R = crate::BitReader;
        #[doc = "Field `RXOVR` writer - SPI Rx FIFO Overflow"]
        pub type RXOVR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CS` reader - CS Status"]
        pub type CS_R = crate::BitReader;
        #[doc = "Field `CSERR` reader - Detected a CS Error Condition in Slave Mode"]
        pub type CSERR_R = crate::BitReader;
        #[doc = "Field `CSERR` writer - Detected a CS Error Condition in Slave Mode"]
        pub type CSERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CSRISE` reader - Detected a Rising Edge on CS, in Slave CON Mode"]
        pub type CSRISE_R = crate::BitReader;
        #[doc = "Field `CSRISE` writer - Detected a Rising Edge on CS, in Slave CON Mode"]
        pub type CSRISE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CSFALL` reader - Detected a Falling Edge on CS, in Slave CON Mode"]
        pub type CSFALL_R = crate::BitReader;
        #[doc = "Field `CSFALL` writer - Detected a Falling Edge on CS, in Slave CON Mode"]
        pub type CSFALL_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RDY` reader - Detected an Edge on Ready Indicator for Flow-control"]
        pub type RDY_R = crate::BitReader;
        #[doc = "Field `RDY` writer - Detected an Edge on Ready Indicator for Flow-control"]
        pub type RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - SPI Interrupt Status"]
            #[inline(always)]
            pub fn irq(&self) -> IRQ_R {
                IRQ_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - SPI Transfer Completion"]
            #[inline(always)]
            pub fn xfrdone(&self) -> XFRDONE_R {
                XFRDONE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - SPI Tx FIFO Empty Interrupt"]
            #[inline(always)]
            pub fn txempty(&self) -> TXEMPTY_R {
                TXEMPTY_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - SPI Tx Done in Read Command Mode"]
            #[inline(always)]
            pub fn txdone(&self) -> TXDONE_R {
                TXDONE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - SPI Tx FIFO Underflow"]
            #[inline(always)]
            pub fn txundr(&self) -> TXUNDR_R {
                TXUNDR_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - SPI Tx IRQ"]
            #[inline(always)]
            pub fn txirq(&self) -> TXIRQ_R {
                TXIRQ_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - SPI Rx IRQ"]
            #[inline(always)]
            pub fn rxirq(&self) -> RXIRQ_R {
                RXIRQ_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - SPI Rx FIFO Overflow"]
            #[inline(always)]
            pub fn rxovr(&self) -> RXOVR_R {
                RXOVR_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 11 - CS Status"]
            #[inline(always)]
            pub fn cs(&self) -> CS_R {
                CS_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Detected a CS Error Condition in Slave Mode"]
            #[inline(always)]
            pub fn cserr(&self) -> CSERR_R {
                CSERR_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Detected a Rising Edge on CS, in Slave CON Mode"]
            #[inline(always)]
            pub fn csrise(&self) -> CSRISE_R {
                CSRISE_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Detected a Falling Edge on CS, in Slave CON Mode"]
            #[inline(always)]
            pub fn csfall(&self) -> CSFALL_R {
                CSFALL_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Detected an Edge on Ready Indicator for Flow-control"]
            #[inline(always)]
            pub fn rdy(&self) -> RDY_R {
                RDY_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STAT")
                    .field("irq", &self.irq())
                    .field("xfrdone", &self.xfrdone())
                    .field("txempty", &self.txempty())
                    .field("txdone", &self.txdone())
                    .field("txundr", &self.txundr())
                    .field("txirq", &self.txirq())
                    .field("rxirq", &self.rxirq())
                    .field("rxovr", &self.rxovr())
                    .field("cs", &self.cs())
                    .field("cserr", &self.cserr())
                    .field("csrise", &self.csrise())
                    .field("csfall", &self.csfall())
                    .field("rdy", &self.rdy())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 1 - SPI Transfer Completion"]
            #[inline(always)]
            pub fn xfrdone(&mut self) -> XFRDONE_W<STATrs> {
                XFRDONE_W::new(self, 1)
            }
            #[doc = "Bit 2 - SPI Tx FIFO Empty Interrupt"]
            #[inline(always)]
            pub fn txempty(&mut self) -> TXEMPTY_W<STATrs> {
                TXEMPTY_W::new(self, 2)
            }
            #[doc = "Bit 3 - SPI Tx Done in Read Command Mode"]
            #[inline(always)]
            pub fn txdone(&mut self) -> TXDONE_W<STATrs> {
                TXDONE_W::new(self, 3)
            }
            #[doc = "Bit 4 - SPI Tx FIFO Underflow"]
            #[inline(always)]
            pub fn txundr(&mut self) -> TXUNDR_W<STATrs> {
                TXUNDR_W::new(self, 4)
            }
            #[doc = "Bit 5 - SPI Tx IRQ"]
            #[inline(always)]
            pub fn txirq(&mut self) -> TXIRQ_W<STATrs> {
                TXIRQ_W::new(self, 5)
            }
            #[doc = "Bit 6 - SPI Rx IRQ"]
            #[inline(always)]
            pub fn rxirq(&mut self) -> RXIRQ_W<STATrs> {
                RXIRQ_W::new(self, 6)
            }
            #[doc = "Bit 7 - SPI Rx FIFO Overflow"]
            #[inline(always)]
            pub fn rxovr(&mut self) -> RXOVR_W<STATrs> {
                RXOVR_W::new(self, 7)
            }
            #[doc = "Bit 12 - Detected a CS Error Condition in Slave Mode"]
            #[inline(always)]
            pub fn cserr(&mut self) -> CSERR_W<STATrs> {
                CSERR_W::new(self, 12)
            }
            #[doc = "Bit 13 - Detected a Rising Edge on CS, in Slave CON Mode"]
            #[inline(always)]
            pub fn csrise(&mut self) -> CSRISE_W<STATrs> {
                CSRISE_W::new(self, 13)
            }
            #[doc = "Bit 14 - Detected a Falling Edge on CS, in Slave CON Mode"]
            #[inline(always)]
            pub fn csfall(&mut self) -> CSFALL_W<STATrs> {
                CSFALL_W::new(self, 14)
            }
            #[doc = "Bit 15 - Detected an Edge on Ready Indicator for Flow-control"]
            #[inline(always)]
            pub fn rdy(&mut self) -> RDY_W<STATrs> {
                RDY_W::new(self, 15)
            }
        }
        #[doc = "Status\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:STAT)"]
        pub struct STATrs;
        impl crate::RegisterSpec for STATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`stat::R`](R) reader structure"]
        impl crate::Readable for STATrs {}
        #[doc = "`write(|w| ..)` method takes [`stat::W`](W) writer structure"]
        impl crate::Writable for STATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STAT to value 0x0800"]
        impl crate::Resettable for STATrs {
            const RESET_VALUE: u32 = 0x0800;
        }
    }
    #[doc = "RX (rw) register accessor: Receive\n\nYou can [`read`](crate::Reg::read) this register and get [`rx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:RX)\n\nFor information about available fields see [`mod@rx`]
module"]
    pub type RX = crate::Reg<rx::RXrs>;
    #[doc = "Receive"]
    pub mod rx {
        #[doc = "Register `RX` reader"]
        pub type R = crate::R<RXrs>;
        #[doc = "Register `RX` writer"]
        pub type W = crate::W<RXrs>;
        #[doc = "Field `BYTE1` reader - 8-bit Receive Buffer"]
        pub type BYTE1_R = crate::FieldReader;
        #[doc = "Field `BYTE2` reader - 8-bit Receive Buffer, Used Only in DMA Modes"]
        pub type BYTE2_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - 8-bit Receive Buffer"]
            #[inline(always)]
            pub fn byte1(&self) -> BYTE1_R {
                BYTE1_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - 8-bit Receive Buffer, Used Only in DMA Modes"]
            #[inline(always)]
            pub fn byte2(&self) -> BYTE2_R {
                BYTE2_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RX")
                    .field("byte1", &self.byte1())
                    .field("byte2", &self.byte2())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Receive\n\nYou can [`read`](crate::Reg::read) this register and get [`rx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:RX)"]
        pub struct RXrs;
        impl crate::RegisterSpec for RXrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rx::R`](R) reader structure"]
        impl crate::Readable for RXrs {}
        #[doc = "`write(|w| ..)` method takes [`rx::W`](W) writer structure"]
        impl crate::Writable for RXrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RX to value 0"]
        impl crate::Resettable for RXrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "TX (rw) register accessor: Transmit\n\nYou can [`read`](crate::Reg::read) this register and get [`tx::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:TX)\n\nFor information about available fields see [`mod@tx`]
module"]
    pub type TX = crate::Reg<tx::TXrs>;
    #[doc = "Transmit"]
    pub mod tx {
        #[doc = "Register `TX` reader"]
        pub type R = crate::R<TXrs>;
        #[doc = "Register `TX` writer"]
        pub type W = crate::W<TXrs>;
        #[doc = "Field `BYTE1` writer - 8-bit Transmit Buffer"]
        pub type BYTE1_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        #[doc = "Field `BYTE2` writer - 8-bit Transmit Buffer, Used Only in DMA Modes"]
        pub type BYTE2_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TX").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - 8-bit Transmit Buffer"]
            #[inline(always)]
            pub fn byte1(&mut self) -> BYTE1_W<TXrs> {
                BYTE1_W::new(self, 0)
            }
            #[doc = "Bits 8:15 - 8-bit Transmit Buffer, Used Only in DMA Modes"]
            #[inline(always)]
            pub fn byte2(&mut self) -> BYTE2_W<TXrs> {
                BYTE2_W::new(self, 8)
            }
        }
        #[doc = "Transmit\n\nYou can [`read`](crate::Reg::read) this register and get [`tx::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:TX)"]
        pub struct TXrs;
        impl crate::RegisterSpec for TXrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tx::R`](R) reader structure"]
        impl crate::Readable for TXrs {}
        #[doc = "`write(|w| ..)` method takes [`tx::W`](W) writer structure"]
        impl crate::Writable for TXrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TX to value 0"]
        impl crate::Resettable for TXrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DIV (rw) register accessor: SPI Baud Rate Selection\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:DIV)\n\nFor information about available fields see [`mod@div`]
module"]
    pub type DIV = crate::Reg<div::DIVrs>;
    #[doc = "SPI Baud Rate Selection"]
    pub mod div {
        #[doc = "Register `DIV` reader"]
        pub type R = crate::R<DIVrs>;
        #[doc = "Register `DIV` writer"]
        pub type W = crate::W<DIVrs>;
        #[doc = "Field `DIV` reader - SPI Clock Divider"]
        pub type DIV_R = crate::FieldReader;
        #[doc = "Field `DIV` writer - SPI Clock Divider"]
        pub type DIV_W<'a, REG> = crate::FieldWriter<'a, REG, 6, u8, crate::Safe>;
        #[doc = "Field `SFR` reader - Slave Free Run Mode"]
        pub type SFR_R = crate::BitReader;
        #[doc = "Field `SFR` writer - Slave Free Run Mode"]
        pub type SFR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:5 - SPI Clock Divider"]
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new((self.bits & 0x3f) as u8)
            }
            #[doc = "Bit 8 - Slave Free Run Mode"]
            #[inline(always)]
            pub fn sfr(&self) -> SFR_R {
                SFR_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DIV")
                    .field("div", &self.div())
                    .field("sfr", &self.sfr())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:5 - SPI Clock Divider"]
            #[inline(always)]
            pub fn div(&mut self) -> DIV_W<DIVrs> {
                DIV_W::new(self, 0)
            }
            #[doc = "Bit 8 - Slave Free Run Mode"]
            #[inline(always)]
            pub fn sfr(&mut self) -> SFR_W<DIVrs> {
                SFR_W::new(self, 8)
            }
        }
        #[doc = "SPI Baud Rate Selection\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:DIV)"]
        pub struct DIVrs;
        impl crate::RegisterSpec for DIVrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`div::R`](R) reader structure"]
        impl crate::Readable for DIVrs {}
        #[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"]
        impl crate::Writable for DIVrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DIV to value 0"]
        impl crate::Resettable for DIVrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CTL (rw) register accessor: SPI Configuration 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:CTL)\n\nFor information about available fields see [`mod@ctl`]
module"]
    pub type CTL = crate::Reg<ctl::CTLrs>;
    #[doc = "SPI Configuration 1"]
    pub mod ctl {
        #[doc = "Register `CTL` reader"]
        pub type R = crate::R<CTLrs>;
        #[doc = "Register `CTL` writer"]
        pub type W = crate::W<CTLrs>;
        #[doc = "Field `SPIEN` reader - SPI Enable"]
        pub type SPIEN_R = crate::BitReader;
        #[doc = "Field `SPIEN` writer - SPI Enable"]
        pub type SPIEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MASEN` reader - Master Mode Enable"]
        pub type MASEN_R = crate::BitReader;
        #[doc = "Field `MASEN` writer - Master Mode Enable"]
        pub type MASEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CPHA` reader - Serial Clock Phase Mode"]
        pub type CPHA_R = crate::BitReader;
        #[doc = "Field `CPHA` writer - Serial Clock Phase Mode"]
        pub type CPHA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CPOL` reader - Serial Clock Polarity"]
        pub type CPOL_R = crate::BitReader;
        #[doc = "Field `CPOL` writer - Serial Clock Polarity"]
        pub type CPOL_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WOM` reader - SPI Wired or Mode"]
        pub type WOM_R = crate::BitReader;
        #[doc = "Field `WOM` writer - SPI Wired or Mode"]
        pub type WOM_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LSB` reader - LSB First Transfer Enable"]
        pub type LSB_R = crate::BitReader;
        #[doc = "Field `LSB` writer - LSB First Transfer Enable"]
        pub type LSB_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TIM` reader - SPI Transfer and Interrupt Mode"]
        pub type TIM_R = crate::BitReader;
        #[doc = "Field `TIM` writer - SPI Transfer and Interrupt Mode"]
        pub type TIM_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ZEN` reader - Transmit Zeros Enable"]
        pub type ZEN_R = crate::BitReader;
        #[doc = "Field `ZEN` writer - Transmit Zeros Enable"]
        pub type ZEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RXOF` reader - RX Overflow Overwrite Enable"]
        pub type RXOF_R = crate::BitReader;
        #[doc = "Field `RXOF` writer - RX Overflow Overwrite Enable"]
        pub type RXOF_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OEN` reader - Slave MISO Output Enable"]
        pub type OEN_R = crate::BitReader;
        #[doc = "Field `OEN` writer - Slave MISO Output Enable"]
        pub type OEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LOOPBACK` reader - Loopback Enable"]
        pub type LOOPBACK_R = crate::BitReader;
        #[doc = "Field `LOOPBACK` writer - Loopback Enable"]
        pub type LOOPBACK_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CON` reader - Continuous Transfer Enable"]
        pub type CON_R = crate::BitReader;
        #[doc = "Field `CON` writer - Continuous Transfer Enable"]
        pub type CON_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RFLUSH` reader - SPI Rx FIFO Flush Enable"]
        pub type RFLUSH_R = crate::BitReader;
        #[doc = "Field `RFLUSH` writer - SPI Rx FIFO Flush Enable"]
        pub type RFLUSH_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TFLUSH` reader - SPI Tx FIFO Flush Enable"]
        pub type TFLUSH_R = crate::BitReader;
        #[doc = "Field `TFLUSH` writer - SPI Tx FIFO Flush Enable"]
        pub type TFLUSH_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CSRST` reader - Reset Mode for CS Error Bit"]
        pub type CSRST_R = crate::BitReader;
        #[doc = "Field `CSRST` writer - Reset Mode for CS Error Bit"]
        pub type CSRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - SPI Enable"]
            #[inline(always)]
            pub fn spien(&self) -> SPIEN_R {
                SPIEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Master Mode Enable"]
            #[inline(always)]
            pub fn masen(&self) -> MASEN_R {
                MASEN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Serial Clock Phase Mode"]
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Serial Clock Polarity"]
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - SPI Wired or Mode"]
            #[inline(always)]
            pub fn wom(&self) -> WOM_R {
                WOM_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - LSB First Transfer Enable"]
            #[inline(always)]
            pub fn lsb(&self) -> LSB_R {
                LSB_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - SPI Transfer and Interrupt Mode"]
            #[inline(always)]
            pub fn tim(&self) -> TIM_R {
                TIM_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Transmit Zeros Enable"]
            #[inline(always)]
            pub fn zen(&self) -> ZEN_R {
                ZEN_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - RX Overflow Overwrite Enable"]
            #[inline(always)]
            pub fn rxof(&self) -> RXOF_R {
                RXOF_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Slave MISO Output Enable"]
            #[inline(always)]
            pub fn oen(&self) -> OEN_R {
                OEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Loopback Enable"]
            #[inline(always)]
            pub fn loopback(&self) -> LOOPBACK_R {
                LOOPBACK_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Continuous Transfer Enable"]
            #[inline(always)]
            pub fn con(&self) -> CON_R {
                CON_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - SPI Rx FIFO Flush Enable"]
            #[inline(always)]
            pub fn rflush(&self) -> RFLUSH_R {
                RFLUSH_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - SPI Tx FIFO Flush Enable"]
            #[inline(always)]
            pub fn tflush(&self) -> TFLUSH_R {
                TFLUSH_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Reset Mode for CS Error Bit"]
            #[inline(always)]
            pub fn csrst(&self) -> CSRST_R {
                CSRST_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CTL")
                    .field("spien", &self.spien())
                    .field("masen", &self.masen())
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .field("wom", &self.wom())
                    .field("lsb", &self.lsb())
                    .field("tim", &self.tim())
                    .field("zen", &self.zen())
                    .field("rxof", &self.rxof())
                    .field("oen", &self.oen())
                    .field("loopback", &self.loopback())
                    .field("con", &self.con())
                    .field("rflush", &self.rflush())
                    .field("tflush", &self.tflush())
                    .field("csrst", &self.csrst())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - SPI Enable"]
            #[inline(always)]
            pub fn spien(&mut self) -> SPIEN_W<CTLrs> {
                SPIEN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Master Mode Enable"]
            #[inline(always)]
            pub fn masen(&mut self) -> MASEN_W<CTLrs> {
                MASEN_W::new(self, 1)
            }
            #[doc = "Bit 2 - Serial Clock Phase Mode"]
            #[inline(always)]
            pub fn cpha(&mut self) -> CPHA_W<CTLrs> {
                CPHA_W::new(self, 2)
            }
            #[doc = "Bit 3 - Serial Clock Polarity"]
            #[inline(always)]
            pub fn cpol(&mut self) -> CPOL_W<CTLrs> {
                CPOL_W::new(self, 3)
            }
            #[doc = "Bit 4 - SPI Wired or Mode"]
            #[inline(always)]
            pub fn wom(&mut self) -> WOM_W<CTLrs> {
                WOM_W::new(self, 4)
            }
            #[doc = "Bit 5 - LSB First Transfer Enable"]
            #[inline(always)]
            pub fn lsb(&mut self) -> LSB_W<CTLrs> {
                LSB_W::new(self, 5)
            }
            #[doc = "Bit 6 - SPI Transfer and Interrupt Mode"]
            #[inline(always)]
            pub fn tim(&mut self) -> TIM_W<CTLrs> {
                TIM_W::new(self, 6)
            }
            #[doc = "Bit 7 - Transmit Zeros Enable"]
            #[inline(always)]
            pub fn zen(&mut self) -> ZEN_W<CTLrs> {
                ZEN_W::new(self, 7)
            }
            #[doc = "Bit 8 - RX Overflow Overwrite Enable"]
            #[inline(always)]
            pub fn rxof(&mut self) -> RXOF_W<CTLrs> {
                RXOF_W::new(self, 8)
            }
            #[doc = "Bit 9 - Slave MISO Output Enable"]
            #[inline(always)]
            pub fn oen(&mut self) -> OEN_W<CTLrs> {
                OEN_W::new(self, 9)
            }
            #[doc = "Bit 10 - Loopback Enable"]
            #[inline(always)]
            pub fn loopback(&mut self) -> LOOPBACK_W<CTLrs> {
                LOOPBACK_W::new(self, 10)
            }
            #[doc = "Bit 11 - Continuous Transfer Enable"]
            #[inline(always)]
            pub fn con(&mut self) -> CON_W<CTLrs> {
                CON_W::new(self, 11)
            }
            #[doc = "Bit 12 - SPI Rx FIFO Flush Enable"]
            #[inline(always)]
            pub fn rflush(&mut self) -> RFLUSH_W<CTLrs> {
                RFLUSH_W::new(self, 12)
            }
            #[doc = "Bit 13 - SPI Tx FIFO Flush Enable"]
            #[inline(always)]
            pub fn tflush(&mut self) -> TFLUSH_W<CTLrs> {
                TFLUSH_W::new(self, 13)
            }
            #[doc = "Bit 14 - Reset Mode for CS Error Bit"]
            #[inline(always)]
            pub fn csrst(&mut self) -> CSRST_W<CTLrs> {
                CSRST_W::new(self, 14)
            }
        }
        #[doc = "SPI Configuration 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:CTL)"]
        pub struct CTLrs;
        impl crate::RegisterSpec for CTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctl::R`](R) reader structure"]
        impl crate::Readable for CTLrs {}
        #[doc = "`write(|w| ..)` method takes [`ctl::W`](W) writer structure"]
        impl crate::Writable for CTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CTL to value 0"]
        impl crate::Resettable for CTLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "IEN (rw) register accessor: SPI Configuration 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ien::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ien::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:IEN)\n\nFor information about available fields see [`mod@ien`]
module"]
    pub type IEN = crate::Reg<ien::IENrs>;
    #[doc = "SPI Configuration 2"]
    pub mod ien {
        #[doc = "Register `IEN` reader"]
        pub type R = crate::R<IENrs>;
        #[doc = "Register `IEN` writer"]
        pub type W = crate::W<IENrs>;
        #[doc = "SPI IRQ Mode Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IRQMODE {
            #[doc = "0: Interrupt Occurs After 1 Byte is Transfered or Received"]
            Tx1rx1 = 0,
            #[doc = "1: Interrupt Occurs After 2 Byte is Transfered or Received"]
            Tx2rx2 = 1,
            #[doc = "2: Interrupt Occurs After 3 Byte is Transfered or Received"]
            Tx3rx3 = 2,
            #[doc = "3: Interrupt Occurs After 4 Byte is Transfered or Received"]
            Tx4rx4 = 3,
            #[doc = "4: Interrupt Occurs After 5 Byte is Transfered or Received"]
            Tx5rx5 = 4,
            #[doc = "5: Interrupt Occurs After 6 Byte is Transfered or Received"]
            Tx6rx6 = 5,
            #[doc = "6: Interrupt Occurs After 7 Byte is Transfered or Received"]
            Tx7rx7 = 6,
            #[doc = "7: Interrupt Occurs After 8 Byte is Transfered or Received"]
            Tx8rx8 = 7,
        }
        impl From<IRQMODE> for u8 {
            #[inline(always)]
            fn from(variant: IRQMODE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for IRQMODE {
            type Ux = u8;
        }
        impl crate::IsEnum for IRQMODE {}
        #[doc = "Field `IRQMODE` reader - SPI IRQ Mode Bits"]
        pub type IRQMODE_R = crate::FieldReader<IRQMODE>;
        impl IRQMODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> IRQMODE {
                match self.bits {
                    0 => IRQMODE::Tx1rx1,
                    1 => IRQMODE::Tx2rx2,
                    2 => IRQMODE::Tx3rx3,
                    3 => IRQMODE::Tx4rx4,
                    4 => IRQMODE::Tx5rx5,
                    5 => IRQMODE::Tx6rx6,
                    6 => IRQMODE::Tx7rx7,
                    7 => IRQMODE::Tx8rx8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Interrupt Occurs After 1 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn is_tx1rx1(&self) -> bool {
                *self == IRQMODE::Tx1rx1
            }
            #[doc = "Interrupt Occurs After 2 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn is_tx2rx2(&self) -> bool {
                *self == IRQMODE::Tx2rx2
            }
            #[doc = "Interrupt Occurs After 3 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn is_tx3rx3(&self) -> bool {
                *self == IRQMODE::Tx3rx3
            }
            #[doc = "Interrupt Occurs After 4 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn is_tx4rx4(&self) -> bool {
                *self == IRQMODE::Tx4rx4
            }
            #[doc = "Interrupt Occurs After 5 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn is_tx5rx5(&self) -> bool {
                *self == IRQMODE::Tx5rx5
            }
            #[doc = "Interrupt Occurs After 6 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn is_tx6rx6(&self) -> bool {
                *self == IRQMODE::Tx6rx6
            }
            #[doc = "Interrupt Occurs After 7 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn is_tx7rx7(&self) -> bool {
                *self == IRQMODE::Tx7rx7
            }
            #[doc = "Interrupt Occurs After 8 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn is_tx8rx8(&self) -> bool {
                *self == IRQMODE::Tx8rx8
            }
        }
        #[doc = "Field `IRQMODE` writer - SPI IRQ Mode Bits"]
        pub type IRQMODE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, IRQMODE, crate::Safe>;
        impl<'a, REG> IRQMODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Interrupt Occurs After 1 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn tx1rx1(self) -> &'a mut crate::W<REG> {
                self.variant(IRQMODE::Tx1rx1)
            }
            #[doc = "Interrupt Occurs After 2 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn tx2rx2(self) -> &'a mut crate::W<REG> {
                self.variant(IRQMODE::Tx2rx2)
            }
            #[doc = "Interrupt Occurs After 3 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn tx3rx3(self) -> &'a mut crate::W<REG> {
                self.variant(IRQMODE::Tx3rx3)
            }
            #[doc = "Interrupt Occurs After 4 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn tx4rx4(self) -> &'a mut crate::W<REG> {
                self.variant(IRQMODE::Tx4rx4)
            }
            #[doc = "Interrupt Occurs After 5 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn tx5rx5(self) -> &'a mut crate::W<REG> {
                self.variant(IRQMODE::Tx5rx5)
            }
            #[doc = "Interrupt Occurs After 6 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn tx6rx6(self) -> &'a mut crate::W<REG> {
                self.variant(IRQMODE::Tx6rx6)
            }
            #[doc = "Interrupt Occurs After 7 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn tx7rx7(self) -> &'a mut crate::W<REG> {
                self.variant(IRQMODE::Tx7rx7)
            }
            #[doc = "Interrupt Occurs After 8 Byte is Transfered or Received"]
            #[inline(always)]
            pub fn tx8rx8(self) -> &'a mut crate::W<REG> {
                self.variant(IRQMODE::Tx8rx8)
            }
        }
        #[doc = "Field `CS` reader - Enable Interrupt on Every CS Edge in Slave CON Mode"]
        pub type CS_R = crate::BitReader;
        #[doc = "Field `CS` writer - Enable Interrupt on Every CS Edge in Slave CON Mode"]
        pub type CS_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXUNDR` reader - Tx-underflow Interrupt Enable"]
        pub type TXUNDR_R = crate::BitReader;
        #[doc = "Field `TXUNDR` writer - Tx-underflow Interrupt Enable"]
        pub type TXUNDR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RXOVR` reader - Rx-overflow Interrupt Enable"]
        pub type RXOVR_R = crate::BitReader;
        #[doc = "Field `RXOVR` writer - Rx-overflow Interrupt Enable"]
        pub type RXOVR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RDY` reader - Ready Signal Edge Interrupt Enable"]
        pub type RDY_R = crate::BitReader;
        #[doc = "Field `RDY` writer - Ready Signal Edge Interrupt Enable"]
        pub type RDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXDONE` reader - SPI Transmit Done Interrupt Enable"]
        pub type TXDONE_R = crate::BitReader;
        #[doc = "Field `TXDONE` writer - SPI Transmit Done Interrupt Enable"]
        pub type TXDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `XFRDONE` reader - SPI Transfer Completion Interrupt Enable"]
        pub type XFRDONE_R = crate::BitReader;
        #[doc = "Field `XFRDONE` writer - SPI Transfer Completion Interrupt Enable"]
        pub type XFRDONE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXEMPTY` reader - Tx-FIFO Empty Interrupt Enable"]
        pub type TXEMPTY_R = crate::BitReader;
        #[doc = "Field `TXEMPTY` writer - Tx-FIFO Empty Interrupt Enable"]
        pub type TXEMPTY_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:2 - SPI IRQ Mode Bits"]
            #[inline(always)]
            pub fn irqmode(&self) -> IRQMODE_R {
                IRQMODE_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bit 8 - Enable Interrupt on Every CS Edge in Slave CON Mode"]
            #[inline(always)]
            pub fn cs(&self) -> CS_R {
                CS_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Tx-underflow Interrupt Enable"]
            #[inline(always)]
            pub fn txundr(&self) -> TXUNDR_R {
                TXUNDR_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Rx-overflow Interrupt Enable"]
            #[inline(always)]
            pub fn rxovr(&self) -> RXOVR_R {
                RXOVR_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Ready Signal Edge Interrupt Enable"]
            #[inline(always)]
            pub fn rdy(&self) -> RDY_R {
                RDY_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - SPI Transmit Done Interrupt Enable"]
            #[inline(always)]
            pub fn txdone(&self) -> TXDONE_R {
                TXDONE_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - SPI Transfer Completion Interrupt Enable"]
            #[inline(always)]
            pub fn xfrdone(&self) -> XFRDONE_R {
                XFRDONE_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Tx-FIFO Empty Interrupt Enable"]
            #[inline(always)]
            pub fn txempty(&self) -> TXEMPTY_R {
                TXEMPTY_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IEN")
                    .field("irqmode", &self.irqmode())
                    .field("cs", &self.cs())
                    .field("txundr", &self.txundr())
                    .field("rxovr", &self.rxovr())
                    .field("rdy", &self.rdy())
                    .field("txdone", &self.txdone())
                    .field("xfrdone", &self.xfrdone())
                    .field("txempty", &self.txempty())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:2 - SPI IRQ Mode Bits"]
            #[inline(always)]
            pub fn irqmode(&mut self) -> IRQMODE_W<IENrs> {
                IRQMODE_W::new(self, 0)
            }
            #[doc = "Bit 8 - Enable Interrupt on Every CS Edge in Slave CON Mode"]
            #[inline(always)]
            pub fn cs(&mut self) -> CS_W<IENrs> {
                CS_W::new(self, 8)
            }
            #[doc = "Bit 9 - Tx-underflow Interrupt Enable"]
            #[inline(always)]
            pub fn txundr(&mut self) -> TXUNDR_W<IENrs> {
                TXUNDR_W::new(self, 9)
            }
            #[doc = "Bit 10 - Rx-overflow Interrupt Enable"]
            #[inline(always)]
            pub fn rxovr(&mut self) -> RXOVR_W<IENrs> {
                RXOVR_W::new(self, 10)
            }
            #[doc = "Bit 11 - Ready Signal Edge Interrupt Enable"]
            #[inline(always)]
            pub fn rdy(&mut self) -> RDY_W<IENrs> {
                RDY_W::new(self, 11)
            }
            #[doc = "Bit 12 - SPI Transmit Done Interrupt Enable"]
            #[inline(always)]
            pub fn txdone(&mut self) -> TXDONE_W<IENrs> {
                TXDONE_W::new(self, 12)
            }
            #[doc = "Bit 13 - SPI Transfer Completion Interrupt Enable"]
            #[inline(always)]
            pub fn xfrdone(&mut self) -> XFRDONE_W<IENrs> {
                XFRDONE_W::new(self, 13)
            }
            #[doc = "Bit 14 - Tx-FIFO Empty Interrupt Enable"]
            #[inline(always)]
            pub fn txempty(&mut self) -> TXEMPTY_W<IENrs> {
                TXEMPTY_W::new(self, 14)
            }
        }
        #[doc = "SPI Configuration 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ien::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ien::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:IEN)"]
        pub struct IENrs;
        impl crate::RegisterSpec for IENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ien::R`](R) reader structure"]
        impl crate::Readable for IENrs {}
        #[doc = "`write(|w| ..)` method takes [`ien::W`](W) writer structure"]
        impl crate::Writable for IENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets IEN to value 0"]
        impl crate::Resettable for IENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CNT (rw) register accessor: Transfer Byte Count\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:CNT)\n\nFor information about available fields see [`mod@cnt`]
module"]
    pub type CNT = crate::Reg<cnt::CNTrs>;
    #[doc = "Transfer Byte Count"]
    pub mod cnt {
        #[doc = "Register `CNT` reader"]
        pub type R = crate::R<CNTrs>;
        #[doc = "Register `CNT` writer"]
        pub type W = crate::W<CNTrs>;
        #[doc = "Field `VALUES` reader - Transfer Byte Count"]
        pub type VALUES_R = crate::FieldReader<u16>;
        #[doc = "Field `VALUES` writer - Transfer Byte Count"]
        pub type VALUES_W<'a, REG> = crate::FieldWriter<'a, REG, 14, u16, crate::Safe>;
        #[doc = "Field `FRAMECONT` reader - Continue Frame"]
        pub type FRAMECONT_R = crate::BitReader;
        #[doc = "Field `FRAMECONT` writer - Continue Frame"]
        pub type FRAMECONT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:13 - Transfer Byte Count"]
            #[inline(always)]
            pub fn values(&self) -> VALUES_R {
                VALUES_R::new((self.bits & 0x3fff) as u16)
            }
            #[doc = "Bit 15 - Continue Frame"]
            #[inline(always)]
            pub fn framecont(&self) -> FRAMECONT_R {
                FRAMECONT_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CNT")
                    .field("values", &self.values())
                    .field("framecont", &self.framecont())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:13 - Transfer Byte Count"]
            #[inline(always)]
            pub fn values(&mut self) -> VALUES_W<CNTrs> {
                VALUES_W::new(self, 0)
            }
            #[doc = "Bit 15 - Continue Frame"]
            #[inline(always)]
            pub fn framecont(&mut self) -> FRAMECONT_W<CNTrs> {
                FRAMECONT_W::new(self, 15)
            }
        }
        #[doc = "Transfer Byte Count\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:CNT)"]
        pub struct CNTrs;
        impl crate::RegisterSpec for CNTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt::R`](R) reader structure"]
        impl crate::Readable for CNTrs {}
        #[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
        impl crate::Writable for CNTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CNT to value 0"]
        impl crate::Resettable for CNTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DMA (rw) register accessor: SPI DMA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:DMA)\n\nFor information about available fields see [`mod@dma`]
module"]
    pub type DMA = crate::Reg<dma::DMArs>;
    #[doc = "SPI DMA Enable"]
    pub mod dma {
        #[doc = "Register `DMA` reader"]
        pub type R = crate::R<DMArs>;
        #[doc = "Register `DMA` writer"]
        pub type W = crate::W<DMArs>;
        #[doc = "Field `EN` reader - Enable DMA for Data Transfer"]
        pub type EN_R = crate::BitReader;
        #[doc = "Field `EN` writer - Enable DMA for Data Transfer"]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXEN` reader - Enable Transmit DMA Request"]
        pub type TXEN_R = crate::BitReader;
        #[doc = "Field `TXEN` writer - Enable Transmit DMA Request"]
        pub type TXEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RXEN` reader - Enable Receive DMA Request"]
        pub type RXEN_R = crate::BitReader;
        #[doc = "Field `RXEN` writer - Enable Receive DMA Request"]
        pub type RXEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Enable DMA for Data Transfer"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Enable Transmit DMA Request"]
            #[inline(always)]
            pub fn txen(&self) -> TXEN_R {
                TXEN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Enable Receive DMA Request"]
            #[inline(always)]
            pub fn rxen(&self) -> RXEN_R {
                RXEN_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DMA")
                    .field("en", &self.en())
                    .field("txen", &self.txen())
                    .field("rxen", &self.rxen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable DMA for Data Transfer"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<DMArs> {
                EN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Enable Transmit DMA Request"]
            #[inline(always)]
            pub fn txen(&mut self) -> TXEN_W<DMArs> {
                TXEN_W::new(self, 1)
            }
            #[doc = "Bit 2 - Enable Receive DMA Request"]
            #[inline(always)]
            pub fn rxen(&mut self) -> RXEN_W<DMArs> {
                RXEN_W::new(self, 2)
            }
        }
        #[doc = "SPI DMA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:DMA)"]
        pub struct DMArs;
        impl crate::RegisterSpec for DMArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dma::R`](R) reader structure"]
        impl crate::Readable for DMArs {}
        #[doc = "`write(|w| ..)` method takes [`dma::W`](W) writer structure"]
        impl crate::Writable for DMArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DMA to value 0"]
        impl crate::Resettable for DMArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FIFOSTAT (rw) register accessor: FIFO Status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifostat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifostat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:FIFOSTAT)\n\nFor information about available fields see [`mod@fifostat`]
module"]
    pub type FIFOSTAT = crate::Reg<fifostat::FIFOSTATrs>;
    #[doc = "FIFO Status"]
    pub mod fifostat {
        #[doc = "Register `FIFOSTAT` reader"]
        pub type R = crate::R<FIFOSTATrs>;
        #[doc = "Register `FIFOSTAT` writer"]
        pub type W = crate::W<FIFOSTATrs>;
        #[doc = "SPI Tx FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TX {
            #[doc = "0: Tx FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Valid Byte/half-word in Tx FIFO"]
            One = 1,
            #[doc = "2: 2 Valid Bytes/half-words in Tx FIFO"]
            Two = 2,
            #[doc = "3: 3 Valid Bytes/half-words in Tx FIFO"]
            Three = 3,
            #[doc = "4: 4 Valid Bytes/half-words in Tx FIFO"]
            Four = 4,
            #[doc = "5: 5 Valid Bytes/half-words in Tx FIFO"]
            Five = 5,
            #[doc = "6: 6 Valid Bytes/half-words in Tx FIFO"]
            Six = 6,
            #[doc = "7: 7 Valid Bytes/half-words in Tx FIFO"]
            Seven = 7,
            #[doc = "8: 8 Valid Bytes/half-words in Tx FIFO (Tx FIFO Full)"]
            Full = 8,
        }
        impl From<TX> for u8 {
            #[inline(always)]
            fn from(variant: TX) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TX {
            type Ux = u8;
        }
        impl crate::IsEnum for TX {}
        #[doc = "Field `TX` reader - SPI Tx FIFO Status"]
        pub type TX_R = crate::FieldReader<TX>;
        impl TX_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<TX> {
                match self.bits {
                    0 => Some(TX::Empty),
                    1 => Some(TX::One),
                    2 => Some(TX::Two),
                    3 => Some(TX::Three),
                    4 => Some(TX::Four),
                    5 => Some(TX::Five),
                    6 => Some(TX::Six),
                    7 => Some(TX::Seven),
                    8 => Some(TX::Full),
                    _ => None,
                }
            }
            #[doc = "Tx FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TX::Empty
            }
            #[doc = "1 Valid Byte/half-word in Tx FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == TX::One
            }
            #[doc = "2 Valid Bytes/half-words in Tx FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == TX::Two
            }
            #[doc = "3 Valid Bytes/half-words in Tx FIFO"]
            #[inline(always)]
            pub fn is_three(&self) -> bool {
                *self == TX::Three
            }
            #[doc = "4 Valid Bytes/half-words in Tx FIFO"]
            #[inline(always)]
            pub fn is_four(&self) -> bool {
                *self == TX::Four
            }
            #[doc = "5 Valid Bytes/half-words in Tx FIFO"]
            #[inline(always)]
            pub fn is_five(&self) -> bool {
                *self == TX::Five
            }
            #[doc = "6 Valid Bytes/half-words in Tx FIFO"]
            #[inline(always)]
            pub fn is_six(&self) -> bool {
                *self == TX::Six
            }
            #[doc = "7 Valid Bytes/half-words in Tx FIFO"]
            #[inline(always)]
            pub fn is_seven(&self) -> bool {
                *self == TX::Seven
            }
            #[doc = "8 Valid Bytes/half-words in Tx FIFO (Tx FIFO Full)"]
            #[inline(always)]
            pub fn is_full(&self) -> bool {
                *self == TX::Full
            }
        }
        #[doc = "SPI Rx FIFO Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum RX {
            #[doc = "0: Rx FIFO Empty"]
            Empty = 0,
            #[doc = "1: 1 Valid Byte/half-word in Rx FIFO"]
            One = 1,
            #[doc = "2: 2 Valid Bytes/half-words in Rx FIFO"]
            Two = 2,
            #[doc = "3: 3 Valid Bytes/half-words in Rx FIFO"]
            Three = 3,
            #[doc = "4: 4 Valid Bytes/half-words in Rx FIFO"]
            Four = 4,
            #[doc = "5: 5 Valid Bytes/half-words in Rx FIFO"]
            Five = 5,
            #[doc = "6: 6 Valid Bytes/half-words in Rx FIFO"]
            Six = 6,
            #[doc = "7: 7 Valid Bytes/half-words in Rx FIFO"]
            Seven = 7,
            #[doc = "8: 8 Valid Bytes/half-words in Rx FIFO (Rx FIFO Full)"]
            Full = 8,
        }
        impl From<RX> for u8 {
            #[inline(always)]
            fn from(variant: RX) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for RX {
            type Ux = u8;
        }
        impl crate::IsEnum for RX {}
        #[doc = "Field `RX` reader - SPI Rx FIFO Status"]
        pub type RX_R = crate::FieldReader<RX>;
        impl RX_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<RX> {
                match self.bits {
                    0 => Some(RX::Empty),
                    1 => Some(RX::One),
                    2 => Some(RX::Two),
                    3 => Some(RX::Three),
                    4 => Some(RX::Four),
                    5 => Some(RX::Five),
                    6 => Some(RX::Six),
                    7 => Some(RX::Seven),
                    8 => Some(RX::Full),
                    _ => None,
                }
            }
            #[doc = "Rx FIFO Empty"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == RX::Empty
            }
            #[doc = "1 Valid Byte/half-word in Rx FIFO"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == RX::One
            }
            #[doc = "2 Valid Bytes/half-words in Rx FIFO"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == RX::Two
            }
            #[doc = "3 Valid Bytes/half-words in Rx FIFO"]
            #[inline(always)]
            pub fn is_three(&self) -> bool {
                *self == RX::Three
            }
            #[doc = "4 Valid Bytes/half-words in Rx FIFO"]
            #[inline(always)]
            pub fn is_four(&self) -> bool {
                *self == RX::Four
            }
            #[doc = "5 Valid Bytes/half-words in Rx FIFO"]
            #[inline(always)]
            pub fn is_five(&self) -> bool {
                *self == RX::Five
            }
            #[doc = "6 Valid Bytes/half-words in Rx FIFO"]
            #[inline(always)]
            pub fn is_six(&self) -> bool {
                *self == RX::Six
            }
            #[doc = "7 Valid Bytes/half-words in Rx FIFO"]
            #[inline(always)]
            pub fn is_seven(&self) -> bool {
                *self == RX::Seven
            }
            #[doc = "8 Valid Bytes/half-words in Rx FIFO (Rx FIFO Full)"]
            #[inline(always)]
            pub fn is_full(&self) -> bool {
                *self == RX::Full
            }
        }
        impl R {
            #[doc = "Bits 0:3 - SPI Tx FIFO Status"]
            #[inline(always)]
            pub fn tx(&self) -> TX_R {
                TX_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 8:11 - SPI Rx FIFO Status"]
            #[inline(always)]
            pub fn rx(&self) -> RX_R {
                RX_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FIFOSTAT")
                    .field("tx", &self.tx())
                    .field("rx", &self.rx())
                    .finish()
            }
        }
        impl W {}
        #[doc = "FIFO Status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifostat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifostat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:FIFOSTAT)"]
        pub struct FIFOSTATrs;
        impl crate::RegisterSpec for FIFOSTATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fifostat::R`](R) reader structure"]
        impl crate::Readable for FIFOSTATrs {}
        #[doc = "`write(|w| ..)` method takes [`fifostat::W`](W) writer structure"]
        impl crate::Writable for FIFOSTATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FIFOSTAT to value 0"]
        impl crate::Resettable for FIFOSTATrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RDCTL (rw) register accessor: Read Control\n\nYou can [`read`](crate::Reg::read) this register and get [`rdctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rdctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:RDCTL)\n\nFor information about available fields see [`mod@rdctl`]
module"]
    pub type RDCTL = crate::Reg<rdctl::RDCTLrs>;
    #[doc = "Read Control"]
    pub mod rdctl {
        #[doc = "Register `RDCTL` reader"]
        pub type R = crate::R<RDCTLrs>;
        #[doc = "Register `RDCTL` writer"]
        pub type W = crate::W<RDCTLrs>;
        #[doc = "Field `CMDEN` reader - Read Command Enable"]
        pub type CMDEN_R = crate::BitReader;
        #[doc = "Field `CMDEN` writer - Read Command Enable"]
        pub type CMDEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OVERLAP` reader - Tx/Rx Overlap Mode"]
        pub type OVERLAP_R = crate::BitReader;
        #[doc = "Field `OVERLAP` writer - Tx/Rx Overlap Mode"]
        pub type OVERLAP_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXBYTES` reader - Transmit Byte Count Minus 1 for Read Command"]
        pub type TXBYTES_R = crate::FieldReader;
        #[doc = "Field `TXBYTES` writer - Transmit Byte Count Minus 1 for Read Command"]
        pub type TXBYTES_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        #[doc = "Field `THREEPIN` reader - Three Pin SPI Mode"]
        pub type THREEPIN_R = crate::BitReader;
        #[doc = "Field `THREEPIN` writer - Three Pin SPI Mode"]
        pub type THREEPIN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Read Command Enable"]
            #[inline(always)]
            pub fn cmden(&self) -> CMDEN_R {
                CMDEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Tx/Rx Overlap Mode"]
            #[inline(always)]
            pub fn overlap(&self) -> OVERLAP_R {
                OVERLAP_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:5 - Transmit Byte Count Minus 1 for Read Command"]
            #[inline(always)]
            pub fn txbytes(&self) -> TXBYTES_R {
                TXBYTES_R::new(((self.bits >> 2) & 0x0f) as u8)
            }
            #[doc = "Bit 8 - Three Pin SPI Mode"]
            #[inline(always)]
            pub fn threepin(&self) -> THREEPIN_R {
                THREEPIN_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RDCTL")
                    .field("cmden", &self.cmden())
                    .field("overlap", &self.overlap())
                    .field("txbytes", &self.txbytes())
                    .field("threepin", &self.threepin())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Read Command Enable"]
            #[inline(always)]
            pub fn cmden(&mut self) -> CMDEN_W<RDCTLrs> {
                CMDEN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Tx/Rx Overlap Mode"]
            #[inline(always)]
            pub fn overlap(&mut self) -> OVERLAP_W<RDCTLrs> {
                OVERLAP_W::new(self, 1)
            }
            #[doc = "Bits 2:5 - Transmit Byte Count Minus 1 for Read Command"]
            #[inline(always)]
            pub fn txbytes(&mut self) -> TXBYTES_W<RDCTLrs> {
                TXBYTES_W::new(self, 2)
            }
            #[doc = "Bit 8 - Three Pin SPI Mode"]
            #[inline(always)]
            pub fn threepin(&mut self) -> THREEPIN_W<RDCTLrs> {
                THREEPIN_W::new(self, 8)
            }
        }
        #[doc = "Read Control\n\nYou can [`read`](crate::Reg::read) this register and get [`rdctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rdctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:RDCTL)"]
        pub struct RDCTLrs;
        impl crate::RegisterSpec for RDCTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rdctl::R`](R) reader structure"]
        impl crate::Readable for RDCTLrs {}
        #[doc = "`write(|w| ..)` method takes [`rdctl::W`](W) writer structure"]
        impl crate::Writable for RDCTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RDCTL to value 0"]
        impl crate::Resettable for RDCTLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FLOWCTL (rw) register accessor: Flow Control\n\nYou can [`read`](crate::Reg::read) this register and get [`flowctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flowctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:FLOWCTL)\n\nFor information about available fields see [`mod@flowctl`]
module"]
    pub type FLOWCTL = crate::Reg<flowctl::FLOWCTLrs>;
    #[doc = "Flow Control"]
    pub mod flowctl {
        #[doc = "Register `FLOWCTL` reader"]
        pub type R = crate::R<FLOWCTLrs>;
        #[doc = "Register `FLOWCTL` writer"]
        pub type W = crate::W<FLOWCTLrs>;
        #[doc = "Flow Control Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MODE {
            #[doc = "0: Flow Control is Disabled."]
            Disable = 0,
            #[doc = "1: Flow Control is Based on Timer (WAIT_TMR)."]
            Timer = 1,
            #[doc = "2: Flow Control is Based on RDY Signal."]
            Rdy = 2,
            #[doc = "3: Flow Control is Based on MISO Pin."]
            Miso = 3,
        }
        impl From<MODE> for u8 {
            #[inline(always)]
            fn from(variant: MODE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for MODE {
            type Ux = u8;
        }
        impl crate::IsEnum for MODE {}
        #[doc = "Field `MODE` reader - Flow Control Mode"]
        pub type MODE_R = crate::FieldReader<MODE>;
        impl MODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MODE {
                match self.bits {
                    0 => MODE::Disable,
                    1 => MODE::Timer,
                    2 => MODE::Rdy,
                    3 => MODE::Miso,
                    _ => unreachable!(),
                }
            }
            #[doc = "Flow Control is Disabled."]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == MODE::Disable
            }
            #[doc = "Flow Control is Based on Timer (WAIT_TMR)."]
            #[inline(always)]
            pub fn is_timer(&self) -> bool {
                *self == MODE::Timer
            }
            #[doc = "Flow Control is Based on RDY Signal."]
            #[inline(always)]
            pub fn is_rdy(&self) -> bool {
                *self == MODE::Rdy
            }
            #[doc = "Flow Control is Based on MISO Pin."]
            #[inline(always)]
            pub fn is_miso(&self) -> bool {
                *self == MODE::Miso
            }
        }
        #[doc = "Field `MODE` writer - Flow Control Mode"]
        pub type MODE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, MODE, crate::Safe>;
        impl<'a, REG> MODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Flow Control is Disabled."]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Disable)
            }
            #[doc = "Flow Control is Based on Timer (WAIT_TMR)."]
            #[inline(always)]
            pub fn timer(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Timer)
            }
            #[doc = "Flow Control is Based on RDY Signal."]
            #[inline(always)]
            pub fn rdy(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Rdy)
            }
            #[doc = "Flow Control is Based on MISO Pin."]
            #[inline(always)]
            pub fn miso(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Miso)
            }
        }
        #[doc = "Polarity of RDY/MISO Line\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RDYPOL {
            #[doc = "0: Polarity is Active HIGH. SPI Master Waits Until RDY/MISO Becomes HIGH."]
            High = 0,
            #[doc = "1: Polarity is Active LOW. SPI Master Waits Until RDY/MISO Becomes LOW."]
            Low = 1,
        }
        impl From<RDYPOL> for bool {
            #[inline(always)]
            fn from(variant: RDYPOL) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RDYPOL` reader - Polarity of RDY/MISO Line"]
        pub type RDYPOL_R = crate::BitReader<RDYPOL>;
        impl RDYPOL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RDYPOL {
                match self.bits {
                    false => RDYPOL::High,
                    true => RDYPOL::Low,
                }
            }
            #[doc = "Polarity is Active HIGH. SPI Master Waits Until RDY/MISO Becomes HIGH."]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == RDYPOL::High
            }
            #[doc = "Polarity is Active LOW. SPI Master Waits Until RDY/MISO Becomes LOW."]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == RDYPOL::Low
            }
        }
        #[doc = "Field `RDYPOL` writer - Polarity of RDY/MISO Line"]
        pub type RDYPOL_W<'a, REG> = crate::BitWriter<'a, REG, RDYPOL>;
        impl<'a, REG> RDYPOL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Polarity is Active HIGH. SPI Master Waits Until RDY/MISO Becomes HIGH."]
            #[inline(always)]
            pub fn high(self) -> &'a mut crate::W<REG> {
                self.variant(RDYPOL::High)
            }
            #[doc = "Polarity is Active LOW. SPI Master Waits Until RDY/MISO Becomes LOW."]
            #[inline(always)]
            pub fn low(self) -> &'a mut crate::W<REG> {
                self.variant(RDYPOL::Low)
            }
        }
        #[doc = "Field `RDBURSTSZ` reader - Read Data Burst Size Minus 1"]
        pub type RDBURSTSZ_R = crate::FieldReader<u16>;
        #[doc = "Field `RDBURSTSZ` writer - Read Data Burst Size Minus 1"]
        pub type RDBURSTSZ_W<'a, REG> = crate::FieldWriter<'a, REG, 10, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:1 - Flow Control Mode"]
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 4 - Polarity of RDY/MISO Line"]
            #[inline(always)]
            pub fn rdypol(&self) -> RDYPOL_R {
                RDYPOL_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 6:15 - Read Data Burst Size Minus 1"]
            #[inline(always)]
            pub fn rdburstsz(&self) -> RDBURSTSZ_R {
                RDBURSTSZ_R::new(((self.bits >> 6) & 0x03ff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FLOWCTL")
                    .field("mode", &self.mode())
                    .field("rdypol", &self.rdypol())
                    .field("rdburstsz", &self.rdburstsz())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Flow Control Mode"]
            #[inline(always)]
            pub fn mode(&mut self) -> MODE_W<FLOWCTLrs> {
                MODE_W::new(self, 0)
            }
            #[doc = "Bit 4 - Polarity of RDY/MISO Line"]
            #[inline(always)]
            pub fn rdypol(&mut self) -> RDYPOL_W<FLOWCTLrs> {
                RDYPOL_W::new(self, 4)
            }
            #[doc = "Bits 6:15 - Read Data Burst Size Minus 1"]
            #[inline(always)]
            pub fn rdburstsz(&mut self) -> RDBURSTSZ_W<FLOWCTLrs> {
                RDBURSTSZ_W::new(self, 6)
            }
        }
        #[doc = "Flow Control\n\nYou can [`read`](crate::Reg::read) this register and get [`flowctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flowctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:FLOWCTL)"]
        pub struct FLOWCTLrs;
        impl crate::RegisterSpec for FLOWCTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`flowctl::R`](R) reader structure"]
        impl crate::Readable for FLOWCTLrs {}
        #[doc = "`write(|w| ..)` method takes [`flowctl::W`](W) writer structure"]
        impl crate::Writable for FLOWCTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FLOWCTL to value 0"]
        impl crate::Resettable for FLOWCTLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "WAITTMR (rw) register accessor: Wait Timer for Flow Control\n\nYou can [`read`](crate::Reg::read) this register and get [`waittmr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`waittmr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:WAITTMR)\n\nFor information about available fields see [`mod@waittmr`]
module"]
    pub type WAITTMR = crate::Reg<waittmr::WAITTMRrs>;
    #[doc = "Wait Timer for Flow Control"]
    pub mod waittmr {
        #[doc = "Register `WAITTMR` reader"]
        pub type R = crate::R<WAITTMRrs>;
        #[doc = "Register `WAITTMR` writer"]
        pub type W = crate::W<WAITTMRrs>;
        #[doc = "Field `TRIMS` reader - Wait Timer for Flow-control"]
        pub type TRIMS_R = crate::FieldReader<u16>;
        #[doc = "Field `TRIMS` writer - Wait Timer for Flow-control"]
        pub type TRIMS_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Wait Timer for Flow-control"]
            #[inline(always)]
            pub fn trims(&self) -> TRIMS_R {
                TRIMS_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("WAITTMR")
                    .field("trims", &self.trims())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Wait Timer for Flow-control"]
            #[inline(always)]
            pub fn trims(&mut self) -> TRIMS_W<WAITTMRrs> {
                TRIMS_W::new(self, 0)
            }
        }
        #[doc = "Wait Timer for Flow Control\n\nYou can [`read`](crate::Reg::read) this register and get [`waittmr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`waittmr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:WAITTMR)"]
        pub struct WAITTMRrs;
        impl crate::RegisterSpec for WAITTMRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`waittmr::R`](R) reader structure"]
        impl crate::Readable for WAITTMRrs {}
        #[doc = "`write(|w| ..)` method takes [`waittmr::W`](W) writer structure"]
        impl crate::Writable for WAITTMRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets WAITTMR to value 0"]
        impl crate::Resettable for WAITTMRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CSOVERRIDE (rw) register accessor: Chip-Select Override\n\nYou can [`read`](crate::Reg::read) this register and get [`csoverride::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csoverride::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:CSOVERRIDE)\n\nFor information about available fields see [`mod@csoverride`]
module"]
    pub type CSOVERRIDE = crate::Reg<csoverride::CSOVERRIDErs>;
    #[doc = "Chip-Select Override"]
    pub mod csoverride {
        #[doc = "Register `CSOVERRIDE` reader"]
        pub type R = crate::R<CSOVERRIDErs>;
        #[doc = "Register `CSOVERRIDE` writer"]
        pub type W = crate::W<CSOVERRIDErs>;
        #[doc = "CS Override Control\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CTL {
            #[doc = "0: CS is Not Forced."]
            Notforce = 0,
            #[doc = "1: CS is Forced to Drive 1'b1."]
            Forceto1 = 1,
            #[doc = "2: CS is Forced to Drive 1'b0."]
            Forceto0 = 2,
        }
        impl From<CTL> for u8 {
            #[inline(always)]
            fn from(variant: CTL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CTL {
            type Ux = u8;
        }
        impl crate::IsEnum for CTL {}
        #[doc = "Field `CTL` reader - CS Override Control"]
        pub type CTL_R = crate::FieldReader<CTL>;
        impl CTL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CTL> {
                match self.bits {
                    0 => Some(CTL::Notforce),
                    1 => Some(CTL::Forceto1),
                    2 => Some(CTL::Forceto0),
                    _ => None,
                }
            }
            #[doc = "CS is Not Forced."]
            #[inline(always)]
            pub fn is_notforce(&self) -> bool {
                *self == CTL::Notforce
            }
            #[doc = "CS is Forced to Drive 1'b1."]
            #[inline(always)]
            pub fn is_forceto1(&self) -> bool {
                *self == CTL::Forceto1
            }
            #[doc = "CS is Forced to Drive 1'b0."]
            #[inline(always)]
            pub fn is_forceto0(&self) -> bool {
                *self == CTL::Forceto0
            }
        }
        #[doc = "Field `CTL` writer - CS Override Control"]
        pub type CTL_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CTL>;
        impl<'a, REG> CTL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "CS is Not Forced."]
            #[inline(always)]
            pub fn notforce(self) -> &'a mut crate::W<REG> {
                self.variant(CTL::Notforce)
            }
            #[doc = "CS is Forced to Drive 1'b1."]
            #[inline(always)]
            pub fn forceto1(self) -> &'a mut crate::W<REG> {
                self.variant(CTL::Forceto1)
            }
            #[doc = "CS is Forced to Drive 1'b0."]
            #[inline(always)]
            pub fn forceto0(self) -> &'a mut crate::W<REG> {
                self.variant(CTL::Forceto0)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - CS Override Control"]
            #[inline(always)]
            pub fn ctl(&self) -> CTL_R {
                CTL_R::new((self.bits & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CSOVERRIDE")
                    .field("ctl", &self.ctl())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - CS Override Control"]
            #[inline(always)]
            pub fn ctl(&mut self) -> CTL_W<CSOVERRIDErs> {
                CTL_W::new(self, 0)
            }
        }
        #[doc = "Chip-Select Override\n\nYou can [`read`](crate::Reg::read) this register and get [`csoverride::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csoverride::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0:CSOVERRIDE)"]
        pub struct CSOVERRIDErs;
        impl crate::RegisterSpec for CSOVERRIDErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`csoverride::R`](R) reader structure"]
        impl crate::Readable for CSOVERRIDErs {}
        #[doc = "`write(|w| ..)` method takes [`csoverride::W`](W) writer structure"]
        impl crate::Writable for CSOVERRIDErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CSOVERRIDE to value 0"]
        impl crate::Resettable for CSOVERRIDErs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Serial Peripheral Interface"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0)"]
pub struct D2D1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for D2D1 {}
impl D2D1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const d2d0::RegisterBlock = 0x4002_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const d2d0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for D2D1 {
    type Target = d2d0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for D2D1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("D2D1").finish()
    }
}
#[doc = "Serial Peripheral Interface"]
pub use self::d2d0 as d2d1;
#[doc = "Serial Peripheral Interface"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0)"]
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const d2d0::RegisterBlock = 0x4005_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const d2d0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI0 {
    type Target = d2d0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
#[doc = "Serial Peripheral Interface"]
pub use self::d2d0 as spi0;
#[doc = "Serial Peripheral Interface"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0)"]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const d2d0::RegisterBlock = 0x4005_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const d2d0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI1 {
    type Target = d2d0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
#[doc = "Serial Peripheral Interface"]
pub use self::d2d0 as spi1;
#[doc = "Serial Peripheral Interface"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#D2D0)"]
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const d2d0::RegisterBlock = 0x4005_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const d2d0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SPI2 {
    type Target = d2d0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI2").finish()
    }
}
#[doc = "Serial Peripheral Interface"]
pub use self::d2d0 as spi2;
#[doc = "DMA"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA)"]
pub struct DMA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA {}
impl DMA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma::RegisterBlock = 0x4004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DMA {
    type Target = dma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA").finish()
    }
}
#[doc = "DMA"]
pub mod dma {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        stat: STAT,
        cfg: CFG,
        pdbptr: PDBPTR,
        adbptr: ADBPTR,
        _reserved4: [u8; 0x04],
        swreq: SWREQ,
        _reserved5: [u8; 0x08],
        rmskset: RMSKSET,
        rmskclr: RMSKCLR,
        enset: ENSET,
        enclr: ENCLR,
        altset: ALTSET,
        altclr: ALTCLR,
        priset: PRISET,
        priclr: PRICLR,
        _reserved13: [u8; 0x08],
        errchnlclr: ERRCHNLCLR,
        errclr: ERRCLR,
        invaliddescclr: INVALIDDESCCLR,
        _reserved16: [u8; 0x07ac],
        bsset: BSSET,
        bsclr: BSCLR,
        _reserved18: [u8; 0x08],
        srcaddrset: SRCADDRSET,
        srcaddrclr: SRCADDRCLR,
        dstaddrset: DSTADDRSET,
        dstaddrclr: DSTADDRCLR,
        _reserved22: [u8; 0x07c0],
        revid: REVID,
    }
    impl RegisterBlock {
        #[doc = "0x00 - DMA Status"]
        #[inline(always)]
        pub const fn stat(&self) -> &STAT {
            &self.stat
        }
        #[doc = "0x04 - DMA Configuration"]
        #[inline(always)]
        pub const fn cfg(&self) -> &CFG {
            &self.cfg
        }
        #[doc = "0x08 - DMA Channel Primary Control Data Base Pointer"]
        #[inline(always)]
        pub const fn pdbptr(&self) -> &PDBPTR {
            &self.pdbptr
        }
        #[doc = "0x0c - DMA Channel Alternate Control Data Base Pointer"]
        #[inline(always)]
        pub const fn adbptr(&self) -> &ADBPTR {
            &self.adbptr
        }
        #[doc = "0x14 - DMA Channel Software Request"]
        #[inline(always)]
        pub const fn swreq(&self) -> &SWREQ {
            &self.swreq
        }
        #[doc = "0x20 - DMA Channel Request Mask Set"]
        #[inline(always)]
        pub const fn rmskset(&self) -> &RMSKSET {
            &self.rmskset
        }
        #[doc = "0x24 - DMA Channel Request Mask Clear"]
        #[inline(always)]
        pub const fn rmskclr(&self) -> &RMSKCLR {
            &self.rmskclr
        }
        #[doc = "0x28 - DMA Channel Enable Set"]
        #[inline(always)]
        pub const fn enset(&self) -> &ENSET {
            &self.enset
        }
        #[doc = "0x2c - DMA Channel Enable Clear"]
        #[inline(always)]
        pub const fn enclr(&self) -> &ENCLR {
            &self.enclr
        }
        #[doc = "0x30 - DMA Channel Primary-alternate Set"]
        #[inline(always)]
        pub const fn altset(&self) -> &ALTSET {
            &self.altset
        }
        #[doc = "0x34 - DMA Channel Primary-alternate Clear"]
        #[inline(always)]
        pub const fn altclr(&self) -> &ALTCLR {
            &self.altclr
        }
        #[doc = "0x38 - DMA Channel Priority Set"]
        #[inline(always)]
        pub const fn priset(&self) -> &PRISET {
            &self.priset
        }
        #[doc = "0x3c - DMA Channel Priority Clear"]
        #[inline(always)]
        pub const fn priclr(&self) -> &PRICLR {
            &self.priclr
        }
        #[doc = "0x48 - DMA per Channel Error Clear"]
        #[inline(always)]
        pub const fn errchnlclr(&self) -> &ERRCHNLCLR {
            &self.errchnlclr
        }
        #[doc = "0x4c - DMA Bus Error Clear"]
        #[inline(always)]
        pub const fn errclr(&self) -> &ERRCLR {
            &self.errclr
        }
        #[doc = "0x50 - DMA per Channel Invalid Descriptor Clear"]
        #[inline(always)]
        pub const fn invaliddescclr(&self) -> &INVALIDDESCCLR {
            &self.invaliddescclr
        }
        #[doc = "0x800 - DMA Channel Bytes Swap Enable Set"]
        #[inline(always)]
        pub const fn bsset(&self) -> &BSSET {
            &self.bsset
        }
        #[doc = "0x804 - DMA Channel Bytes Swap Enable Clear"]
        #[inline(always)]
        pub const fn bsclr(&self) -> &BSCLR {
            &self.bsclr
        }
        #[doc = "0x810 - DMA Channel Source Address Decrement Enable Set"]
        #[inline(always)]
        pub const fn srcaddrset(&self) -> &SRCADDRSET {
            &self.srcaddrset
        }
        #[doc = "0x814 - DMA Channel Source Address Decrement Enable Clear"]
        #[inline(always)]
        pub const fn srcaddrclr(&self) -> &SRCADDRCLR {
            &self.srcaddrclr
        }
        #[doc = "0x818 - DMA Channel Destination Address Decrement Enable Set"]
        #[inline(always)]
        pub const fn dstaddrset(&self) -> &DSTADDRSET {
            &self.dstaddrset
        }
        #[doc = "0x81c - DMA Channel Destination Address Decrement Enable Clear"]
        #[inline(always)]
        pub const fn dstaddrclr(&self) -> &DSTADDRCLR {
            &self.dstaddrclr
        }
        #[doc = "0xfe0 - DMA Controller Revision ID"]
        #[inline(always)]
        pub const fn revid(&self) -> &REVID {
            &self.revid
        }
    }
    #[doc = "STAT (rw) register accessor: DMA Status\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:STAT)\n\nFor information about available fields see [`mod@stat`]
module"]
    pub type STAT = crate::Reg<stat::STATrs>;
    #[doc = "DMA Status"]
    pub mod stat {
        #[doc = "Register `STAT` reader"]
        pub type R = crate::R<STATrs>;
        #[doc = "Register `STAT` writer"]
        pub type W = crate::W<STATrs>;
        #[doc = "Field `MEN` reader - Enable Status of the Controller"]
        pub type MEN_R = crate::BitReader;
        #[doc = "Field `CHANM1` reader - Number of Available DMA Channels Minus 1"]
        pub type CHANM1_R = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - Enable Status of the Controller"]
            #[inline(always)]
            pub fn men(&self) -> MEN_R {
                MEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 16:20 - Number of Available DMA Channels Minus 1"]
            #[inline(always)]
            pub fn chanm1(&self) -> CHANM1_R {
                CHANM1_R::new(((self.bits >> 16) & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STAT")
                    .field("men", &self.men())
                    .field("chanm1", &self.chanm1())
                    .finish()
            }
        }
        impl W {}
        #[doc = "DMA Status\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:STAT)"]
        pub struct STATrs;
        impl crate::RegisterSpec for STATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`stat::R`](R) reader structure"]
        impl crate::Readable for STATrs {}
        #[doc = "`write(|w| ..)` method takes [`stat::W`](W) writer structure"]
        impl crate::Writable for STATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STAT to value 0x001e_0000"]
        impl crate::Resettable for STATrs {
            const RESET_VALUE: u32 = 0x001e_0000;
        }
    }
    #[doc = "CFG (rw) register accessor: DMA Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:CFG)\n\nFor information about available fields see [`mod@cfg`]
module"]
    pub type CFG = crate::Reg<cfg::CFGrs>;
    #[doc = "DMA Configuration"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CFGrs>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CFGrs>;
        #[doc = "Field `MEN` writer - Controller Enable"]
        pub type MEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CFG").finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Controller Enable"]
            #[inline(always)]
            pub fn men(&mut self) -> MEN_W<CFGrs> {
                MEN_W::new(self, 0)
            }
        }
        #[doc = "DMA Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:CFG)"]
        pub struct CFGrs;
        impl crate::RegisterSpec for CFGrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CFGrs {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CFGrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CFG to value 0"]
        impl crate::Resettable for CFGrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PDBPTR (rw) register accessor: DMA Channel Primary Control Data Base Pointer\n\nYou can [`read`](crate::Reg::read) this register and get [`pdbptr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdbptr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:PDBPTR)\n\nFor information about available fields see [`mod@pdbptr`]
module"]
    pub type PDBPTR = crate::Reg<pdbptr::PDBPTRrs>;
    #[doc = "DMA Channel Primary Control Data Base Pointer"]
    pub mod pdbptr {
        #[doc = "Register `PDBPTR` reader"]
        pub type R = crate::R<PDBPTRrs>;
        #[doc = "Register `PDBPTR` writer"]
        pub type W = crate::W<PDBPTRrs>;
        #[doc = "Field `ADDR` reader - Pointer to the Base Address of the Primary Data Structure"]
        pub type ADDR_R = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Pointer to the Base Address of the Primary Data Structure"]
        pub type ADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Pointer to the Base Address of the Primary Data Structure"]
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PDBPTR")
                    .field("addr", &self.addr())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Pointer to the Base Address of the Primary Data Structure"]
            #[inline(always)]
            pub fn addr(&mut self) -> ADDR_W<PDBPTRrs> {
                ADDR_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Primary Control Data Base Pointer\n\nYou can [`read`](crate::Reg::read) this register and get [`pdbptr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pdbptr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:PDBPTR)"]
        pub struct PDBPTRrs;
        impl crate::RegisterSpec for PDBPTRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pdbptr::R`](R) reader structure"]
        impl crate::Readable for PDBPTRrs {}
        #[doc = "`write(|w| ..)` method takes [`pdbptr::W`](W) writer structure"]
        impl crate::Writable for PDBPTRrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PDBPTR to value 0"]
        impl crate::Resettable for PDBPTRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADBPTR (rw) register accessor: DMA Channel Alternate Control Data Base Pointer\n\nYou can [`read`](crate::Reg::read) this register and get [`adbptr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adbptr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ADBPTR)\n\nFor information about available fields see [`mod@adbptr`]
module"]
    pub type ADBPTR = crate::Reg<adbptr::ADBPTRrs>;
    #[doc = "DMA Channel Alternate Control Data Base Pointer"]
    pub mod adbptr {
        #[doc = "Register `ADBPTR` reader"]
        pub type R = crate::R<ADBPTRrs>;
        #[doc = "Register `ADBPTR` writer"]
        pub type W = crate::W<ADBPTRrs>;
        #[doc = "Field `ADDR` reader - Base Address of the Alternate Data Structure"]
        pub type ADDR_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - Base Address of the Alternate Data Structure"]
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADBPTR")
                    .field("addr", &self.addr())
                    .finish()
            }
        }
        impl W {}
        #[doc = "DMA Channel Alternate Control Data Base Pointer\n\nYou can [`read`](crate::Reg::read) this register and get [`adbptr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adbptr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ADBPTR)"]
        pub struct ADBPTRrs;
        impl crate::RegisterSpec for ADBPTRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adbptr::R`](R) reader structure"]
        impl crate::Readable for ADBPTRrs {}
        #[doc = "`write(|w| ..)` method takes [`adbptr::W`](W) writer structure"]
        impl crate::Writable for ADBPTRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADBPTR to value 0x0200"]
        impl crate::Resettable for ADBPTRrs {
            const RESET_VALUE: u32 = 0x0200;
        }
    }
    #[doc = "SWREQ (rw) register accessor: DMA Channel Software Request\n\nYou can [`read`](crate::Reg::read) this register and get [`swreq::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swreq::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:SWREQ)\n\nFor information about available fields see [`mod@swreq`]
module"]
    pub type SWREQ = crate::Reg<swreq::SWREQrs>;
    #[doc = "DMA Channel Software Request"]
    pub mod swreq {
        #[doc = "Register `SWREQ` reader"]
        pub type R = crate::R<SWREQrs>;
        #[doc = "Register `SWREQ` writer"]
        pub type W = crate::W<SWREQrs>;
        #[doc = "Field `CHAN` writer - Generate Software Request"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SWREQ").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Generate Software Request"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<SWREQrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Software Request\n\nYou can [`read`](crate::Reg::read) this register and get [`swreq::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swreq::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:SWREQ)"]
        pub struct SWREQrs;
        impl crate::RegisterSpec for SWREQrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`swreq::R`](R) reader structure"]
        impl crate::Readable for SWREQrs {}
        #[doc = "`write(|w| ..)` method takes [`swreq::W`](W) writer structure"]
        impl crate::Writable for SWREQrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SWREQ to value 0"]
        impl crate::Resettable for SWREQrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RMSKSET (rw) register accessor: DMA Channel Request Mask Set\n\nYou can [`read`](crate::Reg::read) this register and get [`rmskset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rmskset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:RMSKSET)\n\nFor information about available fields see [`mod@rmskset`]
module"]
    pub type RMSKSET = crate::Reg<rmskset::RMSKSETrs>;
    #[doc = "DMA Channel Request Mask Set"]
    pub mod rmskset {
        #[doc = "Register `RMSKSET` reader"]
        pub type R = crate::R<RMSKSETrs>;
        #[doc = "Register `RMSKSET` writer"]
        pub type W = crate::W<RMSKSETrs>;
        #[doc = "Field `CHAN` reader - Mask Requests from DMA Channels"]
        pub type CHAN_R = crate::FieldReader<u32>;
        #[doc = "Field `CHAN` writer - Mask Requests from DMA Channels"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:30 - Mask Requests from DMA Channels"]
            #[inline(always)]
            pub fn chan(&self) -> CHAN_R {
                CHAN_R::new(self.bits & 0x7fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RMSKSET")
                    .field("chan", &self.chan())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Mask Requests from DMA Channels"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<RMSKSETrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Request Mask Set\n\nYou can [`read`](crate::Reg::read) this register and get [`rmskset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rmskset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:RMSKSET)"]
        pub struct RMSKSETrs;
        impl crate::RegisterSpec for RMSKSETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rmskset::R`](R) reader structure"]
        impl crate::Readable for RMSKSETrs {}
        #[doc = "`write(|w| ..)` method takes [`rmskset::W`](W) writer structure"]
        impl crate::Writable for RMSKSETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RMSKSET to value 0"]
        impl crate::Resettable for RMSKSETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RMSKCLR (rw) register accessor: DMA Channel Request Mask Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`rmskclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rmskclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:RMSKCLR)\n\nFor information about available fields see [`mod@rmskclr`]
module"]
    pub type RMSKCLR = crate::Reg<rmskclr::RMSKCLRrs>;
    #[doc = "DMA Channel Request Mask Clear"]
    pub mod rmskclr {
        #[doc = "Register `RMSKCLR` reader"]
        pub type R = crate::R<RMSKCLRrs>;
        #[doc = "Register `RMSKCLR` writer"]
        pub type W = crate::W<RMSKCLRrs>;
        #[doc = "Field `CHAN` writer - Clear REQ_MASK_SET Bits in DMARMSKSET"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RMSKCLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Clear REQ_MASK_SET Bits in DMARMSKSET"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<RMSKCLRrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Request Mask Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`rmskclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rmskclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:RMSKCLR)"]
        pub struct RMSKCLRrs;
        impl crate::RegisterSpec for RMSKCLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rmskclr::R`](R) reader structure"]
        impl crate::Readable for RMSKCLRrs {}
        #[doc = "`write(|w| ..)` method takes [`rmskclr::W`](W) writer structure"]
        impl crate::Writable for RMSKCLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RMSKCLR to value 0"]
        impl crate::Resettable for RMSKCLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ENSET (rw) register accessor: DMA Channel Enable Set\n\nYou can [`read`](crate::Reg::read) this register and get [`enset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ENSET)\n\nFor information about available fields see [`mod@enset`]
module"]
    pub type ENSET = crate::Reg<enset::ENSETrs>;
    #[doc = "DMA Channel Enable Set"]
    pub mod enset {
        #[doc = "Register `ENSET` reader"]
        pub type R = crate::R<ENSETrs>;
        #[doc = "Register `ENSET` writer"]
        pub type W = crate::W<ENSETrs>;
        #[doc = "Field `CHAN` reader - Enable DMA Channels"]
        pub type CHAN_R = crate::FieldReader<u32>;
        #[doc = "Field `CHAN` writer - Enable DMA Channels"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:30 - Enable DMA Channels"]
            #[inline(always)]
            pub fn chan(&self) -> CHAN_R {
                CHAN_R::new(self.bits & 0x7fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ENSET").field("chan", &self.chan()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Enable DMA Channels"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<ENSETrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Enable Set\n\nYou can [`read`](crate::Reg::read) this register and get [`enset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ENSET)"]
        pub struct ENSETrs;
        impl crate::RegisterSpec for ENSETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`enset::R`](R) reader structure"]
        impl crate::Readable for ENSETrs {}
        #[doc = "`write(|w| ..)` method takes [`enset::W`](W) writer structure"]
        impl crate::Writable for ENSETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ENSET to value 0"]
        impl crate::Resettable for ENSETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ENCLR (rw) register accessor: DMA Channel Enable Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`enclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ENCLR)\n\nFor information about available fields see [`mod@enclr`]
module"]
    pub type ENCLR = crate::Reg<enclr::ENCLRrs>;
    #[doc = "DMA Channel Enable Clear"]
    pub mod enclr {
        #[doc = "Register `ENCLR` reader"]
        pub type R = crate::R<ENCLRrs>;
        #[doc = "Register `ENCLR` writer"]
        pub type W = crate::W<ENCLRrs>;
        #[doc = "Field `CHAN` writer - Disable DMA Channels"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ENCLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Disable DMA Channels"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<ENCLRrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Enable Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`enclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ENCLR)"]
        pub struct ENCLRrs;
        impl crate::RegisterSpec for ENCLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`enclr::R`](R) reader structure"]
        impl crate::Readable for ENCLRrs {}
        #[doc = "`write(|w| ..)` method takes [`enclr::W`](W) writer structure"]
        impl crate::Writable for ENCLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ENCLR to value 0"]
        impl crate::Resettable for ENCLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ALTSET (rw) register accessor: DMA Channel Primary-alternate Set\n\nYou can [`read`](crate::Reg::read) this register and get [`altset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`altset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ALTSET)\n\nFor information about available fields see [`mod@altset`]
module"]
    pub type ALTSET = crate::Reg<altset::ALTSETrs>;
    #[doc = "DMA Channel Primary-alternate Set"]
    pub mod altset {
        #[doc = "Register `ALTSET` reader"]
        pub type R = crate::R<ALTSETrs>;
        #[doc = "Register `ALTSET` writer"]
        pub type W = crate::W<ALTSETrs>;
        #[doc = "Field `CHAN` reader - Control Structure Status / Select Alt Structure"]
        pub type CHAN_R = crate::FieldReader<u32>;
        #[doc = "Field `CHAN` writer - Control Structure Status / Select Alt Structure"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:30 - Control Structure Status / Select Alt Structure"]
            #[inline(always)]
            pub fn chan(&self) -> CHAN_R {
                CHAN_R::new(self.bits & 0x7fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ALTSET")
                    .field("chan", &self.chan())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Control Structure Status / Select Alt Structure"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<ALTSETrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Primary-alternate Set\n\nYou can [`read`](crate::Reg::read) this register and get [`altset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`altset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ALTSET)"]
        pub struct ALTSETrs;
        impl crate::RegisterSpec for ALTSETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`altset::R`](R) reader structure"]
        impl crate::Readable for ALTSETrs {}
        #[doc = "`write(|w| ..)` method takes [`altset::W`](W) writer structure"]
        impl crate::Writable for ALTSETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ALTSET to value 0"]
        impl crate::Resettable for ALTSETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ALTCLR (rw) register accessor: DMA Channel Primary-alternate Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`altclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`altclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ALTCLR)\n\nFor information about available fields see [`mod@altclr`]
module"]
    pub type ALTCLR = crate::Reg<altclr::ALTCLRrs>;
    #[doc = "DMA Channel Primary-alternate Clear"]
    pub mod altclr {
        #[doc = "Register `ALTCLR` reader"]
        pub type R = crate::R<ALTCLRrs>;
        #[doc = "Register `ALTCLR` writer"]
        pub type W = crate::W<ALTCLRrs>;
        #[doc = "Field `CHAN` writer - Select Primary Data Structure"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ALTCLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Select Primary Data Structure"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<ALTCLRrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Primary-alternate Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`altclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`altclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ALTCLR)"]
        pub struct ALTCLRrs;
        impl crate::RegisterSpec for ALTCLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`altclr::R`](R) reader structure"]
        impl crate::Readable for ALTCLRrs {}
        #[doc = "`write(|w| ..)` method takes [`altclr::W`](W) writer structure"]
        impl crate::Writable for ALTCLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ALTCLR to value 0"]
        impl crate::Resettable for ALTCLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PRISET (rw) register accessor: DMA Channel Priority Set\n\nYou can [`read`](crate::Reg::read) this register and get [`priset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`priset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:PRISET)\n\nFor information about available fields see [`mod@priset`]
module"]
    pub type PRISET = crate::Reg<priset::PRISETrs>;
    #[doc = "DMA Channel Priority Set"]
    pub mod priset {
        #[doc = "Register `PRISET` reader"]
        pub type R = crate::R<PRISETrs>;
        #[doc = "Register `PRISET` writer"]
        pub type W = crate::W<PRISETrs>;
        #[doc = "Field `CHAN` writer - Configure Channel for High Priority"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PRISET").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Configure Channel for High Priority"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<PRISETrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Priority Set\n\nYou can [`read`](crate::Reg::read) this register and get [`priset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`priset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:PRISET)"]
        pub struct PRISETrs;
        impl crate::RegisterSpec for PRISETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`priset::R`](R) reader structure"]
        impl crate::Readable for PRISETrs {}
        #[doc = "`write(|w| ..)` method takes [`priset::W`](W) writer structure"]
        impl crate::Writable for PRISETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PRISET to value 0"]
        impl crate::Resettable for PRISETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PRICLR (rw) register accessor: DMA Channel Priority Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`priclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`priclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:PRICLR)\n\nFor information about available fields see [`mod@priclr`]
module"]
    pub type PRICLR = crate::Reg<priclr::PRICLRrs>;
    #[doc = "DMA Channel Priority Clear"]
    pub mod priclr {
        #[doc = "Register `PRICLR` reader"]
        pub type R = crate::R<PRICLRrs>;
        #[doc = "Register `PRICLR` writer"]
        pub type W = crate::W<PRICLRrs>;
        #[doc = "Field `CHPRICLR` writer - Configure Channel for Default Priority Level"]
        pub type CHPRICLR_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PRICLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Configure Channel for Default Priority Level"]
            #[inline(always)]
            pub fn chpriclr(&mut self) -> CHPRICLR_W<PRICLRrs> {
                CHPRICLR_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Priority Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`priclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`priclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:PRICLR)"]
        pub struct PRICLRrs;
        impl crate::RegisterSpec for PRICLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`priclr::R`](R) reader structure"]
        impl crate::Readable for PRICLRrs {}
        #[doc = "`write(|w| ..)` method takes [`priclr::W`](W) writer structure"]
        impl crate::Writable for PRICLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PRICLR to value 0"]
        impl crate::Resettable for PRICLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ERRCHNLCLR (rw) register accessor: DMA per Channel Error Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`errchnlclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`errchnlclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ERRCHNLCLR)\n\nFor information about available fields see [`mod@errchnlclr`]
module"]
    pub type ERRCHNLCLR = crate::Reg<errchnlclr::ERRCHNLCLRrs>;
    #[doc = "DMA per Channel Error Clear"]
    pub mod errchnlclr {
        #[doc = "Register `ERRCHNLCLR` reader"]
        pub type R = crate::R<ERRCHNLCLRrs>;
        #[doc = "Register `ERRCHNLCLR` writer"]
        pub type W = crate::W<ERRCHNLCLRrs>;
        #[doc = "Field `CHAN` reader - Per Channel Bus Error Status/ Clear"]
        pub type CHAN_R = crate::FieldReader<u32>;
        #[doc = "Field `CHAN` writer - Per Channel Bus Error Status/ Clear"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:30 - Per Channel Bus Error Status/ Clear"]
            #[inline(always)]
            pub fn chan(&self) -> CHAN_R {
                CHAN_R::new(self.bits & 0x7fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ERRCHNLCLR")
                    .field("chan", &self.chan())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Per Channel Bus Error Status/ Clear"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<ERRCHNLCLRrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA per Channel Error Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`errchnlclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`errchnlclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ERRCHNLCLR)"]
        pub struct ERRCHNLCLRrs;
        impl crate::RegisterSpec for ERRCHNLCLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`errchnlclr::R`](R) reader structure"]
        impl crate::Readable for ERRCHNLCLRrs {}
        #[doc = "`write(|w| ..)` method takes [`errchnlclr::W`](W) writer structure"]
        impl crate::Writable for ERRCHNLCLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ERRCHNLCLR to value 0"]
        impl crate::Resettable for ERRCHNLCLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ERRCLR (rw) register accessor: DMA Bus Error Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`errclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`errclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ERRCLR)\n\nFor information about available fields see [`mod@errclr`]
module"]
    pub type ERRCLR = crate::Reg<errclr::ERRCLRrs>;
    #[doc = "DMA Bus Error Clear"]
    pub mod errclr {
        #[doc = "Register `ERRCLR` reader"]
        pub type R = crate::R<ERRCLRrs>;
        #[doc = "Register `ERRCLR` writer"]
        pub type W = crate::W<ERRCLRrs>;
        #[doc = "Field `CHAN` reader - Bus Error Status"]
        pub type CHAN_R = crate::FieldReader<u32>;
        #[doc = "Field `CHAN` writer - Bus Error Status"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:30 - Bus Error Status"]
            #[inline(always)]
            pub fn chan(&self) -> CHAN_R {
                CHAN_R::new(self.bits & 0x7fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ERRCLR")
                    .field("chan", &self.chan())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Bus Error Status"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<ERRCLRrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Bus Error Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`errclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`errclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:ERRCLR)"]
        pub struct ERRCLRrs;
        impl crate::RegisterSpec for ERRCLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`errclr::R`](R) reader structure"]
        impl crate::Readable for ERRCLRrs {}
        #[doc = "`write(|w| ..)` method takes [`errclr::W`](W) writer structure"]
        impl crate::Writable for ERRCLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ERRCLR to value 0"]
        impl crate::Resettable for ERRCLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "INVALIDDESCCLR (rw) register accessor: DMA per Channel Invalid Descriptor Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`invaliddescclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`invaliddescclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:INVALIDDESCCLR)\n\nFor information about available fields see [`mod@invaliddescclr`]
module"]
    pub type INVALIDDESCCLR = crate::Reg<invaliddescclr::INVALIDDESCCLRrs>;
    #[doc = "DMA per Channel Invalid Descriptor Clear"]
    pub mod invaliddescclr {
        #[doc = "Register `INVALIDDESCCLR` reader"]
        pub type R = crate::R<INVALIDDESCCLRrs>;
        #[doc = "Register `INVALIDDESCCLR` writer"]
        pub type W = crate::W<INVALIDDESCCLRrs>;
        #[doc = "Field `CHAN` reader - Per Channel Invalid Descriptor Status"]
        pub type CHAN_R = crate::FieldReader<u32>;
        #[doc = "Field `CHAN` writer - Per Channel Invalid Descriptor Status"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:30 - Per Channel Invalid Descriptor Status"]
            #[inline(always)]
            pub fn chan(&self) -> CHAN_R {
                CHAN_R::new(self.bits & 0x7fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("INVALIDDESCCLR")
                    .field("chan", &self.chan())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Per Channel Invalid Descriptor Status"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<INVALIDDESCCLRrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA per Channel Invalid Descriptor Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`invaliddescclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`invaliddescclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:INVALIDDESCCLR)"]
        pub struct INVALIDDESCCLRrs;
        impl crate::RegisterSpec for INVALIDDESCCLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`invaliddescclr::R`](R) reader structure"]
        impl crate::Readable for INVALIDDESCCLRrs {}
        #[doc = "`write(|w| ..)` method takes [`invaliddescclr::W`](W) writer structure"]
        impl crate::Writable for INVALIDDESCCLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets INVALIDDESCCLR to value 0"]
        impl crate::Resettable for INVALIDDESCCLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "BSSET (rw) register accessor: DMA Channel Bytes Swap Enable Set\n\nYou can [`read`](crate::Reg::read) this register and get [`bsset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:BSSET)\n\nFor information about available fields see [`mod@bsset`]
module"]
    pub type BSSET = crate::Reg<bsset::BSSETrs>;
    #[doc = "DMA Channel Bytes Swap Enable Set"]
    pub mod bsset {
        #[doc = "Register `BSSET` reader"]
        pub type R = crate::R<BSSETrs>;
        #[doc = "Register `BSSET` writer"]
        pub type W = crate::W<BSSETrs>;
        #[doc = "Field `CHAN` reader - Byte Swap Status"]
        pub type CHAN_R = crate::FieldReader<u32>;
        #[doc = "Field `CHAN` writer - Byte Swap Status"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:30 - Byte Swap Status"]
            #[inline(always)]
            pub fn chan(&self) -> CHAN_R {
                CHAN_R::new(self.bits & 0x7fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BSSET").field("chan", &self.chan()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Byte Swap Status"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<BSSETrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Bytes Swap Enable Set\n\nYou can [`read`](crate::Reg::read) this register and get [`bsset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:BSSET)"]
        pub struct BSSETrs;
        impl crate::RegisterSpec for BSSETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`bsset::R`](R) reader structure"]
        impl crate::Readable for BSSETrs {}
        #[doc = "`write(|w| ..)` method takes [`bsset::W`](W) writer structure"]
        impl crate::Writable for BSSETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets BSSET to value 0"]
        impl crate::Resettable for BSSETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "BSCLR (rw) register accessor: DMA Channel Bytes Swap Enable Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`bsclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:BSCLR)\n\nFor information about available fields see [`mod@bsclr`]
module"]
    pub type BSCLR = crate::Reg<bsclr::BSCLRrs>;
    #[doc = "DMA Channel Bytes Swap Enable Clear"]
    pub mod bsclr {
        #[doc = "Register `BSCLR` reader"]
        pub type R = crate::R<BSCLRrs>;
        #[doc = "Register `BSCLR` writer"]
        pub type W = crate::W<BSCLRrs>;
        #[doc = "Field `CHAN` writer - Disable Byte Swap"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("BSCLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Disable Byte Swap"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<BSCLRrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Bytes Swap Enable Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`bsclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:BSCLR)"]
        pub struct BSCLRrs;
        impl crate::RegisterSpec for BSCLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`bsclr::R`](R) reader structure"]
        impl crate::Readable for BSCLRrs {}
        #[doc = "`write(|w| ..)` method takes [`bsclr::W`](W) writer structure"]
        impl crate::Writable for BSCLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets BSCLR to value 0"]
        impl crate::Resettable for BSCLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRCADDRSET (rw) register accessor: DMA Channel Source Address Decrement Enable Set\n\nYou can [`read`](crate::Reg::read) this register and get [`srcaddrset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srcaddrset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:SRCADDRSET)\n\nFor information about available fields see [`mod@srcaddrset`]
module"]
    pub type SRCADDRSET = crate::Reg<srcaddrset::SRCADDRSETrs>;
    #[doc = "DMA Channel Source Address Decrement Enable Set"]
    pub mod srcaddrset {
        #[doc = "Register `SRCADDRSET` reader"]
        pub type R = crate::R<SRCADDRSETrs>;
        #[doc = "Register `SRCADDRSET` writer"]
        pub type W = crate::W<SRCADDRSETrs>;
        #[doc = "Field `CHAN` reader - Source Address Decrement Status / Configure"]
        pub type CHAN_R = crate::FieldReader<u32>;
        #[doc = "Field `CHAN` writer - Source Address Decrement Status / Configure"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:30 - Source Address Decrement Status / Configure"]
            #[inline(always)]
            pub fn chan(&self) -> CHAN_R {
                CHAN_R::new(self.bits & 0x7fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRCADDRSET")
                    .field("chan", &self.chan())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Source Address Decrement Status / Configure"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<SRCADDRSETrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Source Address Decrement Enable Set\n\nYou can [`read`](crate::Reg::read) this register and get [`srcaddrset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srcaddrset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:SRCADDRSET)"]
        pub struct SRCADDRSETrs;
        impl crate::RegisterSpec for SRCADDRSETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srcaddrset::R`](R) reader structure"]
        impl crate::Readable for SRCADDRSETrs {}
        #[doc = "`write(|w| ..)` method takes [`srcaddrset::W`](W) writer structure"]
        impl crate::Writable for SRCADDRSETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRCADDRSET to value 0"]
        impl crate::Resettable for SRCADDRSETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRCADDRCLR (rw) register accessor: DMA Channel Source Address Decrement Enable Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`srcaddrclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srcaddrclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:SRCADDRCLR)\n\nFor information about available fields see [`mod@srcaddrclr`]
module"]
    pub type SRCADDRCLR = crate::Reg<srcaddrclr::SRCADDRCLRrs>;
    #[doc = "DMA Channel Source Address Decrement Enable Clear"]
    pub mod srcaddrclr {
        #[doc = "Register `SRCADDRCLR` reader"]
        pub type R = crate::R<SRCADDRCLRrs>;
        #[doc = "Register `SRCADDRCLR` writer"]
        pub type W = crate::W<SRCADDRCLRrs>;
        #[doc = "Field `CHAN` writer - Disable Source Address Decrement"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRCADDRCLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Disable Source Address Decrement"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<SRCADDRCLRrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Source Address Decrement Enable Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`srcaddrclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srcaddrclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:SRCADDRCLR)"]
        pub struct SRCADDRCLRrs;
        impl crate::RegisterSpec for SRCADDRCLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srcaddrclr::R`](R) reader structure"]
        impl crate::Readable for SRCADDRCLRrs {}
        #[doc = "`write(|w| ..)` method takes [`srcaddrclr::W`](W) writer structure"]
        impl crate::Writable for SRCADDRCLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRCADDRCLR to value 0"]
        impl crate::Resettable for SRCADDRCLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DSTADDRSET (rw) register accessor: DMA Channel Destination Address Decrement Enable Set\n\nYou can [`read`](crate::Reg::read) this register and get [`dstaddrset::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dstaddrset::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:DSTADDRSET)\n\nFor information about available fields see [`mod@dstaddrset`]
module"]
    pub type DSTADDRSET = crate::Reg<dstaddrset::DSTADDRSETrs>;
    #[doc = "DMA Channel Destination Address Decrement Enable Set"]
    pub mod dstaddrset {
        #[doc = "Register `DSTADDRSET` reader"]
        pub type R = crate::R<DSTADDRSETrs>;
        #[doc = "Register `DSTADDRSET` writer"]
        pub type W = crate::W<DSTADDRSETrs>;
        #[doc = "Field `CHAN` reader - Destination Address Decrement Status"]
        pub type CHAN_R = crate::FieldReader<u32>;
        #[doc = "Field `CHAN` writer - Destination Address Decrement Status"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:30 - Destination Address Decrement Status"]
            #[inline(always)]
            pub fn chan(&self) -> CHAN_R {
                CHAN_R::new(self.bits & 0x7fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DSTADDRSET")
                    .field("chan", &self.chan())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Destination Address Decrement Status"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<DSTADDRSETrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Destination Address Decrement Enable Set\n\nYou can [`read`](crate::Reg::read) this register and get [`dstaddrset::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dstaddrset::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:DSTADDRSET)"]
        pub struct DSTADDRSETrs;
        impl crate::RegisterSpec for DSTADDRSETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dstaddrset::R`](R) reader structure"]
        impl crate::Readable for DSTADDRSETrs {}
        #[doc = "`write(|w| ..)` method takes [`dstaddrset::W`](W) writer structure"]
        impl crate::Writable for DSTADDRSETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DSTADDRSET to value 0"]
        impl crate::Resettable for DSTADDRSETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DSTADDRCLR (rw) register accessor: DMA Channel Destination Address Decrement Enable Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`dstaddrclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dstaddrclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:DSTADDRCLR)\n\nFor information about available fields see [`mod@dstaddrclr`]
module"]
    pub type DSTADDRCLR = crate::Reg<dstaddrclr::DSTADDRCLRrs>;
    #[doc = "DMA Channel Destination Address Decrement Enable Clear"]
    pub mod dstaddrclr {
        #[doc = "Register `DSTADDRCLR` reader"]
        pub type R = crate::R<DSTADDRCLRrs>;
        #[doc = "Register `DSTADDRCLR` writer"]
        pub type W = crate::W<DSTADDRCLRrs>;
        #[doc = "Field `CHAN` writer - Disable Destination Address Decrement"]
        pub type CHAN_W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DSTADDRCLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:30 - Disable Destination Address Decrement"]
            #[inline(always)]
            pub fn chan(&mut self) -> CHAN_W<DSTADDRCLRrs> {
                CHAN_W::new(self, 0)
            }
        }
        #[doc = "DMA Channel Destination Address Decrement Enable Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`dstaddrclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dstaddrclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:DSTADDRCLR)"]
        pub struct DSTADDRCLRrs;
        impl crate::RegisterSpec for DSTADDRCLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dstaddrclr::R`](R) reader structure"]
        impl crate::Readable for DSTADDRCLRrs {}
        #[doc = "`write(|w| ..)` method takes [`dstaddrclr::W`](W) writer structure"]
        impl crate::Writable for DSTADDRCLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DSTADDRCLR to value 0"]
        impl crate::Resettable for DSTADDRCLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "REVID (rw) register accessor: DMA Controller Revision ID\n\nYou can [`read`](crate::Reg::read) this register and get [`revid::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`revid::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:REVID)\n\nFor information about available fields see [`mod@revid`]
module"]
    pub type REVID = crate::Reg<revid::REVIDrs>;
    #[doc = "DMA Controller Revision ID"]
    pub mod revid {
        #[doc = "Register `REVID` reader"]
        pub type R = crate::R<REVIDrs>;
        #[doc = "Register `REVID` writer"]
        pub type W = crate::W<REVIDrs>;
        #[doc = "Field `DMAREVID` reader - DMA Controller Revision ID"]
        pub type DMAREVID_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - DMA Controller Revision ID"]
            #[inline(always)]
            pub fn dmarevid(&self) -> DMAREVID_R {
                DMAREVID_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("REVID")
                    .field("dmarevid", &self.dmarevid())
                    .finish()
            }
        }
        impl W {}
        #[doc = "DMA Controller Revision ID\n\nYou can [`read`](crate::Reg::read) this register and get [`revid::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`revid::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#DMA:REVID)"]
        pub struct REVIDrs;
        impl crate::RegisterSpec for REVIDrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`revid::R`](R) reader structure"]
        impl crate::Readable for REVIDrs {}
        #[doc = "`write(|w| ..)` method takes [`revid::W`](W) writer structure"]
        impl crate::Writable for REVIDrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets REVID to value 0x02"]
        impl crate::Resettable for REVIDrs {
            const RESET_VALUE: u32 = 0x02;
        }
    }
}
#[doc = "Cache Controller"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE)"]
pub struct CACHE {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CACHE {}
impl CACHE {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cache::RegisterBlock = 0x4004_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cache::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CACHE {
    type Target = cache::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CACHE {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CACHE").finish()
    }
}
#[doc = "Cache Controller"]
pub mod cache {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        stat: STAT,
        setup: SETUP,
        key: KEY,
        perfsetup: PERFSETUP,
        accesscntr: ACCESSCNTR,
        _reserved5: [u8; 0x10],
        mstrsetup: MSTRSETUP,
        _reserved6: [u8; 0x0c],
        eccstat: ECCSTAT,
        eccaddr: ECCADDR,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Cache Status Register"]
        #[inline(always)]
        pub const fn stat(&self) -> &STAT {
            &self.stat
        }
        #[doc = "0x04 - Cache Setup Register"]
        #[inline(always)]
        pub const fn setup(&self) -> &SETUP {
            &self.setup
        }
        #[doc = "0x08 - Cache Key Register"]
        #[inline(always)]
        pub const fn key(&self) -> &KEY {
            &self.key
        }
        #[doc = "0x0c - Cache Performance Monitor Setup Register"]
        #[inline(always)]
        pub const fn perfsetup(&self) -> &PERFSETUP {
            &self.perfsetup
        }
        #[doc = "0x10 - Cache Miss Counter"]
        #[inline(always)]
        pub const fn accesscntr(&self) -> &ACCESSCNTR {
            &self.accesscntr
        }
        #[doc = "0x24 - Cache Master Setup Register"]
        #[inline(always)]
        pub const fn mstrsetup(&self) -> &MSTRSETUP {
            &self.mstrsetup
        }
        #[doc = "0x34 - Cache SRAM ECC Status Register"]
        #[inline(always)]
        pub const fn eccstat(&self) -> &ECCSTAT {
            &self.eccstat
        }
        #[doc = "0x38 - Cache SRAM ECC Address Register"]
        #[inline(always)]
        pub const fn eccaddr(&self) -> &ECCADDR {
            &self.eccaddr
        }
    }
    #[doc = "STAT (rw) register accessor: Cache Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:STAT)\n\nFor information about available fields see [`mod@stat`]
module"]
    pub type STAT = crate::Reg<stat::STATrs>;
    #[doc = "Cache Status Register"]
    pub mod stat {
        #[doc = "Register `STAT` reader"]
        pub type R = crate::R<STATrs>;
        #[doc = "Register `STAT` writer"]
        pub type W = crate::W<STATrs>;
        #[doc = "Field `CCEN` reader - Code Cache Enable Status"]
        pub type CCEN_R = crate::BitReader;
        #[doc = "Field `CCLCK` reader - Code Cache Lock Status"]
        pub type CCLCK_R = crate::BitReader;
        #[doc = "Field `CCWIPE` reader - Code Cache Memory Wipe in Progress"]
        pub type CCWIPE_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Code Cache Enable Status"]
            #[inline(always)]
            pub fn ccen(&self) -> CCEN_R {
                CCEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Code Cache Lock Status"]
            #[inline(always)]
            pub fn cclck(&self) -> CCLCK_R {
                CCLCK_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - Code Cache Memory Wipe in Progress"]
            #[inline(always)]
            pub fn ccwipe(&self) -> CCWIPE_R {
                CCWIPE_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("STAT")
                    .field("ccen", &self.ccen())
                    .field("cclck", &self.cclck())
                    .field("ccwipe", &self.ccwipe())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Cache Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:STAT)"]
        pub struct STATrs;
        impl crate::RegisterSpec for STATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`stat::R`](R) reader structure"]
        impl crate::Readable for STATrs {}
        #[doc = "`write(|w| ..)` method takes [`stat::W`](W) writer structure"]
        impl crate::Writable for STATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STAT to value 0"]
        impl crate::Resettable for STATrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SETUP (rw) register accessor: Cache Setup Register\n\nYou can [`read`](crate::Reg::read) this register and get [`setup::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`setup::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:SETUP)\n\nFor information about available fields see [`mod@setup`]
module"]
    pub type SETUP = crate::Reg<setup::SETUPrs>;
    #[doc = "Cache Setup Register"]
    pub mod setup {
        #[doc = "Register `SETUP` reader"]
        pub type R = crate::R<SETUPrs>;
        #[doc = "Register `SETUP` writer"]
        pub type W = crate::W<SETUPrs>;
        #[doc = "Field `CCEN` reader - Code Cache Enable"]
        pub type CCEN_R = crate::BitReader;
        #[doc = "Field `CCEN` writer - Code Cache Enable"]
        pub type CCEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CCFLUSHDIS` reader - Disable Automatic Cache and Buffer Flush on Any Flash Update"]
        pub type CCFLUSHDIS_R = crate::BitReader;
        #[doc = "Field `CCFLUSHDIS` writer - Disable Automatic Cache and Buffer Flush on Any Flash Update"]
        pub type CCFLUSHDIS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Code Cache Enable"]
            #[inline(always)]
            pub fn ccen(&self) -> CCEN_R {
                CCEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 8 - Disable Automatic Cache and Buffer Flush on Any Flash Update"]
            #[inline(always)]
            pub fn ccflushdis(&self) -> CCFLUSHDIS_R {
                CCFLUSHDIS_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SETUP")
                    .field("ccen", &self.ccen())
                    .field("ccflushdis", &self.ccflushdis())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Code Cache Enable"]
            #[inline(always)]
            pub fn ccen(&mut self) -> CCEN_W<SETUPrs> {
                CCEN_W::new(self, 0)
            }
            #[doc = "Bit 8 - Disable Automatic Cache and Buffer Flush on Any Flash Update"]
            #[inline(always)]
            pub fn ccflushdis(&mut self) -> CCFLUSHDIS_W<SETUPrs> {
                CCFLUSHDIS_W::new(self, 8)
            }
        }
        #[doc = "Cache Setup Register\n\nYou can [`read`](crate::Reg::read) this register and get [`setup::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`setup::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:SETUP)"]
        pub struct SETUPrs;
        impl crate::RegisterSpec for SETUPrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`setup::R`](R) reader structure"]
        impl crate::Readable for SETUPrs {}
        #[doc = "`write(|w| ..)` method takes [`setup::W`](W) writer structure"]
        impl crate::Writable for SETUPrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SETUP to value 0"]
        impl crate::Resettable for SETUPrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "KEY (rw) register accessor: Cache Key Register\n\nYou can [`read`](crate::Reg::read) this register and get [`key::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`key::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:KEY)\n\nFor information about available fields see [`mod@key`]
module"]
    pub type KEY = crate::Reg<key::KEYrs>;
    #[doc = "Cache Key Register"]
    pub mod key {
        #[doc = "Register `KEY` reader"]
        pub type R = crate::R<KEYrs>;
        #[doc = "Register `KEY` writer"]
        pub type W = crate::W<KEYrs>;
        #[doc = "Field `KEY` writer - Cache Key Register"]
        pub type KEY_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("KEY").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Cache Key Register"]
            #[inline(always)]
            pub fn key(&mut self) -> KEY_W<KEYrs> {
                KEY_W::new(self, 0)
            }
        }
        #[doc = "Cache Key Register\n\nYou can [`read`](crate::Reg::read) this register and get [`key::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`key::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:KEY)"]
        pub struct KEYrs;
        impl crate::RegisterSpec for KEYrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`key::R`](R) reader structure"]
        impl crate::Readable for KEYrs {}
        #[doc = "`write(|w| ..)` method takes [`key::W`](W) writer structure"]
        impl crate::Writable for KEYrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets KEY to value 0"]
        impl crate::Resettable for KEYrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PERFSETUP (rw) register accessor: Cache Performance Monitor Setup Register\n\nYou can [`read`](crate::Reg::read) this register and get [`perfsetup::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`perfsetup::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:PERFSETUP)\n\nFor information about available fields see [`mod@perfsetup`]
module"]
    pub type PERFSETUP = crate::Reg<perfsetup::PERFSETUPrs>;
    #[doc = "Cache Performance Monitor Setup Register"]
    pub mod perfsetup {
        #[doc = "Register `PERFSETUP` reader"]
        pub type R = crate::R<PERFSETUPrs>;
        #[doc = "Register `PERFSETUP` writer"]
        pub type W = crate::W<PERFSETUPrs>;
        #[doc = "Field `STOPCNTR` writer - Performance Counter Stop"]
        pub type STOPCNTR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STRTCNTR` writer - Performance Counter Start"]
        pub type STRTCNTR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PERFSETUP").finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Performance Counter Stop"]
            #[inline(always)]
            pub fn stopcntr(&mut self) -> STOPCNTR_W<PERFSETUPrs> {
                STOPCNTR_W::new(self, 0)
            }
            #[doc = "Bit 1 - Performance Counter Start"]
            #[inline(always)]
            pub fn strtcntr(&mut self) -> STRTCNTR_W<PERFSETUPrs> {
                STRTCNTR_W::new(self, 1)
            }
        }
        #[doc = "Cache Performance Monitor Setup Register\n\nYou can [`read`](crate::Reg::read) this register and get [`perfsetup::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`perfsetup::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:PERFSETUP)"]
        pub struct PERFSETUPrs;
        impl crate::RegisterSpec for PERFSETUPrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`perfsetup::R`](R) reader structure"]
        impl crate::Readable for PERFSETUPrs {}
        #[doc = "`write(|w| ..)` method takes [`perfsetup::W`](W) writer structure"]
        impl crate::Writable for PERFSETUPrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PERFSETUP to value 0"]
        impl crate::Resettable for PERFSETUPrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ACCESSCNTR (rw) register accessor: Cache Miss Counter\n\nYou can [`read`](crate::Reg::read) this register and get [`accesscntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`accesscntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:ACCESSCNTR)\n\nFor information about available fields see [`mod@accesscntr`]
module"]
    pub type ACCESSCNTR = crate::Reg<accesscntr::ACCESSCNTRrs>;
    #[doc = "Cache Miss Counter"]
    pub mod accesscntr {
        #[doc = "Register `ACCESSCNTR` reader"]
        pub type R = crate::R<ACCESSCNTRrs>;
        #[doc = "Register `ACCESSCNTR` writer"]
        pub type W = crate::W<ACCESSCNTRrs>;
        #[doc = "Field `CNT` reader - Cache Internal Performance Counter"]
        pub type CNT_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - Cache Internal Performance Counter"]
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ACCESSCNTR")
                    .field("cnt", &self.cnt())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Cache Miss Counter\n\nYou can [`read`](crate::Reg::read) this register and get [`accesscntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`accesscntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:ACCESSCNTR)"]
        pub struct ACCESSCNTRrs;
        impl crate::RegisterSpec for ACCESSCNTRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`accesscntr::R`](R) reader structure"]
        impl crate::Readable for ACCESSCNTRrs {}
        #[doc = "`write(|w| ..)` method takes [`accesscntr::W`](W) writer structure"]
        impl crate::Writable for ACCESSCNTRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ACCESSCNTR to value 0"]
        impl crate::Resettable for ACCESSCNTRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MSTRSETUP (rw) register accessor: Cache Master Setup Register\n\nYou can [`read`](crate::Reg::read) this register and get [`mstrsetup::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mstrsetup::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:MSTRSETUP)\n\nFor information about available fields see [`mod@mstrsetup`]
module"]
    pub type MSTRSETUP = crate::Reg<mstrsetup::MSTRSETUPrs>;
    #[doc = "Cache Master Setup Register"]
    pub mod mstrsetup {
        #[doc = "Register `MSTRSETUP` reader"]
        pub type R = crate::R<MSTRSETUPrs>;
        #[doc = "Register `MSTRSETUP` writer"]
        pub type W = crate::W<MSTRSETUPrs>;
        #[doc = "Field `MSTRNRA` reader - No Read Allocate for Master"]
        pub type MSTRNRA_R = crate::FieldReader;
        #[doc = "Field `MSTRNRA` writer - No Read Allocate for Master"]
        pub type MSTRNRA_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - No Read Allocate for Master"]
            #[inline(always)]
            pub fn mstrnra(&self) -> MSTRNRA_R {
                MSTRNRA_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MSTRSETUP")
                    .field("mstrnra", &self.mstrnra())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - No Read Allocate for Master"]
            #[inline(always)]
            pub fn mstrnra(&mut self) -> MSTRNRA_W<MSTRSETUPrs> {
                MSTRNRA_W::new(self, 0)
            }
        }
        #[doc = "Cache Master Setup Register\n\nYou can [`read`](crate::Reg::read) this register and get [`mstrsetup::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mstrsetup::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:MSTRSETUP)"]
        pub struct MSTRSETUPrs;
        impl crate::RegisterSpec for MSTRSETUPrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mstrsetup::R`](R) reader structure"]
        impl crate::Readable for MSTRSETUPrs {}
        #[doc = "`write(|w| ..)` method takes [`mstrsetup::W`](W) writer structure"]
        impl crate::Writable for MSTRSETUPrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MSTRSETUP to value 0"]
        impl crate::Resettable for MSTRSETUPrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ECCSTAT (rw) register accessor: Cache SRAM ECC Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`eccstat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eccstat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:ECCSTAT)\n\nFor information about available fields see [`mod@eccstat`]
module"]
    pub type ECCSTAT = crate::Reg<eccstat::ECCSTATrs>;
    #[doc = "Cache SRAM ECC Status Register"]
    pub mod eccstat {
        #[doc = "Register `ECCSTAT` reader"]
        pub type R = crate::R<ECCSTATrs>;
        #[doc = "Register `ECCSTAT` writer"]
        pub type W = crate::W<ECCSTATrs>;
        #[doc = "Cache SRAM ECC Error Interrupt Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCINT_STA {
            #[doc = "0: No Error"]
            NoError = 0,
            #[doc = "1: 2 Bit Error"]
            Error2bit = 1,
            #[doc = "2: 1 Bit Error"]
            Error1bit = 2,
            #[doc = "3: Either 1 Bit Error or 2 Bit Error"]
            Error1or2bit = 3,
        }
        impl From<ECCINT_STA> for u8 {
            #[inline(always)]
            fn from(variant: ECCINT_STA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCINT_STA {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCINT_STA {}
        #[doc = "Field `ECCIntSta` reader - Cache SRAM ECC Error Interrupt Status"]
        pub type ECCINT_STA_R = crate::FieldReader<ECCINT_STA>;
        impl ECCINT_STA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCINT_STA {
                match self.bits {
                    0 => ECCINT_STA::NoError,
                    1 => ECCINT_STA::Error2bit,
                    2 => ECCINT_STA::Error1bit,
                    3 => ECCINT_STA::Error1or2bit,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == ECCINT_STA::NoError
            }
            #[doc = "2 Bit Error"]
            #[inline(always)]
            pub fn is_error2bit(&self) -> bool {
                *self == ECCINT_STA::Error2bit
            }
            #[doc = "1 Bit Error"]
            #[inline(always)]
            pub fn is_error1bit(&self) -> bool {
                *self == ECCINT_STA::Error1bit
            }
            #[doc = "Either 1 Bit Error or 2 Bit Error"]
            #[inline(always)]
            pub fn is_error1or2bit(&self) -> bool {
                *self == ECCINT_STA::Error1or2bit
            }
        }
        #[doc = "Cache SRAM ECC Error Hresp Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCHRESP_STA {
            #[doc = "0: No Error"]
            NoError = 0,
            #[doc = "1: 2 Bit Error"]
            Error2bit = 1,
            #[doc = "2: 1 Bit Error"]
            Error1bit = 2,
        }
        impl From<ECCHRESP_STA> for u8 {
            #[inline(always)]
            fn from(variant: ECCHRESP_STA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCHRESP_STA {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCHRESP_STA {}
        #[doc = "Field `ECCHrespSta` reader - Cache SRAM ECC Error Hresp Status"]
        pub type ECCHRESP_STA_R = crate::FieldReader<ECCHRESP_STA>;
        impl ECCHRESP_STA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCHRESP_STA {
                match self.bits {
                    0 => ECCHRESP_STA::NoError,
                    1 => ECCHRESP_STA::Error2bit,
                    2 => ECCHRESP_STA::Error1bit,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == ECCHRESP_STA::NoError
            }
            #[doc = "2 Bit Error"]
            #[inline(always)]
            pub fn is_error2bit(&self) -> bool {
                *self == ECCHRESP_STA::Error2bit
            }
            #[doc = "1 Bit Error"]
            #[inline(always)]
            pub fn is_error1bit(&self) -> bool {
                *self == ECCHRESP_STA::Error1bit
            }
        }
        #[doc = "Field `ECCErrorCnt` reader - Cache SRAM ECC Error Counter"]
        pub type ECCERROR_CNT_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:1 - Cache SRAM ECC Error Interrupt Status"]
            #[inline(always)]
            pub fn eccint_sta(&self) -> ECCINT_STA_R {
                ECCINT_STA_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Cache SRAM ECC Error Hresp Status"]
            #[inline(always)]
            pub fn ecchresp_sta(&self) -> ECCHRESP_STA_R {
                ECCHRESP_STA_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:6 - Cache SRAM ECC Error Counter"]
            #[inline(always)]
            pub fn eccerror_cnt(&self) -> ECCERROR_CNT_R {
                ECCERROR_CNT_R::new(((self.bits >> 4) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ECCSTAT")
                    .field("eccint_sta", &self.eccint_sta())
                    .field("ecchresp_sta", &self.ecchresp_sta())
                    .field("eccerror_cnt", &self.eccerror_cnt())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Cache SRAM ECC Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`eccstat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eccstat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:ECCSTAT)"]
        pub struct ECCSTATrs;
        impl crate::RegisterSpec for ECCSTATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`eccstat::R`](R) reader structure"]
        impl crate::Readable for ECCSTATrs {}
        #[doc = "`write(|w| ..)` method takes [`eccstat::W`](W) writer structure"]
        impl crate::Writable for ECCSTATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ECCSTAT to value 0"]
        impl crate::Resettable for ECCSTATrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ECCADDR (rw) register accessor: Cache SRAM ECC Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`eccaddr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eccaddr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:ECCADDR)\n\nFor information about available fields see [`mod@eccaddr`]
module"]
    pub type ECCADDR = crate::Reg<eccaddr::ECCADDRrs>;
    #[doc = "Cache SRAM ECC Address Register"]
    pub mod eccaddr {
        #[doc = "Register `ECCADDR` reader"]
        pub type R = crate::R<ECCADDRrs>;
        #[doc = "Register `ECCADDR` writer"]
        pub type W = crate::W<ECCADDRrs>;
        #[doc = "Field `ECCAddr` reader - Cache SRAM ECC Error Interrupt Address"]
        pub type ECCADDR_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:10 - Cache SRAM ECC Error Interrupt Address"]
            #[inline(always)]
            pub fn eccaddr(&self) -> ECCADDR_R {
                ECCADDR_R::new((self.bits & 0x07ff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ECCADDR")
                    .field("eccaddr", &self.eccaddr())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Cache SRAM ECC Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`eccaddr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eccaddr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CACHE:ECCADDR)"]
        pub struct ECCADDRrs;
        impl crate::RegisterSpec for ECCADDRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`eccaddr::R`](R) reader structure"]
        impl crate::Readable for ECCADDRrs {}
        #[doc = "`write(|w| ..)` method takes [`eccaddr::W`](W) writer structure"]
        impl crate::Writable for ECCADDRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ECCADDR to value 0"]
        impl crate::Resettable for ECCADDRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH)"]
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH {}
impl FLASH {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flash::RegisterBlock = 0x4004_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FLASH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FLASH").finish()
    }
}
#[doc = "Unknown"]
pub mod flash {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        feesta: FEESTA,
        feecon0: FEECON0,
        feecmd: FEECMD,
        feefladr: FEEFLADR,
        feefldata0: FEEFLDATA0,
        feefldata1: FEEFLDATA1,
        feeadr0: FEEADR0,
        feeadr1: FEEADR1,
        feekey: FEEKEY,
        _reserved9: [u8; 0x04],
        feepro0: FEEPRO0,
        feepro1: FEEPRO1,
        _reserved11: [u8; 0x04],
        feesig: FEESIG,
        feecon1: FEECON1,
        _reserved13: [u8; 0x04],
        feewraddra: FEEWRADDRA,
        _reserved14: [u8; 0x04],
        feeaen0: FEEAEN0,
        feeaen1: FEEAEN1,
        feeaen2: FEEAEN2,
        _reserved17: [u8; 0x10],
        feeeccconfig: FEEECCCONFIG,
        _reserved18: [u8; 0x0c],
        feeeccaddrc0: FEEECCADDRC0,
        feeeccaddrc1: FEEECCADDRC1,
        _reserved20: [u8; 0x18],
        feeeccaddrd0: FEEECCADDRD0,
        feeeccaddrd1: FEEECCADDRD1,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Status Register"]
        #[inline(always)]
        pub const fn feesta(&self) -> &FEESTA {
            &self.feesta
        }
        #[doc = "0x04 - Command Control Register - Interrupt Enable Register"]
        #[inline(always)]
        pub const fn feecon0(&self) -> &FEECON0 {
            &self.feecon0
        }
        #[doc = "0x08 - Command Register"]
        #[inline(always)]
        pub const fn feecmd(&self) -> &FEECMD {
            &self.feecmd
        }
        #[doc = "0x0c - Flash Address Key - Hole Register"]
        #[inline(always)]
        pub const fn feefladr(&self) -> &FEEFLADR {
            &self.feefladr
        }
        #[doc = "0x10 - Flash Data Register - Key - Hole Interface Lower 32 Bits"]
        #[inline(always)]
        pub const fn feefldata0(&self) -> &FEEFLDATA0 {
            &self.feefldata0
        }
        #[doc = "0x14 - Flash Data Register - Key - Hole Interface Upper 32 Bits"]
        #[inline(always)]
        pub const fn feefldata1(&self) -> &FEEFLDATA1 {
            &self.feefldata1
        }
        #[doc = "0x18 - Lower Page Address"]
        #[inline(always)]
        pub const fn feeadr0(&self) -> &FEEADR0 {
            &self.feeadr0
        }
        #[doc = "0x1c - Upper Page Address"]
        #[inline(always)]
        pub const fn feeadr1(&self) -> &FEEADR1 {
            &self.feeadr1
        }
        #[doc = "0x20 - Flash Key Register."]
        #[inline(always)]
        pub const fn feekey(&self) -> &FEEKEY {
            &self.feekey
        }
        #[doc = "0x28 - Write Protection Register for Flash0"]
        #[inline(always)]
        pub const fn feepro0(&self) -> &FEEPRO0 {
            &self.feepro0
        }
        #[doc = "0x2c - Write Protection Register for Flash1"]
        #[inline(always)]
        pub const fn feepro1(&self) -> &FEEPRO1 {
            &self.feepro1
        }
        #[doc = "0x34 - Flash Signature"]
        #[inline(always)]
        pub const fn feesig(&self) -> &FEESIG {
            &self.feesig
        }
        #[doc = "0x38 - User Setup Register"]
        #[inline(always)]
        pub const fn feecon1(&self) -> &FEECON1 {
            &self.feecon1
        }
        #[doc = "0x40 - Write Abort Address Register"]
        #[inline(always)]
        pub const fn feewraddra(&self) -> &FEEWRADDRA {
            &self.feewraddra
        }
        #[doc = "0x48 - Lower 32 Bits of the Sys Irq Abort Enable Register."]
        #[inline(always)]
        pub const fn feeaen0(&self) -> &FEEAEN0 {
            &self.feeaen0
        }
        #[doc = "0x4c - Middle 32 Bits of the Sys Irq Abort Enable Register."]
        #[inline(always)]
        pub const fn feeaen1(&self) -> &FEEAEN1 {
            &self.feeaen1
        }
        #[doc = "0x50 - Upper 32 Bits of the Sys Irq Abort Enable Register."]
        #[inline(always)]
        pub const fn feeaen2(&self) -> &FEEAEN2 {
            &self.feeaen2
        }
        #[doc = "0x64 - Configurable ECC Enable/disable, Error Response"]
        #[inline(always)]
        pub const fn feeeccconfig(&self) -> &FEEECCCONFIG {
            &self.feeeccconfig
        }
        #[doc = "0x74 - Flash 0 ECC Error Address via CODE Bus"]
        #[inline(always)]
        pub const fn feeeccaddrc0(&self) -> &FEEECCADDRC0 {
            &self.feeeccaddrc0
        }
        #[doc = "0x78 - Flash 1 ECC Error Address via CODE Bus"]
        #[inline(always)]
        pub const fn feeeccaddrc1(&self) -> &FEEECCADDRC1 {
            &self.feeeccaddrc1
        }
        #[doc = "0x94 - Flash 0 ECC Error Address via DMA Bus"]
        #[inline(always)]
        pub const fn feeeccaddrd0(&self) -> &FEEECCADDRD0 {
            &self.feeeccaddrd0
        }
        #[doc = "0x98 - Flash 1 ECC Error Address via DMA Bus"]
        #[inline(always)]
        pub const fn feeeccaddrd1(&self) -> &FEEECCADDRD1 {
            &self.feeeccaddrd1
        }
    }
    #[doc = "FEESTA (rw) register accessor: Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feesta::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feesta::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEESTA)\n\nFor information about available fields see [`mod@feesta`]
module"]
    pub type FEESTA = crate::Reg<feesta::FEESTArs>;
    #[doc = "Status Register"]
    pub mod feesta {
        #[doc = "Register `FEESTA` reader"]
        pub type R = crate::R<FEESTArs>;
        #[doc = "Register `FEESTA` writer"]
        pub type W = crate::W<FEESTArs>;
        #[doc = "Field `CMDBUSY` reader - Command Busy."]
        pub type CMDBUSY_R = crate::BitReader;
        #[doc = "Field `WRCLOSE` reader - Key-hole Registers Closed for Access"]
        pub type WRCLOSE_R = crate::BitReader;
        #[doc = "Field `CMDCOMP` reader - Command Complete"]
        pub type CMDCOMP_R = crate::BitReader;
        #[doc = "Field `WRALCOMP` reader - Write Almost Complete - Key-hole Registers Open for Access"]
        pub type WRALCOMP_R = crate::BitReader;
        #[doc = "Command Failed\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CMDFAIL {
            #[doc = "0: Successful Completion of a Command or a Write"]
            Success = 0,
            #[doc = "1: Attempted Signcheck,write or Erase of a Protected Location or Out of Memory Location. the Command is Ignored."]
            Denied = 1,
            #[doc = "2: Read Verify Error"]
            Verifyerr = 2,
            #[doc = "3: Indicates That a Command or a Write Was Aborted by an Abort Command or a System Interrupt Has Caused an Abort"]
            Aborted = 3,
        }
        impl From<CMDFAIL> for u8 {
            #[inline(always)]
            fn from(variant: CMDFAIL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CMDFAIL {
            type Ux = u8;
        }
        impl crate::IsEnum for CMDFAIL {}
        #[doc = "Field `CMDFAIL` reader - Command Failed"]
        pub type CMDFAIL_R = crate::FieldReader<CMDFAIL>;
        impl CMDFAIL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CMDFAIL {
                match self.bits {
                    0 => CMDFAIL::Success,
                    1 => CMDFAIL::Denied,
                    2 => CMDFAIL::Verifyerr,
                    3 => CMDFAIL::Aborted,
                    _ => unreachable!(),
                }
            }
            #[doc = "Successful Completion of a Command or a Write"]
            #[inline(always)]
            pub fn is_success(&self) -> bool {
                *self == CMDFAIL::Success
            }
            #[doc = "Attempted Signcheck,write or Erase of a Protected Location or Out of Memory Location. the Command is Ignored."]
            #[inline(always)]
            pub fn is_denied(&self) -> bool {
                *self == CMDFAIL::Denied
            }
            #[doc = "Read Verify Error"]
            #[inline(always)]
            pub fn is_verifyerr(&self) -> bool {
                *self == CMDFAIL::Verifyerr
            }
            #[doc = "Indicates That a Command or a Write Was Aborted by an Abort Command or a System Interrupt Has Caused an Abort"]
            #[inline(always)]
            pub fn is_aborted(&self) -> bool {
                *self == CMDFAIL::Aborted
            }
        }
        #[doc = "ECC Errors Produced During Signature Commands\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCERRCMD {
            #[doc = "0: No Error, Successful Flash Read Operation During Signature Check"]
            NoError = 0,
            #[doc = "1: During Signature Commands, 2 Bit Error is Detected on One or More Flash Locations, Not Corrected."]
            Error2bit = 1,
            #[doc = "2: 1 Bit Error is Corrected for One or More Flash Locations While Doing Signature Commands"]
            Error1bit = 2,
            #[doc = "3: During Signature Commands, 1 Bit Error and 2 Bit Errors are Detected on One or More Flash Locations"]
            Error1or2bit = 3,
        }
        impl From<ECCERRCMD> for u8 {
            #[inline(always)]
            fn from(variant: ECCERRCMD) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCERRCMD {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCERRCMD {}
        #[doc = "Field `ECCERRCMD` reader - ECC Errors Produced During Signature Commands"]
        pub type ECCERRCMD_R = crate::FieldReader<ECCERRCMD>;
        impl ECCERRCMD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCERRCMD {
                match self.bits {
                    0 => ECCERRCMD::NoError,
                    1 => ECCERRCMD::Error2bit,
                    2 => ECCERRCMD::Error1bit,
                    3 => ECCERRCMD::Error1or2bit,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error, Successful Flash Read Operation During Signature Check"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == ECCERRCMD::NoError
            }
            #[doc = "During Signature Commands, 2 Bit Error is Detected on One or More Flash Locations, Not Corrected."]
            #[inline(always)]
            pub fn is_error2bit(&self) -> bool {
                *self == ECCERRCMD::Error2bit
            }
            #[doc = "1 Bit Error is Corrected for One or More Flash Locations While Doing Signature Commands"]
            #[inline(always)]
            pub fn is_error1bit(&self) -> bool {
                *self == ECCERRCMD::Error1bit
            }
            #[doc = "During Signature Commands, 1 Bit Error and 2 Bit Errors are Detected on One or More Flash Locations"]
            #[inline(always)]
            pub fn is_error1or2bit(&self) -> bool {
                *self == ECCERRCMD::Error1or2bit
            }
        }
        #[doc = "ECC Interrupt Errors During AHB Read to Flash 0.\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCREADERRFLSH0 {
            #[doc = "0: No Error. Successful Read from Program Flash via AHB Bus"]
            NoError = 0,
            #[doc = "1: During AHB Read to Flash, 2 Bit Error Detected, Not Corrected."]
            Error2bit = 1,
            #[doc = "2: 1 Bit Error is Corrected for One Flash Location While Doing AHB Read to Program Flash"]
            Error1bit = 2,
            #[doc = "3: During AHB Read, It is Either ECC Error or ECC Corrected Error Only. but This Condition Can Occur If the Consecutive Access Had AHB HRESP Error Due to ECC Error, Before the Status Register is Read."]
            Error1or2bit = 3,
        }
        impl From<ECCREADERRFLSH0> for u8 {
            #[inline(always)]
            fn from(variant: ECCREADERRFLSH0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCREADERRFLSH0 {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCREADERRFLSH0 {}
        #[doc = "Field `ECCREADERRFLSH0` reader - ECC Interrupt Errors During AHB Read to Flash 0."]
        pub type ECCREADERRFLSH0_R = crate::FieldReader<ECCREADERRFLSH0>;
        impl ECCREADERRFLSH0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCREADERRFLSH0 {
                match self.bits {
                    0 => ECCREADERRFLSH0::NoError,
                    1 => ECCREADERRFLSH0::Error2bit,
                    2 => ECCREADERRFLSH0::Error1bit,
                    3 => ECCREADERRFLSH0::Error1or2bit,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error. Successful Read from Program Flash via AHB Bus"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == ECCREADERRFLSH0::NoError
            }
            #[doc = "During AHB Read to Flash, 2 Bit Error Detected, Not Corrected."]
            #[inline(always)]
            pub fn is_error2bit(&self) -> bool {
                *self == ECCREADERRFLSH0::Error2bit
            }
            #[doc = "1 Bit Error is Corrected for One Flash Location While Doing AHB Read to Program Flash"]
            #[inline(always)]
            pub fn is_error1bit(&self) -> bool {
                *self == ECCREADERRFLSH0::Error1bit
            }
            #[doc = "During AHB Read, It is Either ECC Error or ECC Corrected Error Only. but This Condition Can Occur If the Consecutive Access Had AHB HRESP Error Due to ECC Error, Before the Status Register is Read."]
            #[inline(always)]
            pub fn is_error1or2bit(&self) -> bool {
                *self == ECCREADERRFLSH0::Error1or2bit
            }
        }
        #[doc = "ECC Interrupt Errors During AHB Read to Flash 1.\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCREADERRFLSH1 {
            #[doc = "0: No Error. Successful Read from Data Flash via AHB Bus"]
            NoError = 0,
            #[doc = "1: 1 Bit Error is Corrected for One Flash Location While Doing AHB Read to Data Flash"]
            Error2bit = 1,
            #[doc = "2: During AHB Read to Flash, 2 Bit Error Detected, Not Corrected."]
            Error1bit = 2,
            #[doc = "3: During AHB Read, It is Either ECC Error or ECC Corrected Error Only. but This Condition Can Occur If the Consecutive Access Had AHB HRESP Error Due to ECC Error, Before the Status Register is Read."]
            Error1or2bit = 3,
        }
        impl From<ECCREADERRFLSH1> for u8 {
            #[inline(always)]
            fn from(variant: ECCREADERRFLSH1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCREADERRFLSH1 {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCREADERRFLSH1 {}
        #[doc = "Field `ECCREADERRFLSH1` reader - ECC Interrupt Errors During AHB Read to Flash 1."]
        pub type ECCREADERRFLSH1_R = crate::FieldReader<ECCREADERRFLSH1>;
        impl ECCREADERRFLSH1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCREADERRFLSH1 {
                match self.bits {
                    0 => ECCREADERRFLSH1::NoError,
                    1 => ECCREADERRFLSH1::Error2bit,
                    2 => ECCREADERRFLSH1::Error1bit,
                    3 => ECCREADERRFLSH1::Error1or2bit,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error. Successful Read from Data Flash via AHB Bus"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == ECCREADERRFLSH1::NoError
            }
            #[doc = "1 Bit Error is Corrected for One Flash Location While Doing AHB Read to Data Flash"]
            #[inline(always)]
            pub fn is_error2bit(&self) -> bool {
                *self == ECCREADERRFLSH1::Error2bit
            }
            #[doc = "During AHB Read to Flash, 2 Bit Error Detected, Not Corrected."]
            #[inline(always)]
            pub fn is_error1bit(&self) -> bool {
                *self == ECCREADERRFLSH1::Error1bit
            }
            #[doc = "During AHB Read, It is Either ECC Error or ECC Corrected Error Only. but This Condition Can Occur If the Consecutive Access Had AHB HRESP Error Due to ECC Error, Before the Status Register is Read."]
            #[inline(always)]
            pub fn is_error1or2bit(&self) -> bool {
                *self == ECCREADERRFLSH1::Error1or2bit
            }
        }
        #[doc = "Field `SIGNERR` reader - Initial Signature Check Error on Info Space"]
        pub type SIGNERR_R = crate::BitReader;
        #[doc = "Field `INIT` reader - Initialization Upload in Progress."]
        pub type INIT_R = crate::BitReader;
        #[doc = "ECC Error on Initial Info Signature Check\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCERRINITSIGN {
            #[doc = "0: No Error, Successful Flash Read Operation During Initial Signature Check, Page Signature Check"]
            NoError = 0,
            #[doc = "1: During Initial Signature Check, 2 Bit Error Detected, Not Corrected for at Least One Flash Location"]
            Error2bit = 1,
            #[doc = "2: 1 Bit Error is Corrected for One Flash Location While Doing Signature Commands"]
            Error1bit = 2,
            #[doc = "3: During Initial Signature Command, 1 Bit Error and 2 Bit Errors are Detected on One or More Flash Locations"]
            Error1or2bit = 3,
        }
        impl From<ECCERRINITSIGN> for u8 {
            #[inline(always)]
            fn from(variant: ECCERRINITSIGN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCERRINITSIGN {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCERRINITSIGN {}
        #[doc = "Field `ECCERRINITSIGN` reader - ECC Error on Initial Info Signature Check"]
        pub type ECCERRINITSIGN_R = crate::FieldReader<ECCERRINITSIGN>;
        impl ECCERRINITSIGN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCERRINITSIGN {
                match self.bits {
                    0 => ECCERRINITSIGN::NoError,
                    1 => ECCERRINITSIGN::Error2bit,
                    2 => ECCERRINITSIGN::Error1bit,
                    3 => ECCERRINITSIGN::Error1or2bit,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error, Successful Flash Read Operation During Initial Signature Check, Page Signature Check"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == ECCERRINITSIGN::NoError
            }
            #[doc = "During Initial Signature Check, 2 Bit Error Detected, Not Corrected for at Least One Flash Location"]
            #[inline(always)]
            pub fn is_error2bit(&self) -> bool {
                *self == ECCERRINITSIGN::Error2bit
            }
            #[doc = "1 Bit Error is Corrected for One Flash Location While Doing Signature Commands"]
            #[inline(always)]
            pub fn is_error1bit(&self) -> bool {
                *self == ECCERRINITSIGN::Error1bit
            }
            #[doc = "During Initial Signature Command, 1 Bit Error and 2 Bit Errors are Detected on One or More Flash Locations"]
            #[inline(always)]
            pub fn is_error1or2bit(&self) -> bool {
                *self == ECCERRINITSIGN::Error1or2bit
            }
        }
        #[doc = "Field `ECCERRCNTC0` reader - ECC Error Count via CODE Bus of Flash 0"]
        pub type ECCERRCNTC0_R = crate::FieldReader;
        #[doc = "Field `ECCERRCNTD0` reader - ECC Error Count via DMA Bus of Flash 0"]
        pub type ECCERRCNTD0_R = crate::FieldReader;
        #[doc = "Field `ECCERRCNTC1` reader - ECC Error Count via CODE Bus of Flash 1"]
        pub type ECCERRCNTC1_R = crate::FieldReader;
        #[doc = "ECC Error Response on CODE Bus\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCHRESPCODE {
            #[doc = "0: No Error. Successful Read from Program Flash via AHB Bus"]
            NoError = 0,
            #[doc = "1: During AHB Read to Flash, 2 Bit Error Detected, Not Corrected."]
            Error2bit = 1,
            #[doc = "2: 1 Bit Error is Corrected for One Flash Location While Doing AHB Read to Program Flash"]
            Error1bit = 2,
        }
        impl From<ECCHRESPCODE> for u8 {
            #[inline(always)]
            fn from(variant: ECCHRESPCODE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCHRESPCODE {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCHRESPCODE {}
        #[doc = "Field `ECCHRESPCODE` reader - ECC Error Response on CODE Bus"]
        pub type ECCHRESPCODE_R = crate::FieldReader<ECCHRESPCODE>;
        impl ECCHRESPCODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCHRESPCODE {
                match self.bits {
                    0 => ECCHRESPCODE::NoError,
                    1 => ECCHRESPCODE::Error2bit,
                    2 => ECCHRESPCODE::Error1bit,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error. Successful Read from Program Flash via AHB Bus"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == ECCHRESPCODE::NoError
            }
            #[doc = "During AHB Read to Flash, 2 Bit Error Detected, Not Corrected."]
            #[inline(always)]
            pub fn is_error2bit(&self) -> bool {
                *self == ECCHRESPCODE::Error2bit
            }
            #[doc = "1 Bit Error is Corrected for One Flash Location While Doing AHB Read to Program Flash"]
            #[inline(always)]
            pub fn is_error1bit(&self) -> bool {
                *self == ECCHRESPCODE::Error1bit
            }
        }
        #[doc = "ECC Error Response on DMA Bus\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCHRESPDMA {
            #[doc = "0: No Error. Successful Read from Program Flash via AHB Bus"]
            NoError = 0,
            #[doc = "1: During AHB Read to Flash, 2 Bit Error Detected, Not Corrected."]
            Error2bit = 1,
            #[doc = "2: 1 Bit Error is Corrected for One Flash Location While Doing AHB Read to Program Flash"]
            Error1bit = 2,
        }
        impl From<ECCHRESPDMA> for u8 {
            #[inline(always)]
            fn from(variant: ECCHRESPDMA) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCHRESPDMA {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCHRESPDMA {}
        #[doc = "Field `ECCHRESPDMA` reader - ECC Error Response on DMA Bus"]
        pub type ECCHRESPDMA_R = crate::FieldReader<ECCHRESPDMA>;
        impl ECCHRESPDMA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCHRESPDMA {
                match self.bits {
                    0 => ECCHRESPDMA::NoError,
                    1 => ECCHRESPDMA::Error2bit,
                    2 => ECCHRESPDMA::Error1bit,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error. Successful Read from Program Flash via AHB Bus"]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == ECCHRESPDMA::NoError
            }
            #[doc = "During AHB Read to Flash, 2 Bit Error Detected, Not Corrected."]
            #[inline(always)]
            pub fn is_error2bit(&self) -> bool {
                *self == ECCHRESPDMA::Error2bit
            }
            #[doc = "1 Bit Error is Corrected for One Flash Location While Doing AHB Read to Program Flash"]
            #[inline(always)]
            pub fn is_error1bit(&self) -> bool {
                *self == ECCHRESPDMA::Error1bit
            }
        }
        #[doc = "Field `ECCERRCNTD1` reader - ECC Error Count via DMA Bus of Flash 1"]
        pub type ECCERRCNTD1_R = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - Command Busy."]
            #[inline(always)]
            pub fn cmdbusy(&self) -> CMDBUSY_R {
                CMDBUSY_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Key-hole Registers Closed for Access"]
            #[inline(always)]
            pub fn wrclose(&self) -> WRCLOSE_R {
                WRCLOSE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Command Complete"]
            #[inline(always)]
            pub fn cmdcomp(&self) -> CMDCOMP_R {
                CMDCOMP_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Write Almost Complete - Key-hole Registers Open for Access"]
            #[inline(always)]
            pub fn wralcomp(&self) -> WRALCOMP_R {
                WRALCOMP_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - Command Failed"]
            #[inline(always)]
            pub fn cmdfail(&self) -> CMDFAIL_R {
                CMDFAIL_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 7:8 - ECC Errors Produced During Signature Commands"]
            #[inline(always)]
            pub fn eccerrcmd(&self) -> ECCERRCMD_R {
                ECCERRCMD_R::new(((self.bits >> 7) & 3) as u8)
            }
            #[doc = "Bits 9:10 - ECC Interrupt Errors During AHB Read to Flash 0."]
            #[inline(always)]
            pub fn eccreaderrflsh0(&self) -> ECCREADERRFLSH0_R {
                ECCREADERRFLSH0_R::new(((self.bits >> 9) & 3) as u8)
            }
            #[doc = "Bits 11:12 - ECC Interrupt Errors During AHB Read to Flash 1."]
            #[inline(always)]
            pub fn eccreaderrflsh1(&self) -> ECCREADERRFLSH1_R {
                ECCREADERRFLSH1_R::new(((self.bits >> 11) & 3) as u8)
            }
            #[doc = "Bit 13 - Initial Signature Check Error on Info Space"]
            #[inline(always)]
            pub fn signerr(&self) -> SIGNERR_R {
                SIGNERR_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Initialization Upload in Progress."]
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bits 15:16 - ECC Error on Initial Info Signature Check"]
            #[inline(always)]
            pub fn eccerrinitsign(&self) -> ECCERRINITSIGN_R {
                ECCERRINITSIGN_R::new(((self.bits >> 15) & 3) as u8)
            }
            #[doc = "Bits 17:19 - ECC Error Count via CODE Bus of Flash 0"]
            #[inline(always)]
            pub fn eccerrcntc0(&self) -> ECCERRCNTC0_R {
                ECCERRCNTC0_R::new(((self.bits >> 17) & 7) as u8)
            }
            #[doc = "Bits 20:21 - ECC Error Count via DMA Bus of Flash 0"]
            #[inline(always)]
            pub fn eccerrcntd0(&self) -> ECCERRCNTD0_R {
                ECCERRCNTD0_R::new(((self.bits >> 20) & 3) as u8)
            }
            #[doc = "Bits 22:24 - ECC Error Count via CODE Bus of Flash 1"]
            #[inline(always)]
            pub fn eccerrcntc1(&self) -> ECCERRCNTC1_R {
                ECCERRCNTC1_R::new(((self.bits >> 22) & 7) as u8)
            }
            #[doc = "Bits 25:26 - ECC Error Response on CODE Bus"]
            #[inline(always)]
            pub fn ecchrespcode(&self) -> ECCHRESPCODE_R {
                ECCHRESPCODE_R::new(((self.bits >> 25) & 3) as u8)
            }
            #[doc = "Bits 27:28 - ECC Error Response on DMA Bus"]
            #[inline(always)]
            pub fn ecchrespdma(&self) -> ECCHRESPDMA_R {
                ECCHRESPDMA_R::new(((self.bits >> 27) & 3) as u8)
            }
            #[doc = "Bits 29:30 - ECC Error Count via DMA Bus of Flash 1"]
            #[inline(always)]
            pub fn eccerrcntd1(&self) -> ECCERRCNTD1_R {
                ECCERRCNTD1_R::new(((self.bits >> 29) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEESTA")
                    .field("cmdbusy", &self.cmdbusy())
                    .field("wrclose", &self.wrclose())
                    .field("cmdcomp", &self.cmdcomp())
                    .field("wralcomp", &self.wralcomp())
                    .field("cmdfail", &self.cmdfail())
                    .field("eccerrcmd", &self.eccerrcmd())
                    .field("eccreaderrflsh0", &self.eccreaderrflsh0())
                    .field("eccreaderrflsh1", &self.eccreaderrflsh1())
                    .field("signerr", &self.signerr())
                    .field("init", &self.init())
                    .field("eccerrinitsign", &self.eccerrinitsign())
                    .field("eccerrcntc0", &self.eccerrcntc0())
                    .field("eccerrcntd0", &self.eccerrcntd0())
                    .field("eccerrcntc1", &self.eccerrcntc1())
                    .field("ecchrespcode", &self.ecchrespcode())
                    .field("ecchrespdma", &self.ecchrespdma())
                    .field("eccerrcntd1", &self.eccerrcntd1())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feesta::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feesta::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEESTA)"]
        pub struct FEESTArs;
        impl crate::RegisterSpec for FEESTArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feesta::R`](R) reader structure"]
        impl crate::Readable for FEESTArs {}
        #[doc = "`write(|w| ..)` method takes [`feesta::W`](W) writer structure"]
        impl crate::Writable for FEESTArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEESTA to value 0"]
        impl crate::Resettable for FEESTArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEECON0 (rw) register accessor: Command Control Register - Interrupt Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feecon0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feecon0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEECON0)\n\nFor information about available fields see [`mod@feecon0`]
module"]
    pub type FEECON0 = crate::Reg<feecon0::FEECON0rs>;
    #[doc = "Command Control Register - Interrupt Enable Register"]
    pub mod feecon0 {
        #[doc = "Register `FEECON0` reader"]
        pub type R = crate::R<FEECON0rs>;
        #[doc = "Register `FEECON0` writer"]
        pub type W = crate::W<FEECON0rs>;
        #[doc = "Field `IENCMD` reader - Command Complete Interrupt Enable"]
        pub type IENCMD_R = crate::BitReader;
        #[doc = "Field `IENCMD` writer - Command Complete Interrupt Enable"]
        pub type IENCMD_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IWRALCOMP` reader - Write Almost Complete Interrupt Enable"]
        pub type IWRALCOMP_R = crate::BitReader;
        #[doc = "Field `IWRALCOMP` writer - Write Almost Complete Interrupt Enable"]
        pub type IWRALCOMP_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IENERR` reader - Command Fail Interrupt Enable"]
        pub type IENERR_R = crate::BitReader;
        #[doc = "Field `IENERR` writer - Command Fail Interrupt Enable"]
        pub type IENERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Command Complete Interrupt Enable"]
            #[inline(always)]
            pub fn iencmd(&self) -> IENCMD_R {
                IENCMD_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Write Almost Complete Interrupt Enable"]
            #[inline(always)]
            pub fn iwralcomp(&self) -> IWRALCOMP_R {
                IWRALCOMP_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Command Fail Interrupt Enable"]
            #[inline(always)]
            pub fn ienerr(&self) -> IENERR_R {
                IENERR_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEECON0")
                    .field("iencmd", &self.iencmd())
                    .field("iwralcomp", &self.iwralcomp())
                    .field("ienerr", &self.ienerr())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Command Complete Interrupt Enable"]
            #[inline(always)]
            pub fn iencmd(&mut self) -> IENCMD_W<FEECON0rs> {
                IENCMD_W::new(self, 0)
            }
            #[doc = "Bit 1 - Write Almost Complete Interrupt Enable"]
            #[inline(always)]
            pub fn iwralcomp(&mut self) -> IWRALCOMP_W<FEECON0rs> {
                IWRALCOMP_W::new(self, 1)
            }
            #[doc = "Bit 2 - Command Fail Interrupt Enable"]
            #[inline(always)]
            pub fn ienerr(&mut self) -> IENERR_W<FEECON0rs> {
                IENERR_W::new(self, 2)
            }
        }
        #[doc = "Command Control Register - Interrupt Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feecon0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feecon0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEECON0)"]
        pub struct FEECON0rs;
        impl crate::RegisterSpec for FEECON0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feecon0::R`](R) reader structure"]
        impl crate::Readable for FEECON0rs {}
        #[doc = "`write(|w| ..)` method takes [`feecon0::W`](W) writer structure"]
        impl crate::Writable for FEECON0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEECON0 to value 0"]
        impl crate::Resettable for FEECON0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEECMD (rw) register accessor: Command Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feecmd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feecmd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEECMD)\n\nFor information about available fields see [`mod@feecmd`]
module"]
    pub type FEECMD = crate::Reg<feecmd::FEECMDrs>;
    #[doc = "Command Register"]
    pub mod feecmd {
        #[doc = "Register `FEECMD` reader"]
        pub type R = crate::R<FEECMDrs>;
        #[doc = "Register `FEECMD` writer"]
        pub type W = crate::W<FEECMDrs>;
        #[doc = "Commands\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CMD {
            #[doc = "0: IDLE"]
            Idle = 0,
            #[doc = "1: ERASEPAGE"]
            Erasepage = 1,
            #[doc = "2: SIGN"]
            Sign = 2,
            #[doc = "4: WRITE"]
            Write = 4,
            #[doc = "5: MASSERASE_ACTIVE"]
            MasseraseActive = 5,
            #[doc = "6: MASSERASE_PASSIVE"]
            MasserasePassive = 6,
            #[doc = "8: ABORT"]
            Abort = 8,
        }
        impl From<CMD> for u8 {
            #[inline(always)]
            fn from(variant: CMD) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CMD {
            type Ux = u8;
        }
        impl crate::IsEnum for CMD {}
        #[doc = "Field `CMD` reader - Commands"]
        pub type CMD_R = crate::FieldReader<CMD>;
        impl CMD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CMD> {
                match self.bits {
                    0 => Some(CMD::Idle),
                    1 => Some(CMD::Erasepage),
                    2 => Some(CMD::Sign),
                    4 => Some(CMD::Write),
                    5 => Some(CMD::MasseraseActive),
                    6 => Some(CMD::MasserasePassive),
                    8 => Some(CMD::Abort),
                    _ => None,
                }
            }
            #[doc = "IDLE"]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == CMD::Idle
            }
            #[doc = "ERASEPAGE"]
            #[inline(always)]
            pub fn is_erasepage(&self) -> bool {
                *self == CMD::Erasepage
            }
            #[doc = "SIGN"]
            #[inline(always)]
            pub fn is_sign(&self) -> bool {
                *self == CMD::Sign
            }
            #[doc = "WRITE"]
            #[inline(always)]
            pub fn is_write(&self) -> bool {
                *self == CMD::Write
            }
            #[doc = "MASSERASE_ACTIVE"]
            #[inline(always)]
            pub fn is_masserase_active(&self) -> bool {
                *self == CMD::MasseraseActive
            }
            #[doc = "MASSERASE_PASSIVE"]
            #[inline(always)]
            pub fn is_masserase_passive(&self) -> bool {
                *self == CMD::MasserasePassive
            }
            #[doc = "ABORT"]
            #[inline(always)]
            pub fn is_abort(&self) -> bool {
                *self == CMD::Abort
            }
        }
        #[doc = "Field `CMD` writer - Commands"]
        pub type CMD_W<'a, REG> = crate::FieldWriter<'a, REG, 5, CMD>;
        impl<'a, REG> CMD_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "IDLE"]
            #[inline(always)]
            pub fn idle(self) -> &'a mut crate::W<REG> {
                self.variant(CMD::Idle)
            }
            #[doc = "ERASEPAGE"]
            #[inline(always)]
            pub fn erasepage(self) -> &'a mut crate::W<REG> {
                self.variant(CMD::Erasepage)
            }
            #[doc = "SIGN"]
            #[inline(always)]
            pub fn sign(self) -> &'a mut crate::W<REG> {
                self.variant(CMD::Sign)
            }
            #[doc = "WRITE"]
            #[inline(always)]
            pub fn write(self) -> &'a mut crate::W<REG> {
                self.variant(CMD::Write)
            }
            #[doc = "MASSERASE_ACTIVE"]
            #[inline(always)]
            pub fn masserase_active(self) -> &'a mut crate::W<REG> {
                self.variant(CMD::MasseraseActive)
            }
            #[doc = "MASSERASE_PASSIVE"]
            #[inline(always)]
            pub fn masserase_passive(self) -> &'a mut crate::W<REG> {
                self.variant(CMD::MasserasePassive)
            }
            #[doc = "ABORT"]
            #[inline(always)]
            pub fn abort(self) -> &'a mut crate::W<REG> {
                self.variant(CMD::Abort)
            }
        }
        impl R {
            #[doc = "Bits 0:4 - Commands"]
            #[inline(always)]
            pub fn cmd(&self) -> CMD_R {
                CMD_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEECMD").field("cmd", &self.cmd()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:4 - Commands"]
            #[inline(always)]
            pub fn cmd(&mut self) -> CMD_W<FEECMDrs> {
                CMD_W::new(self, 0)
            }
        }
        #[doc = "Command Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feecmd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feecmd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEECMD)"]
        pub struct FEECMDrs;
        impl crate::RegisterSpec for FEECMDrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feecmd::R`](R) reader structure"]
        impl crate::Readable for FEECMDrs {}
        #[doc = "`write(|w| ..)` method takes [`feecmd::W`](W) writer structure"]
        impl crate::Writable for FEECMDrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEECMD to value 0"]
        impl crate::Resettable for FEECMDrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEFLADR (rw) register accessor: Flash Address Key - Hole Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feefladr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feefladr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEFLADR)\n\nFor information about available fields see [`mod@feefladr`]
module"]
    pub type FEEFLADR = crate::Reg<feefladr::FEEFLADRrs>;
    #[doc = "Flash Address Key - Hole Register"]
    pub mod feefladr {
        #[doc = "Register `FEEFLADR` reader"]
        pub type R = crate::R<FEEFLADRrs>;
        #[doc = "Register `FEEFLADR` writer"]
        pub type W = crate::W<FEEFLADRrs>;
        #[doc = "Field `FLAddr` reader - Memory Mapped Address for the Flash Location"]
        pub type FLADDR_R = crate::FieldReader<u32>;
        #[doc = "Field `FLAddr` writer - Memory Mapped Address for the Flash Location"]
        pub type FLADDR_W<'a, REG> = crate::FieldWriter<'a, REG, 18, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 3:20 - Memory Mapped Address for the Flash Location"]
            #[inline(always)]
            pub fn fladdr(&self) -> FLADDR_R {
                FLADDR_R::new((self.bits >> 3) & 0x0003_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEFLADR")
                    .field("fladdr", &self.fladdr())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 3:20 - Memory Mapped Address for the Flash Location"]
            #[inline(always)]
            pub fn fladdr(&mut self) -> FLADDR_W<FEEFLADRrs> {
                FLADDR_W::new(self, 3)
            }
        }
        #[doc = "Flash Address Key - Hole Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feefladr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feefladr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEFLADR)"]
        pub struct FEEFLADRrs;
        impl crate::RegisterSpec for FEEFLADRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feefladr::R`](R) reader structure"]
        impl crate::Readable for FEEFLADRrs {}
        #[doc = "`write(|w| ..)` method takes [`feefladr::W`](W) writer structure"]
        impl crate::Writable for FEEFLADRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEFLADR to value 0"]
        impl crate::Resettable for FEEFLADRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEFLDATA0 (rw) register accessor: Flash Data Register - Key - Hole Interface Lower 32 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`feefldata0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feefldata0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEFLDATA0)\n\nFor information about available fields see [`mod@feefldata0`]
module"]
    pub type FEEFLDATA0 = crate::Reg<feefldata0::FEEFLDATA0rs>;
    #[doc = "Flash Data Register - Key - Hole Interface Lower 32 Bits"]
    pub mod feefldata0 {
        #[doc = "Register `FEEFLDATA0` reader"]
        pub type R = crate::R<FEEFLDATA0rs>;
        #[doc = "Register `FEEFLDATA0` writer"]
        pub type W = crate::W<FEEFLDATA0rs>;
        #[doc = "Field `FLData0` reader - Lower 32 Bit of 64 Bit Data to Be Written to Flash"]
        pub type FLDATA0_R = crate::FieldReader<u32>;
        #[doc = "Field `FLData0` writer - Lower 32 Bit of 64 Bit Data to Be Written to Flash"]
        pub type FLDATA0_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Lower 32 Bit of 64 Bit Data to Be Written to Flash"]
            #[inline(always)]
            pub fn fldata0(&self) -> FLDATA0_R {
                FLDATA0_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEFLDATA0")
                    .field("fldata0", &self.fldata0())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Lower 32 Bit of 64 Bit Data to Be Written to Flash"]
            #[inline(always)]
            pub fn fldata0(&mut self) -> FLDATA0_W<FEEFLDATA0rs> {
                FLDATA0_W::new(self, 0)
            }
        }
        #[doc = "Flash Data Register - Key - Hole Interface Lower 32 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`feefldata0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feefldata0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEFLDATA0)"]
        pub struct FEEFLDATA0rs;
        impl crate::RegisterSpec for FEEFLDATA0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feefldata0::R`](R) reader structure"]
        impl crate::Readable for FEEFLDATA0rs {}
        #[doc = "`write(|w| ..)` method takes [`feefldata0::W`](W) writer structure"]
        impl crate::Writable for FEEFLDATA0rs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEFLDATA0 to value 0"]
        impl crate::Resettable for FEEFLDATA0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEFLDATA1 (rw) register accessor: Flash Data Register - Key - Hole Interface Upper 32 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`feefldata1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feefldata1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEFLDATA1)\n\nFor information about available fields see [`mod@feefldata1`]
module"]
    pub type FEEFLDATA1 = crate::Reg<feefldata1::FEEFLDATA1rs>;
    #[doc = "Flash Data Register - Key - Hole Interface Upper 32 Bits"]
    pub mod feefldata1 {
        #[doc = "Register `FEEFLDATA1` reader"]
        pub type R = crate::R<FEEFLDATA1rs>;
        #[doc = "Register `FEEFLDATA1` writer"]
        pub type W = crate::W<FEEFLDATA1rs>;
        #[doc = "Field `FLData1` reader - Upper 32 Bit of 64 Bit Data to Be Written to Flash"]
        pub type FLDATA1_R = crate::FieldReader<u32>;
        #[doc = "Field `FLData1` writer - Upper 32 Bit of 64 Bit Data to Be Written to Flash"]
        pub type FLDATA1_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Upper 32 Bit of 64 Bit Data to Be Written to Flash"]
            #[inline(always)]
            pub fn fldata1(&self) -> FLDATA1_R {
                FLDATA1_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEFLDATA1")
                    .field("fldata1", &self.fldata1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Upper 32 Bit of 64 Bit Data to Be Written to Flash"]
            #[inline(always)]
            pub fn fldata1(&mut self) -> FLDATA1_W<FEEFLDATA1rs> {
                FLDATA1_W::new(self, 0)
            }
        }
        #[doc = "Flash Data Register - Key - Hole Interface Upper 32 Bits\n\nYou can [`read`](crate::Reg::read) this register and get [`feefldata1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feefldata1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEFLDATA1)"]
        pub struct FEEFLDATA1rs;
        impl crate::RegisterSpec for FEEFLDATA1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feefldata1::R`](R) reader structure"]
        impl crate::Readable for FEEFLDATA1rs {}
        #[doc = "`write(|w| ..)` method takes [`feefldata1::W`](W) writer structure"]
        impl crate::Writable for FEEFLDATA1rs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEFLDATA1 to value 0"]
        impl crate::Resettable for FEEFLDATA1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEADR0 (rw) register accessor: Lower Page Address\n\nYou can [`read`](crate::Reg::read) this register and get [`feeadr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeadr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEADR0)\n\nFor information about available fields see [`mod@feeadr0`]
module"]
    pub type FEEADR0 = crate::Reg<feeadr0::FEEADR0rs>;
    #[doc = "Lower Page Address"]
    pub mod feeadr0 {
        #[doc = "Register `FEEADR0` reader"]
        pub type R = crate::R<FEEADR0rs>;
        #[doc = "Register `FEEADR0` writer"]
        pub type W = crate::W<FEEADR0rs>;
        #[doc = "Field `PageAddr0` reader - Page Address 0"]
        pub type PAGE_ADDR0_R = crate::FieldReader;
        #[doc = "Field `PageAddr0` writer - Page Address 0"]
        pub type PAGE_ADDR0_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 13:20 - Page Address 0"]
            #[inline(always)]
            pub fn page_addr0(&self) -> PAGE_ADDR0_R {
                PAGE_ADDR0_R::new(((self.bits >> 13) & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEADR0")
                    .field("page_addr0", &self.page_addr0())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 13:20 - Page Address 0"]
            #[inline(always)]
            pub fn page_addr0(&mut self) -> PAGE_ADDR0_W<FEEADR0rs> {
                PAGE_ADDR0_W::new(self, 13)
            }
        }
        #[doc = "Lower Page Address\n\nYou can [`read`](crate::Reg::read) this register and get [`feeadr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeadr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEADR0)"]
        pub struct FEEADR0rs;
        impl crate::RegisterSpec for FEEADR0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeadr0::R`](R) reader structure"]
        impl crate::Readable for FEEADR0rs {}
        #[doc = "`write(|w| ..)` method takes [`feeadr0::W`](W) writer structure"]
        impl crate::Writable for FEEADR0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEADR0 to value 0"]
        impl crate::Resettable for FEEADR0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEADR1 (rw) register accessor: Upper Page Address\n\nYou can [`read`](crate::Reg::read) this register and get [`feeadr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeadr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEADR1)\n\nFor information about available fields see [`mod@feeadr1`]
module"]
    pub type FEEADR1 = crate::Reg<feeadr1::FEEADR1rs>;
    #[doc = "Upper Page Address"]
    pub mod feeadr1 {
        #[doc = "Register `FEEADR1` reader"]
        pub type R = crate::R<FEEADR1rs>;
        #[doc = "Register `FEEADR1` writer"]
        pub type W = crate::W<FEEADR1rs>;
        #[doc = "Field `PageAddr1` reader - Page Address 1"]
        pub type PAGE_ADDR1_R = crate::FieldReader;
        #[doc = "Field `PageAddr1` writer - Page Address 1"]
        pub type PAGE_ADDR1_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 13:20 - Page Address 1"]
            #[inline(always)]
            pub fn page_addr1(&self) -> PAGE_ADDR1_R {
                PAGE_ADDR1_R::new(((self.bits >> 13) & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEADR1")
                    .field("page_addr1", &self.page_addr1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 13:20 - Page Address 1"]
            #[inline(always)]
            pub fn page_addr1(&mut self) -> PAGE_ADDR1_W<FEEADR1rs> {
                PAGE_ADDR1_W::new(self, 13)
            }
        }
        #[doc = "Upper Page Address\n\nYou can [`read`](crate::Reg::read) this register and get [`feeadr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeadr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEADR1)"]
        pub struct FEEADR1rs;
        impl crate::RegisterSpec for FEEADR1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeadr1::R`](R) reader structure"]
        impl crate::Readable for FEEADR1rs {}
        #[doc = "`write(|w| ..)` method takes [`feeadr1::W`](W) writer structure"]
        impl crate::Writable for FEEADR1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEADR1 to value 0"]
        impl crate::Resettable for FEEADR1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEKEY (rw) register accessor: Flash Key Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`feekey::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feekey::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEKEY)\n\nFor information about available fields see [`mod@feekey`]
module"]
    pub type FEEKEY = crate::Reg<feekey::FEEKEYrs>;
    #[doc = "Flash Key Register."]
    pub mod feekey {
        #[doc = "Register `FEEKEY` reader"]
        pub type R = crate::R<FEEKEYrs>;
        #[doc = "Register `FEEKEY` writer"]
        pub type W = crate::W<FEEKEYrs>;
        #[doc = "Field `KEY` writer - Key Register"]
        pub type KEY_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEKEY").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Key Register"]
            #[inline(always)]
            pub fn key(&mut self) -> KEY_W<FEEKEYrs> {
                KEY_W::new(self, 0)
            }
        }
        #[doc = "Flash Key Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`feekey::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feekey::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEKEY)"]
        pub struct FEEKEYrs;
        impl crate::RegisterSpec for FEEKEYrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feekey::R`](R) reader structure"]
        impl crate::Readable for FEEKEYrs {}
        #[doc = "`write(|w| ..)` method takes [`feekey::W`](W) writer structure"]
        impl crate::Writable for FEEKEYrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEKEY to value 0"]
        impl crate::Resettable for FEEKEYrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEPRO0 (rw) register accessor: Write Protection Register for Flash0\n\nYou can [`read`](crate::Reg::read) this register and get [`feepro0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feepro0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEPRO0)\n\nFor information about available fields see [`mod@feepro0`]
module"]
    pub type FEEPRO0 = crate::Reg<feepro0::FEEPRO0rs>;
    #[doc = "Write Protection Register for Flash0"]
    pub mod feepro0 {
        #[doc = "Register `FEEPRO0` reader"]
        pub type R = crate::R<FEEPRO0rs>;
        #[doc = "Register `FEEPRO0` writer"]
        pub type W = crate::W<FEEPRO0rs>;
        #[doc = "Field `WrProt0` reader - Write Protection for Flash0 - 32 Bits."]
        pub type WR_PROT0_R = crate::FieldReader<u32>;
        #[doc = "Field `WrProt0` writer - Write Protection for Flash0 - 32 Bits."]
        pub type WR_PROT0_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Write Protection for Flash0 - 32 Bits."]
            #[inline(always)]
            pub fn wr_prot0(&self) -> WR_PROT0_R {
                WR_PROT0_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEPRO0")
                    .field("wr_prot0", &self.wr_prot0())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Write Protection for Flash0 - 32 Bits."]
            #[inline(always)]
            pub fn wr_prot0(&mut self) -> WR_PROT0_W<FEEPRO0rs> {
                WR_PROT0_W::new(self, 0)
            }
        }
        #[doc = "Write Protection Register for Flash0\n\nYou can [`read`](crate::Reg::read) this register and get [`feepro0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feepro0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEPRO0)"]
        pub struct FEEPRO0rs;
        impl crate::RegisterSpec for FEEPRO0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feepro0::R`](R) reader structure"]
        impl crate::Readable for FEEPRO0rs {}
        #[doc = "`write(|w| ..)` method takes [`feepro0::W`](W) writer structure"]
        impl crate::Writable for FEEPRO0rs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEPRO0 to value 0xffff_ffff"]
        impl crate::Resettable for FEEPRO0rs {
            const RESET_VALUE: u32 = 0xffff_ffff;
        }
    }
    #[doc = "FEEPRO1 (rw) register accessor: Write Protection Register for Flash1\n\nYou can [`read`](crate::Reg::read) this register and get [`feepro1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feepro1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEPRO1)\n\nFor information about available fields see [`mod@feepro1`]
module"]
    pub type FEEPRO1 = crate::Reg<feepro1::FEEPRO1rs>;
    #[doc = "Write Protection Register for Flash1"]
    pub mod feepro1 {
        #[doc = "Register `FEEPRO1` reader"]
        pub type R = crate::R<FEEPRO1rs>;
        #[doc = "Register `FEEPRO1` writer"]
        pub type W = crate::W<FEEPRO1rs>;
        #[doc = "Field `WrProt1` reader - Write Protection for Flash1 - 32 Bits."]
        pub type WR_PROT1_R = crate::FieldReader<u32>;
        #[doc = "Field `WrProt1` writer - Write Protection for Flash1 - 32 Bits."]
        pub type WR_PROT1_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Write Protection for Flash1 - 32 Bits."]
            #[inline(always)]
            pub fn wr_prot1(&self) -> WR_PROT1_R {
                WR_PROT1_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEPRO1")
                    .field("wr_prot1", &self.wr_prot1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Write Protection for Flash1 - 32 Bits."]
            #[inline(always)]
            pub fn wr_prot1(&mut self) -> WR_PROT1_W<FEEPRO1rs> {
                WR_PROT1_W::new(self, 0)
            }
        }
        #[doc = "Write Protection Register for Flash1\n\nYou can [`read`](crate::Reg::read) this register and get [`feepro1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feepro1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEPRO1)"]
        pub struct FEEPRO1rs;
        impl crate::RegisterSpec for FEEPRO1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feepro1::R`](R) reader structure"]
        impl crate::Readable for FEEPRO1rs {}
        #[doc = "`write(|w| ..)` method takes [`feepro1::W`](W) writer structure"]
        impl crate::Writable for FEEPRO1rs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEPRO1 to value 0xffff_ffff"]
        impl crate::Resettable for FEEPRO1rs {
            const RESET_VALUE: u32 = 0xffff_ffff;
        }
    }
    #[doc = "FEESIG (rw) register accessor: Flash Signature\n\nYou can [`read`](crate::Reg::read) this register and get [`feesig::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feesig::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEESIG)\n\nFor information about available fields see [`mod@feesig`]
module"]
    pub type FEESIG = crate::Reg<feesig::FEESIGrs>;
    #[doc = "Flash Signature"]
    pub mod feesig {
        #[doc = "Register `FEESIG` reader"]
        pub type R = crate::R<FEESIGrs>;
        #[doc = "Register `FEESIG` writer"]
        pub type W = crate::W<FEESIGrs>;
        #[doc = "Field `Sign` reader - Signature"]
        pub type SIGN_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:23 - Signature"]
            #[inline(always)]
            pub fn sign(&self) -> SIGN_R {
                SIGN_R::new(self.bits & 0x00ff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEESIG")
                    .field("sign", &self.sign())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Flash Signature\n\nYou can [`read`](crate::Reg::read) this register and get [`feesig::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feesig::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEESIG)"]
        pub struct FEESIGrs;
        impl crate::RegisterSpec for FEESIGrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feesig::R`](R) reader structure"]
        impl crate::Readable for FEESIGrs {}
        #[doc = "`write(|w| ..)` method takes [`feesig::W`](W) writer structure"]
        impl crate::Writable for FEESIGrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEESIG to value 0"]
        impl crate::Resettable for FEESIGrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEECON1 (rw) register accessor: User Setup Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feecon1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feecon1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEECON1)\n\nFor information about available fields see [`mod@feecon1`]
module"]
    pub type FEECON1 = crate::Reg<feecon1::FEECON1rs>;
    #[doc = "User Setup Register"]
    pub mod feecon1 {
        #[doc = "Register `FEECON1` reader"]
        pub type R = crate::R<FEECON1rs>;
        #[doc = "Register `FEECON1` writer"]
        pub type W = crate::W<FEECON1rs>;
        #[doc = "Field `JtagDebugEn` reader - JTAG Debug Enable"]
        pub type JTAG_DEBUG_EN_R = crate::BitReader;
        #[doc = "Field `JtagDebugEn` writer - JTAG Debug Enable"]
        pub type JTAG_DEBUG_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `KHDMAEn` reader - Key - Hole DMA Enable."]
        pub type KHDMAEN_R = crate::BitReader;
        #[doc = "Field `KHDMAEn` writer - Key - Hole DMA Enable."]
        pub type KHDMAEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AutoIncrEn` reader - Auto Address Increment for Key Hole Access."]
        pub type AUTO_INCR_EN_R = crate::BitReader;
        #[doc = "Field `AutoIncrEn` writer - Auto Address Increment for Key Hole Access."]
        pub type AUTO_INCR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SwapProgramCode` reader - Swap Program Code for MDIO Mode."]
        pub type SWAP_PROGRAM_CODE_R = crate::BitReader;
        #[doc = "Field `SwapProgramCode` writer - Swap Program Code for MDIO Mode."]
        pub type SWAP_PROGRAM_CODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MDIOmode` reader - MDIO Mode"]
        pub type MDIOMODE_R = crate::BitReader;
        #[doc = "Field `SwapFlash0` reader - Swap Top and Bottom Image Inside Flash 0."]
        pub type SWAP_FLASH0_R = crate::BitReader;
        #[doc = "Field `SwapFlash0` writer - Swap Top and Bottom Image Inside Flash 0."]
        pub type SWAP_FLASH0_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SwapFlash1` reader - Swap Top and Bottom Image Inside Flash 1."]
        pub type SWAP_FLASH1_R = crate::BitReader;
        #[doc = "Field `SwapFlash1` writer - Swap Top and Bottom Image Inside Flash 1."]
        pub type SWAP_FLASH1_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SwapInFlashEn` reader - Swap Inside Flash Enable"]
        pub type SWAP_IN_FLASH_EN_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - JTAG Debug Enable"]
            #[inline(always)]
            pub fn jtag_debug_en(&self) -> JTAG_DEBUG_EN_R {
                JTAG_DEBUG_EN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Key - Hole DMA Enable."]
            #[inline(always)]
            pub fn khdmaen(&self) -> KHDMAEN_R {
                KHDMAEN_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Auto Address Increment for Key Hole Access."]
            #[inline(always)]
            pub fn auto_incr_en(&self) -> AUTO_INCR_EN_R {
                AUTO_INCR_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Swap Program Code for MDIO Mode."]
            #[inline(always)]
            pub fn swap_program_code(&self) -> SWAP_PROGRAM_CODE_R {
                SWAP_PROGRAM_CODE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - MDIO Mode"]
            #[inline(always)]
            pub fn mdiomode(&self) -> MDIOMODE_R {
                MDIOMODE_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Swap Top and Bottom Image Inside Flash 0."]
            #[inline(always)]
            pub fn swap_flash0(&self) -> SWAP_FLASH0_R {
                SWAP_FLASH0_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Swap Top and Bottom Image Inside Flash 1."]
            #[inline(always)]
            pub fn swap_flash1(&self) -> SWAP_FLASH1_R {
                SWAP_FLASH1_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - Swap Inside Flash Enable"]
            #[inline(always)]
            pub fn swap_in_flash_en(&self) -> SWAP_IN_FLASH_EN_R {
                SWAP_IN_FLASH_EN_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEECON1")
                    .field("jtag_debug_en", &self.jtag_debug_en())
                    .field("khdmaen", &self.khdmaen())
                    .field("auto_incr_en", &self.auto_incr_en())
                    .field("swap_program_code", &self.swap_program_code())
                    .field("mdiomode", &self.mdiomode())
                    .field("swap_flash0", &self.swap_flash0())
                    .field("swap_flash1", &self.swap_flash1())
                    .field("swap_in_flash_en", &self.swap_in_flash_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - JTAG Debug Enable"]
            #[inline(always)]
            pub fn jtag_debug_en(&mut self) -> JTAG_DEBUG_EN_W<FEECON1rs> {
                JTAG_DEBUG_EN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Key - Hole DMA Enable."]
            #[inline(always)]
            pub fn khdmaen(&mut self) -> KHDMAEN_W<FEECON1rs> {
                KHDMAEN_W::new(self, 1)
            }
            #[doc = "Bit 2 - Auto Address Increment for Key Hole Access."]
            #[inline(always)]
            pub fn auto_incr_en(&mut self) -> AUTO_INCR_EN_W<FEECON1rs> {
                AUTO_INCR_EN_W::new(self, 2)
            }
            #[doc = "Bit 3 - Swap Program Code for MDIO Mode."]
            #[inline(always)]
            pub fn swap_program_code(&mut self) -> SWAP_PROGRAM_CODE_W<FEECON1rs> {
                SWAP_PROGRAM_CODE_W::new(self, 3)
            }
            #[doc = "Bit 5 - Swap Top and Bottom Image Inside Flash 0."]
            #[inline(always)]
            pub fn swap_flash0(&mut self) -> SWAP_FLASH0_W<FEECON1rs> {
                SWAP_FLASH0_W::new(self, 5)
            }
            #[doc = "Bit 6 - Swap Top and Bottom Image Inside Flash 1."]
            #[inline(always)]
            pub fn swap_flash1(&mut self) -> SWAP_FLASH1_W<FEECON1rs> {
                SWAP_FLASH1_W::new(self, 6)
            }
        }
        #[doc = "User Setup Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feecon1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feecon1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEECON1)"]
        pub struct FEECON1rs;
        impl crate::RegisterSpec for FEECON1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feecon1::R`](R) reader structure"]
        impl crate::Readable for FEECON1rs {}
        #[doc = "`write(|w| ..)` method takes [`feecon1::W`](W) writer structure"]
        impl crate::Writable for FEECON1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEECON1 to value 0"]
        impl crate::Resettable for FEECON1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEWRADDRA (rw) register accessor: Write Abort Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feewraddra::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feewraddra::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEWRADDRA)\n\nFor information about available fields see [`mod@feewraddra`]
module"]
    pub type FEEWRADDRA = crate::Reg<feewraddra::FEEWRADDRArs>;
    #[doc = "Write Abort Address Register"]
    pub mod feewraddra {
        #[doc = "Register `FEEWRADDRA` reader"]
        pub type R = crate::R<FEEWRADDRArs>;
        #[doc = "Register `FEEWRADDRA` writer"]
        pub type W = crate::W<FEEWRADDRArs>;
        #[doc = "Field `WrAbortAddr` reader - Write Abort Address"]
        pub type WR_ABORT_ADDR_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - Write Abort Address"]
            #[inline(always)]
            pub fn wr_abort_addr(&self) -> WR_ABORT_ADDR_R {
                WR_ABORT_ADDR_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEWRADDRA")
                    .field("wr_abort_addr", &self.wr_abort_addr())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Write Abort Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`feewraddra::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feewraddra::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEWRADDRA)"]
        pub struct FEEWRADDRArs;
        impl crate::RegisterSpec for FEEWRADDRArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feewraddra::R`](R) reader structure"]
        impl crate::Readable for FEEWRADDRArs {}
        #[doc = "`write(|w| ..)` method takes [`feewraddra::W`](W) writer structure"]
        impl crate::Writable for FEEWRADDRArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEWRADDRA to value 0"]
        impl crate::Resettable for FEEWRADDRArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEAEN0 (rw) register accessor: Lower 32 Bits of the Sys Irq Abort Enable Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`feeaen0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeaen0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEAEN0)\n\nFor information about available fields see [`mod@feeaen0`]
module"]
    pub type FEEAEN0 = crate::Reg<feeaen0::FEEAEN0rs>;
    #[doc = "Lower 32 Bits of the Sys Irq Abort Enable Register."]
    pub mod feeaen0 {
        #[doc = "Register `FEEAEN0` reader"]
        pub type R = crate::R<FEEAEN0rs>;
        #[doc = "Register `FEEAEN0` writer"]
        pub type W = crate::W<FEEAEN0rs>;
        #[doc = "Field `SysIrqAbortEn` reader - Lower 32 Bits of System Interrupt Abort Enable."]
        pub type SYS_IRQ_ABORT_EN_R = crate::FieldReader<u32>;
        #[doc = "Field `SysIrqAbortEn` writer - Lower 32 Bits of System Interrupt Abort Enable."]
        pub type SYS_IRQ_ABORT_EN_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Lower 32 Bits of System Interrupt Abort Enable."]
            #[inline(always)]
            pub fn sys_irq_abort_en(&self) -> SYS_IRQ_ABORT_EN_R {
                SYS_IRQ_ABORT_EN_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEAEN0")
                    .field("sys_irq_abort_en", &self.sys_irq_abort_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Lower 32 Bits of System Interrupt Abort Enable."]
            #[inline(always)]
            pub fn sys_irq_abort_en(&mut self) -> SYS_IRQ_ABORT_EN_W<FEEAEN0rs> {
                SYS_IRQ_ABORT_EN_W::new(self, 0)
            }
        }
        #[doc = "Lower 32 Bits of the Sys Irq Abort Enable Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`feeaen0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeaen0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEAEN0)"]
        pub struct FEEAEN0rs;
        impl crate::RegisterSpec for FEEAEN0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeaen0::R`](R) reader structure"]
        impl crate::Readable for FEEAEN0rs {}
        #[doc = "`write(|w| ..)` method takes [`feeaen0::W`](W) writer structure"]
        impl crate::Writable for FEEAEN0rs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEAEN0 to value 0"]
        impl crate::Resettable for FEEAEN0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEAEN1 (rw) register accessor: Middle 32 Bits of the Sys Irq Abort Enable Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`feeaen1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeaen1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEAEN1)\n\nFor information about available fields see [`mod@feeaen1`]
module"]
    pub type FEEAEN1 = crate::Reg<feeaen1::FEEAEN1rs>;
    #[doc = "Middle 32 Bits of the Sys Irq Abort Enable Register."]
    pub mod feeaen1 {
        #[doc = "Register `FEEAEN1` reader"]
        pub type R = crate::R<FEEAEN1rs>;
        #[doc = "Register `FEEAEN1` writer"]
        pub type W = crate::W<FEEAEN1rs>;
        #[doc = "Field `SysIrqAbortEn` reader - Middle 32 Bits of System Interrupt Abort Enable."]
        pub type SYS_IRQ_ABORT_EN_R = crate::FieldReader<u32>;
        #[doc = "Field `SysIrqAbortEn` writer - Middle 32 Bits of System Interrupt Abort Enable."]
        pub type SYS_IRQ_ABORT_EN_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Middle 32 Bits of System Interrupt Abort Enable."]
            #[inline(always)]
            pub fn sys_irq_abort_en(&self) -> SYS_IRQ_ABORT_EN_R {
                SYS_IRQ_ABORT_EN_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEAEN1")
                    .field("sys_irq_abort_en", &self.sys_irq_abort_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Middle 32 Bits of System Interrupt Abort Enable."]
            #[inline(always)]
            pub fn sys_irq_abort_en(&mut self) -> SYS_IRQ_ABORT_EN_W<FEEAEN1rs> {
                SYS_IRQ_ABORT_EN_W::new(self, 0)
            }
        }
        #[doc = "Middle 32 Bits of the Sys Irq Abort Enable Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`feeaen1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeaen1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEAEN1)"]
        pub struct FEEAEN1rs;
        impl crate::RegisterSpec for FEEAEN1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeaen1::R`](R) reader structure"]
        impl crate::Readable for FEEAEN1rs {}
        #[doc = "`write(|w| ..)` method takes [`feeaen1::W`](W) writer structure"]
        impl crate::Writable for FEEAEN1rs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEAEN1 to value 0"]
        impl crate::Resettable for FEEAEN1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEAEN2 (rw) register accessor: Upper 32 Bits of the Sys Irq Abort Enable Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`feeaen2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeaen2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEAEN2)\n\nFor information about available fields see [`mod@feeaen2`]
module"]
    pub type FEEAEN2 = crate::Reg<feeaen2::FEEAEN2rs>;
    #[doc = "Upper 32 Bits of the Sys Irq Abort Enable Register."]
    pub mod feeaen2 {
        #[doc = "Register `FEEAEN2` reader"]
        pub type R = crate::R<FEEAEN2rs>;
        #[doc = "Register `FEEAEN2` writer"]
        pub type W = crate::W<FEEAEN2rs>;
        #[doc = "Field `SysIrqAbortEn` reader - Upper 32 Bits of System Interrupt Abort Enable."]
        pub type SYS_IRQ_ABORT_EN_R = crate::FieldReader<u32>;
        #[doc = "Field `SysIrqAbortEn` writer - Upper 32 Bits of System Interrupt Abort Enable."]
        pub type SYS_IRQ_ABORT_EN_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - Upper 32 Bits of System Interrupt Abort Enable."]
            #[inline(always)]
            pub fn sys_irq_abort_en(&self) -> SYS_IRQ_ABORT_EN_R {
                SYS_IRQ_ABORT_EN_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEAEN2")
                    .field("sys_irq_abort_en", &self.sys_irq_abort_en())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Upper 32 Bits of System Interrupt Abort Enable."]
            #[inline(always)]
            pub fn sys_irq_abort_en(&mut self) -> SYS_IRQ_ABORT_EN_W<FEEAEN2rs> {
                SYS_IRQ_ABORT_EN_W::new(self, 0)
            }
        }
        #[doc = "Upper 32 Bits of the Sys Irq Abort Enable Register.\n\nYou can [`read`](crate::Reg::read) this register and get [`feeaen2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeaen2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEAEN2)"]
        pub struct FEEAEN2rs;
        impl crate::RegisterSpec for FEEAEN2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeaen2::R`](R) reader structure"]
        impl crate::Readable for FEEAEN2rs {}
        #[doc = "`write(|w| ..)` method takes [`feeaen2::W`](W) writer structure"]
        impl crate::Writable for FEEAEN2rs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEAEN2 to value 0"]
        impl crate::Resettable for FEEAEN2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEECCCONFIG (rw) register accessor: Configurable ECC Enable/disable, Error Response\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccconfig::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccconfig::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCCONFIG)\n\nFor information about available fields see [`mod@feeeccconfig`]
module"]
    pub type FEEECCCONFIG = crate::Reg<feeeccconfig::FEEECCCONFIGrs>;
    #[doc = "Configurable ECC Enable/disable, Error Response"]
    pub mod feeeccconfig {
        #[doc = "Register `FEEECCCONFIG` reader"]
        pub type R = crate::R<FEEECCCONFIGrs>;
        #[doc = "Register `FEEECCCONFIG` writer"]
        pub type W = crate::W<FEEECCCONFIGrs>;
        #[doc = "Field `ECCDisable` reader - ECC Disable Bit."]
        pub type ECCDISABLE_R = crate::BitReader;
        #[doc = "Field `ECCDisable` writer - ECC Disable Bit."]
        pub type ECCDISABLE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Signifies How to Generate AHB Error on ECC\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCAHBERROR {
            #[doc = "0: AHB Error (HRESP = 1) is Not Generated Even If There is an ECC Error While Reading from Flash via AHB. This Applies to Both Flash."]
            NoError = 0,
            #[doc = "1: AHB Error (HRESP = 1) is Generated Only If 2 Bit Error is Detected During AHB Read to Flash 0 or 1."]
            Error2bit = 1,
            #[doc = "2: AHB Error (HRESP = 1) is Generated Only If 1 Bit Error Corrected During AHB Read to Flash 0 or 1"]
            Error1bit = 2,
            #[doc = "3: AHB Error (HRESP = 1) is Generated If Either 2 Bit Detected or 1 Bit Error Corrected During AHB Read to Flash 0 or 1"]
            Error1or2bit = 3,
        }
        impl From<ECCAHBERROR> for u8 {
            #[inline(always)]
            fn from(variant: ECCAHBERROR) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCAHBERROR {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCAHBERROR {}
        #[doc = "Field `ECCAHBERROR` reader - Signifies How to Generate AHB Error on ECC"]
        pub type ECCAHBERROR_R = crate::FieldReader<ECCAHBERROR>;
        impl ECCAHBERROR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCAHBERROR {
                match self.bits {
                    0 => ECCAHBERROR::NoError,
                    1 => ECCAHBERROR::Error2bit,
                    2 => ECCAHBERROR::Error1bit,
                    3 => ECCAHBERROR::Error1or2bit,
                    _ => unreachable!(),
                }
            }
            #[doc = "AHB Error (HRESP = 1) is Not Generated Even If There is an ECC Error While Reading from Flash via AHB. This Applies to Both Flash."]
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == ECCAHBERROR::NoError
            }
            #[doc = "AHB Error (HRESP = 1) is Generated Only If 2 Bit Error is Detected During AHB Read to Flash 0 or 1."]
            #[inline(always)]
            pub fn is_error2bit(&self) -> bool {
                *self == ECCAHBERROR::Error2bit
            }
            #[doc = "AHB Error (HRESP = 1) is Generated Only If 1 Bit Error Corrected During AHB Read to Flash 0 or 1"]
            #[inline(always)]
            pub fn is_error1bit(&self) -> bool {
                *self == ECCAHBERROR::Error1bit
            }
            #[doc = "AHB Error (HRESP = 1) is Generated If Either 2 Bit Detected or 1 Bit Error Corrected During AHB Read to Flash 0 or 1"]
            #[inline(always)]
            pub fn is_error1or2bit(&self) -> bool {
                *self == ECCAHBERROR::Error1or2bit
            }
        }
        #[doc = "Field `ECCAHBERROR` writer - Signifies How to Generate AHB Error on ECC"]
        pub type ECCAHBERROR_W<'a, REG> = crate::FieldWriter<'a, REG, 2, ECCAHBERROR, crate::Safe>;
        impl<'a, REG> ECCAHBERROR_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "AHB Error (HRESP = 1) is Not Generated Even If There is an ECC Error While Reading from Flash via AHB. This Applies to Both Flash."]
            #[inline(always)]
            pub fn no_error(self) -> &'a mut crate::W<REG> {
                self.variant(ECCAHBERROR::NoError)
            }
            #[doc = "AHB Error (HRESP = 1) is Generated Only If 2 Bit Error is Detected During AHB Read to Flash 0 or 1."]
            #[inline(always)]
            pub fn error2bit(self) -> &'a mut crate::W<REG> {
                self.variant(ECCAHBERROR::Error2bit)
            }
            #[doc = "AHB Error (HRESP = 1) is Generated Only If 1 Bit Error Corrected During AHB Read to Flash 0 or 1"]
            #[inline(always)]
            pub fn error1bit(self) -> &'a mut crate::W<REG> {
                self.variant(ECCAHBERROR::Error1bit)
            }
            #[doc = "AHB Error (HRESP = 1) is Generated If Either 2 Bit Detected or 1 Bit Error Corrected During AHB Read to Flash 0 or 1"]
            #[inline(always)]
            pub fn error1or2bit(self) -> &'a mut crate::W<REG> {
                self.variant(ECCAHBERROR::Error1or2bit)
            }
        }
        #[doc = "Interrupt Enable When a ECC Error Happens During an AHB Read\n\nValue on reset: 2"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCINTR_ERROR {
            #[doc = "0: Interrupt is Not Generated Even If There is an ECC Error While Reading from Flash via AHB. This Applies to Both Flash."]
            Disable = 0,
            #[doc = "1: Interrupt is Generated Only If 2 Bit Error is Detected During AHB Read to Flash 0 or 1."]
            Error2bitEn = 1,
            #[doc = "2: Interrupt is Generated Only If 1 Bit Error Corrected During AHB Read to Flash 0 or 1."]
            Error1bitEn = 2,
            #[doc = "3: Interrupt is Generated If Either 2 Bit Detected or 1 Bit Error Corrected During AHB Read to Flash 0 or 1."]
            Error1or2bitEn = 3,
        }
        impl From<ECCINTR_ERROR> for u8 {
            #[inline(always)]
            fn from(variant: ECCINTR_ERROR) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCINTR_ERROR {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCINTR_ERROR {}
        #[doc = "Field `ECCIntrERROR` reader - Interrupt Enable When a ECC Error Happens During an AHB Read"]
        pub type ECCINTR_ERROR_R = crate::FieldReader<ECCINTR_ERROR>;
        impl ECCINTR_ERROR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCINTR_ERROR {
                match self.bits {
                    0 => ECCINTR_ERROR::Disable,
                    1 => ECCINTR_ERROR::Error2bitEn,
                    2 => ECCINTR_ERROR::Error1bitEn,
                    3 => ECCINTR_ERROR::Error1or2bitEn,
                    _ => unreachable!(),
                }
            }
            #[doc = "Interrupt is Not Generated Even If There is an ECC Error While Reading from Flash via AHB. This Applies to Both Flash."]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == ECCINTR_ERROR::Disable
            }
            #[doc = "Interrupt is Generated Only If 2 Bit Error is Detected During AHB Read to Flash 0 or 1."]
            #[inline(always)]
            pub fn is_error2bit_en(&self) -> bool {
                *self == ECCINTR_ERROR::Error2bitEn
            }
            #[doc = "Interrupt is Generated Only If 1 Bit Error Corrected During AHB Read to Flash 0 or 1."]
            #[inline(always)]
            pub fn is_error1bit_en(&self) -> bool {
                *self == ECCINTR_ERROR::Error1bitEn
            }
            #[doc = "Interrupt is Generated If Either 2 Bit Detected or 1 Bit Error Corrected During AHB Read to Flash 0 or 1."]
            #[inline(always)]
            pub fn is_error1or2bit_en(&self) -> bool {
                *self == ECCINTR_ERROR::Error1or2bitEn
            }
        }
        #[doc = "Field `ECCIntrERROR` writer - Interrupt Enable When a ECC Error Happens During an AHB Read"]
        pub type ECCINTR_ERROR_W<'a, REG> =
            crate::FieldWriter<'a, REG, 2, ECCINTR_ERROR, crate::Safe>;
        impl<'a, REG> ECCINTR_ERROR_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Interrupt is Not Generated Even If There is an ECC Error While Reading from Flash via AHB. This Applies to Both Flash."]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(ECCINTR_ERROR::Disable)
            }
            #[doc = "Interrupt is Generated Only If 2 Bit Error is Detected During AHB Read to Flash 0 or 1."]
            #[inline(always)]
            pub fn error2bit_en(self) -> &'a mut crate::W<REG> {
                self.variant(ECCINTR_ERROR::Error2bitEn)
            }
            #[doc = "Interrupt is Generated Only If 1 Bit Error Corrected During AHB Read to Flash 0 or 1."]
            #[inline(always)]
            pub fn error1bit_en(self) -> &'a mut crate::W<REG> {
                self.variant(ECCINTR_ERROR::Error1bitEn)
            }
            #[doc = "Interrupt is Generated If Either 2 Bit Detected or 1 Bit Error Corrected During AHB Read to Flash 0 or 1."]
            #[inline(always)]
            pub fn error1or2bit_en(self) -> &'a mut crate::W<REG> {
                self.variant(ECCINTR_ERROR::Error1or2bitEn)
            }
        }
        #[doc = "ECC Error Address Control Bit.\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ECCADDR_CON {
            #[doc = "0: ECC Error Address Register Can't Be Cleared Until Reset; Current ECC Error Address Will Be Returned Directly When Reading ECC_ADDR MMR."]
            NbufNclr = 0,
            #[doc = "1: ECC Error Address Register Can't Be Cleared Until Reset; ECC Error Address is Latched on Read of STATUS MMR, and It Will Be Returned When Reading ECC_ADDR MMR."]
            BufNclr = 1,
            #[doc = "2: Previous ECC Error Address Register is Cleared on Read of STATUS MMR; ECC Error Address is Latched on Read of STATUS MMR, and It Will Be Returned When Reading ECC_ADDR MMR."]
            BufClr2 = 2,
            #[doc = "3: Previous ECC Error Address Register is Cleared on Read of STATUS MMR; ECC Error Address is Latched on Read of STATUS MMR, and It Will Be Returned When Reading ECC_ADDR MMR."]
            BufClr3 = 3,
        }
        impl From<ECCADDR_CON> for u8 {
            #[inline(always)]
            fn from(variant: ECCADDR_CON) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ECCADDR_CON {
            type Ux = u8;
        }
        impl crate::IsEnum for ECCADDR_CON {}
        #[doc = "Field `ECCAddrCon` reader - ECC Error Address Control Bit."]
        pub type ECCADDR_CON_R = crate::FieldReader<ECCADDR_CON>;
        impl ECCADDR_CON_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ECCADDR_CON {
                match self.bits {
                    0 => ECCADDR_CON::NbufNclr,
                    1 => ECCADDR_CON::BufNclr,
                    2 => ECCADDR_CON::BufClr2,
                    3 => ECCADDR_CON::BufClr3,
                    _ => unreachable!(),
                }
            }
            #[doc = "ECC Error Address Register Can't Be Cleared Until Reset; Current ECC Error Address Will Be Returned Directly When Reading ECC_ADDR MMR."]
            #[inline(always)]
            pub fn is_nbuf_nclr(&self) -> bool {
                *self == ECCADDR_CON::NbufNclr
            }
            #[doc = "ECC Error Address Register Can't Be Cleared Until Reset; ECC Error Address is Latched on Read of STATUS MMR, and It Will Be Returned When Reading ECC_ADDR MMR."]
            #[inline(always)]
            pub fn is_buf_nclr(&self) -> bool {
                *self == ECCADDR_CON::BufNclr
            }
            #[doc = "Previous ECC Error Address Register is Cleared on Read of STATUS MMR; ECC Error Address is Latched on Read of STATUS MMR, and It Will Be Returned When Reading ECC_ADDR MMR."]
            #[inline(always)]
            pub fn is_buf_clr2(&self) -> bool {
                *self == ECCADDR_CON::BufClr2
            }
            #[doc = "Previous ECC Error Address Register is Cleared on Read of STATUS MMR; ECC Error Address is Latched on Read of STATUS MMR, and It Will Be Returned When Reading ECC_ADDR MMR."]
            #[inline(always)]
            pub fn is_buf_clr3(&self) -> bool {
                *self == ECCADDR_CON::BufClr3
            }
        }
        #[doc = "Field `ECCAddrCon` writer - ECC Error Address Control Bit."]
        pub type ECCADDR_CON_W<'a, REG> = crate::FieldWriter<'a, REG, 2, ECCADDR_CON, crate::Safe>;
        impl<'a, REG> ECCADDR_CON_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "ECC Error Address Register Can't Be Cleared Until Reset; Current ECC Error Address Will Be Returned Directly When Reading ECC_ADDR MMR."]
            #[inline(always)]
            pub fn nbuf_nclr(self) -> &'a mut crate::W<REG> {
                self.variant(ECCADDR_CON::NbufNclr)
            }
            #[doc = "ECC Error Address Register Can't Be Cleared Until Reset; ECC Error Address is Latched on Read of STATUS MMR, and It Will Be Returned When Reading ECC_ADDR MMR."]
            #[inline(always)]
            pub fn buf_nclr(self) -> &'a mut crate::W<REG> {
                self.variant(ECCADDR_CON::BufNclr)
            }
            #[doc = "Previous ECC Error Address Register is Cleared on Read of STATUS MMR; ECC Error Address is Latched on Read of STATUS MMR, and It Will Be Returned When Reading ECC_ADDR MMR."]
            #[inline(always)]
            pub fn buf_clr2(self) -> &'a mut crate::W<REG> {
                self.variant(ECCADDR_CON::BufClr2)
            }
            #[doc = "Previous ECC Error Address Register is Cleared on Read of STATUS MMR; ECC Error Address is Latched on Read of STATUS MMR, and It Will Be Returned When Reading ECC_ADDR MMR."]
            #[inline(always)]
            pub fn buf_clr3(self) -> &'a mut crate::W<REG> {
                self.variant(ECCADDR_CON::BufClr3)
            }
        }
        impl R {
            #[doc = "Bit 0 - ECC Disable Bit."]
            #[inline(always)]
            pub fn eccdisable(&self) -> ECCDISABLE_R {
                ECCDISABLE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:2 - Signifies How to Generate AHB Error on ECC"]
            #[inline(always)]
            pub fn eccahberror(&self) -> ECCAHBERROR_R {
                ECCAHBERROR_R::new(((self.bits >> 1) & 3) as u8)
            }
            #[doc = "Bits 3:4 - Interrupt Enable When a ECC Error Happens During an AHB Read"]
            #[inline(always)]
            pub fn eccintr_error(&self) -> ECCINTR_ERROR_R {
                ECCINTR_ERROR_R::new(((self.bits >> 3) & 3) as u8)
            }
            #[doc = "Bits 5:6 - ECC Error Address Control Bit."]
            #[inline(always)]
            pub fn eccaddr_con(&self) -> ECCADDR_CON_R {
                ECCADDR_CON_R::new(((self.bits >> 5) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEECCCONFIG")
                    .field("eccdisable", &self.eccdisable())
                    .field("eccahberror", &self.eccahberror())
                    .field("eccintr_error", &self.eccintr_error())
                    .field("eccaddr_con", &self.eccaddr_con())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - ECC Disable Bit."]
            #[inline(always)]
            pub fn eccdisable(&mut self) -> ECCDISABLE_W<FEEECCCONFIGrs> {
                ECCDISABLE_W::new(self, 0)
            }
            #[doc = "Bits 1:2 - Signifies How to Generate AHB Error on ECC"]
            #[inline(always)]
            pub fn eccahberror(&mut self) -> ECCAHBERROR_W<FEEECCCONFIGrs> {
                ECCAHBERROR_W::new(self, 1)
            }
            #[doc = "Bits 3:4 - Interrupt Enable When a ECC Error Happens During an AHB Read"]
            #[inline(always)]
            pub fn eccintr_error(&mut self) -> ECCINTR_ERROR_W<FEEECCCONFIGrs> {
                ECCINTR_ERROR_W::new(self, 3)
            }
            #[doc = "Bits 5:6 - ECC Error Address Control Bit."]
            #[inline(always)]
            pub fn eccaddr_con(&mut self) -> ECCADDR_CON_W<FEEECCCONFIGrs> {
                ECCADDR_CON_W::new(self, 5)
            }
        }
        #[doc = "Configurable ECC Enable/disable, Error Response\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccconfig::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccconfig::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCCONFIG)"]
        pub struct FEEECCCONFIGrs;
        impl crate::RegisterSpec for FEEECCCONFIGrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeeccconfig::R`](R) reader structure"]
        impl crate::Readable for FEEECCCONFIGrs {}
        #[doc = "`write(|w| ..)` method takes [`feeeccconfig::W`](W) writer structure"]
        impl crate::Writable for FEEECCCONFIGrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEECCCONFIG to value 0x12"]
        impl crate::Resettable for FEEECCCONFIGrs {
            const RESET_VALUE: u32 = 0x12;
        }
    }
    #[doc = "FEEECCADDRC0 (rw) register accessor: Flash 0 ECC Error Address via CODE Bus\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccaddrc0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccaddrc0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCADDRC0)\n\nFor information about available fields see [`mod@feeeccaddrc0`]
module"]
    pub type FEEECCADDRC0 = crate::Reg<feeeccaddrc0::FEEECCADDRC0rs>;
    #[doc = "Flash 0 ECC Error Address via CODE Bus"]
    pub mod feeeccaddrc0 {
        #[doc = "Register `FEEECCADDRC0` reader"]
        pub type R = crate::R<FEEECCADDRC0rs>;
        #[doc = "Register `FEEECCADDRC0` writer"]
        pub type W = crate::W<FEEECCADDRC0rs>;
        #[doc = "Field `FLECCAddrC0` reader - Flash0 Address for Which ECC Error is Detected via CODE Bus."]
        pub type FLECCADDR_C0_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:20 - Flash0 Address for Which ECC Error is Detected via CODE Bus."]
            #[inline(always)]
            pub fn fleccaddr_c0(&self) -> FLECCADDR_C0_R {
                FLECCADDR_C0_R::new(self.bits & 0x001f_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEECCADDRC0")
                    .field("fleccaddr_c0", &self.fleccaddr_c0())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Flash 0 ECC Error Address via CODE Bus\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccaddrc0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccaddrc0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCADDRC0)"]
        pub struct FEEECCADDRC0rs;
        impl crate::RegisterSpec for FEEECCADDRC0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeeccaddrc0::R`](R) reader structure"]
        impl crate::Readable for FEEECCADDRC0rs {}
        #[doc = "`write(|w| ..)` method takes [`feeeccaddrc0::W`](W) writer structure"]
        impl crate::Writable for FEEECCADDRC0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEECCADDRC0 to value 0"]
        impl crate::Resettable for FEEECCADDRC0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEECCADDRC1 (rw) register accessor: Flash 1 ECC Error Address via CODE Bus\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccaddrc1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccaddrc1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCADDRC1)\n\nFor information about available fields see [`mod@feeeccaddrc1`]
module"]
    pub type FEEECCADDRC1 = crate::Reg<feeeccaddrc1::FEEECCADDRC1rs>;
    #[doc = "Flash 1 ECC Error Address via CODE Bus"]
    pub mod feeeccaddrc1 {
        #[doc = "Register `FEEECCADDRC1` reader"]
        pub type R = crate::R<FEEECCADDRC1rs>;
        #[doc = "Register `FEEECCADDRC1` writer"]
        pub type W = crate::W<FEEECCADDRC1rs>;
        #[doc = "Field `FLECCAddrC1` reader - Flash1 Address for Which ECC Error is Detected via CODE Bus."]
        pub type FLECCADDR_C1_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:20 - Flash1 Address for Which ECC Error is Detected via CODE Bus."]
            #[inline(always)]
            pub fn fleccaddr_c1(&self) -> FLECCADDR_C1_R {
                FLECCADDR_C1_R::new(self.bits & 0x001f_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEECCADDRC1")
                    .field("fleccaddr_c1", &self.fleccaddr_c1())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Flash 1 ECC Error Address via CODE Bus\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccaddrc1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccaddrc1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCADDRC1)"]
        pub struct FEEECCADDRC1rs;
        impl crate::RegisterSpec for FEEECCADDRC1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeeccaddrc1::R`](R) reader structure"]
        impl crate::Readable for FEEECCADDRC1rs {}
        #[doc = "`write(|w| ..)` method takes [`feeeccaddrc1::W`](W) writer structure"]
        impl crate::Writable for FEEECCADDRC1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEECCADDRC1 to value 0"]
        impl crate::Resettable for FEEECCADDRC1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEECCADDRD0 (rw) register accessor: Flash 0 ECC Error Address via DMA Bus\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccaddrd0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccaddrd0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCADDRD0)\n\nFor information about available fields see [`mod@feeeccaddrd0`]
module"]
    pub type FEEECCADDRD0 = crate::Reg<feeeccaddrd0::FEEECCADDRD0rs>;
    #[doc = "Flash 0 ECC Error Address via DMA Bus"]
    pub mod feeeccaddrd0 {
        #[doc = "Register `FEEECCADDRD0` reader"]
        pub type R = crate::R<FEEECCADDRD0rs>;
        #[doc = "Register `FEEECCADDRD0` writer"]
        pub type W = crate::W<FEEECCADDRD0rs>;
        #[doc = "Field `FLECCAddrD0` reader - Flash0 Address for Which ECC Error is Detected via DMA Bus."]
        pub type FLECCADDR_D0_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:20 - Flash0 Address for Which ECC Error is Detected via DMA Bus."]
            #[inline(always)]
            pub fn fleccaddr_d0(&self) -> FLECCADDR_D0_R {
                FLECCADDR_D0_R::new(self.bits & 0x001f_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEECCADDRD0")
                    .field("fleccaddr_d0", &self.fleccaddr_d0())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Flash 0 ECC Error Address via DMA Bus\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccaddrd0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccaddrd0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCADDRD0)"]
        pub struct FEEECCADDRD0rs;
        impl crate::RegisterSpec for FEEECCADDRD0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeeccaddrd0::R`](R) reader structure"]
        impl crate::Readable for FEEECCADDRD0rs {}
        #[doc = "`write(|w| ..)` method takes [`feeeccaddrd0::W`](W) writer structure"]
        impl crate::Writable for FEEECCADDRD0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEECCADDRD0 to value 0"]
        impl crate::Resettable for FEEECCADDRD0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FEEECCADDRD1 (rw) register accessor: Flash 1 ECC Error Address via DMA Bus\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccaddrd1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccaddrd1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCADDRD1)\n\nFor information about available fields see [`mod@feeeccaddrd1`]
module"]
    pub type FEEECCADDRD1 = crate::Reg<feeeccaddrd1::FEEECCADDRD1rs>;
    #[doc = "Flash 1 ECC Error Address via DMA Bus"]
    pub mod feeeccaddrd1 {
        #[doc = "Register `FEEECCADDRD1` reader"]
        pub type R = crate::R<FEEECCADDRD1rs>;
        #[doc = "Register `FEEECCADDRD1` writer"]
        pub type W = crate::W<FEEECCADDRD1rs>;
        #[doc = "Field `FLECCAddrD1` reader - Flash1 Address for Which ECC Error is Detected via DMA Bus."]
        pub type FLECCADDR_D1_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:20 - Flash1 Address for Which ECC Error is Detected via DMA Bus."]
            #[inline(always)]
            pub fn fleccaddr_d1(&self) -> FLECCADDR_D1_R {
                FLECCADDR_D1_R::new(self.bits & 0x001f_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FEEECCADDRD1")
                    .field("fleccaddr_d1", &self.fleccaddr_d1())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Flash 1 ECC Error Address via DMA Bus\n\nYou can [`read`](crate::Reg::read) this register and get [`feeeccaddrd1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`feeeccaddrd1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#FLASH:FEEECCADDRD1)"]
        pub struct FEEECCADDRD1rs;
        impl crate::RegisterSpec for FEEECCADDRD1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`feeeccaddrd1::R`](R) reader structure"]
        impl crate::Readable for FEEECCADDRD1rs {}
        #[doc = "`write(|w| ..)` method takes [`feeeccaddrd1::W`](W) writer structure"]
        impl crate::Writable for FEEECCADDRD1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FEEECCADDRD1 to value 0"]
        impl crate::Resettable for FEEECCADDRD1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO)"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4005_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "Unknown"]
pub mod gpio {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        gp0con: GP0CON,
        gp0oe: GP0OE,
        gp0ie: GP0IE,
        gp0in: GP0IN,
        gp0out: GP0OUT,
        gp0set: GP0SET,
        gp0clr: GP0CLR,
        gp0tgl: GP0TGL,
        gp0ode: GP0ODE,
        gp0is: GP0IS,
        gp0pe: GP0PE,
        gp0ps: GP0PS,
        gp0sr: GP0SR,
        gp0ds: GP0DS,
        gp0pwr: GP0PWR,
        gp0pol: GP0POL,
        gp0iena: GP0IENA,
        gp0ienb: GP0IENB,
        gp0int: GP0INT,
        _reserved19: [u8; 0x04],
        gp1con: GP1CON,
        gp1oe: GP1OE,
        gp1ie: GP1IE,
        gp1in: GP1IN,
        gp1out: GP1OUT,
        gp1set: GP1SET,
        gp1clr: GP1CLR,
        gp1tgl: GP1TGL,
        gp1ode: GP1ODE,
        gp1is: GP1IS,
        gp1pe: GP1PE,
        gp1ps: GP1PS,
        gp1sr: GP1SR,
        gp1ds: GP1DS,
        gp1pwr: GP1PWR,
        gp1pol: GP1POL,
        gp1iena: GP1IENA,
        gp1ienb: GP1IENB,
        gp1int: GP1INT,
        _reserved38: [u8; 0x04],
        gp2con: GP2CON,
        gp2oe: GP2OE,
        gp2ie: GP2IE,
        gp2in: GP2IN,
        gp2out: GP2OUT,
        gp2set: GP2SET,
        gp2clr: GP2CLR,
        gp2tgl: GP2TGL,
        gp2ode: GP2ODE,
        gp2is: GP2IS,
        gp2pe: GP2PE,
        gp2ps: GP2PS,
        gp2sr: GP2SR,
        gp2ds: GP2DS,
        _reserved52: [u8; 0x04],
        gp2pol: GP2POL,
        gp2iena: GP2IENA,
        gp2ienb: GP2IENB,
        gp2int: GP2INT,
        _reserved56: [u8; 0x04],
        gp3con: GP3CON,
        gp3oe: GP3OE,
        gp3ie: GP3IE,
        gp3in: GP3IN,
        gp3out: GP3OUT,
        gp3set: GP3SET,
        gp3clr: GP3CLR,
        gp3tgl: GP3TGL,
        gp3ode: GP3ODE,
        gp3is: GP3IS,
        gp3pe: GP3PE,
        gp3ps: GP3PS,
        gp3sr: GP3SR,
        gp3ds: GP3DS,
        _reserved70: [u8; 0x04],
        gp3pol: GP3POL,
        gp3iena: GP3IENA,
        gp3ienb: GP3IENB,
        gp3int: GP3INT,
        _reserved74: [u8; 0x04],
        gp4con: GP4CON,
        gp4oe: GP4OE,
        gp4ie: GP4IE,
        gp4in: GP4IN,
        gp4out: GP4OUT,
        gp4set: GP4SET,
        gp4clr: GP4CLR,
        gp4tgl: GP4TGL,
        gp4ode: GP4ODE,
        gp4is: GP4IS,
        gp4pe: GP4PE,
        gp4ps: GP4PS,
        gp4sr: GP4SR,
        gp4ds: GP4DS,
        _reserved88: [u8; 0x04],
        gp4pol: GP4POL,
        gp4iena: GP4IENA,
        gp4ienb: GP4IENB,
        gp4int: GP4INT,
        _reserved92: [u8; 0x04],
        gp5con: GP5CON,
        gp5oe: GP5OE,
        gp5ie: GP5IE,
        gp5in: GP5IN,
        gp5out: GP5OUT,
        gp5set: GP5SET,
        gp5clr: GP5CLR,
        gp5tgl: GP5TGL,
        gp5ode: GP5ODE,
        gp5is: GP5IS,
        gp5pe: GP5PE,
        gp5ps: GP5PS,
        gp5sr: GP5SR,
        gp5ds: GP5DS,
        _reserved106: [u8; 0x04],
        gp5pol: GP5POL,
        gp5iena: GP5IENA,
        gp5ienb: GP5IENB,
        gp5int: GP5INT,
    }
    impl RegisterBlock {
        #[doc = "0x00 - GPIO Port 0 Configuration"]
        #[inline(always)]
        pub const fn gp0con(&self) -> &GP0CON {
            &self.gp0con
        }
        #[doc = "0x04 - GPIO Port 0 Output Enable"]
        #[inline(always)]
        pub const fn gp0oe(&self) -> &GP0OE {
            &self.gp0oe
        }
        #[doc = "0x08 - GPIO Port 0 Input Path Enable"]
        #[inline(always)]
        pub const fn gp0ie(&self) -> &GP0IE {
            &self.gp0ie
        }
        #[doc = "0x0c - GPIO Port 0 Registered Data Input"]
        #[inline(always)]
        pub const fn gp0in(&self) -> &GP0IN {
            &self.gp0in
        }
        #[doc = "0x10 - GPIO Port 0 Data Output"]
        #[inline(always)]
        pub const fn gp0out(&self) -> &GP0OUT {
            &self.gp0out
        }
        #[doc = "0x14 - GPIO Port 0 Data Out Set"]
        #[inline(always)]
        pub const fn gp0set(&self) -> &GP0SET {
            &self.gp0set
        }
        #[doc = "0x18 - GPIO Port 0 Data Out Clear"]
        #[inline(always)]
        pub const fn gp0clr(&self) -> &GP0CLR {
            &self.gp0clr
        }
        #[doc = "0x1c - GPIO Port 0 Pin Toggle"]
        #[inline(always)]
        pub const fn gp0tgl(&self) -> &GP0TGL {
            &self.gp0tgl
        }
        #[doc = "0x20 - GPIO Port 0 Open Drain Enable"]
        #[inline(always)]
        pub const fn gp0ode(&self) -> &GP0ODE {
            &self.gp0ode
        }
        #[doc = "0x24 - GPIO Port 0 Input Select"]
        #[inline(always)]
        pub const fn gp0is(&self) -> &GP0IS {
            &self.gp0is
        }
        #[doc = "0x28 - GPIO Port 0 Pull Enable"]
        #[inline(always)]
        pub const fn gp0pe(&self) -> &GP0PE {
            &self.gp0pe
        }
        #[doc = "0x2c - GPIO Port 0 Pull Select"]
        #[inline(always)]
        pub const fn gp0ps(&self) -> &GP0PS {
            &self.gp0ps
        }
        #[doc = "0x30 - GPIO Port 0 Slew Rate"]
        #[inline(always)]
        pub const fn gp0sr(&self) -> &GP0SR {
            &self.gp0sr
        }
        #[doc = "0x34 - GPIO Port 0 Drive Select"]
        #[inline(always)]
        pub const fn gp0ds(&self) -> &GP0DS {
            &self.gp0ds
        }
        #[doc = "0x38 - GPIO Port 0 Power Select"]
        #[inline(always)]
        pub const fn gp0pwr(&self) -> &GP0PWR {
            &self.gp0pwr
        }
        #[doc = "0x3c - GPIO Interrupt Polarity Select"]
        #[inline(always)]
        pub const fn gp0pol(&self) -> &GP0POL {
            &self.gp0pol
        }
        #[doc = "0x40 - InterruptA Enable"]
        #[inline(always)]
        pub const fn gp0iena(&self) -> &GP0IENA {
            &self.gp0iena
        }
        #[doc = "0x44 - InterruptB Enable"]
        #[inline(always)]
        pub const fn gp0ienb(&self) -> &GP0IENB {
            &self.gp0ienb
        }
        #[doc = "0x48 - Interrupt Status"]
        #[inline(always)]
        pub const fn gp0int(&self) -> &GP0INT {
            &self.gp0int
        }
        #[doc = "0x50 - GPIO Port 1 Configuration"]
        #[inline(always)]
        pub const fn gp1con(&self) -> &GP1CON {
            &self.gp1con
        }
        #[doc = "0x54 - GPIO Port 1 Output Enable"]
        #[inline(always)]
        pub const fn gp1oe(&self) -> &GP1OE {
            &self.gp1oe
        }
        #[doc = "0x58 - GPIO Port 1 Input Path Enable"]
        #[inline(always)]
        pub const fn gp1ie(&self) -> &GP1IE {
            &self.gp1ie
        }
        #[doc = "0x5c - GPIO Port 1 Registered Data Input"]
        #[inline(always)]
        pub const fn gp1in(&self) -> &GP1IN {
            &self.gp1in
        }
        #[doc = "0x60 - GPIO Port 1 Data Output"]
        #[inline(always)]
        pub const fn gp1out(&self) -> &GP1OUT {
            &self.gp1out
        }
        #[doc = "0x64 - GPIO Port 1 Data Out Set"]
        #[inline(always)]
        pub const fn gp1set(&self) -> &GP1SET {
            &self.gp1set
        }
        #[doc = "0x68 - GPIO Port 1 Data Out Clear"]
        #[inline(always)]
        pub const fn gp1clr(&self) -> &GP1CLR {
            &self.gp1clr
        }
        #[doc = "0x6c - GPIO Port 1 Pin Toggle"]
        #[inline(always)]
        pub const fn gp1tgl(&self) -> &GP1TGL {
            &self.gp1tgl
        }
        #[doc = "0x70 - GPIO Port 1 Open Drain Enable"]
        #[inline(always)]
        pub const fn gp1ode(&self) -> &GP1ODE {
            &self.gp1ode
        }
        #[doc = "0x74 - GPIO Port 1 Input Select"]
        #[inline(always)]
        pub const fn gp1is(&self) -> &GP1IS {
            &self.gp1is
        }
        #[doc = "0x78 - GPIO Port 1 Pull Enable"]
        #[inline(always)]
        pub const fn gp1pe(&self) -> &GP1PE {
            &self.gp1pe
        }
        #[doc = "0x7c - GPIO Port 1 Pull Select"]
        #[inline(always)]
        pub const fn gp1ps(&self) -> &GP1PS {
            &self.gp1ps
        }
        #[doc = "0x80 - GPIO Port 1 Slew Rate"]
        #[inline(always)]
        pub const fn gp1sr(&self) -> &GP1SR {
            &self.gp1sr
        }
        #[doc = "0x84 - GPIO Port 1 Drive Select"]
        #[inline(always)]
        pub const fn gp1ds(&self) -> &GP1DS {
            &self.gp1ds
        }
        #[doc = "0x88 - GPIO Port 1 Power Select"]
        #[inline(always)]
        pub const fn gp1pwr(&self) -> &GP1PWR {
            &self.gp1pwr
        }
        #[doc = "0x8c - GPIO Interrupt Polarity Select"]
        #[inline(always)]
        pub const fn gp1pol(&self) -> &GP1POL {
            &self.gp1pol
        }
        #[doc = "0x90 - InterruptA Enable"]
        #[inline(always)]
        pub const fn gp1iena(&self) -> &GP1IENA {
            &self.gp1iena
        }
        #[doc = "0x94 - InterruptB Enable"]
        #[inline(always)]
        pub const fn gp1ienb(&self) -> &GP1IENB {
            &self.gp1ienb
        }
        #[doc = "0x98 - Interrupt Status"]
        #[inline(always)]
        pub const fn gp1int(&self) -> &GP1INT {
            &self.gp1int
        }
        #[doc = "0xa0 - GPIO Port 2 Configuration"]
        #[inline(always)]
        pub const fn gp2con(&self) -> &GP2CON {
            &self.gp2con
        }
        #[doc = "0xa4 - GPIO Port 2 Output Enable"]
        #[inline(always)]
        pub const fn gp2oe(&self) -> &GP2OE {
            &self.gp2oe
        }
        #[doc = "0xa8 - GPIO Port 2 Input Path Enable"]
        #[inline(always)]
        pub const fn gp2ie(&self) -> &GP2IE {
            &self.gp2ie
        }
        #[doc = "0xac - GPIO Port 2 Registered Data Input"]
        #[inline(always)]
        pub const fn gp2in(&self) -> &GP2IN {
            &self.gp2in
        }
        #[doc = "0xb0 - GPIO Port 2 Data Output"]
        #[inline(always)]
        pub const fn gp2out(&self) -> &GP2OUT {
            &self.gp2out
        }
        #[doc = "0xb4 - GPIO Port 2 Data Out Set"]
        #[inline(always)]
        pub const fn gp2set(&self) -> &GP2SET {
            &self.gp2set
        }
        #[doc = "0xb8 - GPIO Port 2 Data Out Clear"]
        #[inline(always)]
        pub const fn gp2clr(&self) -> &GP2CLR {
            &self.gp2clr
        }
        #[doc = "0xbc - GPIO Port 2 Pin Toggle"]
        #[inline(always)]
        pub const fn gp2tgl(&self) -> &GP2TGL {
            &self.gp2tgl
        }
        #[doc = "0xc0 - GPIO Port 2 Open Drain Enable"]
        #[inline(always)]
        pub const fn gp2ode(&self) -> &GP2ODE {
            &self.gp2ode
        }
        #[doc = "0xc4 - GPIO Port 2 Input Select"]
        #[inline(always)]
        pub const fn gp2is(&self) -> &GP2IS {
            &self.gp2is
        }
        #[doc = "0xc8 - GPIO Port 2 Pull Enable"]
        #[inline(always)]
        pub const fn gp2pe(&self) -> &GP2PE {
            &self.gp2pe
        }
        #[doc = "0xcc - GPIO Port 2 Pull Select"]
        #[inline(always)]
        pub const fn gp2ps(&self) -> &GP2PS {
            &self.gp2ps
        }
        #[doc = "0xd0 - GPIO Port 2 Slew Rate"]
        #[inline(always)]
        pub const fn gp2sr(&self) -> &GP2SR {
            &self.gp2sr
        }
        #[doc = "0xd4 - GPIO Port 2 Drive Select"]
        #[inline(always)]
        pub const fn gp2ds(&self) -> &GP2DS {
            &self.gp2ds
        }
        #[doc = "0xdc - Interrupt Polarity"]
        #[inline(always)]
        pub const fn gp2pol(&self) -> &GP2POL {
            &self.gp2pol
        }
        #[doc = "0xe0 - InterruptA Enable"]
        #[inline(always)]
        pub const fn gp2iena(&self) -> &GP2IENA {
            &self.gp2iena
        }
        #[doc = "0xe4 - InterruptB Enable"]
        #[inline(always)]
        pub const fn gp2ienb(&self) -> &GP2IENB {
            &self.gp2ienb
        }
        #[doc = "0xe8 - Interrupt Status"]
        #[inline(always)]
        pub const fn gp2int(&self) -> &GP2INT {
            &self.gp2int
        }
        #[doc = "0xf0 - GPIO Port 3 Configuration"]
        #[inline(always)]
        pub const fn gp3con(&self) -> &GP3CON {
            &self.gp3con
        }
        #[doc = "0xf4 - GPIO Port 3 Output Enable"]
        #[inline(always)]
        pub const fn gp3oe(&self) -> &GP3OE {
            &self.gp3oe
        }
        #[doc = "0xf8 - GPIO Port 3 Input Path Enable"]
        #[inline(always)]
        pub const fn gp3ie(&self) -> &GP3IE {
            &self.gp3ie
        }
        #[doc = "0xfc - GPIO Port 3 Registered Data Input"]
        #[inline(always)]
        pub const fn gp3in(&self) -> &GP3IN {
            &self.gp3in
        }
        #[doc = "0x100 - GPIO Port 3 Data Output"]
        #[inline(always)]
        pub const fn gp3out(&self) -> &GP3OUT {
            &self.gp3out
        }
        #[doc = "0x104 - GPIO Port 3 Data Out Set"]
        #[inline(always)]
        pub const fn gp3set(&self) -> &GP3SET {
            &self.gp3set
        }
        #[doc = "0x108 - GPIO Port 3 Data Out Clear"]
        #[inline(always)]
        pub const fn gp3clr(&self) -> &GP3CLR {
            &self.gp3clr
        }
        #[doc = "0x10c - GPIO Port 3 Pin Toggle"]
        #[inline(always)]
        pub const fn gp3tgl(&self) -> &GP3TGL {
            &self.gp3tgl
        }
        #[doc = "0x110 - GPIO Port 3 Open Drain Enable"]
        #[inline(always)]
        pub const fn gp3ode(&self) -> &GP3ODE {
            &self.gp3ode
        }
        #[doc = "0x114 - GPIO Port 3 Input Select"]
        #[inline(always)]
        pub const fn gp3is(&self) -> &GP3IS {
            &self.gp3is
        }
        #[doc = "0x118 - GPIO Port 3 Pull Enable"]
        #[inline(always)]
        pub const fn gp3pe(&self) -> &GP3PE {
            &self.gp3pe
        }
        #[doc = "0x11c - GPIO Port 3 Pull Select"]
        #[inline(always)]
        pub const fn gp3ps(&self) -> &GP3PS {
            &self.gp3ps
        }
        #[doc = "0x120 - GPIO Port 3 Slew Rate"]
        #[inline(always)]
        pub const fn gp3sr(&self) -> &GP3SR {
            &self.gp3sr
        }
        #[doc = "0x124 - GPIO Port 3 Drive Select"]
        #[inline(always)]
        pub const fn gp3ds(&self) -> &GP3DS {
            &self.gp3ds
        }
        #[doc = "0x12c - GPIO Interrupt Polarity Select"]
        #[inline(always)]
        pub const fn gp3pol(&self) -> &GP3POL {
            &self.gp3pol
        }
        #[doc = "0x130 - InterruptA Enable"]
        #[inline(always)]
        pub const fn gp3iena(&self) -> &GP3IENA {
            &self.gp3iena
        }
        #[doc = "0x134 - InterruptB Enable"]
        #[inline(always)]
        pub const fn gp3ienb(&self) -> &GP3IENB {
            &self.gp3ienb
        }
        #[doc = "0x138 - Interrupt Status"]
        #[inline(always)]
        pub const fn gp3int(&self) -> &GP3INT {
            &self.gp3int
        }
        #[doc = "0x140 - GPIO Port 4 Configuration"]
        #[inline(always)]
        pub const fn gp4con(&self) -> &GP4CON {
            &self.gp4con
        }
        #[doc = "0x144 - GPIO Port 4 Output Enable"]
        #[inline(always)]
        pub const fn gp4oe(&self) -> &GP4OE {
            &self.gp4oe
        }
        #[doc = "0x148 - GPIO Port 4 Input Path Enable"]
        #[inline(always)]
        pub const fn gp4ie(&self) -> &GP4IE {
            &self.gp4ie
        }
        #[doc = "0x14c - GPIO Port 4 Registered Data Input"]
        #[inline(always)]
        pub const fn gp4in(&self) -> &GP4IN {
            &self.gp4in
        }
        #[doc = "0x150 - GPIO Port 4 Data Output"]
        #[inline(always)]
        pub const fn gp4out(&self) -> &GP4OUT {
            &self.gp4out
        }
        #[doc = "0x154 - GPIO Port 4 Data Out Set"]
        #[inline(always)]
        pub const fn gp4set(&self) -> &GP4SET {
            &self.gp4set
        }
        #[doc = "0x158 - GPIO Port 4 Data Out Clear"]
        #[inline(always)]
        pub const fn gp4clr(&self) -> &GP4CLR {
            &self.gp4clr
        }
        #[doc = "0x15c - GPIO Port 4 Pin Toggle"]
        #[inline(always)]
        pub const fn gp4tgl(&self) -> &GP4TGL {
            &self.gp4tgl
        }
        #[doc = "0x160 - GPIO Port 4 Open Drain Enable"]
        #[inline(always)]
        pub const fn gp4ode(&self) -> &GP4ODE {
            &self.gp4ode
        }
        #[doc = "0x164 - GPIO Port 4 Input Select"]
        #[inline(always)]
        pub const fn gp4is(&self) -> &GP4IS {
            &self.gp4is
        }
        #[doc = "0x168 - GPIO Port 4 Pull Enable"]
        #[inline(always)]
        pub const fn gp4pe(&self) -> &GP4PE {
            &self.gp4pe
        }
        #[doc = "0x16c - GPIO Port 4 Pull Select"]
        #[inline(always)]
        pub const fn gp4ps(&self) -> &GP4PS {
            &self.gp4ps
        }
        #[doc = "0x170 - GPIO Port 4 Slew Rate"]
        #[inline(always)]
        pub const fn gp4sr(&self) -> &GP4SR {
            &self.gp4sr
        }
        #[doc = "0x174 - GPIO Port 4 Drive Select"]
        #[inline(always)]
        pub const fn gp4ds(&self) -> &GP4DS {
            &self.gp4ds
        }
        #[doc = "0x17c - GPIO Interrupt Polarity Select"]
        #[inline(always)]
        pub const fn gp4pol(&self) -> &GP4POL {
            &self.gp4pol
        }
        #[doc = "0x180 - InterruptA Enable"]
        #[inline(always)]
        pub const fn gp4iena(&self) -> &GP4IENA {
            &self.gp4iena
        }
        #[doc = "0x184 - InterruptB Enable"]
        #[inline(always)]
        pub const fn gp4ienb(&self) -> &GP4IENB {
            &self.gp4ienb
        }
        #[doc = "0x188 - Interrupt Status"]
        #[inline(always)]
        pub const fn gp4int(&self) -> &GP4INT {
            &self.gp4int
        }
        #[doc = "0x190 - GPIO Port 6 Configuration"]
        #[inline(always)]
        pub const fn gp5con(&self) -> &GP5CON {
            &self.gp5con
        }
        #[doc = "0x194 - GPIO Port 5 Output Enable"]
        #[inline(always)]
        pub const fn gp5oe(&self) -> &GP5OE {
            &self.gp5oe
        }
        #[doc = "0x198 - GPIO Port 5 Input Path Enable"]
        #[inline(always)]
        pub const fn gp5ie(&self) -> &GP5IE {
            &self.gp5ie
        }
        #[doc = "0x19c - GPIO Port 5 Registered Data Input"]
        #[inline(always)]
        pub const fn gp5in(&self) -> &GP5IN {
            &self.gp5in
        }
        #[doc = "0x1a0 - GPIO Port 5 Data Output"]
        #[inline(always)]
        pub const fn gp5out(&self) -> &GP5OUT {
            &self.gp5out
        }
        #[doc = "0x1a4 - GPIO Port 5 Data Out Set"]
        #[inline(always)]
        pub const fn gp5set(&self) -> &GP5SET {
            &self.gp5set
        }
        #[doc = "0x1a8 - GPIO Port 5 Data Out Clear"]
        #[inline(always)]
        pub const fn gp5clr(&self) -> &GP5CLR {
            &self.gp5clr
        }
        #[doc = "0x1ac - GPIO Port 5 Pin Toggle"]
        #[inline(always)]
        pub const fn gp5tgl(&self) -> &GP5TGL {
            &self.gp5tgl
        }
        #[doc = "0x1b0 - GPIO Port 5 Open Drain Enable"]
        #[inline(always)]
        pub const fn gp5ode(&self) -> &GP5ODE {
            &self.gp5ode
        }
        #[doc = "0x1b4 - GPIO Port 5 Input Select"]
        #[inline(always)]
        pub const fn gp5is(&self) -> &GP5IS {
            &self.gp5is
        }
        #[doc = "0x1b8 - GPIO Port 5 Pull Enable"]
        #[inline(always)]
        pub const fn gp5pe(&self) -> &GP5PE {
            &self.gp5pe
        }
        #[doc = "0x1bc - GPIO Port 5 Pull Select"]
        #[inline(always)]
        pub const fn gp5ps(&self) -> &GP5PS {
            &self.gp5ps
        }
        #[doc = "0x1c0 - GPIO Port 5 Slew Rate"]
        #[inline(always)]
        pub const fn gp5sr(&self) -> &GP5SR {
            &self.gp5sr
        }
        #[doc = "0x1c4 - GPIO Port 5 Drive Select"]
        #[inline(always)]
        pub const fn gp5ds(&self) -> &GP5DS {
            &self.gp5ds
        }
        #[doc = "0x1cc - GPIO Interrupt Polarity Select"]
        #[inline(always)]
        pub const fn gp5pol(&self) -> &GP5POL {
            &self.gp5pol
        }
        #[doc = "0x1d0 - InterruptA Enable"]
        #[inline(always)]
        pub const fn gp5iena(&self) -> &GP5IENA {
            &self.gp5iena
        }
        #[doc = "0x1d4 - InterruptB Enable"]
        #[inline(always)]
        pub const fn gp5ienb(&self) -> &GP5IENB {
            &self.gp5ienb
        }
        #[doc = "0x1d8 - Interrupt Status"]
        #[inline(always)]
        pub const fn gp5int(&self) -> &GP5INT {
            &self.gp5int
        }
    }
    #[doc = "GP0CON (rw) register accessor: GPIO Port 0 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0CON)\n\nFor information about available fields see [`mod@gp0con`]
module"]
    pub type GP0CON = crate::Reg<gp0con::GP0CONrs>;
    #[doc = "GPIO Port 0 Configuration"]
    pub mod gp0con {
        #[doc = "Register `GP0CON` reader"]
        pub type R = crate::R<GP0CONrs>;
        #[doc = "Register `GP0CON` writer"]
        pub type W = crate::W<GP0CONrs>;
        #[doc = "P0.0 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON0 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: SPI0 SCLK"]
            Sclk0 = 1,
            #[doc = "2: Comparater Output"]
            Comout0 = 2,
            #[doc = "3: PLAI\\[0\\]"]
            Plai0 = 3,
        }
        impl From<CON0> for u8 {
            #[inline(always)]
            fn from(variant: CON0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON0 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON0 {}
        #[doc = "Field `CON0` reader - P0.0 Configuration Bits"]
        pub type CON0_R = crate::FieldReader<CON0>;
        impl CON0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON0 {
                match self.bits {
                    0 => CON0::Gpio,
                    1 => CON0::Sclk0,
                    2 => CON0::Comout0,
                    3 => CON0::Plai0,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON0::Gpio
            }
            #[doc = "SPI0 SCLK"]
            #[inline(always)]
            pub fn is_sclk0(&self) -> bool {
                *self == CON0::Sclk0
            }
            #[doc = "Comparater Output"]
            #[inline(always)]
            pub fn is_comout0(&self) -> bool {
                *self == CON0::Comout0
            }
            #[doc = "PLAI\\[0\\]"]
            #[inline(always)]
            pub fn is_plai0(&self) -> bool {
                *self == CON0::Plai0
            }
        }
        #[doc = "Field `CON0` writer - P0.0 Configuration Bits"]
        pub type CON0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON0, crate::Safe>;
        impl<'a, REG> CON0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Gpio)
            }
            #[doc = "SPI0 SCLK"]
            #[inline(always)]
            pub fn sclk0(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Sclk0)
            }
            #[doc = "Comparater Output"]
            #[inline(always)]
            pub fn comout0(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Comout0)
            }
            #[doc = "PLAI\\[0\\]"]
            #[inline(always)]
            pub fn plai0(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Plai0)
            }
        }
        #[doc = "P0.1 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON1 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: SPI0 MISO"]
            Miso0 = 1,
            #[doc = "2: Comparater Output"]
            Comout1 = 2,
            #[doc = "3: PLAI\\[1\\]"]
            Plai1 = 3,
        }
        impl From<CON1> for u8 {
            #[inline(always)]
            fn from(variant: CON1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON1 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON1 {}
        #[doc = "Field `CON1` reader - P0.1 Configuration Bits"]
        pub type CON1_R = crate::FieldReader<CON1>;
        impl CON1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON1 {
                match self.bits {
                    0 => CON1::Gpio,
                    1 => CON1::Miso0,
                    2 => CON1::Comout1,
                    3 => CON1::Plai1,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON1::Gpio
            }
            #[doc = "SPI0 MISO"]
            #[inline(always)]
            pub fn is_miso0(&self) -> bool {
                *self == CON1::Miso0
            }
            #[doc = "Comparater Output"]
            #[inline(always)]
            pub fn is_comout1(&self) -> bool {
                *self == CON1::Comout1
            }
            #[doc = "PLAI\\[1\\]"]
            #[inline(always)]
            pub fn is_plai1(&self) -> bool {
                *self == CON1::Plai1
            }
        }
        #[doc = "Field `CON1` writer - P0.1 Configuration Bits"]
        pub type CON1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON1, crate::Safe>;
        impl<'a, REG> CON1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Gpio)
            }
            #[doc = "SPI0 MISO"]
            #[inline(always)]
            pub fn miso0(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Miso0)
            }
            #[doc = "Comparater Output"]
            #[inline(always)]
            pub fn comout1(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Comout1)
            }
            #[doc = "PLAI\\[1\\]"]
            #[inline(always)]
            pub fn plai1(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Plai1)
            }
        }
        #[doc = "P0.2 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON2 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: SPI0 MOSI"]
            Mosi0 = 1,
            #[doc = "2: PLA Clock 1"]
            Placlk1 = 2,
            #[doc = "3: PLAI\\[2\\]"]
            Plai2 = 3,
        }
        impl From<CON2> for u8 {
            #[inline(always)]
            fn from(variant: CON2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON2 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON2 {}
        #[doc = "Field `CON2` reader - P0.2 Configuration Bits"]
        pub type CON2_R = crate::FieldReader<CON2>;
        impl CON2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON2 {
                match self.bits {
                    0 => CON2::Gpio,
                    1 => CON2::Mosi0,
                    2 => CON2::Placlk1,
                    3 => CON2::Plai2,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON2::Gpio
            }
            #[doc = "SPI0 MOSI"]
            #[inline(always)]
            pub fn is_mosi0(&self) -> bool {
                *self == CON2::Mosi0
            }
            #[doc = "PLA Clock 1"]
            #[inline(always)]
            pub fn is_placlk1(&self) -> bool {
                *self == CON2::Placlk1
            }
            #[doc = "PLAI\\[2\\]"]
            #[inline(always)]
            pub fn is_plai2(&self) -> bool {
                *self == CON2::Plai2
            }
        }
        #[doc = "Field `CON2` writer - P0.2 Configuration Bits"]
        pub type CON2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON2, crate::Safe>;
        impl<'a, REG> CON2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Gpio)
            }
            #[doc = "SPI0 MOSI"]
            #[inline(always)]
            pub fn mosi0(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Mosi0)
            }
            #[doc = "PLA Clock 1"]
            #[inline(always)]
            pub fn placlk1(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Placlk1)
            }
            #[doc = "PLAI\\[2\\]"]
            #[inline(always)]
            pub fn plai2(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Plai2)
            }
        }
        #[doc = "P0.3 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON3 {
            #[doc = "0: GPIO/IRQ0"]
            Gpioirq0 = 0,
            #[doc = "1: SPI0 CS"]
            Cs0 = 1,
            #[doc = "2: PLA CLK0"]
            Placlk0 = 2,
            #[doc = "3: PLAI\\[3\\]"]
            Plai3 = 3,
        }
        impl From<CON3> for u8 {
            #[inline(always)]
            fn from(variant: CON3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON3 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON3 {}
        #[doc = "Field `CON3` reader - P0.3 Configuration Bits"]
        pub type CON3_R = crate::FieldReader<CON3>;
        impl CON3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON3 {
                match self.bits {
                    0 => CON3::Gpioirq0,
                    1 => CON3::Cs0,
                    2 => CON3::Placlk0,
                    3 => CON3::Plai3,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO/IRQ0"]
            #[inline(always)]
            pub fn is_gpioirq0(&self) -> bool {
                *self == CON3::Gpioirq0
            }
            #[doc = "SPI0 CS"]
            #[inline(always)]
            pub fn is_cs0(&self) -> bool {
                *self == CON3::Cs0
            }
            #[doc = "PLA CLK0"]
            #[inline(always)]
            pub fn is_placlk0(&self) -> bool {
                *self == CON3::Placlk0
            }
            #[doc = "PLAI\\[3\\]"]
            #[inline(always)]
            pub fn is_plai3(&self) -> bool {
                *self == CON3::Plai3
            }
        }
        #[doc = "Field `CON3` writer - P0.3 Configuration Bits"]
        pub type CON3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON3, crate::Safe>;
        impl<'a, REG> CON3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ0"]
            #[inline(always)]
            pub fn gpioirq0(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Gpioirq0)
            }
            #[doc = "SPI0 CS"]
            #[inline(always)]
            pub fn cs0(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Cs0)
            }
            #[doc = "PLA CLK0"]
            #[inline(always)]
            pub fn placlk0(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Placlk0)
            }
            #[doc = "PLAI\\[3\\]"]
            #[inline(always)]
            pub fn plai3(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Plai3)
            }
        }
        #[doc = "P0.4 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON4 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: I2C0 SCL"]
            Scl0 = 1,
            #[doc = "2: UART0 SIN"]
            Sin0 = 2,
            #[doc = "3: PLAO\\[2\\]"]
            Plao2 = 3,
        }
        impl From<CON4> for u8 {
            #[inline(always)]
            fn from(variant: CON4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON4 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON4 {}
        #[doc = "Field `CON4` reader - P0.4 Configuration Bits"]
        pub type CON4_R = crate::FieldReader<CON4>;
        impl CON4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON4 {
                match self.bits {
                    0 => CON4::Gpio,
                    1 => CON4::Scl0,
                    2 => CON4::Sin0,
                    3 => CON4::Plao2,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON4::Gpio
            }
            #[doc = "I2C0 SCL"]
            #[inline(always)]
            pub fn is_scl0(&self) -> bool {
                *self == CON4::Scl0
            }
            #[doc = "UART0 SIN"]
            #[inline(always)]
            pub fn is_sin0(&self) -> bool {
                *self == CON4::Sin0
            }
            #[doc = "PLAO\\[2\\]"]
            #[inline(always)]
            pub fn is_plao2(&self) -> bool {
                *self == CON4::Plao2
            }
        }
        #[doc = "Field `CON4` writer - P0.4 Configuration Bits"]
        pub type CON4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON4, crate::Safe>;
        impl<'a, REG> CON4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Gpio)
            }
            #[doc = "I2C0 SCL"]
            #[inline(always)]
            pub fn scl0(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Scl0)
            }
            #[doc = "UART0 SIN"]
            #[inline(always)]
            pub fn sin0(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Sin0)
            }
            #[doc = "PLAO\\[2\\]"]
            #[inline(always)]
            pub fn plao2(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Plao2)
            }
        }
        #[doc = "P0.5 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON5 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: I2C0 SDA"]
            Sda0 = 1,
            #[doc = "2: UART0 SOUT"]
            Sout0 = 2,
            #[doc = "3: PLAO\\[3\\]"]
            Plao3 = 3,
        }
        impl From<CON5> for u8 {
            #[inline(always)]
            fn from(variant: CON5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON5 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON5 {}
        #[doc = "Field `CON5` reader - P0.5 Configuration Bits"]
        pub type CON5_R = crate::FieldReader<CON5>;
        impl CON5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON5 {
                match self.bits {
                    0 => CON5::Gpio,
                    1 => CON5::Sda0,
                    2 => CON5::Sout0,
                    3 => CON5::Plao3,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON5::Gpio
            }
            #[doc = "I2C0 SDA"]
            #[inline(always)]
            pub fn is_sda0(&self) -> bool {
                *self == CON5::Sda0
            }
            #[doc = "UART0 SOUT"]
            #[inline(always)]
            pub fn is_sout0(&self) -> bool {
                *self == CON5::Sout0
            }
            #[doc = "PLAO\\[3\\]"]
            #[inline(always)]
            pub fn is_plao3(&self) -> bool {
                *self == CON5::Plao3
            }
        }
        #[doc = "Field `CON5` writer - P0.5 Configuration Bits"]
        pub type CON5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON5, crate::Safe>;
        impl<'a, REG> CON5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Gpio)
            }
            #[doc = "I2C0 SDA"]
            #[inline(always)]
            pub fn sda0(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Sda0)
            }
            #[doc = "UART0 SOUT"]
            #[inline(always)]
            pub fn sout0(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Sout0)
            }
            #[doc = "PLAO\\[3\\]"]
            #[inline(always)]
            pub fn plao3(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Plao3)
            }
        }
        #[doc = "P0.6 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON6 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: I2C2 SCL"]
            Scl2 = 1,
            #[doc = "2: Comparator Data Input 0"]
            Compdin0 = 2,
            #[doc = "3: PLAO\\[4\\]"]
            Plao4 = 3,
        }
        impl From<CON6> for u8 {
            #[inline(always)]
            fn from(variant: CON6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON6 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON6 {}
        #[doc = "Field `CON6` reader - P0.6 Configuration Bits"]
        pub type CON6_R = crate::FieldReader<CON6>;
        impl CON6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON6 {
                match self.bits {
                    0 => CON6::Gpio,
                    1 => CON6::Scl2,
                    2 => CON6::Compdin0,
                    3 => CON6::Plao4,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON6::Gpio
            }
            #[doc = "I2C2 SCL"]
            #[inline(always)]
            pub fn is_scl2(&self) -> bool {
                *self == CON6::Scl2
            }
            #[doc = "Comparator Data Input 0"]
            #[inline(always)]
            pub fn is_compdin0(&self) -> bool {
                *self == CON6::Compdin0
            }
            #[doc = "PLAO\\[4\\]"]
            #[inline(always)]
            pub fn is_plao4(&self) -> bool {
                *self == CON6::Plao4
            }
        }
        #[doc = "Field `CON6` writer - P0.6 Configuration Bits"]
        pub type CON6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON6, crate::Safe>;
        impl<'a, REG> CON6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Gpio)
            }
            #[doc = "I2C2 SCL"]
            #[inline(always)]
            pub fn scl2(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Scl2)
            }
            #[doc = "Comparator Data Input 0"]
            #[inline(always)]
            pub fn compdin0(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Compdin0)
            }
            #[doc = "PLAO\\[4\\]"]
            #[inline(always)]
            pub fn plao4(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Plao4)
            }
        }
        #[doc = "P0.7 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON7 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: I2C2 SDA"]
            Sda2 = 1,
            #[doc = "2: Comparator Data Input 1"]
            Compdin1 = 2,
            #[doc = "3: PLAO\\[5\\]"]
            Plao5 = 3,
        }
        impl From<CON7> for u8 {
            #[inline(always)]
            fn from(variant: CON7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON7 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON7 {}
        #[doc = "Field `CON7` reader - P0.7 Configuration Bits"]
        pub type CON7_R = crate::FieldReader<CON7>;
        impl CON7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON7 {
                match self.bits {
                    0 => CON7::Gpio,
                    1 => CON7::Sda2,
                    2 => CON7::Compdin1,
                    3 => CON7::Plao5,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON7::Gpio
            }
            #[doc = "I2C2 SDA"]
            #[inline(always)]
            pub fn is_sda2(&self) -> bool {
                *self == CON7::Sda2
            }
            #[doc = "Comparator Data Input 1"]
            #[inline(always)]
            pub fn is_compdin1(&self) -> bool {
                *self == CON7::Compdin1
            }
            #[doc = "PLAO\\[5\\]"]
            #[inline(always)]
            pub fn is_plao5(&self) -> bool {
                *self == CON7::Plao5
            }
        }
        #[doc = "Field `CON7` writer - P0.7 Configuration Bits"]
        pub type CON7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON7, crate::Safe>;
        impl<'a, REG> CON7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Gpio)
            }
            #[doc = "I2C2 SDA"]
            #[inline(always)]
            pub fn sda2(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Sda2)
            }
            #[doc = "Comparator Data Input 1"]
            #[inline(always)]
            pub fn compdin1(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Compdin1)
            }
            #[doc = "PLAO\\[5\\]"]
            #[inline(always)]
            pub fn plao5(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Plao5)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - P0.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&self) -> CON0_R {
                CON0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - P0.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&self) -> CON1_R {
                CON1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - P0.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&self) -> CON2_R {
                CON2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - P0.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&self) -> CON3_R {
                CON3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - P0.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&self) -> CON4_R {
                CON4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - P0.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&self) -> CON5_R {
                CON5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - P0.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&self) -> CON6_R {
                CON6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - P0.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&self) -> CON7_R {
                CON7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0CON")
                    .field("con0", &self.con0())
                    .field("con1", &self.con1())
                    .field("con2", &self.con2())
                    .field("con3", &self.con3())
                    .field("con4", &self.con4())
                    .field("con5", &self.con5())
                    .field("con6", &self.con6())
                    .field("con7", &self.con7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - P0.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&mut self) -> CON0_W<GP0CONrs> {
                CON0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - P0.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&mut self) -> CON1_W<GP0CONrs> {
                CON1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - P0.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&mut self) -> CON2_W<GP0CONrs> {
                CON2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - P0.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&mut self) -> CON3_W<GP0CONrs> {
                CON3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - P0.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&mut self) -> CON4_W<GP0CONrs> {
                CON4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - P0.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&mut self) -> CON5_W<GP0CONrs> {
                CON5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - P0.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&mut self) -> CON6_W<GP0CONrs> {
                CON6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - P0.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&mut self) -> CON7_W<GP0CONrs> {
                CON7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 0 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0CON)"]
        pub struct GP0CONrs;
        impl crate::RegisterSpec for GP0CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0con::R`](R) reader structure"]
        impl crate::Readable for GP0CONrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0con::W`](W) writer structure"]
        impl crate::Writable for GP0CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0CON to value 0"]
        impl crate::Resettable for GP0CONrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0OE (rw) register accessor: GPIO Port 0 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0oe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0oe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0OE)\n\nFor information about available fields see [`mod@gp0oe`]
module"]
    pub type GP0OE = crate::Reg<gp0oe::GP0OErs>;
    #[doc = "GPIO Port 0 Output Enable"]
    pub mod gp0oe {
        #[doc = "Register `GP0OE` reader"]
        pub type R = crate::R<GP0OErs>;
        #[doc = "Register `GP0OE` writer"]
        pub type W = crate::W<GP0OErs>;
        #[doc = "Field `OE` reader - Open Drain Enable"]
        pub type OE_R = crate::FieldReader;
        #[doc = "Field `OE` writer - Open Drain Enable"]
        pub type OE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0OE").field("oe", &self.oe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn oe(&mut self) -> OE_W<GP0OErs> {
                OE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0oe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0oe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0OE)"]
        pub struct GP0OErs;
        impl crate::RegisterSpec for GP0OErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0oe::R`](R) reader structure"]
        impl crate::Readable for GP0OErs {}
        #[doc = "`write(|w| ..)` method takes [`gp0oe::W`](W) writer structure"]
        impl crate::Writable for GP0OErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0OE to value 0"]
        impl crate::Resettable for GP0OErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0IE (rw) register accessor: GPIO Port 0 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IE)\n\nFor information about available fields see [`mod@gp0ie`]
module"]
    pub type GP0IE = crate::Reg<gp0ie::GP0IErs>;
    #[doc = "GPIO Port 0 Input Path Enable"]
    pub mod gp0ie {
        #[doc = "Register `GP0IE` reader"]
        pub type R = crate::R<GP0IErs>;
        #[doc = "Register `GP0IE` writer"]
        pub type W = crate::W<GP0IErs>;
        #[doc = "Field `IE` reader - Input Enable"]
        pub type IE_R = crate::FieldReader;
        #[doc = "Field `IE` writer - Input Enable"]
        pub type IE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&self) -> IE_R {
                IE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0IE").field("ie", &self.ie()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&mut self) -> IE_W<GP0IErs> {
                IE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IE)"]
        pub struct GP0IErs;
        impl crate::RegisterSpec for GP0IErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0ie::R`](R) reader structure"]
        impl crate::Readable for GP0IErs {}
        #[doc = "`write(|w| ..)` method takes [`gp0ie::W`](W) writer structure"]
        impl crate::Writable for GP0IErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0IE to value 0"]
        impl crate::Resettable for GP0IErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0IN (rw) register accessor: GPIO Port 0 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IN)\n\nFor information about available fields see [`mod@gp0in`]
module"]
    pub type GP0IN = crate::Reg<gp0in::GP0INrs>;
    #[doc = "GPIO Port 0 Registered Data Input"]
    pub mod gp0in {
        #[doc = "Register `GP0IN` reader"]
        pub type R = crate::R<GP0INrs>;
        #[doc = "Register `GP0IN` writer"]
        pub type W = crate::W<GP0INrs>;
        #[doc = "Field `Y` reader - Data Input from Pad"]
        pub type Y_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Data Input from Pad"]
            #[inline(always)]
            pub fn y(&self) -> Y_R {
                Y_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0IN").field("y", &self.y()).finish()
            }
        }
        impl W {}
        #[doc = "GPIO Port 0 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IN)"]
        pub struct GP0INrs;
        impl crate::RegisterSpec for GP0INrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0in::R`](R) reader structure"]
        impl crate::Readable for GP0INrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0in::W`](W) writer structure"]
        impl crate::Writable for GP0INrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0IN to value 0"]
        impl crate::Resettable for GP0INrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0OUT (rw) register accessor: GPIO Port 0 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0OUT)\n\nFor information about available fields see [`mod@gp0out`]
module"]
    pub type GP0OUT = crate::Reg<gp0out::GP0OUTrs>;
    #[doc = "GPIO Port 0 Data Output"]
    pub mod gp0out {
        #[doc = "Register `GP0OUT` reader"]
        pub type R = crate::R<GP0OUTrs>;
        #[doc = "Register `GP0OUT` writer"]
        pub type W = crate::W<GP0OUTrs>;
        #[doc = "Field `A` reader - Data Output to Pad"]
        pub type A_R = crate::FieldReader;
        #[doc = "Field `A` writer - Data Output to Pad"]
        pub type A_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&self) -> A_R {
                A_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0OUT").field("a", &self.a()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&mut self) -> A_W<GP0OUTrs> {
                A_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0OUT)"]
        pub struct GP0OUTrs;
        impl crate::RegisterSpec for GP0OUTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0out::R`](R) reader structure"]
        impl crate::Readable for GP0OUTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0out::W`](W) writer structure"]
        impl crate::Writable for GP0OUTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0OUT to value 0"]
        impl crate::Resettable for GP0OUTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0SET (rw) register accessor: GPIO Port 0 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0SET)\n\nFor information about available fields see [`mod@gp0set`]
module"]
    pub type GP0SET = crate::Reg<gp0set::GP0SETrs>;
    #[doc = "GPIO Port 0 Data Out Set"]
    pub mod gp0set {
        #[doc = "Register `GP0SET` reader"]
        pub type R = crate::R<GP0SETrs>;
        #[doc = "Register `GP0SET` writer"]
        pub type W = crate::W<GP0SETrs>;
        #[doc = "Field `SETUP` writer - Set the Output HIGH for the Pin"]
        pub type SETUP_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0SET").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output HIGH for the Pin"]
            #[inline(always)]
            pub fn setup(&mut self) -> SETUP_W<GP0SETrs> {
                SETUP_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0SET)"]
        pub struct GP0SETrs;
        impl crate::RegisterSpec for GP0SETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0set::R`](R) reader structure"]
        impl crate::Readable for GP0SETrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0set::W`](W) writer structure"]
        impl crate::Writable for GP0SETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0SET to value 0"]
        impl crate::Resettable for GP0SETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0CLR (rw) register accessor: GPIO Port 0 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0CLR)\n\nFor information about available fields see [`mod@gp0clr`]
module"]
    pub type GP0CLR = crate::Reg<gp0clr::GP0CLRrs>;
    #[doc = "GPIO Port 0 Data Out Clear"]
    pub mod gp0clr {
        #[doc = "Register `GP0CLR` reader"]
        pub type R = crate::R<GP0CLRrs>;
        #[doc = "Register `GP0CLR` writer"]
        pub type W = crate::W<GP0CLRrs>;
        #[doc = "Field `CLR` writer - Set the Output Low for the Port Pin"]
        pub type CLR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0CLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output Low for the Port Pin"]
            #[inline(always)]
            pub fn clr(&mut self) -> CLR_W<GP0CLRrs> {
                CLR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0CLR)"]
        pub struct GP0CLRrs;
        impl crate::RegisterSpec for GP0CLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0clr::R`](R) reader structure"]
        impl crate::Readable for GP0CLRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0clr::W`](W) writer structure"]
        impl crate::Writable for GP0CLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0CLR to value 0"]
        impl crate::Resettable for GP0CLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0TGL (rw) register accessor: GPIO Port 0 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0tgl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0tgl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0TGL)\n\nFor information about available fields see [`mod@gp0tgl`]
module"]
    pub type GP0TGL = crate::Reg<gp0tgl::GP0TGLrs>;
    #[doc = "GPIO Port 0 Pin Toggle"]
    pub mod gp0tgl {
        #[doc = "Register `GP0TGL` reader"]
        pub type R = crate::R<GP0TGLrs>;
        #[doc = "Register `GP0TGL` writer"]
        pub type W = crate::W<GP0TGLrs>;
        #[doc = "Field `TGL` writer - Toggle the Output of the Port Pin"]
        pub type TGL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0TGL").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Toggle the Output of the Port Pin"]
            #[inline(always)]
            pub fn tgl(&mut self) -> TGL_W<GP0TGLrs> {
                TGL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0tgl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0tgl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0TGL)"]
        pub struct GP0TGLrs;
        impl crate::RegisterSpec for GP0TGLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0tgl::R`](R) reader structure"]
        impl crate::Readable for GP0TGLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0tgl::W`](W) writer structure"]
        impl crate::Writable for GP0TGLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0TGL to value 0"]
        impl crate::Resettable for GP0TGLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0ODE (rw) register accessor: GPIO Port 0 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0ODE)\n\nFor information about available fields see [`mod@gp0ode`]
module"]
    pub type GP0ODE = crate::Reg<gp0ode::GP0ODErs>;
    #[doc = "GPIO Port 0 Open Drain Enable"]
    pub mod gp0ode {
        #[doc = "Register `GP0ODE` reader"]
        pub type R = crate::R<GP0ODErs>;
        #[doc = "Register `GP0ODE` writer"]
        pub type W = crate::W<GP0ODErs>;
        #[doc = "Field `ODE` reader - Open Drain Enable"]
        pub type ODE_R = crate::FieldReader;
        #[doc = "Field `ODE` writer - Open Drain Enable"]
        pub type ODE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&self) -> ODE_R {
                ODE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0ODE").field("ode", &self.ode()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&mut self) -> ODE_W<GP0ODErs> {
                ODE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0ODE)"]
        pub struct GP0ODErs;
        impl crate::RegisterSpec for GP0ODErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0ode::R`](R) reader structure"]
        impl crate::Readable for GP0ODErs {}
        #[doc = "`write(|w| ..)` method takes [`gp0ode::W`](W) writer structure"]
        impl crate::Writable for GP0ODErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0ODE to value 0"]
        impl crate::Resettable for GP0ODErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0IS (rw) register accessor: GPIO Port 0 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0is::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0is::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IS)\n\nFor information about available fields see [`mod@gp0is`]
module"]
    pub type GP0IS = crate::Reg<gp0is::GP0ISrs>;
    #[doc = "GPIO Port 0 Input Select"]
    pub mod gp0is {
        #[doc = "Register `GP0IS` reader"]
        pub type R = crate::R<GP0ISrs>;
        #[doc = "Register `GP0IS` writer"]
        pub type W = crate::W<GP0ISrs>;
        #[doc = "Field `ISEL` reader - Input Select"]
        pub type ISEL_R = crate::FieldReader;
        #[doc = "Field `ISEL` writer - Input Select"]
        pub type ISEL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&self) -> ISEL_R {
                ISEL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0IS").field("isel", &self.isel()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&mut self) -> ISEL_W<GP0ISrs> {
                ISEL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0is::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0is::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IS)"]
        pub struct GP0ISrs;
        impl crate::RegisterSpec for GP0ISrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0is::R`](R) reader structure"]
        impl crate::Readable for GP0ISrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0is::W`](W) writer structure"]
        impl crate::Writable for GP0ISrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0IS to value 0xff"]
        impl crate::Resettable for GP0ISrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP0PE (rw) register accessor: GPIO Port 0 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0pe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0pe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0PE)\n\nFor information about available fields see [`mod@gp0pe`]
module"]
    pub type GP0PE = crate::Reg<gp0pe::GP0PErs>;
    #[doc = "GPIO Port 0 Pull Enable"]
    pub mod gp0pe {
        #[doc = "Register `GP0PE` reader"]
        pub type R = crate::R<GP0PErs>;
        #[doc = "Register `GP0PE` writer"]
        pub type W = crate::W<GP0PErs>;
        #[doc = "Field `PE` reader - Pull Enable"]
        pub type PE_R = crate::FieldReader;
        #[doc = "Field `PE` writer - Pull Enable"]
        pub type PE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0PE").field("pe", &self.pe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W<GP0PErs> {
                PE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0pe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0pe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0PE)"]
        pub struct GP0PErs;
        impl crate::RegisterSpec for GP0PErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0pe::R`](R) reader structure"]
        impl crate::Readable for GP0PErs {}
        #[doc = "`write(|w| ..)` method takes [`gp0pe::W`](W) writer structure"]
        impl crate::Writable for GP0PErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0PE to value 0"]
        impl crate::Resettable for GP0PErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0PS (rw) register accessor: GPIO Port 0 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ps::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ps::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0PS)\n\nFor information about available fields see [`mod@gp0ps`]
module"]
    pub type GP0PS = crate::Reg<gp0ps::GP0PSrs>;
    #[doc = "GPIO Port 0 Pull Select"]
    pub mod gp0ps {
        #[doc = "Register `GP0PS` reader"]
        pub type R = crate::R<GP0PSrs>;
        #[doc = "Register `GP0PS` writer"]
        pub type W = crate::W<GP0PSrs>;
        #[doc = "Field `PS` reader - Pull Select"]
        pub type PS_R = crate::FieldReader;
        #[doc = "Field `PS` writer - Pull Select"]
        pub type PS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0PS").field("ps", &self.ps()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W<GP0PSrs> {
                PS_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ps::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ps::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0PS)"]
        pub struct GP0PSrs;
        impl crate::RegisterSpec for GP0PSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0ps::R`](R) reader structure"]
        impl crate::Readable for GP0PSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0ps::W`](W) writer structure"]
        impl crate::Writable for GP0PSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0PS to value 0xff"]
        impl crate::Resettable for GP0PSrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP0SR (rw) register accessor: GPIO Port 0 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0SR)\n\nFor information about available fields see [`mod@gp0sr`]
module"]
    pub type GP0SR = crate::Reg<gp0sr::GP0SRrs>;
    #[doc = "GPIO Port 0 Slew Rate"]
    pub mod gp0sr {
        #[doc = "Register `GP0SR` reader"]
        pub type R = crate::R<GP0SRrs>;
        #[doc = "Register `GP0SR` writer"]
        pub type W = crate::W<GP0SRrs>;
        #[doc = "Field `SR` reader - Slew Rate"]
        pub type SR_R = crate::FieldReader;
        #[doc = "Field `SR` writer - Slew Rate"]
        pub type SR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&self) -> SR_R {
                SR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0SR").field("sr", &self.sr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&mut self) -> SR_W<GP0SRrs> {
                SR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0SR)"]
        pub struct GP0SRrs;
        impl crate::RegisterSpec for GP0SRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0sr::R`](R) reader structure"]
        impl crate::Readable for GP0SRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0sr::W`](W) writer structure"]
        impl crate::Writable for GP0SRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0SR to value 0"]
        impl crate::Resettable for GP0SRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0DS (rw) register accessor: GPIO Port 0 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ds::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ds::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0DS)\n\nFor information about available fields see [`mod@gp0ds`]
module"]
    pub type GP0DS = crate::Reg<gp0ds::GP0DSrs>;
    #[doc = "GPIO Port 0 Drive Select"]
    pub mod gp0ds {
        #[doc = "Register `GP0DS` reader"]
        pub type R = crate::R<GP0DSrs>;
        #[doc = "Register `GP0DS` writer"]
        pub type W = crate::W<GP0DSrs>;
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS0 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS0> for u8 {
            #[inline(always)]
            fn from(variant: DS0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS0 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS0 {}
        #[doc = "Field `DS0` reader - Drive Select"]
        pub type DS0_R = crate::FieldReader<DS0>;
        impl DS0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS0 {
                match self.bits {
                    0 => DS0::Strength1,
                    1 => DS0::Strength2,
                    2 => DS0::Strength3,
                    3 => DS0::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS0::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS0::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS0::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS0::Strength4
            }
        }
        #[doc = "Field `DS0` writer - Drive Select"]
        pub type DS0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS0, crate::Safe>;
        impl<'a, REG> DS0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS1 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS1> for u8 {
            #[inline(always)]
            fn from(variant: DS1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS1 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS1 {}
        #[doc = "Field `DS1` reader - Drive Select"]
        pub type DS1_R = crate::FieldReader<DS1>;
        impl DS1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS1 {
                match self.bits {
                    0 => DS1::Strength1,
                    1 => DS1::Strength2,
                    2 => DS1::Strength3,
                    3 => DS1::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS1::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS1::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS1::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS1::Strength4
            }
        }
        #[doc = "Field `DS1` writer - Drive Select"]
        pub type DS1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS1, crate::Safe>;
        impl<'a, REG> DS1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS2 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS2> for u8 {
            #[inline(always)]
            fn from(variant: DS2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS2 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS2 {}
        #[doc = "Field `DS2` reader - Drive Select"]
        pub type DS2_R = crate::FieldReader<DS2>;
        impl DS2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS2 {
                match self.bits {
                    0 => DS2::Strength1,
                    1 => DS2::Strength2,
                    2 => DS2::Strength3,
                    3 => DS2::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS2::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS2::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS2::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS2::Strength4
            }
        }
        #[doc = "Field `DS2` writer - Drive Select"]
        pub type DS2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS2, crate::Safe>;
        impl<'a, REG> DS2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS3 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS3> for u8 {
            #[inline(always)]
            fn from(variant: DS3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS3 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS3 {}
        #[doc = "Field `DS3` reader - Drive Select"]
        pub type DS3_R = crate::FieldReader<DS3>;
        impl DS3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS3 {
                match self.bits {
                    0 => DS3::Strength1,
                    1 => DS3::Strength2,
                    2 => DS3::Strength3,
                    3 => DS3::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS3::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS3::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS3::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS3::Strength4
            }
        }
        #[doc = "Field `DS3` writer - Drive Select"]
        pub type DS3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS3, crate::Safe>;
        impl<'a, REG> DS3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS4 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS4> for u8 {
            #[inline(always)]
            fn from(variant: DS4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS4 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS4 {}
        #[doc = "Field `DS4` reader - Drive Select"]
        pub type DS4_R = crate::FieldReader<DS4>;
        impl DS4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS4 {
                match self.bits {
                    0 => DS4::Strength1,
                    1 => DS4::Strength2,
                    2 => DS4::Strength3,
                    3 => DS4::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS4::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS4::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS4::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS4::Strength4
            }
        }
        #[doc = "Field `DS4` writer - Drive Select"]
        pub type DS4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS4, crate::Safe>;
        impl<'a, REG> DS4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS5 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS5> for u8 {
            #[inline(always)]
            fn from(variant: DS5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS5 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS5 {}
        #[doc = "Field `DS5` reader - Drive Select"]
        pub type DS5_R = crate::FieldReader<DS5>;
        impl DS5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS5 {
                match self.bits {
                    0 => DS5::Strength1,
                    1 => DS5::Strength2,
                    2 => DS5::Strength3,
                    3 => DS5::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS5::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS5::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS5::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS5::Strength4
            }
        }
        #[doc = "Field `DS5` writer - Drive Select"]
        pub type DS5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS5, crate::Safe>;
        impl<'a, REG> DS5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS6 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS6> for u8 {
            #[inline(always)]
            fn from(variant: DS6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS6 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS6 {}
        #[doc = "Field `DS6` reader - Drive Select"]
        pub type DS6_R = crate::FieldReader<DS6>;
        impl DS6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS6 {
                match self.bits {
                    0 => DS6::Strength1,
                    1 => DS6::Strength2,
                    2 => DS6::Strength3,
                    3 => DS6::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS6::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS6::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS6::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS6::Strength4
            }
        }
        #[doc = "Field `DS6` writer - Drive Select"]
        pub type DS6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS6, crate::Safe>;
        impl<'a, REG> DS6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS7 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS7> for u8 {
            #[inline(always)]
            fn from(variant: DS7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS7 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS7 {}
        #[doc = "Field `DS7` reader - Drive Select"]
        pub type DS7_R = crate::FieldReader<DS7>;
        impl DS7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS7 {
                match self.bits {
                    0 => DS7::Strength1,
                    1 => DS7::Strength2,
                    2 => DS7::Strength3,
                    3 => DS7::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS7::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS7::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS7::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS7::Strength4
            }
        }
        #[doc = "Field `DS7` writer - Drive Select"]
        pub type DS7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS7, crate::Safe>;
        impl<'a, REG> DS7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength4)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&self) -> DS0_R {
                DS0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&self) -> DS1_R {
                DS1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&self) -> DS2_R {
                DS2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&self) -> DS3_R {
                DS3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&self) -> DS4_R {
                DS4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&self) -> DS5_R {
                DS5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&self) -> DS6_R {
                DS6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&self) -> DS7_R {
                DS7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0DS")
                    .field("ds0", &self.ds0())
                    .field("ds1", &self.ds1())
                    .field("ds2", &self.ds2())
                    .field("ds3", &self.ds3())
                    .field("ds4", &self.ds4())
                    .field("ds5", &self.ds5())
                    .field("ds6", &self.ds6())
                    .field("ds7", &self.ds7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&mut self) -> DS0_W<GP0DSrs> {
                DS0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&mut self) -> DS1_W<GP0DSrs> {
                DS1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&mut self) -> DS2_W<GP0DSrs> {
                DS2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&mut self) -> DS3_W<GP0DSrs> {
                DS3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&mut self) -> DS4_W<GP0DSrs> {
                DS4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&mut self) -> DS5_W<GP0DSrs> {
                DS5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&mut self) -> DS6_W<GP0DSrs> {
                DS6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&mut self) -> DS7_W<GP0DSrs> {
                DS7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 0 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ds::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ds::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0DS)"]
        pub struct GP0DSrs;
        impl crate::RegisterSpec for GP0DSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0ds::R`](R) reader structure"]
        impl crate::Readable for GP0DSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0ds::W`](W) writer structure"]
        impl crate::Writable for GP0DSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0DS to value 0"]
        impl crate::Resettable for GP0DSrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0PWR (rw) register accessor: GPIO Port 0 Power Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0pwr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0pwr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0PWR)\n\nFor information about available fields see [`mod@gp0pwr`]
module"]
    pub type GP0PWR = crate::Reg<gp0pwr::GP0PWRrs>;
    #[doc = "GPIO Port 0 Power Select"]
    pub mod gp0pwr {
        #[doc = "Register `GP0PWR` reader"]
        pub type R = crate::R<GP0PWRrs>;
        #[doc = "Register `GP0PWR` writer"]
        pub type W = crate::W<GP0PWRrs>;
        #[doc = "Field `PWR` reader - Pad Power Select"]
        pub type PWR_R = crate::FieldReader;
        #[doc = "Field `PWR` writer - Pad Power Select"]
        pub type PWR_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:3 - Pad Power Select"]
            #[inline(always)]
            pub fn pwr(&self) -> PWR_R {
                PWR_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0PWR").field("pwr", &self.pwr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Pad Power Select"]
            #[inline(always)]
            pub fn pwr(&mut self) -> PWR_W<GP0PWRrs> {
                PWR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 0 Power Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0pwr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0pwr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0PWR)"]
        pub struct GP0PWRrs;
        impl crate::RegisterSpec for GP0PWRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0pwr::R`](R) reader structure"]
        impl crate::Readable for GP0PWRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0pwr::W`](W) writer structure"]
        impl crate::Writable for GP0PWRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0PWR to value 0x0f"]
        impl crate::Resettable for GP0PWRrs {
            const RESET_VALUE: u32 = 0x0f;
        }
    }
    #[doc = "GP0POL (rw) register accessor: GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0pol::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0pol::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0POL)\n\nFor information about available fields see [`mod@gp0pol`]
module"]
    pub type GP0POL = crate::Reg<gp0pol::GP0POLrs>;
    #[doc = "GPIO Interrupt Polarity Select"]
    pub mod gp0pol {
        #[doc = "Register `GP0POL` reader"]
        pub type R = crate::R<GP0POLrs>;
        #[doc = "Register `GP0POL` writer"]
        pub type W = crate::W<GP0POLrs>;
        #[doc = "Field `INTPOL` reader - Parametric Output"]
        pub type INTPOL_R = crate::FieldReader;
        #[doc = "Field `INTPOL` writer - Parametric Output"]
        pub type INTPOL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&self) -> INTPOL_R {
                INTPOL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0POL")
                    .field("intpol", &self.intpol())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&mut self) -> INTPOL_W<GP0POLrs> {
                INTPOL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0pol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0pol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0POL)"]
        pub struct GP0POLrs;
        impl crate::RegisterSpec for GP0POLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0pol::R`](R) reader structure"]
        impl crate::Readable for GP0POLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0pol::W`](W) writer structure"]
        impl crate::Writable for GP0POLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0POL to value 0"]
        impl crate::Resettable for GP0POLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0IENA (rw) register accessor: InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0iena::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0iena::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IENA)\n\nFor information about available fields see [`mod@gp0iena`]
module"]
    pub type GP0IENA = crate::Reg<gp0iena::GP0IENArs>;
    #[doc = "InterruptA Enable"]
    pub mod gp0iena {
        #[doc = "Register `GP0IENA` reader"]
        pub type R = crate::R<GP0IENArs>;
        #[doc = "Register `GP0IENA` writer"]
        pub type W = crate::W<GP0IENArs>;
        #[doc = "Field `INTAEN` reader - InterruptA Enable"]
        pub type INTAEN_R = crate::FieldReader;
        #[doc = "Field `INTAEN` writer - InterruptA Enable"]
        pub type INTAEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&self) -> INTAEN_R {
                INTAEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0IENA")
                    .field("intaen", &self.intaen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&mut self) -> INTAEN_W<GP0IENArs> {
                INTAEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0iena::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0iena::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IENA)"]
        pub struct GP0IENArs;
        impl crate::RegisterSpec for GP0IENArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0iena::R`](R) reader structure"]
        impl crate::Readable for GP0IENArs {}
        #[doc = "`write(|w| ..)` method takes [`gp0iena::W`](W) writer structure"]
        impl crate::Writable for GP0IENArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0IENA to value 0"]
        impl crate::Resettable for GP0IENArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0IENB (rw) register accessor: InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ienb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ienb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IENB)\n\nFor information about available fields see [`mod@gp0ienb`]
module"]
    pub type GP0IENB = crate::Reg<gp0ienb::GP0IENBrs>;
    #[doc = "InterruptB Enable"]
    pub mod gp0ienb {
        #[doc = "Register `GP0IENB` reader"]
        pub type R = crate::R<GP0IENBrs>;
        #[doc = "Register `GP0IENB` writer"]
        pub type W = crate::W<GP0IENBrs>;
        #[doc = "Field `INTBEN` reader - InterruptA Enable"]
        pub type INTBEN_R = crate::FieldReader;
        #[doc = "Field `INTBEN` writer - InterruptA Enable"]
        pub type INTBEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intben(&self) -> INTBEN_R {
                INTBEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0IENB")
                    .field("intben", &self.intben())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intben(&mut self) -> INTBEN_W<GP0IENBrs> {
                INTBEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0ienb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0ienb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0IENB)"]
        pub struct GP0IENBrs;
        impl crate::RegisterSpec for GP0IENBrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0ienb::R`](R) reader structure"]
        impl crate::Readable for GP0IENBrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0ienb::W`](W) writer structure"]
        impl crate::Writable for GP0IENBrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0IENB to value 0"]
        impl crate::Resettable for GP0IENBrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP0INT (rw) register accessor: Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0int::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0int::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0INT)\n\nFor information about available fields see [`mod@gp0int`]
module"]
    pub type GP0INT = crate::Reg<gp0int::GP0INTrs>;
    #[doc = "Interrupt Status"]
    pub mod gp0int {
        #[doc = "Register `GP0INT` reader"]
        pub type R = crate::R<GP0INTrs>;
        #[doc = "Register `GP0INT` writer"]
        pub type W = crate::W<GP0INTrs>;
        #[doc = "Field `INTSTATUS` reader - Interrupt Status"]
        pub type INTSTATUS_R = crate::FieldReader;
        #[doc = "Field `INTSTATUS` writer - Interrupt Status"]
        pub type INTSTATUS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&self) -> INTSTATUS_R {
                INTSTATUS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP0INT")
                    .field("intstatus", &self.intstatus())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&mut self) -> INTSTATUS_W<GP0INTrs> {
                INTSTATUS_W::new(self, 0)
            }
        }
        #[doc = "Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp0int::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp0int::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP0INT)"]
        pub struct GP0INTrs;
        impl crate::RegisterSpec for GP0INTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp0int::R`](R) reader structure"]
        impl crate::Readable for GP0INTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp0int::W`](W) writer structure"]
        impl crate::Writable for GP0INTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP0INT to value 0"]
        impl crate::Resettable for GP0INTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1CON (rw) register accessor: GPIO Port 1 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1CON)\n\nFor information about available fields see [`mod@gp1con`]
module"]
    pub type GP1CON = crate::Reg<gp1con::GP1CONrs>;
    #[doc = "GPIO Port 1 Configuration"]
    pub mod gp1con {
        #[doc = "Register `GP1CON` reader"]
        pub type R = crate::R<GP1CONrs>;
        #[doc = "Register `GP1CON` writer"]
        pub type W = crate::W<GP1CONrs>;
        #[doc = "P1.0 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON0 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: UART1 SIN"]
            Sin1 = 1,
            #[doc = "2: Comparater Output 2"]
            Compout2 = 2,
            #[doc = "3: PLAI\\[4\\]"]
            Plai4 = 3,
        }
        impl From<CON0> for u8 {
            #[inline(always)]
            fn from(variant: CON0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON0 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON0 {}
        #[doc = "Field `CON0` reader - P1.0 Configuration Bits"]
        pub type CON0_R = crate::FieldReader<CON0>;
        impl CON0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON0 {
                match self.bits {
                    0 => CON0::Gpio,
                    1 => CON0::Sin1,
                    2 => CON0::Compout2,
                    3 => CON0::Plai4,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON0::Gpio
            }
            #[doc = "UART1 SIN"]
            #[inline(always)]
            pub fn is_sin1(&self) -> bool {
                *self == CON0::Sin1
            }
            #[doc = "Comparater Output 2"]
            #[inline(always)]
            pub fn is_compout2(&self) -> bool {
                *self == CON0::Compout2
            }
            #[doc = "PLAI\\[4\\]"]
            #[inline(always)]
            pub fn is_plai4(&self) -> bool {
                *self == CON0::Plai4
            }
        }
        #[doc = "Field `CON0` writer - P1.0 Configuration Bits"]
        pub type CON0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON0, crate::Safe>;
        impl<'a, REG> CON0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Gpio)
            }
            #[doc = "UART1 SIN"]
            #[inline(always)]
            pub fn sin1(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Sin1)
            }
            #[doc = "Comparater Output 2"]
            #[inline(always)]
            pub fn compout2(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Compout2)
            }
            #[doc = "PLAI\\[4\\]"]
            #[inline(always)]
            pub fn plai4(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Plai4)
            }
        }
        #[doc = "P1.1 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON1 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: UART 1 SOUT"]
            Sout1 = 1,
            #[doc = "2: Comparater Output 3"]
            Comdout3 = 2,
            #[doc = "3: PLAI\\[5\\]"]
            Plai5 = 3,
        }
        impl From<CON1> for u8 {
            #[inline(always)]
            fn from(variant: CON1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON1 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON1 {}
        #[doc = "Field `CON1` reader - P1.1 Configuration Bits"]
        pub type CON1_R = crate::FieldReader<CON1>;
        impl CON1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON1 {
                match self.bits {
                    0 => CON1::Gpio,
                    1 => CON1::Sout1,
                    2 => CON1::Comdout3,
                    3 => CON1::Plai5,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON1::Gpio
            }
            #[doc = "UART 1 SOUT"]
            #[inline(always)]
            pub fn is_sout1(&self) -> bool {
                *self == CON1::Sout1
            }
            #[doc = "Comparater Output 3"]
            #[inline(always)]
            pub fn is_comdout3(&self) -> bool {
                *self == CON1::Comdout3
            }
            #[doc = "PLAI\\[5\\]"]
            #[inline(always)]
            pub fn is_plai5(&self) -> bool {
                *self == CON1::Plai5
            }
        }
        #[doc = "Field `CON1` writer - P1.1 Configuration Bits"]
        pub type CON1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON1, crate::Safe>;
        impl<'a, REG> CON1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Gpio)
            }
            #[doc = "UART 1 SOUT"]
            #[inline(always)]
            pub fn sout1(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Sout1)
            }
            #[doc = "Comparater Output 3"]
            #[inline(always)]
            pub fn comdout3(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Comdout3)
            }
            #[doc = "PLAI\\[5\\]"]
            #[inline(always)]
            pub fn plai5(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Plai5)
            }
        }
        #[doc = "P1.2 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON2 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: I2C1 SCL"]
            Scl1 = 1,
            #[doc = "2: PWM"]
            Pwm0 = 2,
            #[doc = "3: PLAI6]"]
            Plai6 = 3,
        }
        impl From<CON2> for u8 {
            #[inline(always)]
            fn from(variant: CON2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON2 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON2 {}
        #[doc = "Field `CON2` reader - P1.2 Configuration Bits"]
        pub type CON2_R = crate::FieldReader<CON2>;
        impl CON2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON2 {
                match self.bits {
                    0 => CON2::Gpio,
                    1 => CON2::Scl1,
                    2 => CON2::Pwm0,
                    3 => CON2::Plai6,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON2::Gpio
            }
            #[doc = "I2C1 SCL"]
            #[inline(always)]
            pub fn is_scl1(&self) -> bool {
                *self == CON2::Scl1
            }
            #[doc = "PWM"]
            #[inline(always)]
            pub fn is_pwm0(&self) -> bool {
                *self == CON2::Pwm0
            }
            #[doc = "PLAI6]"]
            #[inline(always)]
            pub fn is_plai6(&self) -> bool {
                *self == CON2::Plai6
            }
        }
        #[doc = "Field `CON2` writer - P1.2 Configuration Bits"]
        pub type CON2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON2, crate::Safe>;
        impl<'a, REG> CON2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Gpio)
            }
            #[doc = "I2C1 SCL"]
            #[inline(always)]
            pub fn scl1(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Scl1)
            }
            #[doc = "PWM"]
            #[inline(always)]
            pub fn pwm0(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Pwm0)
            }
            #[doc = "PLAI6]"]
            #[inline(always)]
            pub fn plai6(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Plai6)
            }
        }
        #[doc = "P1.3 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON3 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: I2C1 SDA"]
            Sda1 = 1,
            #[doc = "2: PWM1"]
            Pwm1 = 2,
            #[doc = "3: PLAI\\[7\\]"]
            Plai7 = 3,
        }
        impl From<CON3> for u8 {
            #[inline(always)]
            fn from(variant: CON3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON3 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON3 {}
        #[doc = "Field `CON3` reader - P1.3 Configuration Bits"]
        pub type CON3_R = crate::FieldReader<CON3>;
        impl CON3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON3 {
                match self.bits {
                    0 => CON3::Gpio,
                    1 => CON3::Sda1,
                    2 => CON3::Pwm1,
                    3 => CON3::Plai7,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON3::Gpio
            }
            #[doc = "I2C1 SDA"]
            #[inline(always)]
            pub fn is_sda1(&self) -> bool {
                *self == CON3::Sda1
            }
            #[doc = "PWM1"]
            #[inline(always)]
            pub fn is_pwm1(&self) -> bool {
                *self == CON3::Pwm1
            }
            #[doc = "PLAI\\[7\\]"]
            #[inline(always)]
            pub fn is_plai7(&self) -> bool {
                *self == CON3::Plai7
            }
        }
        #[doc = "Field `CON3` writer - P1.3 Configuration Bits"]
        pub type CON3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON3, crate::Safe>;
        impl<'a, REG> CON3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Gpio)
            }
            #[doc = "I2C1 SDA"]
            #[inline(always)]
            pub fn sda1(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Sda1)
            }
            #[doc = "PWM1"]
            #[inline(always)]
            pub fn pwm1(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Pwm1)
            }
            #[doc = "PLAI\\[7\\]"]
            #[inline(always)]
            pub fn plai7(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Plai7)
            }
        }
        #[doc = "P1.4 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON4 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: SPI1 SCLK"]
            Sclk1 = 1,
            #[doc = "2: PWM2"]
            Pwm2 = 2,
            #[doc = "3: PLAO\\[10\\]"]
            Plao10 = 3,
        }
        impl From<CON4> for u8 {
            #[inline(always)]
            fn from(variant: CON4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON4 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON4 {}
        #[doc = "Field `CON4` reader - P1.4 Configuration Bits"]
        pub type CON4_R = crate::FieldReader<CON4>;
        impl CON4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON4 {
                match self.bits {
                    0 => CON4::Gpio,
                    1 => CON4::Sclk1,
                    2 => CON4::Pwm2,
                    3 => CON4::Plao10,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON4::Gpio
            }
            #[doc = "SPI1 SCLK"]
            #[inline(always)]
            pub fn is_sclk1(&self) -> bool {
                *self == CON4::Sclk1
            }
            #[doc = "PWM2"]
            #[inline(always)]
            pub fn is_pwm2(&self) -> bool {
                *self == CON4::Pwm2
            }
            #[doc = "PLAO\\[10\\]"]
            #[inline(always)]
            pub fn is_plao10(&self) -> bool {
                *self == CON4::Plao10
            }
        }
        #[doc = "Field `CON4` writer - P1.4 Configuration Bits"]
        pub type CON4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON4, crate::Safe>;
        impl<'a, REG> CON4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Gpio)
            }
            #[doc = "SPI1 SCLK"]
            #[inline(always)]
            pub fn sclk1(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Sclk1)
            }
            #[doc = "PWM2"]
            #[inline(always)]
            pub fn pwm2(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Pwm2)
            }
            #[doc = "PLAO\\[10\\]"]
            #[inline(always)]
            pub fn plao10(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Plao10)
            }
        }
        #[doc = "P1.5 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON5 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: SPI1 MISO"]
            Miso1 = 1,
            #[doc = "2: PWM3"]
            Pwm3 = 2,
            #[doc = "3: PLAO\\[11\\]"]
            Plao11 = 3,
        }
        impl From<CON5> for u8 {
            #[inline(always)]
            fn from(variant: CON5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON5 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON5 {}
        #[doc = "Field `CON5` reader - P1.5 Configuration Bits"]
        pub type CON5_R = crate::FieldReader<CON5>;
        impl CON5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON5 {
                match self.bits {
                    0 => CON5::Gpio,
                    1 => CON5::Miso1,
                    2 => CON5::Pwm3,
                    3 => CON5::Plao11,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON5::Gpio
            }
            #[doc = "SPI1 MISO"]
            #[inline(always)]
            pub fn is_miso1(&self) -> bool {
                *self == CON5::Miso1
            }
            #[doc = "PWM3"]
            #[inline(always)]
            pub fn is_pwm3(&self) -> bool {
                *self == CON5::Pwm3
            }
            #[doc = "PLAO\\[11\\]"]
            #[inline(always)]
            pub fn is_plao11(&self) -> bool {
                *self == CON5::Plao11
            }
        }
        #[doc = "Field `CON5` writer - P1.5 Configuration Bits"]
        pub type CON5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON5, crate::Safe>;
        impl<'a, REG> CON5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Gpio)
            }
            #[doc = "SPI1 MISO"]
            #[inline(always)]
            pub fn miso1(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Miso1)
            }
            #[doc = "PWM3"]
            #[inline(always)]
            pub fn pwm3(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Pwm3)
            }
            #[doc = "PLAO\\[11\\]"]
            #[inline(always)]
            pub fn plao11(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Plao11)
            }
        }
        #[doc = "P1.6 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON6 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: SPI1 MOSI"]
            Mosi1 = 1,
            #[doc = "2: PWM4"]
            Pwm4 = 2,
            #[doc = "3: PLAO\\[12\\]"]
            Plao12 = 3,
        }
        impl From<CON6> for u8 {
            #[inline(always)]
            fn from(variant: CON6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON6 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON6 {}
        #[doc = "Field `CON6` reader - P1.6 Configuration Bits"]
        pub type CON6_R = crate::FieldReader<CON6>;
        impl CON6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON6 {
                match self.bits {
                    0 => CON6::Gpio,
                    1 => CON6::Mosi1,
                    2 => CON6::Pwm4,
                    3 => CON6::Plao12,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON6::Gpio
            }
            #[doc = "SPI1 MOSI"]
            #[inline(always)]
            pub fn is_mosi1(&self) -> bool {
                *self == CON6::Mosi1
            }
            #[doc = "PWM4"]
            #[inline(always)]
            pub fn is_pwm4(&self) -> bool {
                *self == CON6::Pwm4
            }
            #[doc = "PLAO\\[12\\]"]
            #[inline(always)]
            pub fn is_plao12(&self) -> bool {
                *self == CON6::Plao12
            }
        }
        #[doc = "Field `CON6` writer - P1.6 Configuration Bits"]
        pub type CON6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON6, crate::Safe>;
        impl<'a, REG> CON6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Gpio)
            }
            #[doc = "SPI1 MOSI"]
            #[inline(always)]
            pub fn mosi1(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Mosi1)
            }
            #[doc = "PWM4"]
            #[inline(always)]
            pub fn pwm4(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Pwm4)
            }
            #[doc = "PLAO\\[12\\]"]
            #[inline(always)]
            pub fn plao12(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Plao12)
            }
        }
        #[doc = "P1.7 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON7 {
            #[doc = "0: GPIO/IRQ1"]
            Gpio = 0,
            #[doc = "1: SPI1 CS"]
            Cs1 = 1,
            #[doc = "2: PWM5"]
            Pwm5 = 2,
            #[doc = "3: PLAO\\[13\\]"]
            Plao13 = 3,
        }
        impl From<CON7> for u8 {
            #[inline(always)]
            fn from(variant: CON7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON7 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON7 {}
        #[doc = "Field `CON7` reader - P1.7 Configuration Bits"]
        pub type CON7_R = crate::FieldReader<CON7>;
        impl CON7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON7 {
                match self.bits {
                    0 => CON7::Gpio,
                    1 => CON7::Cs1,
                    2 => CON7::Pwm5,
                    3 => CON7::Plao13,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO/IRQ1"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON7::Gpio
            }
            #[doc = "SPI1 CS"]
            #[inline(always)]
            pub fn is_cs1(&self) -> bool {
                *self == CON7::Cs1
            }
            #[doc = "PWM5"]
            #[inline(always)]
            pub fn is_pwm5(&self) -> bool {
                *self == CON7::Pwm5
            }
            #[doc = "PLAO\\[13\\]"]
            #[inline(always)]
            pub fn is_plao13(&self) -> bool {
                *self == CON7::Plao13
            }
        }
        #[doc = "Field `CON7` writer - P1.7 Configuration Bits"]
        pub type CON7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON7, crate::Safe>;
        impl<'a, REG> CON7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ1"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Gpio)
            }
            #[doc = "SPI1 CS"]
            #[inline(always)]
            pub fn cs1(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Cs1)
            }
            #[doc = "PWM5"]
            #[inline(always)]
            pub fn pwm5(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Pwm5)
            }
            #[doc = "PLAO\\[13\\]"]
            #[inline(always)]
            pub fn plao13(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Plao13)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - P1.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&self) -> CON0_R {
                CON0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - P1.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&self) -> CON1_R {
                CON1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - P1.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&self) -> CON2_R {
                CON2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - P1.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&self) -> CON3_R {
                CON3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - P1.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&self) -> CON4_R {
                CON4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - P1.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&self) -> CON5_R {
                CON5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - P1.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&self) -> CON6_R {
                CON6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - P1.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&self) -> CON7_R {
                CON7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1CON")
                    .field("con0", &self.con0())
                    .field("con1", &self.con1())
                    .field("con2", &self.con2())
                    .field("con3", &self.con3())
                    .field("con4", &self.con4())
                    .field("con5", &self.con5())
                    .field("con6", &self.con6())
                    .field("con7", &self.con7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - P1.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&mut self) -> CON0_W<GP1CONrs> {
                CON0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - P1.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&mut self) -> CON1_W<GP1CONrs> {
                CON1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - P1.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&mut self) -> CON2_W<GP1CONrs> {
                CON2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - P1.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&mut self) -> CON3_W<GP1CONrs> {
                CON3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - P1.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&mut self) -> CON4_W<GP1CONrs> {
                CON4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - P1.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&mut self) -> CON5_W<GP1CONrs> {
                CON5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - P1.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&mut self) -> CON6_W<GP1CONrs> {
                CON6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - P1.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&mut self) -> CON7_W<GP1CONrs> {
                CON7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 1 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1CON)"]
        pub struct GP1CONrs;
        impl crate::RegisterSpec for GP1CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1con::R`](R) reader structure"]
        impl crate::Readable for GP1CONrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1con::W`](W) writer structure"]
        impl crate::Writable for GP1CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1CON to value 0"]
        impl crate::Resettable for GP1CONrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1OE (rw) register accessor: GPIO Port 1 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1oe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1oe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1OE)\n\nFor information about available fields see [`mod@gp1oe`]
module"]
    pub type GP1OE = crate::Reg<gp1oe::GP1OErs>;
    #[doc = "GPIO Port 1 Output Enable"]
    pub mod gp1oe {
        #[doc = "Register `GP1OE` reader"]
        pub type R = crate::R<GP1OErs>;
        #[doc = "Register `GP1OE` writer"]
        pub type W = crate::W<GP1OErs>;
        #[doc = "Field `OE` reader - Output Enable"]
        pub type OE_R = crate::FieldReader;
        #[doc = "Field `OE` writer - Output Enable"]
        pub type OE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1OE").field("oe", &self.oe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&mut self) -> OE_W<GP1OErs> {
                OE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1oe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1oe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1OE)"]
        pub struct GP1OErs;
        impl crate::RegisterSpec for GP1OErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1oe::R`](R) reader structure"]
        impl crate::Readable for GP1OErs {}
        #[doc = "`write(|w| ..)` method takes [`gp1oe::W`](W) writer structure"]
        impl crate::Writable for GP1OErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1OE to value 0"]
        impl crate::Resettable for GP1OErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1IE (rw) register accessor: GPIO Port 1 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IE)\n\nFor information about available fields see [`mod@gp1ie`]
module"]
    pub type GP1IE = crate::Reg<gp1ie::GP1IErs>;
    #[doc = "GPIO Port 1 Input Path Enable"]
    pub mod gp1ie {
        #[doc = "Register `GP1IE` reader"]
        pub type R = crate::R<GP1IErs>;
        #[doc = "Register `GP1IE` writer"]
        pub type W = crate::W<GP1IErs>;
        #[doc = "Field `IE` reader - Input Enable"]
        pub type IE_R = crate::FieldReader;
        #[doc = "Field `IE` writer - Input Enable"]
        pub type IE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&self) -> IE_R {
                IE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1IE").field("ie", &self.ie()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&mut self) -> IE_W<GP1IErs> {
                IE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IE)"]
        pub struct GP1IErs;
        impl crate::RegisterSpec for GP1IErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1ie::R`](R) reader structure"]
        impl crate::Readable for GP1IErs {}
        #[doc = "`write(|w| ..)` method takes [`gp1ie::W`](W) writer structure"]
        impl crate::Writable for GP1IErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1IE to value 0"]
        impl crate::Resettable for GP1IErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1IN (rw) register accessor: GPIO Port 1 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IN)\n\nFor information about available fields see [`mod@gp1in`]
module"]
    pub type GP1IN = crate::Reg<gp1in::GP1INrs>;
    #[doc = "GPIO Port 1 Registered Data Input"]
    pub mod gp1in {
        #[doc = "Register `GP1IN` reader"]
        pub type R = crate::R<GP1INrs>;
        #[doc = "Register `GP1IN` writer"]
        pub type W = crate::W<GP1INrs>;
        #[doc = "Field `Y` reader - Data Input from Pad"]
        pub type Y_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Data Input from Pad"]
            #[inline(always)]
            pub fn y(&self) -> Y_R {
                Y_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1IN").field("y", &self.y()).finish()
            }
        }
        impl W {}
        #[doc = "GPIO Port 1 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IN)"]
        pub struct GP1INrs;
        impl crate::RegisterSpec for GP1INrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1in::R`](R) reader structure"]
        impl crate::Readable for GP1INrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1in::W`](W) writer structure"]
        impl crate::Writable for GP1INrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1IN to value 0"]
        impl crate::Resettable for GP1INrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1OUT (rw) register accessor: GPIO Port 1 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1OUT)\n\nFor information about available fields see [`mod@gp1out`]
module"]
    pub type GP1OUT = crate::Reg<gp1out::GP1OUTrs>;
    #[doc = "GPIO Port 1 Data Output"]
    pub mod gp1out {
        #[doc = "Register `GP1OUT` reader"]
        pub type R = crate::R<GP1OUTrs>;
        #[doc = "Register `GP1OUT` writer"]
        pub type W = crate::W<GP1OUTrs>;
        #[doc = "Field `A` reader - Data Output to Pad"]
        pub type A_R = crate::FieldReader;
        #[doc = "Field `A` writer - Data Output to Pad"]
        pub type A_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&self) -> A_R {
                A_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1OUT").field("a", &self.a()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&mut self) -> A_W<GP1OUTrs> {
                A_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1OUT)"]
        pub struct GP1OUTrs;
        impl crate::RegisterSpec for GP1OUTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1out::R`](R) reader structure"]
        impl crate::Readable for GP1OUTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1out::W`](W) writer structure"]
        impl crate::Writable for GP1OUTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1OUT to value 0"]
        impl crate::Resettable for GP1OUTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1SET (rw) register accessor: GPIO Port 1 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1SET)\n\nFor information about available fields see [`mod@gp1set`]
module"]
    pub type GP1SET = crate::Reg<gp1set::GP1SETrs>;
    #[doc = "GPIO Port 1 Data Out Set"]
    pub mod gp1set {
        #[doc = "Register `GP1SET` reader"]
        pub type R = crate::R<GP1SETrs>;
        #[doc = "Register `GP1SET` writer"]
        pub type W = crate::W<GP1SETrs>;
        #[doc = "Field `SETUP` writer - Set the Output HIGH for the Pin"]
        pub type SETUP_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1SET").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output HIGH for the Pin"]
            #[inline(always)]
            pub fn setup(&mut self) -> SETUP_W<GP1SETrs> {
                SETUP_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1SET)"]
        pub struct GP1SETrs;
        impl crate::RegisterSpec for GP1SETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1set::R`](R) reader structure"]
        impl crate::Readable for GP1SETrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1set::W`](W) writer structure"]
        impl crate::Writable for GP1SETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1SET to value 0"]
        impl crate::Resettable for GP1SETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1CLR (rw) register accessor: GPIO Port 1 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1CLR)\n\nFor information about available fields see [`mod@gp1clr`]
module"]
    pub type GP1CLR = crate::Reg<gp1clr::GP1CLRrs>;
    #[doc = "GPIO Port 1 Data Out Clear"]
    pub mod gp1clr {
        #[doc = "Register `GP1CLR` reader"]
        pub type R = crate::R<GP1CLRrs>;
        #[doc = "Register `GP1CLR` writer"]
        pub type W = crate::W<GP1CLRrs>;
        #[doc = "Field `CLR` writer - Set the Output Low for the Port Pin"]
        pub type CLR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1CLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output Low for the Port Pin"]
            #[inline(always)]
            pub fn clr(&mut self) -> CLR_W<GP1CLRrs> {
                CLR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1CLR)"]
        pub struct GP1CLRrs;
        impl crate::RegisterSpec for GP1CLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1clr::R`](R) reader structure"]
        impl crate::Readable for GP1CLRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1clr::W`](W) writer structure"]
        impl crate::Writable for GP1CLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1CLR to value 0"]
        impl crate::Resettable for GP1CLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1TGL (rw) register accessor: GPIO Port 1 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1tgl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1tgl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1TGL)\n\nFor information about available fields see [`mod@gp1tgl`]
module"]
    pub type GP1TGL = crate::Reg<gp1tgl::GP1TGLrs>;
    #[doc = "GPIO Port 1 Pin Toggle"]
    pub mod gp1tgl {
        #[doc = "Register `GP1TGL` reader"]
        pub type R = crate::R<GP1TGLrs>;
        #[doc = "Register `GP1TGL` writer"]
        pub type W = crate::W<GP1TGLrs>;
        #[doc = "Field `TGL` writer - Toggle the Output of the Port Pin"]
        pub type TGL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1TGL").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Toggle the Output of the Port Pin"]
            #[inline(always)]
            pub fn tgl(&mut self) -> TGL_W<GP1TGLrs> {
                TGL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1tgl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1tgl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1TGL)"]
        pub struct GP1TGLrs;
        impl crate::RegisterSpec for GP1TGLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1tgl::R`](R) reader structure"]
        impl crate::Readable for GP1TGLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1tgl::W`](W) writer structure"]
        impl crate::Writable for GP1TGLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1TGL to value 0"]
        impl crate::Resettable for GP1TGLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1ODE (rw) register accessor: GPIO Port 1 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1ODE)\n\nFor information about available fields see [`mod@gp1ode`]
module"]
    pub type GP1ODE = crate::Reg<gp1ode::GP1ODErs>;
    #[doc = "GPIO Port 1 Open Drain Enable"]
    pub mod gp1ode {
        #[doc = "Register `GP1ODE` reader"]
        pub type R = crate::R<GP1ODErs>;
        #[doc = "Register `GP1ODE` writer"]
        pub type W = crate::W<GP1ODErs>;
        #[doc = "Field `ODE` reader - Open Drain Enable"]
        pub type ODE_R = crate::FieldReader;
        #[doc = "Field `ODE` writer - Open Drain Enable"]
        pub type ODE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&self) -> ODE_R {
                ODE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1ODE").field("ode", &self.ode()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&mut self) -> ODE_W<GP1ODErs> {
                ODE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1ODE)"]
        pub struct GP1ODErs;
        impl crate::RegisterSpec for GP1ODErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1ode::R`](R) reader structure"]
        impl crate::Readable for GP1ODErs {}
        #[doc = "`write(|w| ..)` method takes [`gp1ode::W`](W) writer structure"]
        impl crate::Writable for GP1ODErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1ODE to value 0"]
        impl crate::Resettable for GP1ODErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1IS (rw) register accessor: GPIO Port 1 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1is::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1is::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IS)\n\nFor information about available fields see [`mod@gp1is`]
module"]
    pub type GP1IS = crate::Reg<gp1is::GP1ISrs>;
    #[doc = "GPIO Port 1 Input Select"]
    pub mod gp1is {
        #[doc = "Register `GP1IS` reader"]
        pub type R = crate::R<GP1ISrs>;
        #[doc = "Register `GP1IS` writer"]
        pub type W = crate::W<GP1ISrs>;
        #[doc = "Field `ISEL` reader - Input Select"]
        pub type ISEL_R = crate::FieldReader;
        #[doc = "Field `ISEL` writer - Input Select"]
        pub type ISEL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&self) -> ISEL_R {
                ISEL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1IS").field("isel", &self.isel()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&mut self) -> ISEL_W<GP1ISrs> {
                ISEL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1is::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1is::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IS)"]
        pub struct GP1ISrs;
        impl crate::RegisterSpec for GP1ISrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1is::R`](R) reader structure"]
        impl crate::Readable for GP1ISrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1is::W`](W) writer structure"]
        impl crate::Writable for GP1ISrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1IS to value 0xff"]
        impl crate::Resettable for GP1ISrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP1PE (rw) register accessor: GPIO Port 1 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1pe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1pe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1PE)\n\nFor information about available fields see [`mod@gp1pe`]
module"]
    pub type GP1PE = crate::Reg<gp1pe::GP1PErs>;
    #[doc = "GPIO Port 1 Pull Enable"]
    pub mod gp1pe {
        #[doc = "Register `GP1PE` reader"]
        pub type R = crate::R<GP1PErs>;
        #[doc = "Register `GP1PE` writer"]
        pub type W = crate::W<GP1PErs>;
        #[doc = "Field `PE` reader - Pull Enable"]
        pub type PE_R = crate::FieldReader;
        #[doc = "Field `PE` writer - Pull Enable"]
        pub type PE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1PE").field("pe", &self.pe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W<GP1PErs> {
                PE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1pe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1pe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1PE)"]
        pub struct GP1PErs;
        impl crate::RegisterSpec for GP1PErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1pe::R`](R) reader structure"]
        impl crate::Readable for GP1PErs {}
        #[doc = "`write(|w| ..)` method takes [`gp1pe::W`](W) writer structure"]
        impl crate::Writable for GP1PErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1PE to value 0"]
        impl crate::Resettable for GP1PErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1PS (rw) register accessor: GPIO Port 1 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ps::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ps::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1PS)\n\nFor information about available fields see [`mod@gp1ps`]
module"]
    pub type GP1PS = crate::Reg<gp1ps::GP1PSrs>;
    #[doc = "GPIO Port 1 Pull Select"]
    pub mod gp1ps {
        #[doc = "Register `GP1PS` reader"]
        pub type R = crate::R<GP1PSrs>;
        #[doc = "Register `GP1PS` writer"]
        pub type W = crate::W<GP1PSrs>;
        #[doc = "Field `PS` reader - Pull Select"]
        pub type PS_R = crate::FieldReader;
        #[doc = "Field `PS` writer - Pull Select"]
        pub type PS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1PS").field("ps", &self.ps()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W<GP1PSrs> {
                PS_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ps::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ps::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1PS)"]
        pub struct GP1PSrs;
        impl crate::RegisterSpec for GP1PSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1ps::R`](R) reader structure"]
        impl crate::Readable for GP1PSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1ps::W`](W) writer structure"]
        impl crate::Writable for GP1PSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1PS to value 0xff"]
        impl crate::Resettable for GP1PSrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP1SR (rw) register accessor: GPIO Port 1 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1SR)\n\nFor information about available fields see [`mod@gp1sr`]
module"]
    pub type GP1SR = crate::Reg<gp1sr::GP1SRrs>;
    #[doc = "GPIO Port 1 Slew Rate"]
    pub mod gp1sr {
        #[doc = "Register `GP1SR` reader"]
        pub type R = crate::R<GP1SRrs>;
        #[doc = "Register `GP1SR` writer"]
        pub type W = crate::W<GP1SRrs>;
        #[doc = "Field `SR` reader - Slew Rate"]
        pub type SR_R = crate::FieldReader;
        #[doc = "Field `SR` writer - Slew Rate"]
        pub type SR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&self) -> SR_R {
                SR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1SR").field("sr", &self.sr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&mut self) -> SR_W<GP1SRrs> {
                SR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1SR)"]
        pub struct GP1SRrs;
        impl crate::RegisterSpec for GP1SRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1sr::R`](R) reader structure"]
        impl crate::Readable for GP1SRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1sr::W`](W) writer structure"]
        impl crate::Writable for GP1SRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1SR to value 0"]
        impl crate::Resettable for GP1SRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1DS (rw) register accessor: GPIO Port 1 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ds::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ds::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1DS)\n\nFor information about available fields see [`mod@gp1ds`]
module"]
    pub type GP1DS = crate::Reg<gp1ds::GP1DSrs>;
    #[doc = "GPIO Port 1 Drive Select"]
    pub mod gp1ds {
        #[doc = "Register `GP1DS` reader"]
        pub type R = crate::R<GP1DSrs>;
        #[doc = "Register `GP1DS` writer"]
        pub type W = crate::W<GP1DSrs>;
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS0 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS0> for u8 {
            #[inline(always)]
            fn from(variant: DS0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS0 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS0 {}
        #[doc = "Field `DS0` reader - Drive Select"]
        pub type DS0_R = crate::FieldReader<DS0>;
        impl DS0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS0 {
                match self.bits {
                    0 => DS0::Strength1,
                    1 => DS0::Strength2,
                    2 => DS0::Strength3,
                    3 => DS0::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS0::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS0::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS0::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS0::Strength4
            }
        }
        #[doc = "Field `DS0` writer - Drive Select"]
        pub type DS0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS0, crate::Safe>;
        impl<'a, REG> DS0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS1 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS1> for u8 {
            #[inline(always)]
            fn from(variant: DS1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS1 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS1 {}
        #[doc = "Field `DS1` reader - Drive Select"]
        pub type DS1_R = crate::FieldReader<DS1>;
        impl DS1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS1 {
                match self.bits {
                    0 => DS1::Strength1,
                    1 => DS1::Strength2,
                    2 => DS1::Strength3,
                    3 => DS1::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS1::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS1::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS1::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS1::Strength4
            }
        }
        #[doc = "Field `DS1` writer - Drive Select"]
        pub type DS1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS1, crate::Safe>;
        impl<'a, REG> DS1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS2 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS2> for u8 {
            #[inline(always)]
            fn from(variant: DS2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS2 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS2 {}
        #[doc = "Field `DS2` reader - Drive Select"]
        pub type DS2_R = crate::FieldReader<DS2>;
        impl DS2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS2 {
                match self.bits {
                    0 => DS2::Strength1,
                    1 => DS2::Strength2,
                    2 => DS2::Strength3,
                    3 => DS2::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS2::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS2::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS2::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS2::Strength4
            }
        }
        #[doc = "Field `DS2` writer - Drive Select"]
        pub type DS2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS2, crate::Safe>;
        impl<'a, REG> DS2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS3 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS3> for u8 {
            #[inline(always)]
            fn from(variant: DS3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS3 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS3 {}
        #[doc = "Field `DS3` reader - Drive Select"]
        pub type DS3_R = crate::FieldReader<DS3>;
        impl DS3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS3 {
                match self.bits {
                    0 => DS3::Strength1,
                    1 => DS3::Strength2,
                    2 => DS3::Strength3,
                    3 => DS3::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS3::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS3::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS3::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS3::Strength4
            }
        }
        #[doc = "Field `DS3` writer - Drive Select"]
        pub type DS3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS3, crate::Safe>;
        impl<'a, REG> DS3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS4 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS4> for u8 {
            #[inline(always)]
            fn from(variant: DS4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS4 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS4 {}
        #[doc = "Field `DS4` reader - Drive Select"]
        pub type DS4_R = crate::FieldReader<DS4>;
        impl DS4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS4 {
                match self.bits {
                    0 => DS4::Strength1,
                    1 => DS4::Strength2,
                    2 => DS4::Strength3,
                    3 => DS4::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS4::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS4::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS4::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS4::Strength4
            }
        }
        #[doc = "Field `DS4` writer - Drive Select"]
        pub type DS4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS4, crate::Safe>;
        impl<'a, REG> DS4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS5 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS5> for u8 {
            #[inline(always)]
            fn from(variant: DS5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS5 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS5 {}
        #[doc = "Field `DS5` reader - Drive Select"]
        pub type DS5_R = crate::FieldReader<DS5>;
        impl DS5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS5 {
                match self.bits {
                    0 => DS5::Strength1,
                    1 => DS5::Strength2,
                    2 => DS5::Strength3,
                    3 => DS5::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS5::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS5::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS5::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS5::Strength4
            }
        }
        #[doc = "Field `DS5` writer - Drive Select"]
        pub type DS5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS5, crate::Safe>;
        impl<'a, REG> DS5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS6 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS6> for u8 {
            #[inline(always)]
            fn from(variant: DS6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS6 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS6 {}
        #[doc = "Field `DS6` reader - Drive Select"]
        pub type DS6_R = crate::FieldReader<DS6>;
        impl DS6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS6 {
                match self.bits {
                    0 => DS6::Strength1,
                    1 => DS6::Strength2,
                    2 => DS6::Strength3,
                    3 => DS6::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS6::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS6::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS6::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS6::Strength4
            }
        }
        #[doc = "Field `DS6` writer - Drive Select"]
        pub type DS6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS6, crate::Safe>;
        impl<'a, REG> DS6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS7 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS7> for u8 {
            #[inline(always)]
            fn from(variant: DS7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS7 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS7 {}
        #[doc = "Field `DS7` reader - Drive Select"]
        pub type DS7_R = crate::FieldReader<DS7>;
        impl DS7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS7 {
                match self.bits {
                    0 => DS7::Strength1,
                    1 => DS7::Strength2,
                    2 => DS7::Strength3,
                    3 => DS7::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS7::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS7::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS7::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS7::Strength4
            }
        }
        #[doc = "Field `DS7` writer - Drive Select"]
        pub type DS7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS7, crate::Safe>;
        impl<'a, REG> DS7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength4)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&self) -> DS0_R {
                DS0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&self) -> DS1_R {
                DS1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&self) -> DS2_R {
                DS2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&self) -> DS3_R {
                DS3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&self) -> DS4_R {
                DS4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&self) -> DS5_R {
                DS5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&self) -> DS6_R {
                DS6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&self) -> DS7_R {
                DS7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1DS")
                    .field("ds0", &self.ds0())
                    .field("ds1", &self.ds1())
                    .field("ds2", &self.ds2())
                    .field("ds3", &self.ds3())
                    .field("ds4", &self.ds4())
                    .field("ds5", &self.ds5())
                    .field("ds6", &self.ds6())
                    .field("ds7", &self.ds7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&mut self) -> DS0_W<GP1DSrs> {
                DS0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&mut self) -> DS1_W<GP1DSrs> {
                DS1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&mut self) -> DS2_W<GP1DSrs> {
                DS2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&mut self) -> DS3_W<GP1DSrs> {
                DS3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&mut self) -> DS4_W<GP1DSrs> {
                DS4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&mut self) -> DS5_W<GP1DSrs> {
                DS5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&mut self) -> DS6_W<GP1DSrs> {
                DS6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&mut self) -> DS7_W<GP1DSrs> {
                DS7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 1 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ds::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ds::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1DS)"]
        pub struct GP1DSrs;
        impl crate::RegisterSpec for GP1DSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1ds::R`](R) reader structure"]
        impl crate::Readable for GP1DSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1ds::W`](W) writer structure"]
        impl crate::Writable for GP1DSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1DS to value 0"]
        impl crate::Resettable for GP1DSrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1PWR (rw) register accessor: GPIO Port 1 Power Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1pwr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1pwr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1PWR)\n\nFor information about available fields see [`mod@gp1pwr`]
module"]
    pub type GP1PWR = crate::Reg<gp1pwr::GP1PWRrs>;
    #[doc = "GPIO Port 1 Power Select"]
    pub mod gp1pwr {
        #[doc = "Register `GP1PWR` reader"]
        pub type R = crate::R<GP1PWRrs>;
        #[doc = "Register `GP1PWR` writer"]
        pub type W = crate::W<GP1PWRrs>;
        #[doc = "Field `PWR` reader - Pad Power Select"]
        pub type PWR_R = crate::FieldReader;
        #[doc = "Field `PWR` writer - Pad Power Select"]
        pub type PWR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pad Power Select"]
            #[inline(always)]
            pub fn pwr(&self) -> PWR_R {
                PWR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1PWR").field("pwr", &self.pwr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pad Power Select"]
            #[inline(always)]
            pub fn pwr(&mut self) -> PWR_W<GP1PWRrs> {
                PWR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 1 Power Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1pwr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1pwr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1PWR)"]
        pub struct GP1PWRrs;
        impl crate::RegisterSpec for GP1PWRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1pwr::R`](R) reader structure"]
        impl crate::Readable for GP1PWRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1pwr::W`](W) writer structure"]
        impl crate::Writable for GP1PWRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1PWR to value 0xff"]
        impl crate::Resettable for GP1PWRrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP1POL (rw) register accessor: GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1pol::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1pol::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1POL)\n\nFor information about available fields see [`mod@gp1pol`]
module"]
    pub type GP1POL = crate::Reg<gp1pol::GP1POLrs>;
    #[doc = "GPIO Interrupt Polarity Select"]
    pub mod gp1pol {
        #[doc = "Register `GP1POL` reader"]
        pub type R = crate::R<GP1POLrs>;
        #[doc = "Register `GP1POL` writer"]
        pub type W = crate::W<GP1POLrs>;
        #[doc = "Field `INTPOL` reader - Parametric Output"]
        pub type INTPOL_R = crate::FieldReader;
        #[doc = "Field `INTPOL` writer - Parametric Output"]
        pub type INTPOL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&self) -> INTPOL_R {
                INTPOL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1POL")
                    .field("intpol", &self.intpol())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&mut self) -> INTPOL_W<GP1POLrs> {
                INTPOL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1pol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1pol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1POL)"]
        pub struct GP1POLrs;
        impl crate::RegisterSpec for GP1POLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1pol::R`](R) reader structure"]
        impl crate::Readable for GP1POLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1pol::W`](W) writer structure"]
        impl crate::Writable for GP1POLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1POL to value 0"]
        impl crate::Resettable for GP1POLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1IENA (rw) register accessor: InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1iena::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1iena::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IENA)\n\nFor information about available fields see [`mod@gp1iena`]
module"]
    pub type GP1IENA = crate::Reg<gp1iena::GP1IENArs>;
    #[doc = "InterruptA Enable"]
    pub mod gp1iena {
        #[doc = "Register `GP1IENA` reader"]
        pub type R = crate::R<GP1IENArs>;
        #[doc = "Register `GP1IENA` writer"]
        pub type W = crate::W<GP1IENArs>;
        #[doc = "Field `INTAEN` reader - InterruptA Enable"]
        pub type INTAEN_R = crate::FieldReader;
        #[doc = "Field `INTAEN` writer - InterruptA Enable"]
        pub type INTAEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&self) -> INTAEN_R {
                INTAEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1IENA")
                    .field("intaen", &self.intaen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&mut self) -> INTAEN_W<GP1IENArs> {
                INTAEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1iena::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1iena::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IENA)"]
        pub struct GP1IENArs;
        impl crate::RegisterSpec for GP1IENArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1iena::R`](R) reader structure"]
        impl crate::Readable for GP1IENArs {}
        #[doc = "`write(|w| ..)` method takes [`gp1iena::W`](W) writer structure"]
        impl crate::Writable for GP1IENArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1IENA to value 0"]
        impl crate::Resettable for GP1IENArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1IENB (rw) register accessor: InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ienb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ienb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IENB)\n\nFor information about available fields see [`mod@gp1ienb`]
module"]
    pub type GP1IENB = crate::Reg<gp1ienb::GP1IENBrs>;
    #[doc = "InterruptB Enable"]
    pub mod gp1ienb {
        #[doc = "Register `GP1IENB` reader"]
        pub type R = crate::R<GP1IENBrs>;
        #[doc = "Register `GP1IENB` writer"]
        pub type W = crate::W<GP1IENBrs>;
        #[doc = "Field `INTBEN` reader - InterruptB Enable"]
        pub type INTBEN_R = crate::FieldReader;
        #[doc = "Field `INTBEN` writer - InterruptB Enable"]
        pub type INTBEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&self) -> INTBEN_R {
                INTBEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1IENB")
                    .field("intben", &self.intben())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&mut self) -> INTBEN_W<GP1IENBrs> {
                INTBEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1ienb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1ienb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1IENB)"]
        pub struct GP1IENBrs;
        impl crate::RegisterSpec for GP1IENBrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1ienb::R`](R) reader structure"]
        impl crate::Readable for GP1IENBrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1ienb::W`](W) writer structure"]
        impl crate::Writable for GP1IENBrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1IENB to value 0"]
        impl crate::Resettable for GP1IENBrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP1INT (rw) register accessor: Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1int::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1int::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1INT)\n\nFor information about available fields see [`mod@gp1int`]
module"]
    pub type GP1INT = crate::Reg<gp1int::GP1INTrs>;
    #[doc = "Interrupt Status"]
    pub mod gp1int {
        #[doc = "Register `GP1INT` reader"]
        pub type R = crate::R<GP1INTrs>;
        #[doc = "Register `GP1INT` writer"]
        pub type W = crate::W<GP1INTrs>;
        #[doc = "Field `INTSTATUS` reader - Interrupt Status"]
        pub type INTSTATUS_R = crate::FieldReader;
        #[doc = "Field `INTSTATUS` writer - Interrupt Status"]
        pub type INTSTATUS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&self) -> INTSTATUS_R {
                INTSTATUS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP1INT")
                    .field("intstatus", &self.intstatus())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&mut self) -> INTSTATUS_W<GP1INTrs> {
                INTSTATUS_W::new(self, 0)
            }
        }
        #[doc = "Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp1int::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp1int::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP1INT)"]
        pub struct GP1INTrs;
        impl crate::RegisterSpec for GP1INTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp1int::R`](R) reader structure"]
        impl crate::Readable for GP1INTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp1int::W`](W) writer structure"]
        impl crate::Writable for GP1INTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP1INT to value 0"]
        impl crate::Resettable for GP1INTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2CON (rw) register accessor: GPIO Port 2 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2CON)\n\nFor information about available fields see [`mod@gp2con`]
module"]
    pub type GP2CON = crate::Reg<gp2con::GP2CONrs>;
    #[doc = "GPIO Port 2 Configuration"]
    pub mod gp2con {
        #[doc = "Register `GP2CON` reader"]
        pub type R = crate::R<GP2CONrs>;
        #[doc = "Register `GP2CON` writer"]
        pub type W = crate::W<GP2CONrs>;
        #[doc = "P2.0 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON0 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: ADC Convert"]
            Adcconv = 1,
            #[doc = "2: Comparator Data Input 2"]
            Comdin2 = 2,
            #[doc = "3: PLA GPIO Input\\[8\\]"]
            Plai8 = 3,
        }
        impl From<CON0> for u8 {
            #[inline(always)]
            fn from(variant: CON0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON0 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON0 {}
        #[doc = "Field `CON0` reader - P2.0 Configuration Bits"]
        pub type CON0_R = crate::FieldReader<CON0>;
        impl CON0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON0 {
                match self.bits {
                    0 => CON0::Gpio,
                    1 => CON0::Adcconv,
                    2 => CON0::Comdin2,
                    3 => CON0::Plai8,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON0::Gpio
            }
            #[doc = "ADC Convert"]
            #[inline(always)]
            pub fn is_adcconv(&self) -> bool {
                *self == CON0::Adcconv
            }
            #[doc = "Comparator Data Input 2"]
            #[inline(always)]
            pub fn is_comdin2(&self) -> bool {
                *self == CON0::Comdin2
            }
            #[doc = "PLA GPIO Input\\[8\\]"]
            #[inline(always)]
            pub fn is_plai8(&self) -> bool {
                *self == CON0::Plai8
            }
        }
        #[doc = "Field `CON0` writer - P2.0 Configuration Bits"]
        pub type CON0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON0, crate::Safe>;
        impl<'a, REG> CON0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Gpio)
            }
            #[doc = "ADC Convert"]
            #[inline(always)]
            pub fn adcconv(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Adcconv)
            }
            #[doc = "Comparator Data Input 2"]
            #[inline(always)]
            pub fn comdin2(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Comdin2)
            }
            #[doc = "PLA GPIO Input\\[8\\]"]
            #[inline(always)]
            pub fn plai8(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Plai8)
            }
        }
        #[doc = "P2.1 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON1 {
            #[doc = "0: GPIO/IRQ2"]
            Gpioirq2 = 0,
            #[doc = "1: External Clock in"]
            Eclkin = 1,
            #[doc = "2: Comparater Data Input"]
            Compdin3 = 2,
            #[doc = "3: PLAI\\[9\\]"]
            Plai9 = 3,
        }
        impl From<CON1> for u8 {
            #[inline(always)]
            fn from(variant: CON1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON1 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON1 {}
        #[doc = "Field `CON1` reader - P2.1 Configuration Bits"]
        pub type CON1_R = crate::FieldReader<CON1>;
        impl CON1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON1 {
                match self.bits {
                    0 => CON1::Gpioirq2,
                    1 => CON1::Eclkin,
                    2 => CON1::Compdin3,
                    3 => CON1::Plai9,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO/IRQ2"]
            #[inline(always)]
            pub fn is_gpioirq2(&self) -> bool {
                *self == CON1::Gpioirq2
            }
            #[doc = "External Clock in"]
            #[inline(always)]
            pub fn is_eclkin(&self) -> bool {
                *self == CON1::Eclkin
            }
            #[doc = "Comparater Data Input"]
            #[inline(always)]
            pub fn is_compdin3(&self) -> bool {
                *self == CON1::Compdin3
            }
            #[doc = "PLAI\\[9\\]"]
            #[inline(always)]
            pub fn is_plai9(&self) -> bool {
                *self == CON1::Plai9
            }
        }
        #[doc = "Field `CON1` writer - P2.1 Configuration Bits"]
        pub type CON1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON1, crate::Safe>;
        impl<'a, REG> CON1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ2"]
            #[inline(always)]
            pub fn gpioirq2(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Gpioirq2)
            }
            #[doc = "External Clock in"]
            #[inline(always)]
            pub fn eclkin(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Eclkin)
            }
            #[doc = "Comparater Data Input"]
            #[inline(always)]
            pub fn compdin3(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Compdin3)
            }
            #[doc = "PLAI\\[9\\]"]
            #[inline(always)]
            pub fn plai9(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Plai9)
            }
        }
        #[doc = "P2.2 Configuration Bits\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON2 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: Power Reset"]
            Por = 1,
            #[doc = "2: Clock Output"]
            Clkout = 2,
            #[doc = "3: Serial Wire Output"]
            Swo = 3,
        }
        impl From<CON2> for u8 {
            #[inline(always)]
            fn from(variant: CON2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON2 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON2 {}
        #[doc = "Field `CON2` reader - P2.2 Configuration Bits"]
        pub type CON2_R = crate::FieldReader<CON2>;
        impl CON2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON2 {
                match self.bits {
                    0 => CON2::Gpio,
                    1 => CON2::Por,
                    2 => CON2::Clkout,
                    3 => CON2::Swo,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON2::Gpio
            }
            #[doc = "Power Reset"]
            #[inline(always)]
            pub fn is_por(&self) -> bool {
                *self == CON2::Por
            }
            #[doc = "Clock Output"]
            #[inline(always)]
            pub fn is_clkout(&self) -> bool {
                *self == CON2::Clkout
            }
            #[doc = "Serial Wire Output"]
            #[inline(always)]
            pub fn is_swo(&self) -> bool {
                *self == CON2::Swo
            }
        }
        #[doc = "Field `CON2` writer - P2.2 Configuration Bits"]
        pub type CON2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON2, crate::Safe>;
        impl<'a, REG> CON2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Gpio)
            }
            #[doc = "Power Reset"]
            #[inline(always)]
            pub fn por(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Por)
            }
            #[doc = "Clock Output"]
            #[inline(always)]
            pub fn clkout(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Clkout)
            }
            #[doc = "Serial Wire Output"]
            #[inline(always)]
            pub fn swo(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Swo)
            }
        }
        #[doc = "P2.3 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON3 {
            #[doc = "0: GPIO/BM"]
            Gpiobm = 0,
            #[doc = "3: PLAI\\[10\\]"]
            Plai10 = 3,
        }
        impl From<CON3> for u8 {
            #[inline(always)]
            fn from(variant: CON3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON3 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON3 {}
        #[doc = "Field `CON3` reader - P2.3 Configuration Bits"]
        pub type CON3_R = crate::FieldReader<CON3>;
        impl CON3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON3> {
                match self.bits {
                    0 => Some(CON3::Gpiobm),
                    3 => Some(CON3::Plai10),
                    _ => None,
                }
            }
            #[doc = "GPIO/BM"]
            #[inline(always)]
            pub fn is_gpiobm(&self) -> bool {
                *self == CON3::Gpiobm
            }
            #[doc = "PLAI\\[10\\]"]
            #[inline(always)]
            pub fn is_plai10(&self) -> bool {
                *self == CON3::Plai10
            }
        }
        #[doc = "Field `CON3` writer - P2.3 Configuration Bits"]
        pub type CON3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON3>;
        impl<'a, REG> CON3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/BM"]
            #[inline(always)]
            pub fn gpiobm(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Gpiobm)
            }
            #[doc = "PLAI\\[10\\]"]
            #[inline(always)]
            pub fn plai10(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Plai10)
            }
        }
        #[doc = "P2.4 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON4 {
            #[doc = "0: GPIO/IRQ4"]
            Gipo = 0,
            #[doc = "1: SPI2 MOSI"]
            Mosi2 = 1,
            #[doc = "2: UART1 RX of ITLA package"]
            Sin1 = 2,
            #[doc = "3: PLAO\\[18\\]"]
            Plao18 = 3,
        }
        impl From<CON4> for u8 {
            #[inline(always)]
            fn from(variant: CON4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON4 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON4 {}
        #[doc = "Field `CON4` reader - P2.4 Configuration Bits"]
        pub type CON4_R = crate::FieldReader<CON4>;
        impl CON4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON4 {
                match self.bits {
                    0 => CON4::Gipo,
                    1 => CON4::Mosi2,
                    2 => CON4::Sin1,
                    3 => CON4::Plao18,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO/IRQ4"]
            #[inline(always)]
            pub fn is_gipo(&self) -> bool {
                *self == CON4::Gipo
            }
            #[doc = "SPI2 MOSI"]
            #[inline(always)]
            pub fn is_mosi2(&self) -> bool {
                *self == CON4::Mosi2
            }
            #[doc = "UART1 RX of ITLA package"]
            #[inline(always)]
            pub fn is_sin1(&self) -> bool {
                *self == CON4::Sin1
            }
            #[doc = "PLAO\\[18\\]"]
            #[inline(always)]
            pub fn is_plao18(&self) -> bool {
                *self == CON4::Plao18
            }
        }
        #[doc = "Field `CON4` writer - P2.4 Configuration Bits"]
        pub type CON4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON4, crate::Safe>;
        impl<'a, REG> CON4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ4"]
            #[inline(always)]
            pub fn gipo(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Gipo)
            }
            #[doc = "SPI2 MOSI"]
            #[inline(always)]
            pub fn mosi2(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Mosi2)
            }
            #[doc = "UART1 RX of ITLA package"]
            #[inline(always)]
            pub fn sin1(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Sin1)
            }
            #[doc = "PLAO\\[18\\]"]
            #[inline(always)]
            pub fn plao18(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Plao18)
            }
        }
        #[doc = "P2.5 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON5 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: Spi2 Miso"]
            Miso2 = 1,
            #[doc = "2: UART1 TX of ITLA package"]
            Sout1 = 2,
            #[doc = "3: PLAO\\[19\\]"]
            Plao19 = 3,
        }
        impl From<CON5> for u8 {
            #[inline(always)]
            fn from(variant: CON5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON5 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON5 {}
        #[doc = "Field `CON5` reader - P2.5 Configuration Bits"]
        pub type CON5_R = crate::FieldReader<CON5>;
        impl CON5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON5 {
                match self.bits {
                    0 => CON5::Gpio,
                    1 => CON5::Miso2,
                    2 => CON5::Sout1,
                    3 => CON5::Plao19,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON5::Gpio
            }
            #[doc = "Spi2 Miso"]
            #[inline(always)]
            pub fn is_miso2(&self) -> bool {
                *self == CON5::Miso2
            }
            #[doc = "UART1 TX of ITLA package"]
            #[inline(always)]
            pub fn is_sout1(&self) -> bool {
                *self == CON5::Sout1
            }
            #[doc = "PLAO\\[19\\]"]
            #[inline(always)]
            pub fn is_plao19(&self) -> bool {
                *self == CON5::Plao19
            }
        }
        #[doc = "Field `CON5` writer - P2.5 Configuration Bits"]
        pub type CON5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON5, crate::Safe>;
        impl<'a, REG> CON5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Gpio)
            }
            #[doc = "Spi2 Miso"]
            #[inline(always)]
            pub fn miso2(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Miso2)
            }
            #[doc = "UART1 TX of ITLA package"]
            #[inline(always)]
            pub fn sout1(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Sout1)
            }
            #[doc = "PLAO\\[19\\]"]
            #[inline(always)]
            pub fn plao19(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Plao19)
            }
        }
        #[doc = "P2.6 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON6 {
            #[doc = "0: GPIO/IRQ5"]
            Gpioirq5 = 0,
            #[doc = "1: SPI 2 SCLK"]
            Sclk2 = 1,
            #[doc = "2: I2C1 SCL of ITLA Package"]
            Scl1 = 2,
            #[doc = "3: PLAO\\[20\\]"]
            Plao20 = 3,
        }
        impl From<CON6> for u8 {
            #[inline(always)]
            fn from(variant: CON6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON6 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON6 {}
        #[doc = "Field `CON6` reader - P2.6 Configuration Bits"]
        pub type CON6_R = crate::FieldReader<CON6>;
        impl CON6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON6 {
                match self.bits {
                    0 => CON6::Gpioirq5,
                    1 => CON6::Sclk2,
                    2 => CON6::Scl1,
                    3 => CON6::Plao20,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO/IRQ5"]
            #[inline(always)]
            pub fn is_gpioirq5(&self) -> bool {
                *self == CON6::Gpioirq5
            }
            #[doc = "SPI 2 SCLK"]
            #[inline(always)]
            pub fn is_sclk2(&self) -> bool {
                *self == CON6::Sclk2
            }
            #[doc = "I2C1 SCL of ITLA Package"]
            #[inline(always)]
            pub fn is_scl1(&self) -> bool {
                *self == CON6::Scl1
            }
            #[doc = "PLAO\\[20\\]"]
            #[inline(always)]
            pub fn is_plao20(&self) -> bool {
                *self == CON6::Plao20
            }
        }
        #[doc = "Field `CON6` writer - P2.6 Configuration Bits"]
        pub type CON6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON6, crate::Safe>;
        impl<'a, REG> CON6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ5"]
            #[inline(always)]
            pub fn gpioirq5(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Gpioirq5)
            }
            #[doc = "SPI 2 SCLK"]
            #[inline(always)]
            pub fn sclk2(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Sclk2)
            }
            #[doc = "I2C1 SCL of ITLA Package"]
            #[inline(always)]
            pub fn scl1(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Scl1)
            }
            #[doc = "PLAO\\[20\\]"]
            #[inline(always)]
            pub fn plao20(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Plao20)
            }
        }
        #[doc = "P2.7 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON7 {
            #[doc = "0: GPIO/IRQ6"]
            Gpioirq6 = 0,
            #[doc = "1: SPI 2 CS"]
            Cs2 = 1,
            #[doc = "2: I2C1 SDA of ITLA package"]
            Sda1 = 2,
            #[doc = "3: PLAO\\[21\\]"]
            Plao21 = 3,
        }
        impl From<CON7> for u8 {
            #[inline(always)]
            fn from(variant: CON7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON7 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON7 {}
        #[doc = "Field `CON7` reader - P2.7 Configuration Bits"]
        pub type CON7_R = crate::FieldReader<CON7>;
        impl CON7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON7 {
                match self.bits {
                    0 => CON7::Gpioirq6,
                    1 => CON7::Cs2,
                    2 => CON7::Sda1,
                    3 => CON7::Plao21,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO/IRQ6"]
            #[inline(always)]
            pub fn is_gpioirq6(&self) -> bool {
                *self == CON7::Gpioirq6
            }
            #[doc = "SPI 2 CS"]
            #[inline(always)]
            pub fn is_cs2(&self) -> bool {
                *self == CON7::Cs2
            }
            #[doc = "I2C1 SDA of ITLA package"]
            #[inline(always)]
            pub fn is_sda1(&self) -> bool {
                *self == CON7::Sda1
            }
            #[doc = "PLAO\\[21\\]"]
            #[inline(always)]
            pub fn is_plao21(&self) -> bool {
                *self == CON7::Plao21
            }
        }
        #[doc = "Field `CON7` writer - P2.7 Configuration Bits"]
        pub type CON7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON7, crate::Safe>;
        impl<'a, REG> CON7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ6"]
            #[inline(always)]
            pub fn gpioirq6(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Gpioirq6)
            }
            #[doc = "SPI 2 CS"]
            #[inline(always)]
            pub fn cs2(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Cs2)
            }
            #[doc = "I2C1 SDA of ITLA package"]
            #[inline(always)]
            pub fn sda1(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Sda1)
            }
            #[doc = "PLAO\\[21\\]"]
            #[inline(always)]
            pub fn plao21(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Plao21)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - P2.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&self) -> CON0_R {
                CON0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - P2.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&self) -> CON1_R {
                CON1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - P2.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&self) -> CON2_R {
                CON2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - P2.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&self) -> CON3_R {
                CON3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - P2.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&self) -> CON4_R {
                CON4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - P2.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&self) -> CON5_R {
                CON5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - P2.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&self) -> CON6_R {
                CON6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - P2.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&self) -> CON7_R {
                CON7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2CON")
                    .field("con0", &self.con0())
                    .field("con1", &self.con1())
                    .field("con2", &self.con2())
                    .field("con3", &self.con3())
                    .field("con4", &self.con4())
                    .field("con5", &self.con5())
                    .field("con6", &self.con6())
                    .field("con7", &self.con7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - P2.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&mut self) -> CON0_W<GP2CONrs> {
                CON0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - P2.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&mut self) -> CON1_W<GP2CONrs> {
                CON1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - P2.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&mut self) -> CON2_W<GP2CONrs> {
                CON2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - P2.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&mut self) -> CON3_W<GP2CONrs> {
                CON3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - P2.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&mut self) -> CON4_W<GP2CONrs> {
                CON4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - P2.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&mut self) -> CON5_W<GP2CONrs> {
                CON5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - P2.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&mut self) -> CON6_W<GP2CONrs> {
                CON6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - P2.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&mut self) -> CON7_W<GP2CONrs> {
                CON7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 2 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2CON)"]
        pub struct GP2CONrs;
        impl crate::RegisterSpec for GP2CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2con::R`](R) reader structure"]
        impl crate::Readable for GP2CONrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2con::W`](W) writer structure"]
        impl crate::Writable for GP2CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2CON to value 0x10"]
        impl crate::Resettable for GP2CONrs {
            const RESET_VALUE: u32 = 0x10;
        }
    }
    #[doc = "GP2OE (rw) register accessor: GPIO Port 2 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2oe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2oe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2OE)\n\nFor information about available fields see [`mod@gp2oe`]
module"]
    pub type GP2OE = crate::Reg<gp2oe::GP2OErs>;
    #[doc = "GPIO Port 2 Output Enable"]
    pub mod gp2oe {
        #[doc = "Register `GP2OE` reader"]
        pub type R = crate::R<GP2OErs>;
        #[doc = "Register `GP2OE` writer"]
        pub type W = crate::W<GP2OErs>;
        #[doc = "Field `OE` reader - Output Enable"]
        pub type OE_R = crate::FieldReader;
        #[doc = "Field `OE` writer - Output Enable"]
        pub type OE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2OE").field("oe", &self.oe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&mut self) -> OE_W<GP2OErs> {
                OE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2oe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2oe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2OE)"]
        pub struct GP2OErs;
        impl crate::RegisterSpec for GP2OErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2oe::R`](R) reader structure"]
        impl crate::Readable for GP2OErs {}
        #[doc = "`write(|w| ..)` method takes [`gp2oe::W`](W) writer structure"]
        impl crate::Writable for GP2OErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2OE to value 0x04"]
        impl crate::Resettable for GP2OErs {
            const RESET_VALUE: u32 = 0x04;
        }
    }
    #[doc = "GP2IE (rw) register accessor: GPIO Port 2 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IE)\n\nFor information about available fields see [`mod@gp2ie`]
module"]
    pub type GP2IE = crate::Reg<gp2ie::GP2IErs>;
    #[doc = "GPIO Port 2 Input Path Enable"]
    pub mod gp2ie {
        #[doc = "Register `GP2IE` reader"]
        pub type R = crate::R<GP2IErs>;
        #[doc = "Register `GP2IE` writer"]
        pub type W = crate::W<GP2IErs>;
        #[doc = "Field `IE` reader - Input Enable"]
        pub type IE_R = crate::FieldReader;
        #[doc = "Field `IE` writer - Input Enable"]
        pub type IE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&self) -> IE_R {
                IE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2IE").field("ie", &self.ie()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&mut self) -> IE_W<GP2IErs> {
                IE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IE)"]
        pub struct GP2IErs;
        impl crate::RegisterSpec for GP2IErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2ie::R`](R) reader structure"]
        impl crate::Readable for GP2IErs {}
        #[doc = "`write(|w| ..)` method takes [`gp2ie::W`](W) writer structure"]
        impl crate::Writable for GP2IErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2IE to value 0"]
        impl crate::Resettable for GP2IErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2IN (rw) register accessor: GPIO Port 2 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IN)\n\nFor information about available fields see [`mod@gp2in`]
module"]
    pub type GP2IN = crate::Reg<gp2in::GP2INrs>;
    #[doc = "GPIO Port 2 Registered Data Input"]
    pub mod gp2in {
        #[doc = "Register `GP2IN` reader"]
        pub type R = crate::R<GP2INrs>;
        #[doc = "Register `GP2IN` writer"]
        pub type W = crate::W<GP2INrs>;
        #[doc = "Field `Y` reader - Data Input from Pad"]
        pub type Y_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Data Input from Pad"]
            #[inline(always)]
            pub fn y(&self) -> Y_R {
                Y_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2IN").field("y", &self.y()).finish()
            }
        }
        impl W {}
        #[doc = "GPIO Port 2 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IN)"]
        pub struct GP2INrs;
        impl crate::RegisterSpec for GP2INrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2in::R`](R) reader structure"]
        impl crate::Readable for GP2INrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2in::W`](W) writer structure"]
        impl crate::Writable for GP2INrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2IN to value 0"]
        impl crate::Resettable for GP2INrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2OUT (rw) register accessor: GPIO Port 2 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2OUT)\n\nFor information about available fields see [`mod@gp2out`]
module"]
    pub type GP2OUT = crate::Reg<gp2out::GP2OUTrs>;
    #[doc = "GPIO Port 2 Data Output"]
    pub mod gp2out {
        #[doc = "Register `GP2OUT` reader"]
        pub type R = crate::R<GP2OUTrs>;
        #[doc = "Register `GP2OUT` writer"]
        pub type W = crate::W<GP2OUTrs>;
        #[doc = "Field `A` reader - Data Output to Pad"]
        pub type A_R = crate::FieldReader;
        #[doc = "Field `A` writer - Data Output to Pad"]
        pub type A_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&self) -> A_R {
                A_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2OUT").field("a", &self.a()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&mut self) -> A_W<GP2OUTrs> {
                A_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2OUT)"]
        pub struct GP2OUTrs;
        impl crate::RegisterSpec for GP2OUTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2out::R`](R) reader structure"]
        impl crate::Readable for GP2OUTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2out::W`](W) writer structure"]
        impl crate::Writable for GP2OUTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2OUT to value 0"]
        impl crate::Resettable for GP2OUTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2SET (rw) register accessor: GPIO Port 2 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2SET)\n\nFor information about available fields see [`mod@gp2set`]
module"]
    pub type GP2SET = crate::Reg<gp2set::GP2SETrs>;
    #[doc = "GPIO Port 2 Data Out Set"]
    pub mod gp2set {
        #[doc = "Register `GP2SET` reader"]
        pub type R = crate::R<GP2SETrs>;
        #[doc = "Register `GP2SET` writer"]
        pub type W = crate::W<GP2SETrs>;
        #[doc = "Field `SETUP` writer - Set the Output HIGH for the Pin"]
        pub type SETUP_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2SET").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output HIGH for the Pin"]
            #[inline(always)]
            pub fn setup(&mut self) -> SETUP_W<GP2SETrs> {
                SETUP_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2SET)"]
        pub struct GP2SETrs;
        impl crate::RegisterSpec for GP2SETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2set::R`](R) reader structure"]
        impl crate::Readable for GP2SETrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2set::W`](W) writer structure"]
        impl crate::Writable for GP2SETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2SET to value 0"]
        impl crate::Resettable for GP2SETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2CLR (rw) register accessor: GPIO Port 2 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2CLR)\n\nFor information about available fields see [`mod@gp2clr`]
module"]
    pub type GP2CLR = crate::Reg<gp2clr::GP2CLRrs>;
    #[doc = "GPIO Port 2 Data Out Clear"]
    pub mod gp2clr {
        #[doc = "Register `GP2CLR` reader"]
        pub type R = crate::R<GP2CLRrs>;
        #[doc = "Register `GP2CLR` writer"]
        pub type W = crate::W<GP2CLRrs>;
        #[doc = "Field `CLR` writer - Set the Output Low for the Port Pin"]
        pub type CLR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2CLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output Low for the Port Pin"]
            #[inline(always)]
            pub fn clr(&mut self) -> CLR_W<GP2CLRrs> {
                CLR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2CLR)"]
        pub struct GP2CLRrs;
        impl crate::RegisterSpec for GP2CLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2clr::R`](R) reader structure"]
        impl crate::Readable for GP2CLRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2clr::W`](W) writer structure"]
        impl crate::Writable for GP2CLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2CLR to value 0"]
        impl crate::Resettable for GP2CLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2TGL (rw) register accessor: GPIO Port 2 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2tgl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2tgl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2TGL)\n\nFor information about available fields see [`mod@gp2tgl`]
module"]
    pub type GP2TGL = crate::Reg<gp2tgl::GP2TGLrs>;
    #[doc = "GPIO Port 2 Pin Toggle"]
    pub mod gp2tgl {
        #[doc = "Register `GP2TGL` reader"]
        pub type R = crate::R<GP2TGLrs>;
        #[doc = "Register `GP2TGL` writer"]
        pub type W = crate::W<GP2TGLrs>;
        #[doc = "Field `TGL` writer - Toggle the Output of the Port Pin"]
        pub type TGL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2TGL").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Toggle the Output of the Port Pin"]
            #[inline(always)]
            pub fn tgl(&mut self) -> TGL_W<GP2TGLrs> {
                TGL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2tgl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2tgl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2TGL)"]
        pub struct GP2TGLrs;
        impl crate::RegisterSpec for GP2TGLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2tgl::R`](R) reader structure"]
        impl crate::Readable for GP2TGLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2tgl::W`](W) writer structure"]
        impl crate::Writable for GP2TGLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2TGL to value 0"]
        impl crate::Resettable for GP2TGLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2ODE (rw) register accessor: GPIO Port 2 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2ODE)\n\nFor information about available fields see [`mod@gp2ode`]
module"]
    pub type GP2ODE = crate::Reg<gp2ode::GP2ODErs>;
    #[doc = "GPIO Port 2 Open Drain Enable"]
    pub mod gp2ode {
        #[doc = "Register `GP2ODE` reader"]
        pub type R = crate::R<GP2ODErs>;
        #[doc = "Register `GP2ODE` writer"]
        pub type W = crate::W<GP2ODErs>;
        #[doc = "Field `ODE` reader - Open Drain Enable"]
        pub type ODE_R = crate::FieldReader;
        #[doc = "Field `ODE` writer - Open Drain Enable"]
        pub type ODE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&self) -> ODE_R {
                ODE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2ODE").field("ode", &self.ode()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&mut self) -> ODE_W<GP2ODErs> {
                ODE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2ODE)"]
        pub struct GP2ODErs;
        impl crate::RegisterSpec for GP2ODErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2ode::R`](R) reader structure"]
        impl crate::Readable for GP2ODErs {}
        #[doc = "`write(|w| ..)` method takes [`gp2ode::W`](W) writer structure"]
        impl crate::Writable for GP2ODErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2ODE to value 0"]
        impl crate::Resettable for GP2ODErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2IS (rw) register accessor: GPIO Port 2 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2is::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2is::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IS)\n\nFor information about available fields see [`mod@gp2is`]
module"]
    pub type GP2IS = crate::Reg<gp2is::GP2ISrs>;
    #[doc = "GPIO Port 2 Input Select"]
    pub mod gp2is {
        #[doc = "Register `GP2IS` reader"]
        pub type R = crate::R<GP2ISrs>;
        #[doc = "Register `GP2IS` writer"]
        pub type W = crate::W<GP2ISrs>;
        #[doc = "Field `ISEL` reader - Input Select"]
        pub type ISEL_R = crate::FieldReader;
        #[doc = "Field `ISEL` writer - Input Select"]
        pub type ISEL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&self) -> ISEL_R {
                ISEL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2IS").field("isel", &self.isel()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&mut self) -> ISEL_W<GP2ISrs> {
                ISEL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2is::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2is::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IS)"]
        pub struct GP2ISrs;
        impl crate::RegisterSpec for GP2ISrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2is::R`](R) reader structure"]
        impl crate::Readable for GP2ISrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2is::W`](W) writer structure"]
        impl crate::Writable for GP2ISrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2IS to value 0xff"]
        impl crate::Resettable for GP2ISrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP2PE (rw) register accessor: GPIO Port 2 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2pe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2pe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2PE)\n\nFor information about available fields see [`mod@gp2pe`]
module"]
    pub type GP2PE = crate::Reg<gp2pe::GP2PErs>;
    #[doc = "GPIO Port 2 Pull Enable"]
    pub mod gp2pe {
        #[doc = "Register `GP2PE` reader"]
        pub type R = crate::R<GP2PErs>;
        #[doc = "Register `GP2PE` writer"]
        pub type W = crate::W<GP2PErs>;
        #[doc = "Field `PE` reader - Pull Enable"]
        pub type PE_R = crate::FieldReader;
        #[doc = "Field `PE` writer - Pull Enable"]
        pub type PE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2PE").field("pe", &self.pe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W<GP2PErs> {
                PE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2pe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2pe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2PE)"]
        pub struct GP2PErs;
        impl crate::RegisterSpec for GP2PErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2pe::R`](R) reader structure"]
        impl crate::Readable for GP2PErs {}
        #[doc = "`write(|w| ..)` method takes [`gp2pe::W`](W) writer structure"]
        impl crate::Writable for GP2PErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2PE to value 0"]
        impl crate::Resettable for GP2PErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2PS (rw) register accessor: GPIO Port 2 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ps::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ps::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2PS)\n\nFor information about available fields see [`mod@gp2ps`]
module"]
    pub type GP2PS = crate::Reg<gp2ps::GP2PSrs>;
    #[doc = "GPIO Port 2 Pull Select"]
    pub mod gp2ps {
        #[doc = "Register `GP2PS` reader"]
        pub type R = crate::R<GP2PSrs>;
        #[doc = "Register `GP2PS` writer"]
        pub type W = crate::W<GP2PSrs>;
        #[doc = "Field `PS` reader - Pull Select"]
        pub type PS_R = crate::FieldReader;
        #[doc = "Field `PS` writer - Pull Select"]
        pub type PS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2PS").field("ps", &self.ps()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W<GP2PSrs> {
                PS_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ps::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ps::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2PS)"]
        pub struct GP2PSrs;
        impl crate::RegisterSpec for GP2PSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2ps::R`](R) reader structure"]
        impl crate::Readable for GP2PSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2ps::W`](W) writer structure"]
        impl crate::Writable for GP2PSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2PS to value 0xff"]
        impl crate::Resettable for GP2PSrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP2SR (rw) register accessor: GPIO Port 2 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2SR)\n\nFor information about available fields see [`mod@gp2sr`]
module"]
    pub type GP2SR = crate::Reg<gp2sr::GP2SRrs>;
    #[doc = "GPIO Port 2 Slew Rate"]
    pub mod gp2sr {
        #[doc = "Register `GP2SR` reader"]
        pub type R = crate::R<GP2SRrs>;
        #[doc = "Register `GP2SR` writer"]
        pub type W = crate::W<GP2SRrs>;
        #[doc = "Field `SR` reader - Slew Rate"]
        pub type SR_R = crate::FieldReader;
        #[doc = "Field `SR` writer - Slew Rate"]
        pub type SR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&self) -> SR_R {
                SR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2SR").field("sr", &self.sr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&mut self) -> SR_W<GP2SRrs> {
                SR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 2 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2SR)"]
        pub struct GP2SRrs;
        impl crate::RegisterSpec for GP2SRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2sr::R`](R) reader structure"]
        impl crate::Readable for GP2SRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2sr::W`](W) writer structure"]
        impl crate::Writable for GP2SRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2SR to value 0"]
        impl crate::Resettable for GP2SRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2DS (rw) register accessor: GPIO Port 2 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ds::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ds::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2DS)\n\nFor information about available fields see [`mod@gp2ds`]
module"]
    pub type GP2DS = crate::Reg<gp2ds::GP2DSrs>;
    #[doc = "GPIO Port 2 Drive Select"]
    pub mod gp2ds {
        #[doc = "Register `GP2DS` reader"]
        pub type R = crate::R<GP2DSrs>;
        #[doc = "Register `GP2DS` writer"]
        pub type W = crate::W<GP2DSrs>;
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS0 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS0> for u8 {
            #[inline(always)]
            fn from(variant: DS0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS0 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS0 {}
        #[doc = "Field `DS0` reader - Drive Select"]
        pub type DS0_R = crate::FieldReader<DS0>;
        impl DS0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS0 {
                match self.bits {
                    0 => DS0::Strength1,
                    1 => DS0::Strength2,
                    2 => DS0::Strength3,
                    3 => DS0::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS0::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS0::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS0::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS0::Strength4
            }
        }
        #[doc = "Field `DS0` writer - Drive Select"]
        pub type DS0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS0, crate::Safe>;
        impl<'a, REG> DS0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS1 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS1> for u8 {
            #[inline(always)]
            fn from(variant: DS1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS1 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS1 {}
        #[doc = "Field `DS1` reader - Drive Select"]
        pub type DS1_R = crate::FieldReader<DS1>;
        impl DS1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS1 {
                match self.bits {
                    0 => DS1::Strength1,
                    1 => DS1::Strength2,
                    2 => DS1::Strength3,
                    3 => DS1::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS1::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS1::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS1::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS1::Strength4
            }
        }
        #[doc = "Field `DS1` writer - Drive Select"]
        pub type DS1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS1, crate::Safe>;
        impl<'a, REG> DS1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS2 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS2> for u8 {
            #[inline(always)]
            fn from(variant: DS2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS2 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS2 {}
        #[doc = "Field `DS2` reader - Drive Select"]
        pub type DS2_R = crate::FieldReader<DS2>;
        impl DS2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS2 {
                match self.bits {
                    0 => DS2::Strength1,
                    1 => DS2::Strength2,
                    2 => DS2::Strength3,
                    3 => DS2::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS2::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS2::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS2::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS2::Strength4
            }
        }
        #[doc = "Field `DS2` writer - Drive Select"]
        pub type DS2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS2, crate::Safe>;
        impl<'a, REG> DS2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS3 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS3> for u8 {
            #[inline(always)]
            fn from(variant: DS3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS3 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS3 {}
        #[doc = "Field `DS3` reader - Drive Select"]
        pub type DS3_R = crate::FieldReader<DS3>;
        impl DS3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS3 {
                match self.bits {
                    0 => DS3::Strength1,
                    1 => DS3::Strength2,
                    2 => DS3::Strength3,
                    3 => DS3::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS3::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS3::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS3::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS3::Strength4
            }
        }
        #[doc = "Field `DS3` writer - Drive Select"]
        pub type DS3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS3, crate::Safe>;
        impl<'a, REG> DS3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS4 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS4> for u8 {
            #[inline(always)]
            fn from(variant: DS4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS4 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS4 {}
        #[doc = "Field `DS4` reader - Drive Select"]
        pub type DS4_R = crate::FieldReader<DS4>;
        impl DS4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS4 {
                match self.bits {
                    0 => DS4::Strength1,
                    1 => DS4::Strength2,
                    2 => DS4::Strength3,
                    3 => DS4::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS4::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS4::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS4::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS4::Strength4
            }
        }
        #[doc = "Field `DS4` writer - Drive Select"]
        pub type DS4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS4, crate::Safe>;
        impl<'a, REG> DS4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS5 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS5> for u8 {
            #[inline(always)]
            fn from(variant: DS5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS5 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS5 {}
        #[doc = "Field `DS5` reader - Drive Select"]
        pub type DS5_R = crate::FieldReader<DS5>;
        impl DS5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS5 {
                match self.bits {
                    0 => DS5::Strength1,
                    1 => DS5::Strength2,
                    2 => DS5::Strength3,
                    3 => DS5::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS5::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS5::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS5::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS5::Strength4
            }
        }
        #[doc = "Field `DS5` writer - Drive Select"]
        pub type DS5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS5, crate::Safe>;
        impl<'a, REG> DS5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS6 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS6> for u8 {
            #[inline(always)]
            fn from(variant: DS6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS6 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS6 {}
        #[doc = "Field `DS6` reader - Drive Select"]
        pub type DS6_R = crate::FieldReader<DS6>;
        impl DS6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS6 {
                match self.bits {
                    0 => DS6::Strength1,
                    1 => DS6::Strength2,
                    2 => DS6::Strength3,
                    3 => DS6::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS6::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS6::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS6::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS6::Strength4
            }
        }
        #[doc = "Field `DS6` writer - Drive Select"]
        pub type DS6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS6, crate::Safe>;
        impl<'a, REG> DS6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS7 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS7> for u8 {
            #[inline(always)]
            fn from(variant: DS7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS7 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS7 {}
        #[doc = "Field `DS7` reader - Drive Select"]
        pub type DS7_R = crate::FieldReader<DS7>;
        impl DS7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS7 {
                match self.bits {
                    0 => DS7::Strength1,
                    1 => DS7::Strength2,
                    2 => DS7::Strength3,
                    3 => DS7::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS7::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS7::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS7::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS7::Strength4
            }
        }
        #[doc = "Field `DS7` writer - Drive Select"]
        pub type DS7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS7, crate::Safe>;
        impl<'a, REG> DS7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength4)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&self) -> DS0_R {
                DS0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&self) -> DS1_R {
                DS1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&self) -> DS2_R {
                DS2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&self) -> DS3_R {
                DS3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&self) -> DS4_R {
                DS4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&self) -> DS5_R {
                DS5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&self) -> DS6_R {
                DS6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&self) -> DS7_R {
                DS7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2DS")
                    .field("ds0", &self.ds0())
                    .field("ds1", &self.ds1())
                    .field("ds2", &self.ds2())
                    .field("ds3", &self.ds3())
                    .field("ds4", &self.ds4())
                    .field("ds5", &self.ds5())
                    .field("ds6", &self.ds6())
                    .field("ds7", &self.ds7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&mut self) -> DS0_W<GP2DSrs> {
                DS0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&mut self) -> DS1_W<GP2DSrs> {
                DS1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&mut self) -> DS2_W<GP2DSrs> {
                DS2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&mut self) -> DS3_W<GP2DSrs> {
                DS3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&mut self) -> DS4_W<GP2DSrs> {
                DS4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&mut self) -> DS5_W<GP2DSrs> {
                DS5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&mut self) -> DS6_W<GP2DSrs> {
                DS6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&mut self) -> DS7_W<GP2DSrs> {
                DS7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 2 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ds::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ds::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2DS)"]
        pub struct GP2DSrs;
        impl crate::RegisterSpec for GP2DSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2ds::R`](R) reader structure"]
        impl crate::Readable for GP2DSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2ds::W`](W) writer structure"]
        impl crate::Writable for GP2DSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2DS to value 0"]
        impl crate::Resettable for GP2DSrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2POL (rw) register accessor: Interrupt Polarity\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2pol::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2pol::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2POL)\n\nFor information about available fields see [`mod@gp2pol`]
module"]
    pub type GP2POL = crate::Reg<gp2pol::GP2POLrs>;
    #[doc = "Interrupt Polarity"]
    pub mod gp2pol {
        #[doc = "Register `GP2POL` reader"]
        pub type R = crate::R<GP2POLrs>;
        #[doc = "Register `GP2POL` writer"]
        pub type W = crate::W<GP2POLrs>;
        #[doc = "Field `INTPOL` reader - Interrupt Polarity"]
        pub type INTPOL_R = crate::FieldReader;
        #[doc = "Field `INTPOL` writer - Interrupt Polarity"]
        pub type INTPOL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Interrupt Polarity"]
            #[inline(always)]
            pub fn intpol(&self) -> INTPOL_R {
                INTPOL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2POL")
                    .field("intpol", &self.intpol())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Interrupt Polarity"]
            #[inline(always)]
            pub fn intpol(&mut self) -> INTPOL_W<GP2POLrs> {
                INTPOL_W::new(self, 0)
            }
        }
        #[doc = "Interrupt Polarity\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2pol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2pol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2POL)"]
        pub struct GP2POLrs;
        impl crate::RegisterSpec for GP2POLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2pol::R`](R) reader structure"]
        impl crate::Readable for GP2POLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2pol::W`](W) writer structure"]
        impl crate::Writable for GP2POLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2POL to value 0"]
        impl crate::Resettable for GP2POLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2IENA (rw) register accessor: InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2iena::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2iena::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IENA)\n\nFor information about available fields see [`mod@gp2iena`]
module"]
    pub type GP2IENA = crate::Reg<gp2iena::GP2IENArs>;
    #[doc = "InterruptA Enable"]
    pub mod gp2iena {
        #[doc = "Register `GP2IENA` reader"]
        pub type R = crate::R<GP2IENArs>;
        #[doc = "Register `GP2IENA` writer"]
        pub type W = crate::W<GP2IENArs>;
        #[doc = "Field `INTAEN` reader - InterruptA Enable"]
        pub type INTAEN_R = crate::FieldReader;
        #[doc = "Field `INTAEN` writer - InterruptA Enable"]
        pub type INTAEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&self) -> INTAEN_R {
                INTAEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2IENA")
                    .field("intaen", &self.intaen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&mut self) -> INTAEN_W<GP2IENArs> {
                INTAEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2iena::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2iena::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IENA)"]
        pub struct GP2IENArs;
        impl crate::RegisterSpec for GP2IENArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2iena::R`](R) reader structure"]
        impl crate::Readable for GP2IENArs {}
        #[doc = "`write(|w| ..)` method takes [`gp2iena::W`](W) writer structure"]
        impl crate::Writable for GP2IENArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2IENA to value 0"]
        impl crate::Resettable for GP2IENArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2IENB (rw) register accessor: InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ienb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ienb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IENB)\n\nFor information about available fields see [`mod@gp2ienb`]
module"]
    pub type GP2IENB = crate::Reg<gp2ienb::GP2IENBrs>;
    #[doc = "InterruptB Enable"]
    pub mod gp2ienb {
        #[doc = "Register `GP2IENB` reader"]
        pub type R = crate::R<GP2IENBrs>;
        #[doc = "Register `GP2IENB` writer"]
        pub type W = crate::W<GP2IENBrs>;
        #[doc = "Field `INTBEN` reader - InterruptB Enable"]
        pub type INTBEN_R = crate::FieldReader;
        #[doc = "Field `INTBEN` writer - InterruptB Enable"]
        pub type INTBEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&self) -> INTBEN_R {
                INTBEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2IENB")
                    .field("intben", &self.intben())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&mut self) -> INTBEN_W<GP2IENBrs> {
                INTBEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2ienb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2ienb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2IENB)"]
        pub struct GP2IENBrs;
        impl crate::RegisterSpec for GP2IENBrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2ienb::R`](R) reader structure"]
        impl crate::Readable for GP2IENBrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2ienb::W`](W) writer structure"]
        impl crate::Writable for GP2IENBrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2IENB to value 0"]
        impl crate::Resettable for GP2IENBrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP2INT (rw) register accessor: Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2int::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2int::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2INT)\n\nFor information about available fields see [`mod@gp2int`]
module"]
    pub type GP2INT = crate::Reg<gp2int::GP2INTrs>;
    #[doc = "Interrupt Status"]
    pub mod gp2int {
        #[doc = "Register `GP2INT` reader"]
        pub type R = crate::R<GP2INTrs>;
        #[doc = "Register `GP2INT` writer"]
        pub type W = crate::W<GP2INTrs>;
        #[doc = "Field `INTSTATUS` reader - Interrupt Status"]
        pub type INTSTATUS_R = crate::FieldReader;
        #[doc = "Field `INTSTATUS` writer - Interrupt Status"]
        pub type INTSTATUS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&self) -> INTSTATUS_R {
                INTSTATUS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP2INT")
                    .field("intstatus", &self.intstatus())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&mut self) -> INTSTATUS_W<GP2INTrs> {
                INTSTATUS_W::new(self, 0)
            }
        }
        #[doc = "Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp2int::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp2int::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP2INT)"]
        pub struct GP2INTrs;
        impl crate::RegisterSpec for GP2INTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp2int::R`](R) reader structure"]
        impl crate::Readable for GP2INTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp2int::W`](W) writer structure"]
        impl crate::Writable for GP2INTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP2INT to value 0"]
        impl crate::Resettable for GP2INTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3CON (rw) register accessor: GPIO Port 3 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3CON)\n\nFor information about available fields see [`mod@gp3con`]
module"]
    pub type GP3CON = crate::Reg<gp3con::GP3CONrs>;
    #[doc = "GPIO Port 3 Configuration"]
    pub mod gp3con {
        #[doc = "Register `GP3CON` reader"]
        pub type R = crate::R<GP3CONrs>;
        #[doc = "Register `GP3CON` writer"]
        pub type W = crate::W<GP3CONrs>;
        #[doc = "P3.0 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON0 {
            #[doc = "0: GPIO/IRQ8"]
            Gpio = 0,
            #[doc = "1: MDIO Port Address 0"]
            Prtaddr0 = 1,
            #[doc = "2: SPI 0 Sready"]
            Srdy0 = 2,
            #[doc = "3: PLAI\\[12\\]"]
            Plai12 = 3,
        }
        impl From<CON0> for u8 {
            #[inline(always)]
            fn from(variant: CON0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON0 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON0 {}
        #[doc = "Field `CON0` reader - P3.0 Configuration Bits"]
        pub type CON0_R = crate::FieldReader<CON0>;
        impl CON0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON0 {
                match self.bits {
                    0 => CON0::Gpio,
                    1 => CON0::Prtaddr0,
                    2 => CON0::Srdy0,
                    3 => CON0::Plai12,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO/IRQ8"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON0::Gpio
            }
            #[doc = "MDIO Port Address 0"]
            #[inline(always)]
            pub fn is_prtaddr0(&self) -> bool {
                *self == CON0::Prtaddr0
            }
            #[doc = "SPI 0 Sready"]
            #[inline(always)]
            pub fn is_srdy0(&self) -> bool {
                *self == CON0::Srdy0
            }
            #[doc = "PLAI\\[12\\]"]
            #[inline(always)]
            pub fn is_plai12(&self) -> bool {
                *self == CON0::Plai12
            }
        }
        #[doc = "Field `CON0` writer - P3.0 Configuration Bits"]
        pub type CON0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON0, crate::Safe>;
        impl<'a, REG> CON0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ8"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Gpio)
            }
            #[doc = "MDIO Port Address 0"]
            #[inline(always)]
            pub fn prtaddr0(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Prtaddr0)
            }
            #[doc = "SPI 0 Sready"]
            #[inline(always)]
            pub fn srdy0(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Srdy0)
            }
            #[doc = "PLAI\\[12\\]"]
            #[inline(always)]
            pub fn plai12(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Plai12)
            }
        }
        #[doc = "P3.1 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON1 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: MDIO PRTADDR1"]
            Prtaddr1 = 1,
            #[doc = "2: PWM Sync"]
            Pwmsync = 2,
            #[doc = "3: PLAI\\[13\\]"]
            Plai13 = 3,
        }
        impl From<CON1> for u8 {
            #[inline(always)]
            fn from(variant: CON1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON1 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON1 {}
        #[doc = "Field `CON1` reader - P3.1 Configuration Bits"]
        pub type CON1_R = crate::FieldReader<CON1>;
        impl CON1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON1 {
                match self.bits {
                    0 => CON1::Gpio,
                    1 => CON1::Prtaddr1,
                    2 => CON1::Pwmsync,
                    3 => CON1::Plai13,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON1::Gpio
            }
            #[doc = "MDIO PRTADDR1"]
            #[inline(always)]
            pub fn is_prtaddr1(&self) -> bool {
                *self == CON1::Prtaddr1
            }
            #[doc = "PWM Sync"]
            #[inline(always)]
            pub fn is_pwmsync(&self) -> bool {
                *self == CON1::Pwmsync
            }
            #[doc = "PLAI\\[13\\]"]
            #[inline(always)]
            pub fn is_plai13(&self) -> bool {
                *self == CON1::Plai13
            }
        }
        #[doc = "Field `CON1` writer - P3.1 Configuration Bits"]
        pub type CON1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON1, crate::Safe>;
        impl<'a, REG> CON1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Gpio)
            }
            #[doc = "MDIO PRTADDR1"]
            #[inline(always)]
            pub fn prtaddr1(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Prtaddr1)
            }
            #[doc = "PWM Sync"]
            #[inline(always)]
            pub fn pwmsync(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Pwmsync)
            }
            #[doc = "PLAI\\[13\\]"]
            #[inline(always)]
            pub fn plai13(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Plai13)
            }
        }
        #[doc = "P3.2 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON2 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: MDIO Port Address2"]
            Prtadd2 = 1,
            #[doc = "2: PWM Trip"]
            Pwmtrip = 2,
            #[doc = "3: PLAI\\[14\\]"]
            Plai14 = 3,
        }
        impl From<CON2> for u8 {
            #[inline(always)]
            fn from(variant: CON2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON2 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON2 {}
        #[doc = "Field `CON2` reader - P3.2 Configuration Bits"]
        pub type CON2_R = crate::FieldReader<CON2>;
        impl CON2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON2 {
                match self.bits {
                    0 => CON2::Gpio,
                    1 => CON2::Prtadd2,
                    2 => CON2::Pwmtrip,
                    3 => CON2::Plai14,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON2::Gpio
            }
            #[doc = "MDIO Port Address2"]
            #[inline(always)]
            pub fn is_prtadd2(&self) -> bool {
                *self == CON2::Prtadd2
            }
            #[doc = "PWM Trip"]
            #[inline(always)]
            pub fn is_pwmtrip(&self) -> bool {
                *self == CON2::Pwmtrip
            }
            #[doc = "PLAI\\[14\\]"]
            #[inline(always)]
            pub fn is_plai14(&self) -> bool {
                *self == CON2::Plai14
            }
        }
        #[doc = "Field `CON2` writer - P3.2 Configuration Bits"]
        pub type CON2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON2, crate::Safe>;
        impl<'a, REG> CON2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Gpio)
            }
            #[doc = "MDIO Port Address2"]
            #[inline(always)]
            pub fn prtadd2(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Prtadd2)
            }
            #[doc = "PWM Trip"]
            #[inline(always)]
            pub fn pwmtrip(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Pwmtrip)
            }
            #[doc = "PLAI\\[14\\]"]
            #[inline(always)]
            pub fn plai14(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Plai14)
            }
        }
        #[doc = "P3.3 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON3 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: MDIO Port Address3"]
            Prtaddr3 = 1,
            #[doc = "2: Duplicate SIN0"]
            Sin0 = 2,
            #[doc = "3: PLAI\\[15\\]"]
            Plai15 = 3,
        }
        impl From<CON3> for u8 {
            #[inline(always)]
            fn from(variant: CON3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON3 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON3 {}
        #[doc = "Field `CON3` reader - P3.3 Configuration Bits"]
        pub type CON3_R = crate::FieldReader<CON3>;
        impl CON3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON3 {
                match self.bits {
                    0 => CON3::Gpio,
                    1 => CON3::Prtaddr3,
                    2 => CON3::Sin0,
                    3 => CON3::Plai15,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON3::Gpio
            }
            #[doc = "MDIO Port Address3"]
            #[inline(always)]
            pub fn is_prtaddr3(&self) -> bool {
                *self == CON3::Prtaddr3
            }
            #[doc = "Duplicate SIN0"]
            #[inline(always)]
            pub fn is_sin0(&self) -> bool {
                *self == CON3::Sin0
            }
            #[doc = "PLAI\\[15\\]"]
            #[inline(always)]
            pub fn is_plai15(&self) -> bool {
                *self == CON3::Plai15
            }
        }
        #[doc = "Field `CON3` writer - P3.3 Configuration Bits"]
        pub type CON3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON3, crate::Safe>;
        impl<'a, REG> CON3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Gpio)
            }
            #[doc = "MDIO Port Address3"]
            #[inline(always)]
            pub fn prtaddr3(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Prtaddr3)
            }
            #[doc = "Duplicate SIN0"]
            #[inline(always)]
            pub fn sin0(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Sin0)
            }
            #[doc = "PLAI\\[15\\]"]
            #[inline(always)]
            pub fn plai15(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Plai15)
            }
        }
        #[doc = "P3.4 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON4 {
            #[doc = "0: GPIO/IRQ9"]
            Gpioirq9 = 0,
            #[doc = "1: MDIO Port Address 4"]
            Prtaddr4 = 1,
            #[doc = "2: Duplicate SOUT0"]
            Sout0 = 2,
            #[doc = "3: PLAO\\[26\\]"]
            Plao26 = 3,
        }
        impl From<CON4> for u8 {
            #[inline(always)]
            fn from(variant: CON4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON4 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON4 {}
        #[doc = "Field `CON4` reader - P3.4 Configuration Bits"]
        pub type CON4_R = crate::FieldReader<CON4>;
        impl CON4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON4 {
                match self.bits {
                    0 => CON4::Gpioirq9,
                    1 => CON4::Prtaddr4,
                    2 => CON4::Sout0,
                    3 => CON4::Plao26,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO/IRQ9"]
            #[inline(always)]
            pub fn is_gpioirq9(&self) -> bool {
                *self == CON4::Gpioirq9
            }
            #[doc = "MDIO Port Address 4"]
            #[inline(always)]
            pub fn is_prtaddr4(&self) -> bool {
                *self == CON4::Prtaddr4
            }
            #[doc = "Duplicate SOUT0"]
            #[inline(always)]
            pub fn is_sout0(&self) -> bool {
                *self == CON4::Sout0
            }
            #[doc = "PLAO\\[26\\]"]
            #[inline(always)]
            pub fn is_plao26(&self) -> bool {
                *self == CON4::Plao26
            }
        }
        #[doc = "Field `CON4` writer - P3.4 Configuration Bits"]
        pub type CON4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON4, crate::Safe>;
        impl<'a, REG> CON4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ9"]
            #[inline(always)]
            pub fn gpioirq9(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Gpioirq9)
            }
            #[doc = "MDIO Port Address 4"]
            #[inline(always)]
            pub fn prtaddr4(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Prtaddr4)
            }
            #[doc = "Duplicate SOUT0"]
            #[inline(always)]
            pub fn sout0(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Sout0)
            }
            #[doc = "PLAO\\[26\\]"]
            #[inline(always)]
            pub fn plao26(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Plao26)
            }
        }
        #[doc = "P3.5 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON5 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: SLVA MDIO MCK"]
            Mck = 1,
            #[doc = "2: SPI 1 Sready"]
            Srdy1 = 2,
            #[doc = "3: PLAO\\[27\\]"]
            Plao27 = 3,
        }
        impl From<CON5> for u8 {
            #[inline(always)]
            fn from(variant: CON5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON5 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON5 {}
        #[doc = "Field `CON5` reader - P3.5 Configuration Bits"]
        pub type CON5_R = crate::FieldReader<CON5>;
        impl CON5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON5 {
                match self.bits {
                    0 => CON5::Gpio,
                    1 => CON5::Mck,
                    2 => CON5::Srdy1,
                    3 => CON5::Plao27,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON5::Gpio
            }
            #[doc = "SLVA MDIO MCK"]
            #[inline(always)]
            pub fn is_mck(&self) -> bool {
                *self == CON5::Mck
            }
            #[doc = "SPI 1 Sready"]
            #[inline(always)]
            pub fn is_srdy1(&self) -> bool {
                *self == CON5::Srdy1
            }
            #[doc = "PLAO\\[27\\]"]
            #[inline(always)]
            pub fn is_plao27(&self) -> bool {
                *self == CON5::Plao27
            }
        }
        #[doc = "Field `CON5` writer - P3.5 Configuration Bits"]
        pub type CON5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON5, crate::Safe>;
        impl<'a, REG> CON5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Gpio)
            }
            #[doc = "SLVA MDIO MCK"]
            #[inline(always)]
            pub fn mck(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Mck)
            }
            #[doc = "SPI 1 Sready"]
            #[inline(always)]
            pub fn srdy1(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Srdy1)
            }
            #[doc = "PLAO\\[27\\]"]
            #[inline(always)]
            pub fn plao27(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Plao27)
            }
        }
        #[doc = "P3.6 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON6 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: SLAVE MDIO MDIO"]
            Mdio = 1,
            #[doc = "2: SPI 2 Sready"]
            Srdy2 = 2,
            #[doc = "3: PLA Output 30"]
            Plao30 = 3,
        }
        impl From<CON6> for u8 {
            #[inline(always)]
            fn from(variant: CON6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON6 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON6 {}
        #[doc = "Field `CON6` reader - P3.6 Configuration Bits"]
        pub type CON6_R = crate::FieldReader<CON6>;
        impl CON6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CON6 {
                match self.bits {
                    0 => CON6::Gpio,
                    1 => CON6::Mdio,
                    2 => CON6::Srdy2,
                    3 => CON6::Plao30,
                    _ => unreachable!(),
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON6::Gpio
            }
            #[doc = "SLAVE MDIO MDIO"]
            #[inline(always)]
            pub fn is_mdio(&self) -> bool {
                *self == CON6::Mdio
            }
            #[doc = "SPI 2 Sready"]
            #[inline(always)]
            pub fn is_srdy2(&self) -> bool {
                *self == CON6::Srdy2
            }
            #[doc = "PLA Output 30"]
            #[inline(always)]
            pub fn is_plao30(&self) -> bool {
                *self == CON6::Plao30
            }
        }
        #[doc = "Field `CON6` writer - P3.6 Configuration Bits"]
        pub type CON6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON6, crate::Safe>;
        impl<'a, REG> CON6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Gpio)
            }
            #[doc = "SLAVE MDIO MDIO"]
            #[inline(always)]
            pub fn mdio(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Mdio)
            }
            #[doc = "SPI 2 Sready"]
            #[inline(always)]
            pub fn srdy2(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Srdy2)
            }
            #[doc = "PLA Output 30"]
            #[inline(always)]
            pub fn plao30(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Plao30)
            }
        }
        #[doc = "P3.7 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON7 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "3: PLAO\\[29\\]"]
            Plao29 = 3,
        }
        impl From<CON7> for u8 {
            #[inline(always)]
            fn from(variant: CON7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON7 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON7 {}
        #[doc = "Field `CON7` reader - P3.7 Configuration Bits"]
        pub type CON7_R = crate::FieldReader<CON7>;
        impl CON7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON7> {
                match self.bits {
                    0 => Some(CON7::Gpio),
                    3 => Some(CON7::Plao29),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON7::Gpio
            }
            #[doc = "PLAO\\[29\\]"]
            #[inline(always)]
            pub fn is_plao29(&self) -> bool {
                *self == CON7::Plao29
            }
        }
        #[doc = "Field `CON7` writer - P3.7 Configuration Bits"]
        pub type CON7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON7>;
        impl<'a, REG> CON7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Gpio)
            }
            #[doc = "PLAO\\[29\\]"]
            #[inline(always)]
            pub fn plao29(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Plao29)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - P3.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&self) -> CON0_R {
                CON0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - P3.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&self) -> CON1_R {
                CON1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - P3.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&self) -> CON2_R {
                CON2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - P3.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&self) -> CON3_R {
                CON3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - P3.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&self) -> CON4_R {
                CON4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - P3.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&self) -> CON5_R {
                CON5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - P3.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&self) -> CON6_R {
                CON6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - P3.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&self) -> CON7_R {
                CON7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3CON")
                    .field("con0", &self.con0())
                    .field("con1", &self.con1())
                    .field("con2", &self.con2())
                    .field("con3", &self.con3())
                    .field("con4", &self.con4())
                    .field("con5", &self.con5())
                    .field("con6", &self.con6())
                    .field("con7", &self.con7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - P3.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&mut self) -> CON0_W<GP3CONrs> {
                CON0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - P3.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&mut self) -> CON1_W<GP3CONrs> {
                CON1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - P3.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&mut self) -> CON2_W<GP3CONrs> {
                CON2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - P3.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&mut self) -> CON3_W<GP3CONrs> {
                CON3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - P3.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&mut self) -> CON4_W<GP3CONrs> {
                CON4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - P3.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&mut self) -> CON5_W<GP3CONrs> {
                CON5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - P3.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&mut self) -> CON6_W<GP3CONrs> {
                CON6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - P3.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&mut self) -> CON7_W<GP3CONrs> {
                CON7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 3 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3CON)"]
        pub struct GP3CONrs;
        impl crate::RegisterSpec for GP3CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3con::R`](R) reader structure"]
        impl crate::Readable for GP3CONrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3con::W`](W) writer structure"]
        impl crate::Writable for GP3CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3CON to value 0"]
        impl crate::Resettable for GP3CONrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3OE (rw) register accessor: GPIO Port 3 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3oe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3oe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3OE)\n\nFor information about available fields see [`mod@gp3oe`]
module"]
    pub type GP3OE = crate::Reg<gp3oe::GP3OErs>;
    #[doc = "GPIO Port 3 Output Enable"]
    pub mod gp3oe {
        #[doc = "Register `GP3OE` reader"]
        pub type R = crate::R<GP3OErs>;
        #[doc = "Register `GP3OE` writer"]
        pub type W = crate::W<GP3OErs>;
        #[doc = "Field `OE` reader - Output Enable"]
        pub type OE_R = crate::FieldReader;
        #[doc = "Field `OE` writer - Output Enable"]
        pub type OE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3OE").field("oe", &self.oe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&mut self) -> OE_W<GP3OErs> {
                OE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3oe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3oe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3OE)"]
        pub struct GP3OErs;
        impl crate::RegisterSpec for GP3OErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3oe::R`](R) reader structure"]
        impl crate::Readable for GP3OErs {}
        #[doc = "`write(|w| ..)` method takes [`gp3oe::W`](W) writer structure"]
        impl crate::Writable for GP3OErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3OE to value 0"]
        impl crate::Resettable for GP3OErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3IE (rw) register accessor: GPIO Port 3 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IE)\n\nFor information about available fields see [`mod@gp3ie`]
module"]
    pub type GP3IE = crate::Reg<gp3ie::GP3IErs>;
    #[doc = "GPIO Port 3 Input Path Enable"]
    pub mod gp3ie {
        #[doc = "Register `GP3IE` reader"]
        pub type R = crate::R<GP3IErs>;
        #[doc = "Register `GP3IE` writer"]
        pub type W = crate::W<GP3IErs>;
        #[doc = "Field `IE` reader - Input Enable"]
        pub type IE_R = crate::FieldReader;
        #[doc = "Field `IE` writer - Input Enable"]
        pub type IE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&self) -> IE_R {
                IE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3IE").field("ie", &self.ie()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&mut self) -> IE_W<GP3IErs> {
                IE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IE)"]
        pub struct GP3IErs;
        impl crate::RegisterSpec for GP3IErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3ie::R`](R) reader structure"]
        impl crate::Readable for GP3IErs {}
        #[doc = "`write(|w| ..)` method takes [`gp3ie::W`](W) writer structure"]
        impl crate::Writable for GP3IErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3IE to value 0"]
        impl crate::Resettable for GP3IErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3IN (rw) register accessor: GPIO Port 3 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IN)\n\nFor information about available fields see [`mod@gp3in`]
module"]
    pub type GP3IN = crate::Reg<gp3in::GP3INrs>;
    #[doc = "GPIO Port 3 Registered Data Input"]
    pub mod gp3in {
        #[doc = "Register `GP3IN` reader"]
        pub type R = crate::R<GP3INrs>;
        #[doc = "Register `GP3IN` writer"]
        pub type W = crate::W<GP3INrs>;
        #[doc = "Field `Y` reader - Data Input from Pad"]
        pub type Y_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Data Input from Pad"]
            #[inline(always)]
            pub fn y(&self) -> Y_R {
                Y_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3IN").field("y", &self.y()).finish()
            }
        }
        impl W {}
        #[doc = "GPIO Port 3 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IN)"]
        pub struct GP3INrs;
        impl crate::RegisterSpec for GP3INrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3in::R`](R) reader structure"]
        impl crate::Readable for GP3INrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3in::W`](W) writer structure"]
        impl crate::Writable for GP3INrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3IN to value 0"]
        impl crate::Resettable for GP3INrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3OUT (rw) register accessor: GPIO Port 3 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3OUT)\n\nFor information about available fields see [`mod@gp3out`]
module"]
    pub type GP3OUT = crate::Reg<gp3out::GP3OUTrs>;
    #[doc = "GPIO Port 3 Data Output"]
    pub mod gp3out {
        #[doc = "Register `GP3OUT` reader"]
        pub type R = crate::R<GP3OUTrs>;
        #[doc = "Register `GP3OUT` writer"]
        pub type W = crate::W<GP3OUTrs>;
        #[doc = "Field `A` reader - Data Output to Pad"]
        pub type A_R = crate::FieldReader;
        #[doc = "Field `A` writer - Data Output to Pad"]
        pub type A_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&self) -> A_R {
                A_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3OUT").field("a", &self.a()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&mut self) -> A_W<GP3OUTrs> {
                A_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3OUT)"]
        pub struct GP3OUTrs;
        impl crate::RegisterSpec for GP3OUTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3out::R`](R) reader structure"]
        impl crate::Readable for GP3OUTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3out::W`](W) writer structure"]
        impl crate::Writable for GP3OUTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3OUT to value 0"]
        impl crate::Resettable for GP3OUTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3SET (rw) register accessor: GPIO Port 3 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3SET)\n\nFor information about available fields see [`mod@gp3set`]
module"]
    pub type GP3SET = crate::Reg<gp3set::GP3SETrs>;
    #[doc = "GPIO Port 3 Data Out Set"]
    pub mod gp3set {
        #[doc = "Register `GP3SET` reader"]
        pub type R = crate::R<GP3SETrs>;
        #[doc = "Register `GP3SET` writer"]
        pub type W = crate::W<GP3SETrs>;
        #[doc = "Field `SETUP` writer - Set the Output HIGH for the Pin"]
        pub type SETUP_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3SET").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output HIGH for the Pin"]
            #[inline(always)]
            pub fn setup(&mut self) -> SETUP_W<GP3SETrs> {
                SETUP_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3SET)"]
        pub struct GP3SETrs;
        impl crate::RegisterSpec for GP3SETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3set::R`](R) reader structure"]
        impl crate::Readable for GP3SETrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3set::W`](W) writer structure"]
        impl crate::Writable for GP3SETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3SET to value 0"]
        impl crate::Resettable for GP3SETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3CLR (rw) register accessor: GPIO Port 3 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3CLR)\n\nFor information about available fields see [`mod@gp3clr`]
module"]
    pub type GP3CLR = crate::Reg<gp3clr::GP3CLRrs>;
    #[doc = "GPIO Port 3 Data Out Clear"]
    pub mod gp3clr {
        #[doc = "Register `GP3CLR` reader"]
        pub type R = crate::R<GP3CLRrs>;
        #[doc = "Register `GP3CLR` writer"]
        pub type W = crate::W<GP3CLRrs>;
        #[doc = "Field `CLR` writer - Set the Output Low for the Port Pin"]
        pub type CLR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3CLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output Low for the Port Pin"]
            #[inline(always)]
            pub fn clr(&mut self) -> CLR_W<GP3CLRrs> {
                CLR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3CLR)"]
        pub struct GP3CLRrs;
        impl crate::RegisterSpec for GP3CLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3clr::R`](R) reader structure"]
        impl crate::Readable for GP3CLRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3clr::W`](W) writer structure"]
        impl crate::Writable for GP3CLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3CLR to value 0"]
        impl crate::Resettable for GP3CLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3TGL (rw) register accessor: GPIO Port 3 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3tgl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3tgl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3TGL)\n\nFor information about available fields see [`mod@gp3tgl`]
module"]
    pub type GP3TGL = crate::Reg<gp3tgl::GP3TGLrs>;
    #[doc = "GPIO Port 3 Pin Toggle"]
    pub mod gp3tgl {
        #[doc = "Register `GP3TGL` reader"]
        pub type R = crate::R<GP3TGLrs>;
        #[doc = "Register `GP3TGL` writer"]
        pub type W = crate::W<GP3TGLrs>;
        #[doc = "Field `TGL` writer - Toggle the Output of the Port Pin"]
        pub type TGL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3TGL").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Toggle the Output of the Port Pin"]
            #[inline(always)]
            pub fn tgl(&mut self) -> TGL_W<GP3TGLrs> {
                TGL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3tgl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3tgl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3TGL)"]
        pub struct GP3TGLrs;
        impl crate::RegisterSpec for GP3TGLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3tgl::R`](R) reader structure"]
        impl crate::Readable for GP3TGLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3tgl::W`](W) writer structure"]
        impl crate::Writable for GP3TGLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3TGL to value 0"]
        impl crate::Resettable for GP3TGLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3ODE (rw) register accessor: GPIO Port 3 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3ODE)\n\nFor information about available fields see [`mod@gp3ode`]
module"]
    pub type GP3ODE = crate::Reg<gp3ode::GP3ODErs>;
    #[doc = "GPIO Port 3 Open Drain Enable"]
    pub mod gp3ode {
        #[doc = "Register `GP3ODE` reader"]
        pub type R = crate::R<GP3ODErs>;
        #[doc = "Register `GP3ODE` writer"]
        pub type W = crate::W<GP3ODErs>;
        #[doc = "Field `ODE` reader - Open Drain Enable"]
        pub type ODE_R = crate::FieldReader;
        #[doc = "Field `ODE` writer - Open Drain Enable"]
        pub type ODE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&self) -> ODE_R {
                ODE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3ODE").field("ode", &self.ode()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&mut self) -> ODE_W<GP3ODErs> {
                ODE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3ODE)"]
        pub struct GP3ODErs;
        impl crate::RegisterSpec for GP3ODErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3ode::R`](R) reader structure"]
        impl crate::Readable for GP3ODErs {}
        #[doc = "`write(|w| ..)` method takes [`gp3ode::W`](W) writer structure"]
        impl crate::Writable for GP3ODErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3ODE to value 0"]
        impl crate::Resettable for GP3ODErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3IS (rw) register accessor: GPIO Port 3 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3is::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3is::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IS)\n\nFor information about available fields see [`mod@gp3is`]
module"]
    pub type GP3IS = crate::Reg<gp3is::GP3ISrs>;
    #[doc = "GPIO Port 3 Input Select"]
    pub mod gp3is {
        #[doc = "Register `GP3IS` reader"]
        pub type R = crate::R<GP3ISrs>;
        #[doc = "Register `GP3IS` writer"]
        pub type W = crate::W<GP3ISrs>;
        #[doc = "Field `ISEL` reader - Input Select"]
        pub type ISEL_R = crate::FieldReader;
        #[doc = "Field `ISEL` writer - Input Select"]
        pub type ISEL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&self) -> ISEL_R {
                ISEL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3IS").field("isel", &self.isel()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&mut self) -> ISEL_W<GP3ISrs> {
                ISEL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3is::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3is::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IS)"]
        pub struct GP3ISrs;
        impl crate::RegisterSpec for GP3ISrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3is::R`](R) reader structure"]
        impl crate::Readable for GP3ISrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3is::W`](W) writer structure"]
        impl crate::Writable for GP3ISrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3IS to value 0xff"]
        impl crate::Resettable for GP3ISrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP3PE (rw) register accessor: GPIO Port 3 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3pe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3pe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3PE)\n\nFor information about available fields see [`mod@gp3pe`]
module"]
    pub type GP3PE = crate::Reg<gp3pe::GP3PErs>;
    #[doc = "GPIO Port 3 Pull Enable"]
    pub mod gp3pe {
        #[doc = "Register `GP3PE` reader"]
        pub type R = crate::R<GP3PErs>;
        #[doc = "Register `GP3PE` writer"]
        pub type W = crate::W<GP3PErs>;
        #[doc = "Field `PE` reader - Pull Enable"]
        pub type PE_R = crate::FieldReader;
        #[doc = "Field `PE` writer - Pull Enable"]
        pub type PE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3PE").field("pe", &self.pe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W<GP3PErs> {
                PE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3pe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3pe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3PE)"]
        pub struct GP3PErs;
        impl crate::RegisterSpec for GP3PErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3pe::R`](R) reader structure"]
        impl crate::Readable for GP3PErs {}
        #[doc = "`write(|w| ..)` method takes [`gp3pe::W`](W) writer structure"]
        impl crate::Writable for GP3PErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3PE to value 0"]
        impl crate::Resettable for GP3PErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3PS (rw) register accessor: GPIO Port 3 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ps::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ps::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3PS)\n\nFor information about available fields see [`mod@gp3ps`]
module"]
    pub type GP3PS = crate::Reg<gp3ps::GP3PSrs>;
    #[doc = "GPIO Port 3 Pull Select"]
    pub mod gp3ps {
        #[doc = "Register `GP3PS` reader"]
        pub type R = crate::R<GP3PSrs>;
        #[doc = "Register `GP3PS` writer"]
        pub type W = crate::W<GP3PSrs>;
        #[doc = "Field `PS` reader - Pull Select"]
        pub type PS_R = crate::FieldReader;
        #[doc = "Field `PS` writer - Pull Select"]
        pub type PS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3PS").field("ps", &self.ps()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W<GP3PSrs> {
                PS_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ps::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ps::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3PS)"]
        pub struct GP3PSrs;
        impl crate::RegisterSpec for GP3PSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3ps::R`](R) reader structure"]
        impl crate::Readable for GP3PSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3ps::W`](W) writer structure"]
        impl crate::Writable for GP3PSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3PS to value 0xff"]
        impl crate::Resettable for GP3PSrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP3SR (rw) register accessor: GPIO Port 3 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3SR)\n\nFor information about available fields see [`mod@gp3sr`]
module"]
    pub type GP3SR = crate::Reg<gp3sr::GP3SRrs>;
    #[doc = "GPIO Port 3 Slew Rate"]
    pub mod gp3sr {
        #[doc = "Register `GP3SR` reader"]
        pub type R = crate::R<GP3SRrs>;
        #[doc = "Register `GP3SR` writer"]
        pub type W = crate::W<GP3SRrs>;
        #[doc = "Field `SR` reader - Slew Rate"]
        pub type SR_R = crate::FieldReader;
        #[doc = "Field `SR` writer - Slew Rate"]
        pub type SR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&self) -> SR_R {
                SR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3SR").field("sr", &self.sr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&mut self) -> SR_W<GP3SRrs> {
                SR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 3 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3SR)"]
        pub struct GP3SRrs;
        impl crate::RegisterSpec for GP3SRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3sr::R`](R) reader structure"]
        impl crate::Readable for GP3SRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3sr::W`](W) writer structure"]
        impl crate::Writable for GP3SRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3SR to value 0"]
        impl crate::Resettable for GP3SRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3DS (rw) register accessor: GPIO Port 3 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ds::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ds::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3DS)\n\nFor information about available fields see [`mod@gp3ds`]
module"]
    pub type GP3DS = crate::Reg<gp3ds::GP3DSrs>;
    #[doc = "GPIO Port 3 Drive Select"]
    pub mod gp3ds {
        #[doc = "Register `GP3DS` reader"]
        pub type R = crate::R<GP3DSrs>;
        #[doc = "Register `GP3DS` writer"]
        pub type W = crate::W<GP3DSrs>;
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS0 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS0> for u8 {
            #[inline(always)]
            fn from(variant: DS0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS0 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS0 {}
        #[doc = "Field `DS0` reader - Drive Select"]
        pub type DS0_R = crate::FieldReader<DS0>;
        impl DS0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS0 {
                match self.bits {
                    0 => DS0::Strength1,
                    1 => DS0::Strength2,
                    2 => DS0::Strength3,
                    3 => DS0::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS0::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS0::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS0::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS0::Strength4
            }
        }
        #[doc = "Field `DS0` writer - Drive Select"]
        pub type DS0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS0, crate::Safe>;
        impl<'a, REG> DS0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS1 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS1> for u8 {
            #[inline(always)]
            fn from(variant: DS1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS1 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS1 {}
        #[doc = "Field `DS1` reader - Drive Select"]
        pub type DS1_R = crate::FieldReader<DS1>;
        impl DS1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS1 {
                match self.bits {
                    0 => DS1::Strength1,
                    1 => DS1::Strength2,
                    2 => DS1::Strength3,
                    3 => DS1::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS1::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS1::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS1::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS1::Strength4
            }
        }
        #[doc = "Field `DS1` writer - Drive Select"]
        pub type DS1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS1, crate::Safe>;
        impl<'a, REG> DS1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS2 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS2> for u8 {
            #[inline(always)]
            fn from(variant: DS2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS2 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS2 {}
        #[doc = "Field `DS2` reader - Drive Select"]
        pub type DS2_R = crate::FieldReader<DS2>;
        impl DS2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS2 {
                match self.bits {
                    0 => DS2::Strength1,
                    1 => DS2::Strength2,
                    2 => DS2::Strength3,
                    3 => DS2::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS2::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS2::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS2::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS2::Strength4
            }
        }
        #[doc = "Field `DS2` writer - Drive Select"]
        pub type DS2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS2, crate::Safe>;
        impl<'a, REG> DS2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS3 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS3> for u8 {
            #[inline(always)]
            fn from(variant: DS3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS3 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS3 {}
        #[doc = "Field `DS3` reader - Drive Select"]
        pub type DS3_R = crate::FieldReader<DS3>;
        impl DS3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS3 {
                match self.bits {
                    0 => DS3::Strength1,
                    1 => DS3::Strength2,
                    2 => DS3::Strength3,
                    3 => DS3::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS3::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS3::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS3::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS3::Strength4
            }
        }
        #[doc = "Field `DS3` writer - Drive Select"]
        pub type DS3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS3, crate::Safe>;
        impl<'a, REG> DS3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS4 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS4> for u8 {
            #[inline(always)]
            fn from(variant: DS4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS4 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS4 {}
        #[doc = "Field `DS4` reader - Drive Select"]
        pub type DS4_R = crate::FieldReader<DS4>;
        impl DS4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS4 {
                match self.bits {
                    0 => DS4::Strength1,
                    1 => DS4::Strength2,
                    2 => DS4::Strength3,
                    3 => DS4::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS4::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS4::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS4::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS4::Strength4
            }
        }
        #[doc = "Field `DS4` writer - Drive Select"]
        pub type DS4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS4, crate::Safe>;
        impl<'a, REG> DS4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS5 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS5> for u8 {
            #[inline(always)]
            fn from(variant: DS5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS5 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS5 {}
        #[doc = "Field `DS5` reader - Drive Select"]
        pub type DS5_R = crate::FieldReader<DS5>;
        impl DS5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS5 {
                match self.bits {
                    0 => DS5::Strength1,
                    1 => DS5::Strength2,
                    2 => DS5::Strength3,
                    3 => DS5::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS5::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS5::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS5::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS5::Strength4
            }
        }
        #[doc = "Field `DS5` writer - Drive Select"]
        pub type DS5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS5, crate::Safe>;
        impl<'a, REG> DS5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS6 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS6> for u8 {
            #[inline(always)]
            fn from(variant: DS6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS6 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS6 {}
        #[doc = "Field `DS6` reader - Drive Select"]
        pub type DS6_R = crate::FieldReader<DS6>;
        impl DS6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS6 {
                match self.bits {
                    0 => DS6::Strength1,
                    1 => DS6::Strength2,
                    2 => DS6::Strength3,
                    3 => DS6::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS6::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS6::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS6::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS6::Strength4
            }
        }
        #[doc = "Field `DS6` writer - Drive Select"]
        pub type DS6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS6, crate::Safe>;
        impl<'a, REG> DS6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS7 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS7> for u8 {
            #[inline(always)]
            fn from(variant: DS7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS7 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS7 {}
        #[doc = "Field `DS7` reader - Drive Select"]
        pub type DS7_R = crate::FieldReader<DS7>;
        impl DS7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS7 {
                match self.bits {
                    0 => DS7::Strength1,
                    1 => DS7::Strength2,
                    2 => DS7::Strength3,
                    3 => DS7::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS7::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS7::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS7::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS7::Strength4
            }
        }
        #[doc = "Field `DS7` writer - Drive Select"]
        pub type DS7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS7, crate::Safe>;
        impl<'a, REG> DS7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength4)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&self) -> DS0_R {
                DS0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&self) -> DS1_R {
                DS1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&self) -> DS2_R {
                DS2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&self) -> DS3_R {
                DS3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&self) -> DS4_R {
                DS4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&self) -> DS5_R {
                DS5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&self) -> DS6_R {
                DS6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&self) -> DS7_R {
                DS7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3DS")
                    .field("ds0", &self.ds0())
                    .field("ds1", &self.ds1())
                    .field("ds2", &self.ds2())
                    .field("ds3", &self.ds3())
                    .field("ds4", &self.ds4())
                    .field("ds5", &self.ds5())
                    .field("ds6", &self.ds6())
                    .field("ds7", &self.ds7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&mut self) -> DS0_W<GP3DSrs> {
                DS0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&mut self) -> DS1_W<GP3DSrs> {
                DS1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&mut self) -> DS2_W<GP3DSrs> {
                DS2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&mut self) -> DS3_W<GP3DSrs> {
                DS3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&mut self) -> DS4_W<GP3DSrs> {
                DS4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&mut self) -> DS5_W<GP3DSrs> {
                DS5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&mut self) -> DS6_W<GP3DSrs> {
                DS6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&mut self) -> DS7_W<GP3DSrs> {
                DS7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 3 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ds::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ds::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3DS)"]
        pub struct GP3DSrs;
        impl crate::RegisterSpec for GP3DSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3ds::R`](R) reader structure"]
        impl crate::Readable for GP3DSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3ds::W`](W) writer structure"]
        impl crate::Writable for GP3DSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3DS to value 0"]
        impl crate::Resettable for GP3DSrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3POL (rw) register accessor: GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3pol::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3pol::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3POL)\n\nFor information about available fields see [`mod@gp3pol`]
module"]
    pub type GP3POL = crate::Reg<gp3pol::GP3POLrs>;
    #[doc = "GPIO Interrupt Polarity Select"]
    pub mod gp3pol {
        #[doc = "Register `GP3POL` reader"]
        pub type R = crate::R<GP3POLrs>;
        #[doc = "Register `GP3POL` writer"]
        pub type W = crate::W<GP3POLrs>;
        #[doc = "Field `INTPOL` reader - Parametric Output"]
        pub type INTPOL_R = crate::FieldReader;
        #[doc = "Field `INTPOL` writer - Parametric Output"]
        pub type INTPOL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&self) -> INTPOL_R {
                INTPOL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3POL")
                    .field("intpol", &self.intpol())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&mut self) -> INTPOL_W<GP3POLrs> {
                INTPOL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3pol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3pol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3POL)"]
        pub struct GP3POLrs;
        impl crate::RegisterSpec for GP3POLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3pol::R`](R) reader structure"]
        impl crate::Readable for GP3POLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3pol::W`](W) writer structure"]
        impl crate::Writable for GP3POLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3POL to value 0"]
        impl crate::Resettable for GP3POLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3IENA (rw) register accessor: InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3iena::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3iena::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IENA)\n\nFor information about available fields see [`mod@gp3iena`]
module"]
    pub type GP3IENA = crate::Reg<gp3iena::GP3IENArs>;
    #[doc = "InterruptA Enable"]
    pub mod gp3iena {
        #[doc = "Register `GP3IENA` reader"]
        pub type R = crate::R<GP3IENArs>;
        #[doc = "Register `GP3IENA` writer"]
        pub type W = crate::W<GP3IENArs>;
        #[doc = "Field `INTAEN` reader - InterruptA Enable"]
        pub type INTAEN_R = crate::FieldReader;
        #[doc = "Field `INTAEN` writer - InterruptA Enable"]
        pub type INTAEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&self) -> INTAEN_R {
                INTAEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3IENA")
                    .field("intaen", &self.intaen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&mut self) -> INTAEN_W<GP3IENArs> {
                INTAEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3iena::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3iena::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IENA)"]
        pub struct GP3IENArs;
        impl crate::RegisterSpec for GP3IENArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3iena::R`](R) reader structure"]
        impl crate::Readable for GP3IENArs {}
        #[doc = "`write(|w| ..)` method takes [`gp3iena::W`](W) writer structure"]
        impl crate::Writable for GP3IENArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3IENA to value 0"]
        impl crate::Resettable for GP3IENArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3IENB (rw) register accessor: InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ienb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ienb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IENB)\n\nFor information about available fields see [`mod@gp3ienb`]
module"]
    pub type GP3IENB = crate::Reg<gp3ienb::GP3IENBrs>;
    #[doc = "InterruptB Enable"]
    pub mod gp3ienb {
        #[doc = "Register `GP3IENB` reader"]
        pub type R = crate::R<GP3IENBrs>;
        #[doc = "Register `GP3IENB` writer"]
        pub type W = crate::W<GP3IENBrs>;
        #[doc = "Field `INTBEN` reader - InterruptB Enable"]
        pub type INTBEN_R = crate::FieldReader;
        #[doc = "Field `INTBEN` writer - InterruptB Enable"]
        pub type INTBEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&self) -> INTBEN_R {
                INTBEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3IENB")
                    .field("intben", &self.intben())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&mut self) -> INTBEN_W<GP3IENBrs> {
                INTBEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3ienb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3ienb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3IENB)"]
        pub struct GP3IENBrs;
        impl crate::RegisterSpec for GP3IENBrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3ienb::R`](R) reader structure"]
        impl crate::Readable for GP3IENBrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3ienb::W`](W) writer structure"]
        impl crate::Writable for GP3IENBrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3IENB to value 0"]
        impl crate::Resettable for GP3IENBrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP3INT (rw) register accessor: Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3int::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3int::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3INT)\n\nFor information about available fields see [`mod@gp3int`]
module"]
    pub type GP3INT = crate::Reg<gp3int::GP3INTrs>;
    #[doc = "Interrupt Status"]
    pub mod gp3int {
        #[doc = "Register `GP3INT` reader"]
        pub type R = crate::R<GP3INTrs>;
        #[doc = "Register `GP3INT` writer"]
        pub type W = crate::W<GP3INTrs>;
        #[doc = "Field `INTSTATUS` reader - Interrupt Status"]
        pub type INTSTATUS_R = crate::FieldReader;
        #[doc = "Field `INTSTATUS` writer - Interrupt Status"]
        pub type INTSTATUS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&self) -> INTSTATUS_R {
                INTSTATUS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP3INT")
                    .field("intstatus", &self.intstatus())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&mut self) -> INTSTATUS_W<GP3INTrs> {
                INTSTATUS_W::new(self, 0)
            }
        }
        #[doc = "Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp3int::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp3int::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP3INT)"]
        pub struct GP3INTrs;
        impl crate::RegisterSpec for GP3INTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp3int::R`](R) reader structure"]
        impl crate::Readable for GP3INTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp3int::W`](W) writer structure"]
        impl crate::Writable for GP3INTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP3INT to value 0"]
        impl crate::Resettable for GP3INTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4CON (rw) register accessor: GPIO Port 4 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4CON)\n\nFor information about available fields see [`mod@gp4con`]
module"]
    pub type GP4CON = crate::Reg<gp4con::GP4CONrs>;
    #[doc = "GPIO Port 4 Configuration"]
    pub mod gp4con {
        #[doc = "Register `GP4CON` reader"]
        pub type R = crate::R<GP4CONrs>;
        #[doc = "Register `GP4CON` writer"]
        pub type W = crate::W<GP4CONrs>;
        #[doc = "P4.0 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON0 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: VDAC3"]
            Vdac3 = 1,
            #[doc = "3: PLAI\\[11\\]"]
            Plai11 = 3,
        }
        impl From<CON0> for u8 {
            #[inline(always)]
            fn from(variant: CON0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON0 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON0 {}
        #[doc = "Field `CON0` reader - P4.0 Configuration Bits"]
        pub type CON0_R = crate::FieldReader<CON0>;
        impl CON0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON0> {
                match self.bits {
                    0 => Some(CON0::Gpio),
                    1 => Some(CON0::Vdac3),
                    3 => Some(CON0::Plai11),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON0::Gpio
            }
            #[doc = "VDAC3"]
            #[inline(always)]
            pub fn is_vdac3(&self) -> bool {
                *self == CON0::Vdac3
            }
            #[doc = "PLAI\\[11\\]"]
            #[inline(always)]
            pub fn is_plai11(&self) -> bool {
                *self == CON0::Plai11
            }
        }
        #[doc = "Field `CON0` writer - P4.0 Configuration Bits"]
        pub type CON0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON0>;
        impl<'a, REG> CON0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Gpio)
            }
            #[doc = "VDAC3"]
            #[inline(always)]
            pub fn vdac3(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Vdac3)
            }
            #[doc = "PLAI\\[11\\]"]
            #[inline(always)]
            pub fn plai11(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Plai11)
            }
        }
        #[doc = "P4.1 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON1 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: VDAC6"]
            Vdac6 = 1,
            #[doc = "3: PLAO\\[28\\]"]
            Plao28 = 3,
        }
        impl From<CON1> for u8 {
            #[inline(always)]
            fn from(variant: CON1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON1 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON1 {}
        #[doc = "Field `CON1` reader - P4.1 Configuration Bits"]
        pub type CON1_R = crate::FieldReader<CON1>;
        impl CON1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON1> {
                match self.bits {
                    0 => Some(CON1::Gpio),
                    1 => Some(CON1::Vdac6),
                    3 => Some(CON1::Plao28),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON1::Gpio
            }
            #[doc = "VDAC6"]
            #[inline(always)]
            pub fn is_vdac6(&self) -> bool {
                *self == CON1::Vdac6
            }
            #[doc = "PLAO\\[28\\]"]
            #[inline(always)]
            pub fn is_plao28(&self) -> bool {
                *self == CON1::Plao28
            }
        }
        #[doc = "Field `CON1` writer - P4.1 Configuration Bits"]
        pub type CON1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON1>;
        impl<'a, REG> CON1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Gpio)
            }
            #[doc = "VDAC6"]
            #[inline(always)]
            pub fn vdac6(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Vdac6)
            }
            #[doc = "PLAO\\[28\\]"]
            #[inline(always)]
            pub fn plao28(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Plao28)
            }
        }
        #[doc = "P4.2 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON2 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: VDAC7"]
            Vdac7 = 1,
        }
        impl From<CON2> for u8 {
            #[inline(always)]
            fn from(variant: CON2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON2 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON2 {}
        #[doc = "Field `CON2` reader - P4.2 Configuration Bits"]
        pub type CON2_R = crate::FieldReader<CON2>;
        impl CON2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON2> {
                match self.bits {
                    0 => Some(CON2::Gpio),
                    1 => Some(CON2::Vdac7),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON2::Gpio
            }
            #[doc = "VDAC7"]
            #[inline(always)]
            pub fn is_vdac7(&self) -> bool {
                *self == CON2::Vdac7
            }
        }
        #[doc = "Field `CON2` writer - P4.2 Configuration Bits"]
        pub type CON2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON2>;
        impl<'a, REG> CON2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Gpio)
            }
            #[doc = "VDAC7"]
            #[inline(always)]
            pub fn vdac7(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Vdac7)
            }
        }
        #[doc = "P4.3 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON3 {
            #[doc = "0: GPIO"]
            Gpio = 0,
        }
        impl From<CON3> for u8 {
            #[inline(always)]
            fn from(variant: CON3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON3 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON3 {}
        #[doc = "Field `CON3` reader - P4.3 Configuration Bits"]
        pub type CON3_R = crate::FieldReader<CON3>;
        impl CON3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON3> {
                match self.bits {
                    0 => Some(CON3::Gpio),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON3::Gpio
            }
        }
        #[doc = "Field `CON3` writer - P4.3 Configuration Bits"]
        pub type CON3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON3>;
        impl<'a, REG> CON3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Gpio)
            }
        }
        #[doc = "P4.4 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON4 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: VDAC5"]
            Vdac5 = 1,
        }
        impl From<CON4> for u8 {
            #[inline(always)]
            fn from(variant: CON4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON4 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON4 {}
        #[doc = "Field `CON4` reader - P4.4 Configuration Bits"]
        pub type CON4_R = crate::FieldReader<CON4>;
        impl CON4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON4> {
                match self.bits {
                    0 => Some(CON4::Gpio),
                    1 => Some(CON4::Vdac5),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON4::Gpio
            }
            #[doc = "VDAC5"]
            #[inline(always)]
            pub fn is_vdac5(&self) -> bool {
                *self == CON4::Vdac5
            }
        }
        #[doc = "Field `CON4` writer - P4.4 Configuration Bits"]
        pub type CON4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON4>;
        impl<'a, REG> CON4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Gpio)
            }
            #[doc = "VDAC5"]
            #[inline(always)]
            pub fn vdac5(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Vdac5)
            }
        }
        #[doc = "P4.5 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON5 {
            #[doc = "0: GPIO"]
            Gpio = 0,
        }
        impl From<CON5> for u8 {
            #[inline(always)]
            fn from(variant: CON5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON5 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON5 {}
        #[doc = "Field `CON5` reader - P4.5 Configuration Bits"]
        pub type CON5_R = crate::FieldReader<CON5>;
        impl CON5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON5> {
                match self.bits {
                    0 => Some(CON5::Gpio),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON5::Gpio
            }
        }
        #[doc = "Field `CON5` writer - P4.5 Configuration Bits"]
        pub type CON5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON5>;
        impl<'a, REG> CON5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Gpio)
            }
        }
        #[doc = "P4.7 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON7 {
            #[doc = "0: GPIO/IRQ7"]
            Gpioirq7 = 0,
            #[doc = "2: PLA Clock 2"]
            Placlk2 = 2,
        }
        impl From<CON7> for u8 {
            #[inline(always)]
            fn from(variant: CON7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON7 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON7 {}
        #[doc = "Field `CON7` reader - P4.7 Configuration Bits"]
        pub type CON7_R = crate::FieldReader<CON7>;
        impl CON7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON7> {
                match self.bits {
                    0 => Some(CON7::Gpioirq7),
                    2 => Some(CON7::Placlk2),
                    _ => None,
                }
            }
            #[doc = "GPIO/IRQ7"]
            #[inline(always)]
            pub fn is_gpioirq7(&self) -> bool {
                *self == CON7::Gpioirq7
            }
            #[doc = "PLA Clock 2"]
            #[inline(always)]
            pub fn is_placlk2(&self) -> bool {
                *self == CON7::Placlk2
            }
        }
        #[doc = "Field `CON7` writer - P4.7 Configuration Bits"]
        pub type CON7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON7>;
        impl<'a, REG> CON7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ7"]
            #[inline(always)]
            pub fn gpioirq7(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Gpioirq7)
            }
            #[doc = "PLA Clock 2"]
            #[inline(always)]
            pub fn placlk2(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Placlk2)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - P4.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&self) -> CON0_R {
                CON0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - P4.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&self) -> CON1_R {
                CON1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - P4.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&self) -> CON2_R {
                CON2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - P4.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&self) -> CON3_R {
                CON3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - P4.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&self) -> CON4_R {
                CON4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - P4.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&self) -> CON5_R {
                CON5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 14:15 - P4.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&self) -> CON7_R {
                CON7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4CON")
                    .field("con0", &self.con0())
                    .field("con1", &self.con1())
                    .field("con2", &self.con2())
                    .field("con3", &self.con3())
                    .field("con4", &self.con4())
                    .field("con5", &self.con5())
                    .field("con7", &self.con7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - P4.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&mut self) -> CON0_W<GP4CONrs> {
                CON0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - P4.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&mut self) -> CON1_W<GP4CONrs> {
                CON1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - P4.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&mut self) -> CON2_W<GP4CONrs> {
                CON2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - P4.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&mut self) -> CON3_W<GP4CONrs> {
                CON3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - P4.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&mut self) -> CON4_W<GP4CONrs> {
                CON4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - P4.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&mut self) -> CON5_W<GP4CONrs> {
                CON5_W::new(self, 10)
            }
            #[doc = "Bits 14:15 - P4.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&mut self) -> CON7_W<GP4CONrs> {
                CON7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 4 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4CON)"]
        pub struct GP4CONrs;
        impl crate::RegisterSpec for GP4CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4con::R`](R) reader structure"]
        impl crate::Readable for GP4CONrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4con::W`](W) writer structure"]
        impl crate::Writable for GP4CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4CON to value 0"]
        impl crate::Resettable for GP4CONrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4OE (rw) register accessor: GPIO Port 4 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4oe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4oe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4OE)\n\nFor information about available fields see [`mod@gp4oe`]
module"]
    pub type GP4OE = crate::Reg<gp4oe::GP4OErs>;
    #[doc = "GPIO Port 4 Output Enable"]
    pub mod gp4oe {
        #[doc = "Register `GP4OE` reader"]
        pub type R = crate::R<GP4OErs>;
        #[doc = "Register `GP4OE` writer"]
        pub type W = crate::W<GP4OErs>;
        #[doc = "Field `OE` reader - Output Enable"]
        pub type OE_R = crate::FieldReader;
        #[doc = "Field `OE` writer - Output Enable"]
        pub type OE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4OE").field("oe", &self.oe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&mut self) -> OE_W<GP4OErs> {
                OE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4oe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4oe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4OE)"]
        pub struct GP4OErs;
        impl crate::RegisterSpec for GP4OErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4oe::R`](R) reader structure"]
        impl crate::Readable for GP4OErs {}
        #[doc = "`write(|w| ..)` method takes [`gp4oe::W`](W) writer structure"]
        impl crate::Writable for GP4OErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4OE to value 0"]
        impl crate::Resettable for GP4OErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4IE (rw) register accessor: GPIO Port 4 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IE)\n\nFor information about available fields see [`mod@gp4ie`]
module"]
    pub type GP4IE = crate::Reg<gp4ie::GP4IErs>;
    #[doc = "GPIO Port 4 Input Path Enable"]
    pub mod gp4ie {
        #[doc = "Register `GP4IE` reader"]
        pub type R = crate::R<GP4IErs>;
        #[doc = "Register `GP4IE` writer"]
        pub type W = crate::W<GP4IErs>;
        #[doc = "Field `IE` reader - Input Enable"]
        pub type IE_R = crate::FieldReader;
        #[doc = "Field `IE` writer - Input Enable"]
        pub type IE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&self) -> IE_R {
                IE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4IE").field("ie", &self.ie()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&mut self) -> IE_W<GP4IErs> {
                IE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IE)"]
        pub struct GP4IErs;
        impl crate::RegisterSpec for GP4IErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4ie::R`](R) reader structure"]
        impl crate::Readable for GP4IErs {}
        #[doc = "`write(|w| ..)` method takes [`gp4ie::W`](W) writer structure"]
        impl crate::Writable for GP4IErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4IE to value 0"]
        impl crate::Resettable for GP4IErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4IN (rw) register accessor: GPIO Port 4 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IN)\n\nFor information about available fields see [`mod@gp4in`]
module"]
    pub type GP4IN = crate::Reg<gp4in::GP4INrs>;
    #[doc = "GPIO Port 4 Registered Data Input"]
    pub mod gp4in {
        #[doc = "Register `GP4IN` reader"]
        pub type R = crate::R<GP4INrs>;
        #[doc = "Register `GP4IN` writer"]
        pub type W = crate::W<GP4INrs>;
        #[doc = "Field `Y` reader - Data Input from Pad"]
        pub type Y_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Data Input from Pad"]
            #[inline(always)]
            pub fn y(&self) -> Y_R {
                Y_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4IN").field("y", &self.y()).finish()
            }
        }
        impl W {}
        #[doc = "GPIO Port 4 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IN)"]
        pub struct GP4INrs;
        impl crate::RegisterSpec for GP4INrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4in::R`](R) reader structure"]
        impl crate::Readable for GP4INrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4in::W`](W) writer structure"]
        impl crate::Writable for GP4INrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4IN to value 0"]
        impl crate::Resettable for GP4INrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4OUT (rw) register accessor: GPIO Port 4 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4OUT)\n\nFor information about available fields see [`mod@gp4out`]
module"]
    pub type GP4OUT = crate::Reg<gp4out::GP4OUTrs>;
    #[doc = "GPIO Port 4 Data Output"]
    pub mod gp4out {
        #[doc = "Register `GP4OUT` reader"]
        pub type R = crate::R<GP4OUTrs>;
        #[doc = "Register `GP4OUT` writer"]
        pub type W = crate::W<GP4OUTrs>;
        #[doc = "Field `A` reader - Data Output to Pad"]
        pub type A_R = crate::FieldReader;
        #[doc = "Field `A` writer - Data Output to Pad"]
        pub type A_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&self) -> A_R {
                A_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4OUT").field("a", &self.a()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&mut self) -> A_W<GP4OUTrs> {
                A_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4OUT)"]
        pub struct GP4OUTrs;
        impl crate::RegisterSpec for GP4OUTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4out::R`](R) reader structure"]
        impl crate::Readable for GP4OUTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4out::W`](W) writer structure"]
        impl crate::Writable for GP4OUTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4OUT to value 0"]
        impl crate::Resettable for GP4OUTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4SET (rw) register accessor: GPIO Port 4 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4SET)\n\nFor information about available fields see [`mod@gp4set`]
module"]
    pub type GP4SET = crate::Reg<gp4set::GP4SETrs>;
    #[doc = "GPIO Port 4 Data Out Set"]
    pub mod gp4set {
        #[doc = "Register `GP4SET` reader"]
        pub type R = crate::R<GP4SETrs>;
        #[doc = "Register `GP4SET` writer"]
        pub type W = crate::W<GP4SETrs>;
        #[doc = "Field `SETUP` writer - Set the Output HIGH for the Pin"]
        pub type SETUP_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4SET").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output HIGH for the Pin"]
            #[inline(always)]
            pub fn setup(&mut self) -> SETUP_W<GP4SETrs> {
                SETUP_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4SET)"]
        pub struct GP4SETrs;
        impl crate::RegisterSpec for GP4SETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4set::R`](R) reader structure"]
        impl crate::Readable for GP4SETrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4set::W`](W) writer structure"]
        impl crate::Writable for GP4SETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4SET to value 0"]
        impl crate::Resettable for GP4SETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4CLR (rw) register accessor: GPIO Port 4 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4CLR)\n\nFor information about available fields see [`mod@gp4clr`]
module"]
    pub type GP4CLR = crate::Reg<gp4clr::GP4CLRrs>;
    #[doc = "GPIO Port 4 Data Out Clear"]
    pub mod gp4clr {
        #[doc = "Register `GP4CLR` reader"]
        pub type R = crate::R<GP4CLRrs>;
        #[doc = "Register `GP4CLR` writer"]
        pub type W = crate::W<GP4CLRrs>;
        #[doc = "Field `CLR` writer - Set the Output Low for the Port Pin"]
        pub type CLR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4CLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output Low for the Port Pin"]
            #[inline(always)]
            pub fn clr(&mut self) -> CLR_W<GP4CLRrs> {
                CLR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4CLR)"]
        pub struct GP4CLRrs;
        impl crate::RegisterSpec for GP4CLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4clr::R`](R) reader structure"]
        impl crate::Readable for GP4CLRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4clr::W`](W) writer structure"]
        impl crate::Writable for GP4CLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4CLR to value 0"]
        impl crate::Resettable for GP4CLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4TGL (rw) register accessor: GPIO Port 4 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4tgl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4tgl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4TGL)\n\nFor information about available fields see [`mod@gp4tgl`]
module"]
    pub type GP4TGL = crate::Reg<gp4tgl::GP4TGLrs>;
    #[doc = "GPIO Port 4 Pin Toggle"]
    pub mod gp4tgl {
        #[doc = "Register `GP4TGL` reader"]
        pub type R = crate::R<GP4TGLrs>;
        #[doc = "Register `GP4TGL` writer"]
        pub type W = crate::W<GP4TGLrs>;
        #[doc = "Field `TGL` writer - Toggle the Output of the Port Pin"]
        pub type TGL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4TGL").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Toggle the Output of the Port Pin"]
            #[inline(always)]
            pub fn tgl(&mut self) -> TGL_W<GP4TGLrs> {
                TGL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4tgl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4tgl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4TGL)"]
        pub struct GP4TGLrs;
        impl crate::RegisterSpec for GP4TGLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4tgl::R`](R) reader structure"]
        impl crate::Readable for GP4TGLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4tgl::W`](W) writer structure"]
        impl crate::Writable for GP4TGLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4TGL to value 0"]
        impl crate::Resettable for GP4TGLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4ODE (rw) register accessor: GPIO Port 4 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4ODE)\n\nFor information about available fields see [`mod@gp4ode`]
module"]
    pub type GP4ODE = crate::Reg<gp4ode::GP4ODErs>;
    #[doc = "GPIO Port 4 Open Drain Enable"]
    pub mod gp4ode {
        #[doc = "Register `GP4ODE` reader"]
        pub type R = crate::R<GP4ODErs>;
        #[doc = "Register `GP4ODE` writer"]
        pub type W = crate::W<GP4ODErs>;
        #[doc = "Field `ODE` reader - Open Drain Enable"]
        pub type ODE_R = crate::FieldReader;
        #[doc = "Field `ODE` writer - Open Drain Enable"]
        pub type ODE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&self) -> ODE_R {
                ODE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4ODE").field("ode", &self.ode()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&mut self) -> ODE_W<GP4ODErs> {
                ODE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4ODE)"]
        pub struct GP4ODErs;
        impl crate::RegisterSpec for GP4ODErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4ode::R`](R) reader structure"]
        impl crate::Readable for GP4ODErs {}
        #[doc = "`write(|w| ..)` method takes [`gp4ode::W`](W) writer structure"]
        impl crate::Writable for GP4ODErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4ODE to value 0"]
        impl crate::Resettable for GP4ODErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4IS (rw) register accessor: GPIO Port 4 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4is::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4is::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IS)\n\nFor information about available fields see [`mod@gp4is`]
module"]
    pub type GP4IS = crate::Reg<gp4is::GP4ISrs>;
    #[doc = "GPIO Port 4 Input Select"]
    pub mod gp4is {
        #[doc = "Register `GP4IS` reader"]
        pub type R = crate::R<GP4ISrs>;
        #[doc = "Register `GP4IS` writer"]
        pub type W = crate::W<GP4ISrs>;
        #[doc = "Field `ISEL` reader - Input Select"]
        pub type ISEL_R = crate::FieldReader;
        #[doc = "Field `ISEL` writer - Input Select"]
        pub type ISEL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&self) -> ISEL_R {
                ISEL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4IS").field("isel", &self.isel()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&mut self) -> ISEL_W<GP4ISrs> {
                ISEL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4is::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4is::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IS)"]
        pub struct GP4ISrs;
        impl crate::RegisterSpec for GP4ISrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4is::R`](R) reader structure"]
        impl crate::Readable for GP4ISrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4is::W`](W) writer structure"]
        impl crate::Writable for GP4ISrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4IS to value 0xff"]
        impl crate::Resettable for GP4ISrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP4PE (rw) register accessor: GPIO Port 4 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4pe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4pe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4PE)\n\nFor information about available fields see [`mod@gp4pe`]
module"]
    pub type GP4PE = crate::Reg<gp4pe::GP4PErs>;
    #[doc = "GPIO Port 4 Pull Enable"]
    pub mod gp4pe {
        #[doc = "Register `GP4PE` reader"]
        pub type R = crate::R<GP4PErs>;
        #[doc = "Register `GP4PE` writer"]
        pub type W = crate::W<GP4PErs>;
        #[doc = "Field `PE` reader - Pull Enable"]
        pub type PE_R = crate::FieldReader;
        #[doc = "Field `PE` writer - Pull Enable"]
        pub type PE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4PE").field("pe", &self.pe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W<GP4PErs> {
                PE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4pe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4pe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4PE)"]
        pub struct GP4PErs;
        impl crate::RegisterSpec for GP4PErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4pe::R`](R) reader structure"]
        impl crate::Readable for GP4PErs {}
        #[doc = "`write(|w| ..)` method takes [`gp4pe::W`](W) writer structure"]
        impl crate::Writable for GP4PErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4PE to value 0"]
        impl crate::Resettable for GP4PErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4PS (rw) register accessor: GPIO Port 4 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ps::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ps::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4PS)\n\nFor information about available fields see [`mod@gp4ps`]
module"]
    pub type GP4PS = crate::Reg<gp4ps::GP4PSrs>;
    #[doc = "GPIO Port 4 Pull Select"]
    pub mod gp4ps {
        #[doc = "Register `GP4PS` reader"]
        pub type R = crate::R<GP4PSrs>;
        #[doc = "Register `GP4PS` writer"]
        pub type W = crate::W<GP4PSrs>;
        #[doc = "Field `PS` reader - Pull Select"]
        pub type PS_R = crate::FieldReader;
        #[doc = "Field `PS` writer - Pull Select"]
        pub type PS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4PS").field("ps", &self.ps()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W<GP4PSrs> {
                PS_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ps::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ps::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4PS)"]
        pub struct GP4PSrs;
        impl crate::RegisterSpec for GP4PSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4ps::R`](R) reader structure"]
        impl crate::Readable for GP4PSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4ps::W`](W) writer structure"]
        impl crate::Writable for GP4PSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4PS to value 0xff"]
        impl crate::Resettable for GP4PSrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP4SR (rw) register accessor: GPIO Port 4 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4SR)\n\nFor information about available fields see [`mod@gp4sr`]
module"]
    pub type GP4SR = crate::Reg<gp4sr::GP4SRrs>;
    #[doc = "GPIO Port 4 Slew Rate"]
    pub mod gp4sr {
        #[doc = "Register `GP4SR` reader"]
        pub type R = crate::R<GP4SRrs>;
        #[doc = "Register `GP4SR` writer"]
        pub type W = crate::W<GP4SRrs>;
        #[doc = "Field `SR` reader - Slew Rate"]
        pub type SR_R = crate::FieldReader;
        #[doc = "Field `SR` writer - Slew Rate"]
        pub type SR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&self) -> SR_R {
                SR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4SR").field("sr", &self.sr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&mut self) -> SR_W<GP4SRrs> {
                SR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 4 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4SR)"]
        pub struct GP4SRrs;
        impl crate::RegisterSpec for GP4SRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4sr::R`](R) reader structure"]
        impl crate::Readable for GP4SRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4sr::W`](W) writer structure"]
        impl crate::Writable for GP4SRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4SR to value 0"]
        impl crate::Resettable for GP4SRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4DS (rw) register accessor: GPIO Port 4 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ds::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ds::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4DS)\n\nFor information about available fields see [`mod@gp4ds`]
module"]
    pub type GP4DS = crate::Reg<gp4ds::GP4DSrs>;
    #[doc = "GPIO Port 4 Drive Select"]
    pub mod gp4ds {
        #[doc = "Register `GP4DS` reader"]
        pub type R = crate::R<GP4DSrs>;
        #[doc = "Register `GP4DS` writer"]
        pub type W = crate::W<GP4DSrs>;
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS0 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS0> for u8 {
            #[inline(always)]
            fn from(variant: DS0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS0 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS0 {}
        #[doc = "Field `DS0` reader - Drive Select"]
        pub type DS0_R = crate::FieldReader<DS0>;
        impl DS0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS0 {
                match self.bits {
                    0 => DS0::Strength1,
                    1 => DS0::Strength2,
                    2 => DS0::Strength3,
                    3 => DS0::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS0::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS0::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS0::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS0::Strength4
            }
        }
        #[doc = "Field `DS0` writer - Drive Select"]
        pub type DS0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS0, crate::Safe>;
        impl<'a, REG> DS0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS1 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS1> for u8 {
            #[inline(always)]
            fn from(variant: DS1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS1 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS1 {}
        #[doc = "Field `DS1` reader - Drive Select"]
        pub type DS1_R = crate::FieldReader<DS1>;
        impl DS1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS1 {
                match self.bits {
                    0 => DS1::Strength1,
                    1 => DS1::Strength2,
                    2 => DS1::Strength3,
                    3 => DS1::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS1::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS1::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS1::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS1::Strength4
            }
        }
        #[doc = "Field `DS1` writer - Drive Select"]
        pub type DS1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS1, crate::Safe>;
        impl<'a, REG> DS1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS2 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS2> for u8 {
            #[inline(always)]
            fn from(variant: DS2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS2 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS2 {}
        #[doc = "Field `DS2` reader - Drive Select"]
        pub type DS2_R = crate::FieldReader<DS2>;
        impl DS2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS2 {
                match self.bits {
                    0 => DS2::Strength1,
                    1 => DS2::Strength2,
                    2 => DS2::Strength3,
                    3 => DS2::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS2::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS2::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS2::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS2::Strength4
            }
        }
        #[doc = "Field `DS2` writer - Drive Select"]
        pub type DS2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS2, crate::Safe>;
        impl<'a, REG> DS2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS3 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS3> for u8 {
            #[inline(always)]
            fn from(variant: DS3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS3 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS3 {}
        #[doc = "Field `DS3` reader - Drive Select"]
        pub type DS3_R = crate::FieldReader<DS3>;
        impl DS3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS3 {
                match self.bits {
                    0 => DS3::Strength1,
                    1 => DS3::Strength2,
                    2 => DS3::Strength3,
                    3 => DS3::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS3::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS3::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS3::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS3::Strength4
            }
        }
        #[doc = "Field `DS3` writer - Drive Select"]
        pub type DS3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS3, crate::Safe>;
        impl<'a, REG> DS3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS4 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS4> for u8 {
            #[inline(always)]
            fn from(variant: DS4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS4 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS4 {}
        #[doc = "Field `DS4` reader - Drive Select"]
        pub type DS4_R = crate::FieldReader<DS4>;
        impl DS4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS4 {
                match self.bits {
                    0 => DS4::Strength1,
                    1 => DS4::Strength2,
                    2 => DS4::Strength3,
                    3 => DS4::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS4::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS4::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS4::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS4::Strength4
            }
        }
        #[doc = "Field `DS4` writer - Drive Select"]
        pub type DS4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS4, crate::Safe>;
        impl<'a, REG> DS4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS5 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS5> for u8 {
            #[inline(always)]
            fn from(variant: DS5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS5 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS5 {}
        #[doc = "Field `DS5` reader - Drive Select"]
        pub type DS5_R = crate::FieldReader<DS5>;
        impl DS5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS5 {
                match self.bits {
                    0 => DS5::Strength1,
                    1 => DS5::Strength2,
                    2 => DS5::Strength3,
                    3 => DS5::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS5::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS5::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS5::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS5::Strength4
            }
        }
        #[doc = "Field `DS5` writer - Drive Select"]
        pub type DS5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS5, crate::Safe>;
        impl<'a, REG> DS5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS6 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS6> for u8 {
            #[inline(always)]
            fn from(variant: DS6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS6 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS6 {}
        #[doc = "Field `DS6` reader - Drive Select"]
        pub type DS6_R = crate::FieldReader<DS6>;
        impl DS6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS6 {
                match self.bits {
                    0 => DS6::Strength1,
                    1 => DS6::Strength2,
                    2 => DS6::Strength3,
                    3 => DS6::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS6::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS6::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS6::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS6::Strength4
            }
        }
        #[doc = "Field `DS6` writer - Drive Select"]
        pub type DS6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS6, crate::Safe>;
        impl<'a, REG> DS6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS7 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS7> for u8 {
            #[inline(always)]
            fn from(variant: DS7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS7 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS7 {}
        #[doc = "Field `DS7` reader - Drive Select"]
        pub type DS7_R = crate::FieldReader<DS7>;
        impl DS7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS7 {
                match self.bits {
                    0 => DS7::Strength1,
                    1 => DS7::Strength2,
                    2 => DS7::Strength3,
                    3 => DS7::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS7::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS7::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS7::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS7::Strength4
            }
        }
        #[doc = "Field `DS7` writer - Drive Select"]
        pub type DS7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS7, crate::Safe>;
        impl<'a, REG> DS7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength4)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&self) -> DS0_R {
                DS0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&self) -> DS1_R {
                DS1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&self) -> DS2_R {
                DS2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&self) -> DS3_R {
                DS3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&self) -> DS4_R {
                DS4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&self) -> DS5_R {
                DS5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&self) -> DS6_R {
                DS6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&self) -> DS7_R {
                DS7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4DS")
                    .field("ds0", &self.ds0())
                    .field("ds1", &self.ds1())
                    .field("ds2", &self.ds2())
                    .field("ds3", &self.ds3())
                    .field("ds4", &self.ds4())
                    .field("ds5", &self.ds5())
                    .field("ds6", &self.ds6())
                    .field("ds7", &self.ds7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&mut self) -> DS0_W<GP4DSrs> {
                DS0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&mut self) -> DS1_W<GP4DSrs> {
                DS1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&mut self) -> DS2_W<GP4DSrs> {
                DS2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&mut self) -> DS3_W<GP4DSrs> {
                DS3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&mut self) -> DS4_W<GP4DSrs> {
                DS4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&mut self) -> DS5_W<GP4DSrs> {
                DS5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&mut self) -> DS6_W<GP4DSrs> {
                DS6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&mut self) -> DS7_W<GP4DSrs> {
                DS7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 4 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ds::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ds::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4DS)"]
        pub struct GP4DSrs;
        impl crate::RegisterSpec for GP4DSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4ds::R`](R) reader structure"]
        impl crate::Readable for GP4DSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4ds::W`](W) writer structure"]
        impl crate::Writable for GP4DSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4DS to value 0"]
        impl crate::Resettable for GP4DSrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4POL (rw) register accessor: GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4pol::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4pol::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4POL)\n\nFor information about available fields see [`mod@gp4pol`]
module"]
    pub type GP4POL = crate::Reg<gp4pol::GP4POLrs>;
    #[doc = "GPIO Interrupt Polarity Select"]
    pub mod gp4pol {
        #[doc = "Register `GP4POL` reader"]
        pub type R = crate::R<GP4POLrs>;
        #[doc = "Register `GP4POL` writer"]
        pub type W = crate::W<GP4POLrs>;
        #[doc = "Field `INTPOL` reader - Parametric Output"]
        pub type INTPOL_R = crate::FieldReader;
        #[doc = "Field `INTPOL` writer - Parametric Output"]
        pub type INTPOL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&self) -> INTPOL_R {
                INTPOL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4POL")
                    .field("intpol", &self.intpol())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&mut self) -> INTPOL_W<GP4POLrs> {
                INTPOL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4pol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4pol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4POL)"]
        pub struct GP4POLrs;
        impl crate::RegisterSpec for GP4POLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4pol::R`](R) reader structure"]
        impl crate::Readable for GP4POLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4pol::W`](W) writer structure"]
        impl crate::Writable for GP4POLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4POL to value 0"]
        impl crate::Resettable for GP4POLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4IENA (rw) register accessor: InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4iena::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4iena::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IENA)\n\nFor information about available fields see [`mod@gp4iena`]
module"]
    pub type GP4IENA = crate::Reg<gp4iena::GP4IENArs>;
    #[doc = "InterruptA Enable"]
    pub mod gp4iena {
        #[doc = "Register `GP4IENA` reader"]
        pub type R = crate::R<GP4IENArs>;
        #[doc = "Register `GP4IENA` writer"]
        pub type W = crate::W<GP4IENArs>;
        #[doc = "Field `INTAEN` reader - InterruptA Enable"]
        pub type INTAEN_R = crate::FieldReader;
        #[doc = "Field `INTAEN` writer - InterruptA Enable"]
        pub type INTAEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&self) -> INTAEN_R {
                INTAEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4IENA")
                    .field("intaen", &self.intaen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&mut self) -> INTAEN_W<GP4IENArs> {
                INTAEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4iena::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4iena::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IENA)"]
        pub struct GP4IENArs;
        impl crate::RegisterSpec for GP4IENArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4iena::R`](R) reader structure"]
        impl crate::Readable for GP4IENArs {}
        #[doc = "`write(|w| ..)` method takes [`gp4iena::W`](W) writer structure"]
        impl crate::Writable for GP4IENArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4IENA to value 0"]
        impl crate::Resettable for GP4IENArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4IENB (rw) register accessor: InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ienb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ienb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IENB)\n\nFor information about available fields see [`mod@gp4ienb`]
module"]
    pub type GP4IENB = crate::Reg<gp4ienb::GP4IENBrs>;
    #[doc = "InterruptB Enable"]
    pub mod gp4ienb {
        #[doc = "Register `GP4IENB` reader"]
        pub type R = crate::R<GP4IENBrs>;
        #[doc = "Register `GP4IENB` writer"]
        pub type W = crate::W<GP4IENBrs>;
        #[doc = "Field `INTBEN` reader - InterruptB Enable"]
        pub type INTBEN_R = crate::FieldReader;
        #[doc = "Field `INTBEN` writer - InterruptB Enable"]
        pub type INTBEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&self) -> INTBEN_R {
                INTBEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4IENB")
                    .field("intben", &self.intben())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&mut self) -> INTBEN_W<GP4IENBrs> {
                INTBEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4ienb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4ienb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4IENB)"]
        pub struct GP4IENBrs;
        impl crate::RegisterSpec for GP4IENBrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4ienb::R`](R) reader structure"]
        impl crate::Readable for GP4IENBrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4ienb::W`](W) writer structure"]
        impl crate::Writable for GP4IENBrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4IENB to value 0"]
        impl crate::Resettable for GP4IENBrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP4INT (rw) register accessor: Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4int::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4int::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4INT)\n\nFor information about available fields see [`mod@gp4int`]
module"]
    pub type GP4INT = crate::Reg<gp4int::GP4INTrs>;
    #[doc = "Interrupt Status"]
    pub mod gp4int {
        #[doc = "Register `GP4INT` reader"]
        pub type R = crate::R<GP4INTrs>;
        #[doc = "Register `GP4INT` writer"]
        pub type W = crate::W<GP4INTrs>;
        #[doc = "Field `INTSTATUS` reader - Interrupt Status"]
        pub type INTSTATUS_R = crate::FieldReader;
        #[doc = "Field `INTSTATUS` writer - Interrupt Status"]
        pub type INTSTATUS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&self) -> INTSTATUS_R {
                INTSTATUS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP4INT")
                    .field("intstatus", &self.intstatus())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&mut self) -> INTSTATUS_W<GP4INTrs> {
                INTSTATUS_W::new(self, 0)
            }
        }
        #[doc = "Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp4int::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp4int::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP4INT)"]
        pub struct GP4INTrs;
        impl crate::RegisterSpec for GP4INTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp4int::R`](R) reader structure"]
        impl crate::Readable for GP4INTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp4int::W`](W) writer structure"]
        impl crate::Writable for GP4INTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP4INT to value 0"]
        impl crate::Resettable for GP4INTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5CON (rw) register accessor: GPIO Port 6 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5CON)\n\nFor information about available fields see [`mod@gp5con`]
module"]
    pub type GP5CON = crate::Reg<gp5con::GP5CONrs>;
    #[doc = "GPIO Port 6 Configuration"]
    pub mod gp5con {
        #[doc = "Register `GP5CON` reader"]
        pub type R = crate::R<GP5CONrs>;
        #[doc = "Register `GP5CON` writer"]
        pub type W = crate::W<GP5CONrs>;
        #[doc = "P5.0 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON0 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: Full Mux 0"]
            FullMux0 = 1,
            #[doc = "2: VDAC8"]
            Vdac8 = 2,
        }
        impl From<CON0> for u8 {
            #[inline(always)]
            fn from(variant: CON0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON0 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON0 {}
        #[doc = "Field `CON0` reader - P5.0 Configuration Bits"]
        pub type CON0_R = crate::FieldReader<CON0>;
        impl CON0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON0> {
                match self.bits {
                    0 => Some(CON0::Gpio),
                    1 => Some(CON0::FullMux0),
                    2 => Some(CON0::Vdac8),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON0::Gpio
            }
            #[doc = "Full Mux 0"]
            #[inline(always)]
            pub fn is_full_mux0(&self) -> bool {
                *self == CON0::FullMux0
            }
            #[doc = "VDAC8"]
            #[inline(always)]
            pub fn is_vdac8(&self) -> bool {
                *self == CON0::Vdac8
            }
        }
        #[doc = "Field `CON0` writer - P5.0 Configuration Bits"]
        pub type CON0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON0>;
        impl<'a, REG> CON0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Gpio)
            }
            #[doc = "Full Mux 0"]
            #[inline(always)]
            pub fn full_mux0(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::FullMux0)
            }
            #[doc = "VDAC8"]
            #[inline(always)]
            pub fn vdac8(self) -> &'a mut crate::W<REG> {
                self.variant(CON0::Vdac8)
            }
        }
        #[doc = "P5.1 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON1 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: Full Mux 1"]
            FullMux1 = 1,
            #[doc = "2: VDAC9"]
            Vdac9 = 2,
        }
        impl From<CON1> for u8 {
            #[inline(always)]
            fn from(variant: CON1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON1 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON1 {}
        #[doc = "Field `CON1` reader - P5.1 Configuration Bits"]
        pub type CON1_R = crate::FieldReader<CON1>;
        impl CON1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON1> {
                match self.bits {
                    0 => Some(CON1::Gpio),
                    1 => Some(CON1::FullMux1),
                    2 => Some(CON1::Vdac9),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON1::Gpio
            }
            #[doc = "Full Mux 1"]
            #[inline(always)]
            pub fn is_full_mux1(&self) -> bool {
                *self == CON1::FullMux1
            }
            #[doc = "VDAC9"]
            #[inline(always)]
            pub fn is_vdac9(&self) -> bool {
                *self == CON1::Vdac9
            }
        }
        #[doc = "Field `CON1` writer - P5.1 Configuration Bits"]
        pub type CON1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON1>;
        impl<'a, REG> CON1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Gpio)
            }
            #[doc = "Full Mux 1"]
            #[inline(always)]
            pub fn full_mux1(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::FullMux1)
            }
            #[doc = "VDAC9"]
            #[inline(always)]
            pub fn vdac9(self) -> &'a mut crate::W<REG> {
                self.variant(CON1::Vdac9)
            }
        }
        #[doc = "P5.2 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON2 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: Full Mux 2"]
            FullMux2 = 1,
            #[doc = "2: VDAC10"]
            Vdac10 = 2,
        }
        impl From<CON2> for u8 {
            #[inline(always)]
            fn from(variant: CON2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON2 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON2 {}
        #[doc = "Field `CON2` reader - P5.2 Configuration Bits"]
        pub type CON2_R = crate::FieldReader<CON2>;
        impl CON2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON2> {
                match self.bits {
                    0 => Some(CON2::Gpio),
                    1 => Some(CON2::FullMux2),
                    2 => Some(CON2::Vdac10),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON2::Gpio
            }
            #[doc = "Full Mux 2"]
            #[inline(always)]
            pub fn is_full_mux2(&self) -> bool {
                *self == CON2::FullMux2
            }
            #[doc = "VDAC10"]
            #[inline(always)]
            pub fn is_vdac10(&self) -> bool {
                *self == CON2::Vdac10
            }
        }
        #[doc = "Field `CON2` writer - P5.2 Configuration Bits"]
        pub type CON2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON2>;
        impl<'a, REG> CON2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Gpio)
            }
            #[doc = "Full Mux 2"]
            #[inline(always)]
            pub fn full_mux2(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::FullMux2)
            }
            #[doc = "VDAC10"]
            #[inline(always)]
            pub fn vdac10(self) -> &'a mut crate::W<REG> {
                self.variant(CON2::Vdac10)
            }
        }
        #[doc = "P5.3 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON3 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: Full Mux 3"]
            FullMux3 = 1,
            #[doc = "2: VDAC11"]
            Vdac11 = 2,
        }
        impl From<CON3> for u8 {
            #[inline(always)]
            fn from(variant: CON3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON3 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON3 {}
        #[doc = "Field `CON3` reader - P5.3 Configuration Bits"]
        pub type CON3_R = crate::FieldReader<CON3>;
        impl CON3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON3> {
                match self.bits {
                    0 => Some(CON3::Gpio),
                    1 => Some(CON3::FullMux3),
                    2 => Some(CON3::Vdac11),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON3::Gpio
            }
            #[doc = "Full Mux 3"]
            #[inline(always)]
            pub fn is_full_mux3(&self) -> bool {
                *self == CON3::FullMux3
            }
            #[doc = "VDAC11"]
            #[inline(always)]
            pub fn is_vdac11(&self) -> bool {
                *self == CON3::Vdac11
            }
        }
        #[doc = "Field `CON3` writer - P5.3 Configuration Bits"]
        pub type CON3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON3>;
        impl<'a, REG> CON3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Gpio)
            }
            #[doc = "Full Mux 3"]
            #[inline(always)]
            pub fn full_mux3(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::FullMux3)
            }
            #[doc = "VDAC11"]
            #[inline(always)]
            pub fn vdac11(self) -> &'a mut crate::W<REG> {
                self.variant(CON3::Vdac11)
            }
        }
        #[doc = "P5.4 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON4 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: Full_mux 4"]
            FullMux4 = 1,
        }
        impl From<CON4> for u8 {
            #[inline(always)]
            fn from(variant: CON4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON4 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON4 {}
        #[doc = "Field `CON4` reader - P5.4 Configuration Bits"]
        pub type CON4_R = crate::FieldReader<CON4>;
        impl CON4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON4> {
                match self.bits {
                    0 => Some(CON4::Gpio),
                    1 => Some(CON4::FullMux4),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON4::Gpio
            }
            #[doc = "Full_mux 4"]
            #[inline(always)]
            pub fn is_full_mux4(&self) -> bool {
                *self == CON4::FullMux4
            }
        }
        #[doc = "Field `CON4` writer - P5.4 Configuration Bits"]
        pub type CON4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON4>;
        impl<'a, REG> CON4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::Gpio)
            }
            #[doc = "Full_mux 4"]
            #[inline(always)]
            pub fn full_mux4(self) -> &'a mut crate::W<REG> {
                self.variant(CON4::FullMux4)
            }
        }
        #[doc = "P5.5 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON5 {
            #[doc = "0: GPIO"]
            Gpio = 0,
            #[doc = "1: Full Mux5"]
            FullMux5 = 1,
        }
        impl From<CON5> for u8 {
            #[inline(always)]
            fn from(variant: CON5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON5 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON5 {}
        #[doc = "Field `CON5` reader - P5.5 Configuration Bits"]
        pub type CON5_R = crate::FieldReader<CON5>;
        impl CON5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON5> {
                match self.bits {
                    0 => Some(CON5::Gpio),
                    1 => Some(CON5::FullMux5),
                    _ => None,
                }
            }
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON5::Gpio
            }
            #[doc = "Full Mux5"]
            #[inline(always)]
            pub fn is_full_mux5(&self) -> bool {
                *self == CON5::FullMux5
            }
        }
        #[doc = "Field `CON5` writer - P5.5 Configuration Bits"]
        pub type CON5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON5>;
        impl<'a, REG> CON5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::Gpio)
            }
            #[doc = "Full Mux5"]
            #[inline(always)]
            pub fn full_mux5(self) -> &'a mut crate::W<REG> {
                self.variant(CON5::FullMux5)
            }
        }
        #[doc = "P5.6 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON6 {
            #[doc = "0: GPIO/IRQ_HV"]
            Gpio = 0,
            #[doc = "1: Full Mux 6"]
            FullMux6 = 1,
        }
        impl From<CON6> for u8 {
            #[inline(always)]
            fn from(variant: CON6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON6 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON6 {}
        #[doc = "Field `CON6` reader - P5.6 Configuration Bits"]
        pub type CON6_R = crate::FieldReader<CON6>;
        impl CON6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON6> {
                match self.bits {
                    0 => Some(CON6::Gpio),
                    1 => Some(CON6::FullMux6),
                    _ => None,
                }
            }
            #[doc = "GPIO/IRQ_HV"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON6::Gpio
            }
            #[doc = "Full Mux 6"]
            #[inline(always)]
            pub fn is_full_mux6(&self) -> bool {
                *self == CON6::FullMux6
            }
        }
        #[doc = "Field `CON6` writer - P5.6 Configuration Bits"]
        pub type CON6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON6>;
        impl<'a, REG> CON6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ_HV"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::Gpio)
            }
            #[doc = "Full Mux 6"]
            #[inline(always)]
            pub fn full_mux6(self) -> &'a mut crate::W<REG> {
                self.variant(CON6::FullMux6)
            }
        }
        #[doc = "P5.7 Configuration Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CON7 {
            #[doc = "0: GPIO/IRQ_HV"]
            Gpio = 0,
            #[doc = "1: Full Mux 6"]
            FullMux6 = 1,
        }
        impl From<CON7> for u8 {
            #[inline(always)]
            fn from(variant: CON7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CON7 {
            type Ux = u8;
        }
        impl crate::IsEnum for CON7 {}
        #[doc = "Field `CON7` reader - P5.7 Configuration Bits"]
        pub type CON7_R = crate::FieldReader<CON7>;
        impl CON7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CON7> {
                match self.bits {
                    0 => Some(CON7::Gpio),
                    1 => Some(CON7::FullMux6),
                    _ => None,
                }
            }
            #[doc = "GPIO/IRQ_HV"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CON7::Gpio
            }
            #[doc = "Full Mux 6"]
            #[inline(always)]
            pub fn is_full_mux6(&self) -> bool {
                *self == CON7::FullMux6
            }
        }
        #[doc = "Field `CON7` writer - P5.7 Configuration Bits"]
        pub type CON7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CON7>;
        impl<'a, REG> CON7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "GPIO/IRQ_HV"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::Gpio)
            }
            #[doc = "Full Mux 6"]
            #[inline(always)]
            pub fn full_mux6(self) -> &'a mut crate::W<REG> {
                self.variant(CON7::FullMux6)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - P5.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&self) -> CON0_R {
                CON0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - P5.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&self) -> CON1_R {
                CON1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - P5.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&self) -> CON2_R {
                CON2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - P5.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&self) -> CON3_R {
                CON3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - P5.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&self) -> CON4_R {
                CON4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - P5.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&self) -> CON5_R {
                CON5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - P5.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&self) -> CON6_R {
                CON6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - P5.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&self) -> CON7_R {
                CON7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5CON")
                    .field("con0", &self.con0())
                    .field("con1", &self.con1())
                    .field("con2", &self.con2())
                    .field("con3", &self.con3())
                    .field("con4", &self.con4())
                    .field("con5", &self.con5())
                    .field("con6", &self.con6())
                    .field("con7", &self.con7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - P5.0 Configuration Bits"]
            #[inline(always)]
            pub fn con0(&mut self) -> CON0_W<GP5CONrs> {
                CON0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - P5.1 Configuration Bits"]
            #[inline(always)]
            pub fn con1(&mut self) -> CON1_W<GP5CONrs> {
                CON1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - P5.2 Configuration Bits"]
            #[inline(always)]
            pub fn con2(&mut self) -> CON2_W<GP5CONrs> {
                CON2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - P5.3 Configuration Bits"]
            #[inline(always)]
            pub fn con3(&mut self) -> CON3_W<GP5CONrs> {
                CON3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - P5.4 Configuration Bits"]
            #[inline(always)]
            pub fn con4(&mut self) -> CON4_W<GP5CONrs> {
                CON4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - P5.5 Configuration Bits"]
            #[inline(always)]
            pub fn con5(&mut self) -> CON5_W<GP5CONrs> {
                CON5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - P5.6 Configuration Bits"]
            #[inline(always)]
            pub fn con6(&mut self) -> CON6_W<GP5CONrs> {
                CON6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - P5.7 Configuration Bits"]
            #[inline(always)]
            pub fn con7(&mut self) -> CON7_W<GP5CONrs> {
                CON7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 6 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5CON)"]
        pub struct GP5CONrs;
        impl crate::RegisterSpec for GP5CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5con::R`](R) reader structure"]
        impl crate::Readable for GP5CONrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5con::W`](W) writer structure"]
        impl crate::Writable for GP5CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5CON to value 0"]
        impl crate::Resettable for GP5CONrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5OE (rw) register accessor: GPIO Port 5 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5oe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5oe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5OE)\n\nFor information about available fields see [`mod@gp5oe`]
module"]
    pub type GP5OE = crate::Reg<gp5oe::GP5OErs>;
    #[doc = "GPIO Port 5 Output Enable"]
    pub mod gp5oe {
        #[doc = "Register `GP5OE` reader"]
        pub type R = crate::R<GP5OErs>;
        #[doc = "Register `GP5OE` writer"]
        pub type W = crate::W<GP5OErs>;
        #[doc = "Field `OE` reader - Output Enable"]
        pub type OE_R = crate::FieldReader;
        #[doc = "Field `OE` writer - Output Enable"]
        pub type OE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5OE").field("oe", &self.oe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Output Enable"]
            #[inline(always)]
            pub fn oe(&mut self) -> OE_W<GP5OErs> {
                OE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Output Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5oe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5oe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5OE)"]
        pub struct GP5OErs;
        impl crate::RegisterSpec for GP5OErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5oe::R`](R) reader structure"]
        impl crate::Readable for GP5OErs {}
        #[doc = "`write(|w| ..)` method takes [`gp5oe::W`](W) writer structure"]
        impl crate::Writable for GP5OErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5OE to value 0"]
        impl crate::Resettable for GP5OErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5IE (rw) register accessor: GPIO Port 5 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IE)\n\nFor information about available fields see [`mod@gp5ie`]
module"]
    pub type GP5IE = crate::Reg<gp5ie::GP5IErs>;
    #[doc = "GPIO Port 5 Input Path Enable"]
    pub mod gp5ie {
        #[doc = "Register `GP5IE` reader"]
        pub type R = crate::R<GP5IErs>;
        #[doc = "Register `GP5IE` writer"]
        pub type W = crate::W<GP5IErs>;
        #[doc = "Field `IE` reader - Input Enable"]
        pub type IE_R = crate::FieldReader;
        #[doc = "Field `IE` writer - Input Enable"]
        pub type IE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&self) -> IE_R {
                IE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5IE").field("ie", &self.ie()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Enable"]
            #[inline(always)]
            pub fn ie(&mut self) -> IE_W<GP5IErs> {
                IE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Input Path Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IE)"]
        pub struct GP5IErs;
        impl crate::RegisterSpec for GP5IErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5ie::R`](R) reader structure"]
        impl crate::Readable for GP5IErs {}
        #[doc = "`write(|w| ..)` method takes [`gp5ie::W`](W) writer structure"]
        impl crate::Writable for GP5IErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5IE to value 0"]
        impl crate::Resettable for GP5IErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5IN (rw) register accessor: GPIO Port 5 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IN)\n\nFor information about available fields see [`mod@gp5in`]
module"]
    pub type GP5IN = crate::Reg<gp5in::GP5INrs>;
    #[doc = "GPIO Port 5 Registered Data Input"]
    pub mod gp5in {
        #[doc = "Register `GP5IN` reader"]
        pub type R = crate::R<GP5INrs>;
        #[doc = "Register `GP5IN` writer"]
        pub type W = crate::W<GP5INrs>;
        #[doc = "Field `Y` reader - Data Input from Pad"]
        pub type Y_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Data Input from Pad"]
            #[inline(always)]
            pub fn y(&self) -> Y_R {
                Y_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5IN").field("y", &self.y()).finish()
            }
        }
        impl W {}
        #[doc = "GPIO Port 5 Registered Data Input\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IN)"]
        pub struct GP5INrs;
        impl crate::RegisterSpec for GP5INrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5in::R`](R) reader structure"]
        impl crate::Readable for GP5INrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5in::W`](W) writer structure"]
        impl crate::Writable for GP5INrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5IN to value 0"]
        impl crate::Resettable for GP5INrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5OUT (rw) register accessor: GPIO Port 5 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5OUT)\n\nFor information about available fields see [`mod@gp5out`]
module"]
    pub type GP5OUT = crate::Reg<gp5out::GP5OUTrs>;
    #[doc = "GPIO Port 5 Data Output"]
    pub mod gp5out {
        #[doc = "Register `GP5OUT` reader"]
        pub type R = crate::R<GP5OUTrs>;
        #[doc = "Register `GP5OUT` writer"]
        pub type W = crate::W<GP5OUTrs>;
        #[doc = "Field `A` reader - Data Output to Pad"]
        pub type A_R = crate::FieldReader;
        #[doc = "Field `A` writer - Data Output to Pad"]
        pub type A_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&self) -> A_R {
                A_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5OUT").field("a", &self.a()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Data Output to Pad"]
            #[inline(always)]
            pub fn a(&mut self) -> A_W<GP5OUTrs> {
                A_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Data Output\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5OUT)"]
        pub struct GP5OUTrs;
        impl crate::RegisterSpec for GP5OUTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5out::R`](R) reader structure"]
        impl crate::Readable for GP5OUTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5out::W`](W) writer structure"]
        impl crate::Writable for GP5OUTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5OUT to value 0"]
        impl crate::Resettable for GP5OUTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5SET (rw) register accessor: GPIO Port 5 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5SET)\n\nFor information about available fields see [`mod@gp5set`]
module"]
    pub type GP5SET = crate::Reg<gp5set::GP5SETrs>;
    #[doc = "GPIO Port 5 Data Out Set"]
    pub mod gp5set {
        #[doc = "Register `GP5SET` reader"]
        pub type R = crate::R<GP5SETrs>;
        #[doc = "Register `GP5SET` writer"]
        pub type W = crate::W<GP5SETrs>;
        #[doc = "Field `SETUP` writer - Set the Output HIGH for the Pin"]
        pub type SETUP_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5SET").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output HIGH for the Pin"]
            #[inline(always)]
            pub fn setup(&mut self) -> SETUP_W<GP5SETrs> {
                SETUP_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Data Out Set\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5SET)"]
        pub struct GP5SETrs;
        impl crate::RegisterSpec for GP5SETrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5set::R`](R) reader structure"]
        impl crate::Readable for GP5SETrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5set::W`](W) writer structure"]
        impl crate::Writable for GP5SETrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5SET to value 0"]
        impl crate::Resettable for GP5SETrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5CLR (rw) register accessor: GPIO Port 5 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5CLR)\n\nFor information about available fields see [`mod@gp5clr`]
module"]
    pub type GP5CLR = crate::Reg<gp5clr::GP5CLRrs>;
    #[doc = "GPIO Port 5 Data Out Clear"]
    pub mod gp5clr {
        #[doc = "Register `GP5CLR` reader"]
        pub type R = crate::R<GP5CLRrs>;
        #[doc = "Register `GP5CLR` writer"]
        pub type W = crate::W<GP5CLRrs>;
        #[doc = "Field `CLR` writer - Set the Output Low for the Port Pin"]
        pub type CLR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5CLR").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Set the Output Low for the Port Pin"]
            #[inline(always)]
            pub fn clr(&mut self) -> CLR_W<GP5CLRrs> {
                CLR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Data Out Clear\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5CLR)"]
        pub struct GP5CLRrs;
        impl crate::RegisterSpec for GP5CLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5clr::R`](R) reader structure"]
        impl crate::Readable for GP5CLRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5clr::W`](W) writer structure"]
        impl crate::Writable for GP5CLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5CLR to value 0"]
        impl crate::Resettable for GP5CLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5TGL (rw) register accessor: GPIO Port 5 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5tgl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5tgl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5TGL)\n\nFor information about available fields see [`mod@gp5tgl`]
module"]
    pub type GP5TGL = crate::Reg<gp5tgl::GP5TGLrs>;
    #[doc = "GPIO Port 5 Pin Toggle"]
    pub mod gp5tgl {
        #[doc = "Register `GP5TGL` reader"]
        pub type R = crate::R<GP5TGLrs>;
        #[doc = "Register `GP5TGL` writer"]
        pub type W = crate::W<GP5TGLrs>;
        #[doc = "Field `TGL` writer - Toggle the Output of the Port Pin"]
        pub type TGL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5TGL").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Toggle the Output of the Port Pin"]
            #[inline(always)]
            pub fn tgl(&mut self) -> TGL_W<GP5TGLrs> {
                TGL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Pin Toggle\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5tgl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5tgl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5TGL)"]
        pub struct GP5TGLrs;
        impl crate::RegisterSpec for GP5TGLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5tgl::R`](R) reader structure"]
        impl crate::Readable for GP5TGLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5tgl::W`](W) writer structure"]
        impl crate::Writable for GP5TGLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5TGL to value 0"]
        impl crate::Resettable for GP5TGLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5ODE (rw) register accessor: GPIO Port 5 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5ODE)\n\nFor information about available fields see [`mod@gp5ode`]
module"]
    pub type GP5ODE = crate::Reg<gp5ode::GP5ODErs>;
    #[doc = "GPIO Port 5 Open Drain Enable"]
    pub mod gp5ode {
        #[doc = "Register `GP5ODE` reader"]
        pub type R = crate::R<GP5ODErs>;
        #[doc = "Register `GP5ODE` writer"]
        pub type W = crate::W<GP5ODErs>;
        #[doc = "Field `ODE` reader - Open Drain Enable"]
        pub type ODE_R = crate::FieldReader;
        #[doc = "Field `ODE` writer - Open Drain Enable"]
        pub type ODE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&self) -> ODE_R {
                ODE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5ODE").field("ode", &self.ode()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Open Drain Enable"]
            #[inline(always)]
            pub fn ode(&mut self) -> ODE_W<GP5ODErs> {
                ODE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Open Drain Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5ODE)"]
        pub struct GP5ODErs;
        impl crate::RegisterSpec for GP5ODErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5ode::R`](R) reader structure"]
        impl crate::Readable for GP5ODErs {}
        #[doc = "`write(|w| ..)` method takes [`gp5ode::W`](W) writer structure"]
        impl crate::Writable for GP5ODErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5ODE to value 0"]
        impl crate::Resettable for GP5ODErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5IS (rw) register accessor: GPIO Port 5 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5is::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5is::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IS)\n\nFor information about available fields see [`mod@gp5is`]
module"]
    pub type GP5IS = crate::Reg<gp5is::GP5ISrs>;
    #[doc = "GPIO Port 5 Input Select"]
    pub mod gp5is {
        #[doc = "Register `GP5IS` reader"]
        pub type R = crate::R<GP5ISrs>;
        #[doc = "Register `GP5IS` writer"]
        pub type W = crate::W<GP5ISrs>;
        #[doc = "Field `ISEL` reader - Input Select"]
        pub type ISEL_R = crate::FieldReader;
        #[doc = "Field `ISEL` writer - Input Select"]
        pub type ISEL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&self) -> ISEL_R {
                ISEL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5IS").field("isel", &self.isel()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Input Select"]
            #[inline(always)]
            pub fn isel(&mut self) -> ISEL_W<GP5ISrs> {
                ISEL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Input Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5is::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5is::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IS)"]
        pub struct GP5ISrs;
        impl crate::RegisterSpec for GP5ISrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5is::R`](R) reader structure"]
        impl crate::Readable for GP5ISrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5is::W`](W) writer structure"]
        impl crate::Writable for GP5ISrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5IS to value 0xff"]
        impl crate::Resettable for GP5ISrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP5PE (rw) register accessor: GPIO Port 5 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5pe::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5pe::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5PE)\n\nFor information about available fields see [`mod@gp5pe`]
module"]
    pub type GP5PE = crate::Reg<gp5pe::GP5PErs>;
    #[doc = "GPIO Port 5 Pull Enable"]
    pub mod gp5pe {
        #[doc = "Register `GP5PE` reader"]
        pub type R = crate::R<GP5PErs>;
        #[doc = "Register `GP5PE` writer"]
        pub type W = crate::W<GP5PErs>;
        #[doc = "Field `PE` reader - Pull Enable"]
        pub type PE_R = crate::FieldReader;
        #[doc = "Field `PE` writer - Pull Enable"]
        pub type PE_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5PE").field("pe", &self.pe()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W<GP5PErs> {
                PE_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Pull Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5pe::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5pe::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5PE)"]
        pub struct GP5PErs;
        impl crate::RegisterSpec for GP5PErs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5pe::R`](R) reader structure"]
        impl crate::Readable for GP5PErs {}
        #[doc = "`write(|w| ..)` method takes [`gp5pe::W`](W) writer structure"]
        impl crate::Writable for GP5PErs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5PE to value 0"]
        impl crate::Resettable for GP5PErs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5PS (rw) register accessor: GPIO Port 5 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ps::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ps::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5PS)\n\nFor information about available fields see [`mod@gp5ps`]
module"]
    pub type GP5PS = crate::Reg<gp5ps::GP5PSrs>;
    #[doc = "GPIO Port 5 Pull Select"]
    pub mod gp5ps {
        #[doc = "Register `GP5PS` reader"]
        pub type R = crate::R<GP5PSrs>;
        #[doc = "Register `GP5PS` writer"]
        pub type W = crate::W<GP5PSrs>;
        #[doc = "Field `PS` reader - Pull Select"]
        pub type PS_R = crate::FieldReader;
        #[doc = "Field `PS` writer - Pull Select"]
        pub type PS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5PS").field("ps", &self.ps()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Pull Select"]
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W<GP5PSrs> {
                PS_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Pull Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ps::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ps::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5PS)"]
        pub struct GP5PSrs;
        impl crate::RegisterSpec for GP5PSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5ps::R`](R) reader structure"]
        impl crate::Readable for GP5PSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5ps::W`](W) writer structure"]
        impl crate::Writable for GP5PSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5PS to value 0xff"]
        impl crate::Resettable for GP5PSrs {
            const RESET_VALUE: u32 = 0xff;
        }
    }
    #[doc = "GP5SR (rw) register accessor: GPIO Port 5 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5SR)\n\nFor information about available fields see [`mod@gp5sr`]
module"]
    pub type GP5SR = crate::Reg<gp5sr::GP5SRrs>;
    #[doc = "GPIO Port 5 Slew Rate"]
    pub mod gp5sr {
        #[doc = "Register `GP5SR` reader"]
        pub type R = crate::R<GP5SRrs>;
        #[doc = "Register `GP5SR` writer"]
        pub type W = crate::W<GP5SRrs>;
        #[doc = "Field `SR` reader - Slew Rate"]
        pub type SR_R = crate::FieldReader;
        #[doc = "Field `SR` writer - Slew Rate"]
        pub type SR_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&self) -> SR_R {
                SR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5SR").field("sr", &self.sr()).finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Slew Rate"]
            #[inline(always)]
            pub fn sr(&mut self) -> SR_W<GP5SRrs> {
                SR_W::new(self, 0)
            }
        }
        #[doc = "GPIO Port 5 Slew Rate\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5SR)"]
        pub struct GP5SRrs;
        impl crate::RegisterSpec for GP5SRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5sr::R`](R) reader structure"]
        impl crate::Readable for GP5SRrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5sr::W`](W) writer structure"]
        impl crate::Writable for GP5SRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5SR to value 0"]
        impl crate::Resettable for GP5SRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5DS (rw) register accessor: GPIO Port 5 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ds::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ds::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5DS)\n\nFor information about available fields see [`mod@gp5ds`]
module"]
    pub type GP5DS = crate::Reg<gp5ds::GP5DSrs>;
    #[doc = "GPIO Port 5 Drive Select"]
    pub mod gp5ds {
        #[doc = "Register `GP5DS` reader"]
        pub type R = crate::R<GP5DSrs>;
        #[doc = "Register `GP5DS` writer"]
        pub type W = crate::W<GP5DSrs>;
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS0 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS0> for u8 {
            #[inline(always)]
            fn from(variant: DS0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS0 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS0 {}
        #[doc = "Field `DS0` reader - Drive Select"]
        pub type DS0_R = crate::FieldReader<DS0>;
        impl DS0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS0 {
                match self.bits {
                    0 => DS0::Strength1,
                    1 => DS0::Strength2,
                    2 => DS0::Strength3,
                    3 => DS0::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS0::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS0::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS0::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS0::Strength4
            }
        }
        #[doc = "Field `DS0` writer - Drive Select"]
        pub type DS0_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS0, crate::Safe>;
        impl<'a, REG> DS0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS0::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS1 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS1> for u8 {
            #[inline(always)]
            fn from(variant: DS1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS1 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS1 {}
        #[doc = "Field `DS1` reader - Drive Select"]
        pub type DS1_R = crate::FieldReader<DS1>;
        impl DS1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS1 {
                match self.bits {
                    0 => DS1::Strength1,
                    1 => DS1::Strength2,
                    2 => DS1::Strength3,
                    3 => DS1::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS1::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS1::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS1::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS1::Strength4
            }
        }
        #[doc = "Field `DS1` writer - Drive Select"]
        pub type DS1_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS1, crate::Safe>;
        impl<'a, REG> DS1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS1::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS2 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS2> for u8 {
            #[inline(always)]
            fn from(variant: DS2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS2 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS2 {}
        #[doc = "Field `DS2` reader - Drive Select"]
        pub type DS2_R = crate::FieldReader<DS2>;
        impl DS2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS2 {
                match self.bits {
                    0 => DS2::Strength1,
                    1 => DS2::Strength2,
                    2 => DS2::Strength3,
                    3 => DS2::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS2::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS2::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS2::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS2::Strength4
            }
        }
        #[doc = "Field `DS2` writer - Drive Select"]
        pub type DS2_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS2, crate::Safe>;
        impl<'a, REG> DS2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS2::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS3 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS3> for u8 {
            #[inline(always)]
            fn from(variant: DS3) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS3 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS3 {}
        #[doc = "Field `DS3` reader - Drive Select"]
        pub type DS3_R = crate::FieldReader<DS3>;
        impl DS3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS3 {
                match self.bits {
                    0 => DS3::Strength1,
                    1 => DS3::Strength2,
                    2 => DS3::Strength3,
                    3 => DS3::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS3::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS3::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS3::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS3::Strength4
            }
        }
        #[doc = "Field `DS3` writer - Drive Select"]
        pub type DS3_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS3, crate::Safe>;
        impl<'a, REG> DS3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS3::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS4 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS4> for u8 {
            #[inline(always)]
            fn from(variant: DS4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS4 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS4 {}
        #[doc = "Field `DS4` reader - Drive Select"]
        pub type DS4_R = crate::FieldReader<DS4>;
        impl DS4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS4 {
                match self.bits {
                    0 => DS4::Strength1,
                    1 => DS4::Strength2,
                    2 => DS4::Strength3,
                    3 => DS4::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS4::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS4::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS4::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS4::Strength4
            }
        }
        #[doc = "Field `DS4` writer - Drive Select"]
        pub type DS4_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS4, crate::Safe>;
        impl<'a, REG> DS4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS4::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS5 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS5> for u8 {
            #[inline(always)]
            fn from(variant: DS5) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS5 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS5 {}
        #[doc = "Field `DS5` reader - Drive Select"]
        pub type DS5_R = crate::FieldReader<DS5>;
        impl DS5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS5 {
                match self.bits {
                    0 => DS5::Strength1,
                    1 => DS5::Strength2,
                    2 => DS5::Strength3,
                    3 => DS5::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS5::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS5::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS5::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS5::Strength4
            }
        }
        #[doc = "Field `DS5` writer - Drive Select"]
        pub type DS5_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS5, crate::Safe>;
        impl<'a, REG> DS5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS5::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS6 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS6> for u8 {
            #[inline(always)]
            fn from(variant: DS6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS6 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS6 {}
        #[doc = "Field `DS6` reader - Drive Select"]
        pub type DS6_R = crate::FieldReader<DS6>;
        impl DS6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS6 {
                match self.bits {
                    0 => DS6::Strength1,
                    1 => DS6::Strength2,
                    2 => DS6::Strength3,
                    3 => DS6::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS6::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS6::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS6::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS6::Strength4
            }
        }
        #[doc = "Field `DS6` writer - Drive Select"]
        pub type DS6_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS6, crate::Safe>;
        impl<'a, REG> DS6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS6::Strength4)
            }
        }
        #[doc = "Drive Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DS7 {
            #[doc = "0: Drive Strength 1"]
            Strength1 = 0,
            #[doc = "1: Drive Strength 2"]
            Strength2 = 1,
            #[doc = "2: Drive Strength 3"]
            Strength3 = 2,
            #[doc = "3: Drive Strength 4"]
            Strength4 = 3,
        }
        impl From<DS7> for u8 {
            #[inline(always)]
            fn from(variant: DS7) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DS7 {
            type Ux = u8;
        }
        impl crate::IsEnum for DS7 {}
        #[doc = "Field `DS7` reader - Drive Select"]
        pub type DS7_R = crate::FieldReader<DS7>;
        impl DS7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DS7 {
                match self.bits {
                    0 => DS7::Strength1,
                    1 => DS7::Strength2,
                    2 => DS7::Strength3,
                    3 => DS7::Strength4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn is_strength1(&self) -> bool {
                *self == DS7::Strength1
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn is_strength2(&self) -> bool {
                *self == DS7::Strength2
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn is_strength3(&self) -> bool {
                *self == DS7::Strength3
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn is_strength4(&self) -> bool {
                *self == DS7::Strength4
            }
        }
        #[doc = "Field `DS7` writer - Drive Select"]
        pub type DS7_W<'a, REG> = crate::FieldWriter<'a, REG, 2, DS7, crate::Safe>;
        impl<'a, REG> DS7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Drive Strength 1"]
            #[inline(always)]
            pub fn strength1(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength1)
            }
            #[doc = "Drive Strength 2"]
            #[inline(always)]
            pub fn strength2(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength2)
            }
            #[doc = "Drive Strength 3"]
            #[inline(always)]
            pub fn strength3(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength3)
            }
            #[doc = "Drive Strength 4"]
            #[inline(always)]
            pub fn strength4(self) -> &'a mut crate::W<REG> {
                self.variant(DS7::Strength4)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&self) -> DS0_R {
                DS0_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&self) -> DS1_R {
                DS1_R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&self) -> DS2_R {
                DS2_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&self) -> DS3_R {
                DS3_R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&self) -> DS4_R {
                DS4_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&self) -> DS5_R {
                DS5_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&self) -> DS6_R {
                DS6_R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&self) -> DS7_R {
                DS7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5DS")
                    .field("ds0", &self.ds0())
                    .field("ds1", &self.ds1())
                    .field("ds2", &self.ds2())
                    .field("ds3", &self.ds3())
                    .field("ds4", &self.ds4())
                    .field("ds5", &self.ds5())
                    .field("ds6", &self.ds6())
                    .field("ds7", &self.ds7())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Drive Select"]
            #[inline(always)]
            pub fn ds0(&mut self) -> DS0_W<GP5DSrs> {
                DS0_W::new(self, 0)
            }
            #[doc = "Bits 2:3 - Drive Select"]
            #[inline(always)]
            pub fn ds1(&mut self) -> DS1_W<GP5DSrs> {
                DS1_W::new(self, 2)
            }
            #[doc = "Bits 4:5 - Drive Select"]
            #[inline(always)]
            pub fn ds2(&mut self) -> DS2_W<GP5DSrs> {
                DS2_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - Drive Select"]
            #[inline(always)]
            pub fn ds3(&mut self) -> DS3_W<GP5DSrs> {
                DS3_W::new(self, 6)
            }
            #[doc = "Bits 8:9 - Drive Select"]
            #[inline(always)]
            pub fn ds4(&mut self) -> DS4_W<GP5DSrs> {
                DS4_W::new(self, 8)
            }
            #[doc = "Bits 10:11 - Drive Select"]
            #[inline(always)]
            pub fn ds5(&mut self) -> DS5_W<GP5DSrs> {
                DS5_W::new(self, 10)
            }
            #[doc = "Bits 12:13 - Drive Select"]
            #[inline(always)]
            pub fn ds6(&mut self) -> DS6_W<GP5DSrs> {
                DS6_W::new(self, 12)
            }
            #[doc = "Bits 14:15 - Drive Select"]
            #[inline(always)]
            pub fn ds7(&mut self) -> DS7_W<GP5DSrs> {
                DS7_W::new(self, 14)
            }
        }
        #[doc = "GPIO Port 5 Drive Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ds::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ds::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5DS)"]
        pub struct GP5DSrs;
        impl crate::RegisterSpec for GP5DSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5ds::R`](R) reader structure"]
        impl crate::Readable for GP5DSrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5ds::W`](W) writer structure"]
        impl crate::Writable for GP5DSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5DS to value 0"]
        impl crate::Resettable for GP5DSrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5POL (rw) register accessor: GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5pol::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5pol::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5POL)\n\nFor information about available fields see [`mod@gp5pol`]
module"]
    pub type GP5POL = crate::Reg<gp5pol::GP5POLrs>;
    #[doc = "GPIO Interrupt Polarity Select"]
    pub mod gp5pol {
        #[doc = "Register `GP5POL` reader"]
        pub type R = crate::R<GP5POLrs>;
        #[doc = "Register `GP5POL` writer"]
        pub type W = crate::W<GP5POLrs>;
        #[doc = "Field `INTPOL` reader - Parametric Output"]
        pub type INTPOL_R = crate::FieldReader;
        #[doc = "Field `INTPOL` writer - Parametric Output"]
        pub type INTPOL_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&self) -> INTPOL_R {
                INTPOL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5POL")
                    .field("intpol", &self.intpol())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Parametric Output"]
            #[inline(always)]
            pub fn intpol(&mut self) -> INTPOL_W<GP5POLrs> {
                INTPOL_W::new(self, 0)
            }
        }
        #[doc = "GPIO Interrupt Polarity Select\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5pol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5pol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5POL)"]
        pub struct GP5POLrs;
        impl crate::RegisterSpec for GP5POLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5pol::R`](R) reader structure"]
        impl crate::Readable for GP5POLrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5pol::W`](W) writer structure"]
        impl crate::Writable for GP5POLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5POL to value 0"]
        impl crate::Resettable for GP5POLrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5IENA (rw) register accessor: InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5iena::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5iena::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IENA)\n\nFor information about available fields see [`mod@gp5iena`]
module"]
    pub type GP5IENA = crate::Reg<gp5iena::GP5IENArs>;
    #[doc = "InterruptA Enable"]
    pub mod gp5iena {
        #[doc = "Register `GP5IENA` reader"]
        pub type R = crate::R<GP5IENArs>;
        #[doc = "Register `GP5IENA` writer"]
        pub type W = crate::W<GP5IENArs>;
        #[doc = "Field `INTAEN` reader - InterruptA Enable"]
        pub type INTAEN_R = crate::FieldReader;
        #[doc = "Field `INTAEN` writer - InterruptA Enable"]
        pub type INTAEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&self) -> INTAEN_R {
                INTAEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5IENA")
                    .field("intaen", &self.intaen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptA Enable"]
            #[inline(always)]
            pub fn intaen(&mut self) -> INTAEN_W<GP5IENArs> {
                INTAEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptA Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5iena::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5iena::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IENA)"]
        pub struct GP5IENArs;
        impl crate::RegisterSpec for GP5IENArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5iena::R`](R) reader structure"]
        impl crate::Readable for GP5IENArs {}
        #[doc = "`write(|w| ..)` method takes [`gp5iena::W`](W) writer structure"]
        impl crate::Writable for GP5IENArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5IENA to value 0"]
        impl crate::Resettable for GP5IENArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5IENB (rw) register accessor: InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ienb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ienb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IENB)\n\nFor information about available fields see [`mod@gp5ienb`]
module"]
    pub type GP5IENB = crate::Reg<gp5ienb::GP5IENBrs>;
    #[doc = "InterruptB Enable"]
    pub mod gp5ienb {
        #[doc = "Register `GP5IENB` reader"]
        pub type R = crate::R<GP5IENBrs>;
        #[doc = "Register `GP5IENB` writer"]
        pub type W = crate::W<GP5IENBrs>;
        #[doc = "Field `INTBEN` reader - InterruptB Enable"]
        pub type INTBEN_R = crate::FieldReader;
        #[doc = "Field `INTBEN` writer - InterruptB Enable"]
        pub type INTBEN_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&self) -> INTBEN_R {
                INTBEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5IENB")
                    .field("intben", &self.intben())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - InterruptB Enable"]
            #[inline(always)]
            pub fn intben(&mut self) -> INTBEN_W<GP5IENBrs> {
                INTBEN_W::new(self, 0)
            }
        }
        #[doc = "InterruptB Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5ienb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5ienb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5IENB)"]
        pub struct GP5IENBrs;
        impl crate::RegisterSpec for GP5IENBrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5ienb::R`](R) reader structure"]
        impl crate::Readable for GP5IENBrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5ienb::W`](W) writer structure"]
        impl crate::Writable for GP5IENBrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5IENB to value 0"]
        impl crate::Resettable for GP5IENBrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "GP5INT (rw) register accessor: Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5int::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5int::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5INT)\n\nFor information about available fields see [`mod@gp5int`]
module"]
    pub type GP5INT = crate::Reg<gp5int::GP5INTrs>;
    #[doc = "Interrupt Status"]
    pub mod gp5int {
        #[doc = "Register `GP5INT` reader"]
        pub type R = crate::R<GP5INTrs>;
        #[doc = "Register `GP5INT` writer"]
        pub type W = crate::W<GP5INTrs>;
        #[doc = "Field `INTSTATUS` reader - Interrupt Status"]
        pub type INTSTATUS_R = crate::FieldReader;
        #[doc = "Field `INTSTATUS` writer - Interrupt Status"]
        pub type INTSTATUS_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&self) -> INTSTATUS_R {
                INTSTATUS_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GP5INT")
                    .field("intstatus", &self.intstatus())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Interrupt Status"]
            #[inline(always)]
            pub fn intstatus(&mut self) -> INTSTATUS_W<GP5INTrs> {
                INTSTATUS_W::new(self, 0)
            }
        }
        #[doc = "Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`gp5int::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gp5int::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#GPIO:GP5INT)"]
        pub struct GP5INTrs;
        impl crate::RegisterSpec for GP5INTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gp5int::R`](R) reader structure"]
        impl crate::Readable for GP5INTrs {}
        #[doc = "`write(|w| ..)` method takes [`gp5int::W`](W) writer structure"]
        impl crate::Writable for GP5INTrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets GP5INT to value 0"]
        impl crate::Resettable for GP5INTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CLK)"]
pub struct CLK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CLK {}
impl CLK {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const clk::RegisterBlock = 0x4006_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const clk::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CLK {
    type Target = clk::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CLK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CLK").finish()
    }
}
#[doc = "Unknown"]
pub mod clk {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        clkcon0: CLKCON0,
        clkcon1: CLKCON1,
        clkstat0: CLKSTAT0,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Misc Clock Settings Register"]
        #[inline(always)]
        pub const fn clkcon0(&self) -> &CLKCON0 {
            &self.clkcon0
        }
        #[doc = "0x04 - Clock Dividers Register"]
        #[inline(always)]
        pub const fn clkcon1(&self) -> &CLKCON1 {
            &self.clkcon1
        }
        #[doc = "0x08 - Clocking Status"]
        #[inline(always)]
        pub const fn clkstat0(&self) -> &CLKSTAT0 {
            &self.clkstat0
        }
    }
    #[doc = "CLKCON0 (rw) register accessor: Misc Clock Settings Register\n\nYou can [`read`](crate::Reg::read) this register and get [`clkcon0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clkcon0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CLK:CLKCON0)\n\nFor information about available fields see [`mod@clkcon0`]
module"]
    pub type CLKCON0 = crate::Reg<clkcon0::CLKCON0rs>;
    #[doc = "Misc Clock Settings Register"]
    pub mod clkcon0 {
        #[doc = "Register `CLKCON0` reader"]
        pub type R = crate::R<CLKCON0rs>;
        #[doc = "Register `CLKCON0` writer"]
        pub type W = crate::W<CLKCON0rs>;
        #[doc = "Clock Mux Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CLKMUX {
            #[doc = "0: High Frequency Internal Oscillator (HFOSC)"]
            Hfosc = 0,
            #[doc = "1: System PLL is Selected (160 MHz)"]
            Spll = 1,
            #[doc = "3: External GPIO Port is Selected (ECLKIN)"]
            Extclk = 3,
        }
        impl From<CLKMUX> for u8 {
            #[inline(always)]
            fn from(variant: CLKMUX) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CLKMUX {
            type Ux = u8;
        }
        impl crate::IsEnum for CLKMUX {}
        #[doc = "Field `CLKMUX` reader - Clock Mux Select"]
        pub type CLKMUX_R = crate::FieldReader<CLKMUX>;
        impl CLKMUX_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CLKMUX> {
                match self.bits {
                    0 => Some(CLKMUX::Hfosc),
                    1 => Some(CLKMUX::Spll),
                    3 => Some(CLKMUX::Extclk),
                    _ => None,
                }
            }
            #[doc = "High Frequency Internal Oscillator (HFOSC)"]
            #[inline(always)]
            pub fn is_hfosc(&self) -> bool {
                *self == CLKMUX::Hfosc
            }
            #[doc = "System PLL is Selected (160 MHz)"]
            #[inline(always)]
            pub fn is_spll(&self) -> bool {
                *self == CLKMUX::Spll
            }
            #[doc = "External GPIO Port is Selected (ECLKIN)"]
            #[inline(always)]
            pub fn is_extclk(&self) -> bool {
                *self == CLKMUX::Extclk
            }
        }
        #[doc = "Field `CLKMUX` writer - Clock Mux Select"]
        pub type CLKMUX_W<'a, REG> = crate::FieldWriter<'a, REG, 2, CLKMUX>;
        impl<'a, REG> CLKMUX_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "High Frequency Internal Oscillator (HFOSC)"]
            #[inline(always)]
            pub fn hfosc(self) -> &'a mut crate::W<REG> {
                self.variant(CLKMUX::Hfosc)
            }
            #[doc = "System PLL is Selected (160 MHz)"]
            #[inline(always)]
            pub fn spll(self) -> &'a mut crate::W<REG> {
                self.variant(CLKMUX::Spll)
            }
            #[doc = "External GPIO Port is Selected (ECLKIN)"]
            #[inline(always)]
            pub fn extclk(self) -> &'a mut crate::W<REG> {
                self.variant(CLKMUX::Extclk)
            }
        }
        #[doc = "GPIO CLK Out Select\n\nValue on reset: 15"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CLKOUT {
            #[doc = "0: HFOSC (16 MHz)"]
            Hfosc = 0,
            #[doc = "1: Root Clock"]
            Root = 1,
            #[doc = "3: 32K OSC"]
            Lfosc = 3,
            #[doc = "4: Core Clock"]
            Core = 4,
            #[doc = "5: Bridge 0 Pclk"]
            B0Pclk = 5,
            #[doc = "6: Bridge 1 PCLK"]
            B1Pclk = 6,
            #[doc = "7: Bridge 2 PCLK"]
            B2Pclk = 7,
            #[doc = "8: Analog Test Signal"]
            AnaClk = 8,
            #[doc = "9: Timer 0 Clock"]
            T0 = 9,
            #[doc = "10: Wake up Timer Clock"]
            Wut = 10,
            #[doc = "11: Timer 3 Clock"]
            T3 = 11,
            #[doc = "12: Hclk_bus"]
            Hclkbus = 12,
            #[doc = "13: SPLL clock"]
            SpllClk = 13,
        }
        impl From<CLKOUT> for u8 {
            #[inline(always)]
            fn from(variant: CLKOUT) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CLKOUT {
            type Ux = u8;
        }
        impl crate::IsEnum for CLKOUT {}
        #[doc = "Field `CLKOUT` reader - GPIO CLK Out Select"]
        pub type CLKOUT_R = crate::FieldReader<CLKOUT>;
        impl CLKOUT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CLKOUT> {
                match self.bits {
                    0 => Some(CLKOUT::Hfosc),
                    1 => Some(CLKOUT::Root),
                    3 => Some(CLKOUT::Lfosc),
                    4 => Some(CLKOUT::Core),
                    5 => Some(CLKOUT::B0Pclk),
                    6 => Some(CLKOUT::B1Pclk),
                    7 => Some(CLKOUT::B2Pclk),
                    8 => Some(CLKOUT::AnaClk),
                    9 => Some(CLKOUT::T0),
                    10 => Some(CLKOUT::Wut),
                    11 => Some(CLKOUT::T3),
                    12 => Some(CLKOUT::Hclkbus),
                    13 => Some(CLKOUT::SpllClk),
                    _ => None,
                }
            }
            #[doc = "HFOSC (16 MHz)"]
            #[inline(always)]
            pub fn is_hfosc(&self) -> bool {
                *self == CLKOUT::Hfosc
            }
            #[doc = "Root Clock"]
            #[inline(always)]
            pub fn is_root(&self) -> bool {
                *self == CLKOUT::Root
            }
            #[doc = "32K OSC"]
            #[inline(always)]
            pub fn is_lfosc(&self) -> bool {
                *self == CLKOUT::Lfosc
            }
            #[doc = "Core Clock"]
            #[inline(always)]
            pub fn is_core(&self) -> bool {
                *self == CLKOUT::Core
            }
            #[doc = "Bridge 0 Pclk"]
            #[inline(always)]
            pub fn is_b0_pclk(&self) -> bool {
                *self == CLKOUT::B0Pclk
            }
            #[doc = "Bridge 1 PCLK"]
            #[inline(always)]
            pub fn is_b1_pclk(&self) -> bool {
                *self == CLKOUT::B1Pclk
            }
            #[doc = "Bridge 2 PCLK"]
            #[inline(always)]
            pub fn is_b2_pclk(&self) -> bool {
                *self == CLKOUT::B2Pclk
            }
            #[doc = "Analog Test Signal"]
            #[inline(always)]
            pub fn is_ana_clk(&self) -> bool {
                *self == CLKOUT::AnaClk
            }
            #[doc = "Timer 0 Clock"]
            #[inline(always)]
            pub fn is_t0(&self) -> bool {
                *self == CLKOUT::T0
            }
            #[doc = "Wake up Timer Clock"]
            #[inline(always)]
            pub fn is_wut(&self) -> bool {
                *self == CLKOUT::Wut
            }
            #[doc = "Timer 3 Clock"]
            #[inline(always)]
            pub fn is_t3(&self) -> bool {
                *self == CLKOUT::T3
            }
            #[doc = "Hclk_bus"]
            #[inline(always)]
            pub fn is_hclkbus(&self) -> bool {
                *self == CLKOUT::Hclkbus
            }
            #[doc = "SPLL clock"]
            #[inline(always)]
            pub fn is_spll_clk(&self) -> bool {
                *self == CLKOUT::SpllClk
            }
        }
        #[doc = "Field `CLKOUT` writer - GPIO CLK Out Select"]
        pub type CLKOUT_W<'a, REG> = crate::FieldWriter<'a, REG, 4, CLKOUT>;
        impl<'a, REG> CLKOUT_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "HFOSC (16 MHz)"]
            #[inline(always)]
            pub fn hfosc(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::Hfosc)
            }
            #[doc = "Root Clock"]
            #[inline(always)]
            pub fn root(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::Root)
            }
            #[doc = "32K OSC"]
            #[inline(always)]
            pub fn lfosc(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::Lfosc)
            }
            #[doc = "Core Clock"]
            #[inline(always)]
            pub fn core(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::Core)
            }
            #[doc = "Bridge 0 Pclk"]
            #[inline(always)]
            pub fn b0_pclk(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::B0Pclk)
            }
            #[doc = "Bridge 1 PCLK"]
            #[inline(always)]
            pub fn b1_pclk(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::B1Pclk)
            }
            #[doc = "Bridge 2 PCLK"]
            #[inline(always)]
            pub fn b2_pclk(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::B2Pclk)
            }
            #[doc = "Analog Test Signal"]
            #[inline(always)]
            pub fn ana_clk(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::AnaClk)
            }
            #[doc = "Timer 0 Clock"]
            #[inline(always)]
            pub fn t0(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::T0)
            }
            #[doc = "Wake up Timer Clock"]
            #[inline(always)]
            pub fn wut(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::Wut)
            }
            #[doc = "Timer 3 Clock"]
            #[inline(always)]
            pub fn t3(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::T3)
            }
            #[doc = "Hclk_bus"]
            #[inline(always)]
            pub fn hclkbus(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::Hclkbus)
            }
            #[doc = "SPLL clock"]
            #[inline(always)]
            pub fn spll_clk(self) -> &'a mut crate::W<REG> {
                self.variant(CLKOUT::SpllClk)
            }
        }
        #[doc = "Mux Selection Analog Clock Source\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ANACLKMUX {
            #[doc = "0: Internal Oscillator is Selected (HFOSC)"]
            Hfosc = 0,
            #[doc = "2: GPIO Clock"]
            Gpioclk = 2,
        }
        impl From<ANACLKMUX> for u8 {
            #[inline(always)]
            fn from(variant: ANACLKMUX) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ANACLKMUX {
            type Ux = u8;
        }
        impl crate::IsEnum for ANACLKMUX {}
        #[doc = "Field `ANACLKMUX` reader - Mux Selection Analog Clock Source"]
        pub type ANACLKMUX_R = crate::FieldReader<ANACLKMUX>;
        impl ANACLKMUX_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<ANACLKMUX> {
                match self.bits {
                    0 => Some(ANACLKMUX::Hfosc),
                    2 => Some(ANACLKMUX::Gpioclk),
                    _ => None,
                }
            }
            #[doc = "Internal Oscillator is Selected (HFOSC)"]
            #[inline(always)]
            pub fn is_hfosc(&self) -> bool {
                *self == ANACLKMUX::Hfosc
            }
            #[doc = "GPIO Clock"]
            #[inline(always)]
            pub fn is_gpioclk(&self) -> bool {
                *self == ANACLKMUX::Gpioclk
            }
        }
        #[doc = "Field `ANACLKMUX` writer - Mux Selection Analog Clock Source"]
        pub type ANACLKMUX_W<'a, REG> = crate::FieldWriter<'a, REG, 2, ANACLKMUX>;
        impl<'a, REG> ANACLKMUX_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Internal Oscillator is Selected (HFOSC)"]
            #[inline(always)]
            pub fn hfosc(self) -> &'a mut crate::W<REG> {
                self.variant(ANACLKMUX::Hfosc)
            }
            #[doc = "GPIO Clock"]
            #[inline(always)]
            pub fn gpioclk(self) -> &'a mut crate::W<REG> {
                self.variant(ANACLKMUX::Gpioclk)
            }
        }
        #[doc = "PLL Unlock and Lock Interrupt Enable\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SPLLIE {
            #[doc = "0: PLL Interrupt Will Not Be Generated"]
            Dis = 0,
            #[doc = "1: PLL Interrupt Will Be Generated"]
            En = 1,
        }
        impl From<SPLLIE> for bool {
            #[inline(always)]
            fn from(variant: SPLLIE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SPLLIE` reader - PLL Unlock and Lock Interrupt Enable"]
        pub type SPLLIE_R = crate::BitReader<SPLLIE>;
        impl SPLLIE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SPLLIE {
                match self.bits {
                    false => SPLLIE::Dis,
                    true => SPLLIE::En,
                }
            }
            #[doc = "PLL Interrupt Will Not Be Generated"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == SPLLIE::Dis
            }
            #[doc = "PLL Interrupt Will Be Generated"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == SPLLIE::En
            }
        }
        #[doc = "Field `SPLLIE` writer - PLL Unlock and Lock Interrupt Enable"]
        pub type SPLLIE_W<'a, REG> = crate::BitWriter<'a, REG, SPLLIE>;
        impl<'a, REG> SPLLIE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PLL Interrupt Will Not Be Generated"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(SPLLIE::Dis)
            }
            #[doc = "PLL Interrupt Will Be Generated"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(SPLLIE::En)
            }
        }
        #[doc = "Clock Mux Select\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ANAROOTCLKMUX {
            #[doc = "0: 16MHz Oscillator Clock"]
            Osc16 = 0,
            #[doc = "1: 32MHz Oscillator Clock"]
            Osc32 = 1,
            #[doc = "2: PLL Clock"]
            Pll = 2,
            #[doc = "3: External GPIO Clock"]
            Gpio = 3,
        }
        impl From<ANAROOTCLKMUX> for u8 {
            #[inline(always)]
            fn from(variant: ANAROOTCLKMUX) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ANAROOTCLKMUX {
            type Ux = u8;
        }
        impl crate::IsEnum for ANAROOTCLKMUX {}
        #[doc = "Field `ANAROOTCLKMUX` reader - Clock Mux Select"]
        pub type ANAROOTCLKMUX_R = crate::FieldReader<ANAROOTCLKMUX>;
        impl ANAROOTCLKMUX_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ANAROOTCLKMUX {
                match self.bits {
                    0 => ANAROOTCLKMUX::Osc16,
                    1 => ANAROOTCLKMUX::Osc32,
                    2 => ANAROOTCLKMUX::Pll,
                    3 => ANAROOTCLKMUX::Gpio,
                    _ => unreachable!(),
                }
            }
            #[doc = "16MHz Oscillator Clock"]
            #[inline(always)]
            pub fn is_osc16(&self) -> bool {
                *self == ANAROOTCLKMUX::Osc16
            }
            #[doc = "32MHz Oscillator Clock"]
            #[inline(always)]
            pub fn is_osc32(&self) -> bool {
                *self == ANAROOTCLKMUX::Osc32
            }
            #[doc = "PLL Clock"]
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == ANAROOTCLKMUX::Pll
            }
            #[doc = "External GPIO Clock"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == ANAROOTCLKMUX::Gpio
            }
        }
        #[doc = "Field `ANAROOTCLKMUX` writer - Clock Mux Select"]
        pub type ANAROOTCLKMUX_W<'a, REG> =
            crate::FieldWriter<'a, REG, 2, ANAROOTCLKMUX, crate::Safe>;
        impl<'a, REG> ANAROOTCLKMUX_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "16MHz Oscillator Clock"]
            #[inline(always)]
            pub fn osc16(self) -> &'a mut crate::W<REG> {
                self.variant(ANAROOTCLKMUX::Osc16)
            }
            #[doc = "32MHz Oscillator Clock"]
            #[inline(always)]
            pub fn osc32(self) -> &'a mut crate::W<REG> {
                self.variant(ANAROOTCLKMUX::Osc32)
            }
            #[doc = "PLL Clock"]
            #[inline(always)]
            pub fn pll(self) -> &'a mut crate::W<REG> {
                self.variant(ANAROOTCLKMUX::Pll)
            }
            #[doc = "External GPIO Clock"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(ANAROOTCLKMUX::Gpio)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Clock Mux Select"]
            #[inline(always)]
            pub fn clkmux(&self) -> CLKMUX_R {
                CLKMUX_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:5 - GPIO CLK Out Select"]
            #[inline(always)]
            pub fn clkout(&self) -> CLKOUT_R {
                CLKOUT_R::new(((self.bits >> 2) & 0x0f) as u8)
            }
            #[doc = "Bits 7:8 - Mux Selection Analog Clock Source"]
            #[inline(always)]
            pub fn anaclkmux(&self) -> ANACLKMUX_R {
                ANACLKMUX_R::new(((self.bits >> 7) & 3) as u8)
            }
            #[doc = "Bit 9 - PLL Unlock and Lock Interrupt Enable"]
            #[inline(always)]
            pub fn spllie(&self) -> SPLLIE_R {
                SPLLIE_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bits 10:11 - Clock Mux Select"]
            #[inline(always)]
            pub fn anarootclkmux(&self) -> ANAROOTCLKMUX_R {
                ANAROOTCLKMUX_R::new(((self.bits >> 10) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CLKCON0")
                    .field("clkmux", &self.clkmux())
                    .field("clkout", &self.clkout())
                    .field("anaclkmux", &self.anaclkmux())
                    .field("spllie", &self.spllie())
                    .field("anarootclkmux", &self.anarootclkmux())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Clock Mux Select"]
            #[inline(always)]
            pub fn clkmux(&mut self) -> CLKMUX_W<CLKCON0rs> {
                CLKMUX_W::new(self, 0)
            }
            #[doc = "Bits 2:5 - GPIO CLK Out Select"]
            #[inline(always)]
            pub fn clkout(&mut self) -> CLKOUT_W<CLKCON0rs> {
                CLKOUT_W::new(self, 2)
            }
            #[doc = "Bits 7:8 - Mux Selection Analog Clock Source"]
            #[inline(always)]
            pub fn anaclkmux(&mut self) -> ANACLKMUX_W<CLKCON0rs> {
                ANACLKMUX_W::new(self, 7)
            }
            #[doc = "Bit 9 - PLL Unlock and Lock Interrupt Enable"]
            #[inline(always)]
            pub fn spllie(&mut self) -> SPLLIE_W<CLKCON0rs> {
                SPLLIE_W::new(self, 9)
            }
            #[doc = "Bits 10:11 - Clock Mux Select"]
            #[inline(always)]
            pub fn anarootclkmux(&mut self) -> ANAROOTCLKMUX_W<CLKCON0rs> {
                ANAROOTCLKMUX_W::new(self, 10)
            }
        }
        #[doc = "Misc Clock Settings Register\n\nYou can [`read`](crate::Reg::read) this register and get [`clkcon0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clkcon0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CLK:CLKCON0)"]
        pub struct CLKCON0rs;
        impl crate::RegisterSpec for CLKCON0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clkcon0::R`](R) reader structure"]
        impl crate::Readable for CLKCON0rs {}
        #[doc = "`write(|w| ..)` method takes [`clkcon0::W`](W) writer structure"]
        impl crate::Writable for CLKCON0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CLKCON0 to value 0x043c"]
        impl crate::Resettable for CLKCON0rs {
            const RESET_VALUE: u32 = 0x043c;
        }
    }
    #[doc = "CLKCON1 (rw) register accessor: Clock Dividers Register\n\nYou can [`read`](crate::Reg::read) this register and get [`clkcon1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clkcon1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CLK:CLKCON1)\n\nFor information about available fields see [`mod@clkcon1`]
module"]
    pub type CLKCON1 = crate::Reg<clkcon1::CLKCON1rs>;
    #[doc = "Clock Dividers Register"]
    pub mod clkcon1 {
        #[doc = "Register `CLKCON1` reader"]
        pub type R = crate::R<CLKCON1rs>;
        #[doc = "Register `CLKCON1` writer"]
        pub type W = crate::W<CLKCON1rs>;
        #[doc = "HCLK Divide Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CDHCLK {
            #[doc = "0: DIV1. Divide by 1 (HCLK is Equal to Root Clock)"]
            Div1 = 0,
            #[doc = "1: DIV2. Divide by 2 (HCLK is Half the Frequency of Root Clock)"]
            Div2 = 1,
            #[doc = "2: DIV4. Divide by 4 (HCLK is Quarter the Frequency of Root Clock)"]
            Div4 = 2,
            #[doc = "3: DIV8. Divide by 8"]
            Div8 = 3,
            #[doc = "4: DIV16.Divide by 16"]
            Div16 = 4,
            #[doc = "5: DIV32.Divide by 32"]
            Div32 = 5,
            #[doc = "6: DIV64.Divide by 64"]
            Div64 = 6,
            #[doc = "7: DIV128. Divide by 128"]
            Div128 = 7,
        }
        impl From<CDHCLK> for u8 {
            #[inline(always)]
            fn from(variant: CDHCLK) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CDHCLK {
            type Ux = u8;
        }
        impl crate::IsEnum for CDHCLK {}
        #[doc = "Field `CDHCLK` reader - HCLK Divide Bits"]
        pub type CDHCLK_R = crate::FieldReader<CDHCLK>;
        impl CDHCLK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CDHCLK {
                match self.bits {
                    0 => CDHCLK::Div1,
                    1 => CDHCLK::Div2,
                    2 => CDHCLK::Div4,
                    3 => CDHCLK::Div8,
                    4 => CDHCLK::Div16,
                    5 => CDHCLK::Div32,
                    6 => CDHCLK::Div64,
                    7 => CDHCLK::Div128,
                    _ => unreachable!(),
                }
            }
            #[doc = "DIV1. Divide by 1 (HCLK is Equal to Root Clock)"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CDHCLK::Div1
            }
            #[doc = "DIV2. Divide by 2 (HCLK is Half the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CDHCLK::Div2
            }
            #[doc = "DIV4. Divide by 4 (HCLK is Quarter the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CDHCLK::Div4
            }
            #[doc = "DIV8. Divide by 8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == CDHCLK::Div8
            }
            #[doc = "DIV16.Divide by 16"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == CDHCLK::Div16
            }
            #[doc = "DIV32.Divide by 32"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == CDHCLK::Div32
            }
            #[doc = "DIV64.Divide by 64"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == CDHCLK::Div64
            }
            #[doc = "DIV128. Divide by 128"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == CDHCLK::Div128
            }
        }
        #[doc = "Field `CDHCLK` writer - HCLK Divide Bits"]
        pub type CDHCLK_W<'a, REG> = crate::FieldWriter<'a, REG, 3, CDHCLK, crate::Safe>;
        impl<'a, REG> CDHCLK_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "DIV1. Divide by 1 (HCLK is Equal to Root Clock)"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(CDHCLK::Div1)
            }
            #[doc = "DIV2. Divide by 2 (HCLK is Half the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(CDHCLK::Div2)
            }
            #[doc = "DIV4. Divide by 4 (HCLK is Quarter the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(CDHCLK::Div4)
            }
            #[doc = "DIV8. Divide by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(CDHCLK::Div8)
            }
            #[doc = "DIV16.Divide by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut crate::W<REG> {
                self.variant(CDHCLK::Div16)
            }
            #[doc = "DIV32.Divide by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut crate::W<REG> {
                self.variant(CDHCLK::Div32)
            }
            #[doc = "DIV64.Divide by 64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut crate::W<REG> {
                self.variant(CDHCLK::Div64)
            }
            #[doc = "DIV128. Divide by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut crate::W<REG> {
                self.variant(CDHCLK::Div128)
            }
        }
        #[doc = "APB0 PCLK Divide Bits\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CDPCLK0 {
            #[doc = "0: DIV1. Divide by 1 (PCLK is Equal to Root Clock)"]
            Div1 = 0,
            #[doc = "1: DIV2. Divide by 2 (PCLK is Half the Frequency of Root Clock)"]
            Div2 = 1,
            #[doc = "2: DIV4. Divide by 4 (PCLK is Quarter the Frequency of Root Clock, 20 MHz)"]
            Div4 = 2,
            #[doc = "3: DIV8. Divide by 8"]
            Div8 = 3,
            #[doc = "4: DIV16. Divide by 16"]
            Div16 = 4,
            #[doc = "5: DIV32. Divide by 32"]
            Div32 = 5,
            #[doc = "6: DIV64. Divide by 164"]
            Div64 = 6,
            #[doc = "7: DIV128. Divide by 128"]
            Div128 = 7,
        }
        impl From<CDPCLK0> for u8 {
            #[inline(always)]
            fn from(variant: CDPCLK0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CDPCLK0 {
            type Ux = u8;
        }
        impl crate::IsEnum for CDPCLK0 {}
        #[doc = "Field `CDPCLK0` reader - APB0 PCLK Divide Bits"]
        pub type CDPCLK0_R = crate::FieldReader<CDPCLK0>;
        impl CDPCLK0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CDPCLK0 {
                match self.bits {
                    0 => CDPCLK0::Div1,
                    1 => CDPCLK0::Div2,
                    2 => CDPCLK0::Div4,
                    3 => CDPCLK0::Div8,
                    4 => CDPCLK0::Div16,
                    5 => CDPCLK0::Div32,
                    6 => CDPCLK0::Div64,
                    7 => CDPCLK0::Div128,
                    _ => unreachable!(),
                }
            }
            #[doc = "DIV1. Divide by 1 (PCLK is Equal to Root Clock)"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CDPCLK0::Div1
            }
            #[doc = "DIV2. Divide by 2 (PCLK is Half the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CDPCLK0::Div2
            }
            #[doc = "DIV4. Divide by 4 (PCLK is Quarter the Frequency of Root Clock, 20 MHz)"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CDPCLK0::Div4
            }
            #[doc = "DIV8. Divide by 8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == CDPCLK0::Div8
            }
            #[doc = "DIV16. Divide by 16"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == CDPCLK0::Div16
            }
            #[doc = "DIV32. Divide by 32"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == CDPCLK0::Div32
            }
            #[doc = "DIV64. Divide by 164"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == CDPCLK0::Div64
            }
            #[doc = "DIV128. Divide by 128"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == CDPCLK0::Div128
            }
        }
        #[doc = "Field `CDPCLK0` writer - APB0 PCLK Divide Bits"]
        pub type CDPCLK0_W<'a, REG> = crate::FieldWriter<'a, REG, 3, CDPCLK0, crate::Safe>;
        impl<'a, REG> CDPCLK0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "DIV1. Divide by 1 (PCLK is Equal to Root Clock)"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK0::Div1)
            }
            #[doc = "DIV2. Divide by 2 (PCLK is Half the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK0::Div2)
            }
            #[doc = "DIV4. Divide by 4 (PCLK is Quarter the Frequency of Root Clock, 20 MHz)"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK0::Div4)
            }
            #[doc = "DIV8. Divide by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK0::Div8)
            }
            #[doc = "DIV16. Divide by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK0::Div16)
            }
            #[doc = "DIV32. Divide by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK0::Div32)
            }
            #[doc = "DIV64. Divide by 164"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK0::Div64)
            }
            #[doc = "DIV128. Divide by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK0::Div128)
            }
        }
        #[doc = "APB1 PCLK Divide Bits\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CDPCLK1 {
            #[doc = "0: DIV1. Divide by 1 (PCLK is Equal to Root Clock)"]
            Div1 = 0,
            #[doc = "1: DIV2. Divide by 2 (PCLK is Half the Frequency of Root Clock)"]
            Div2 = 1,
            #[doc = "2: DIV4. Divide by 4 (PCLK is Quarter the Frequency of Root Clock, 20 MHz)"]
            Div4 = 2,
            #[doc = "3: DIV8. Divide by 8"]
            Div8 = 3,
            #[doc = "4: DIV16. Divide by 16"]
            Div16 = 4,
            #[doc = "5: DIV32. Divide by 32"]
            Div32 = 5,
            #[doc = "6: DIV64. Divide by 164"]
            Div64 = 6,
            #[doc = "7: DIV128. Divide by 128"]
            Div128 = 7,
        }
        impl From<CDPCLK1> for u8 {
            #[inline(always)]
            fn from(variant: CDPCLK1) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CDPCLK1 {
            type Ux = u8;
        }
        impl crate::IsEnum for CDPCLK1 {}
        #[doc = "Field `CDPCLK1` reader - APB1 PCLK Divide Bits"]
        pub type CDPCLK1_R = crate::FieldReader<CDPCLK1>;
        impl CDPCLK1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CDPCLK1 {
                match self.bits {
                    0 => CDPCLK1::Div1,
                    1 => CDPCLK1::Div2,
                    2 => CDPCLK1::Div4,
                    3 => CDPCLK1::Div8,
                    4 => CDPCLK1::Div16,
                    5 => CDPCLK1::Div32,
                    6 => CDPCLK1::Div64,
                    7 => CDPCLK1::Div128,
                    _ => unreachable!(),
                }
            }
            #[doc = "DIV1. Divide by 1 (PCLK is Equal to Root Clock)"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CDPCLK1::Div1
            }
            #[doc = "DIV2. Divide by 2 (PCLK is Half the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CDPCLK1::Div2
            }
            #[doc = "DIV4. Divide by 4 (PCLK is Quarter the Frequency of Root Clock, 20 MHz)"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CDPCLK1::Div4
            }
            #[doc = "DIV8. Divide by 8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == CDPCLK1::Div8
            }
            #[doc = "DIV16. Divide by 16"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == CDPCLK1::Div16
            }
            #[doc = "DIV32. Divide by 32"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == CDPCLK1::Div32
            }
            #[doc = "DIV64. Divide by 164"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == CDPCLK1::Div64
            }
            #[doc = "DIV128. Divide by 128"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == CDPCLK1::Div128
            }
        }
        #[doc = "Field `CDPCLK1` writer - APB1 PCLK Divide Bits"]
        pub type CDPCLK1_W<'a, REG> = crate::FieldWriter<'a, REG, 3, CDPCLK1, crate::Safe>;
        impl<'a, REG> CDPCLK1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "DIV1. Divide by 1 (PCLK is Equal to Root Clock)"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK1::Div1)
            }
            #[doc = "DIV2. Divide by 2 (PCLK is Half the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK1::Div2)
            }
            #[doc = "DIV4. Divide by 4 (PCLK is Quarter the Frequency of Root Clock, 20 MHz)"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK1::Div4)
            }
            #[doc = "DIV8. Divide by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK1::Div8)
            }
            #[doc = "DIV16. Divide by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK1::Div16)
            }
            #[doc = "DIV32. Divide by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK1::Div32)
            }
            #[doc = "DIV64. Divide by 164"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK1::Div64)
            }
            #[doc = "DIV128. Divide by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut crate::W<REG> {
                self.variant(CDPCLK1::Div128)
            }
        }
        #[doc = "ADCCLK Divide Bits\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CDADCCLK {
            #[doc = "0: DIV1. Divide by 1 (ADCCLK is Equal to Root Clock)"]
            Div1 = 0,
            #[doc = "1: DIV2. Divide by 2 (ADCCLK is Half the Frequency of Root Clock)"]
            Div2 = 1,
            #[doc = "2: DIV4. Divide by 4 (ADCCLK is Quarter the Frequency of Root Clock, 20 MHz)"]
            Div4 = 2,
            #[doc = "3: DIV8. Divide by 8"]
            Div8 = 3,
            #[doc = "4: DIV16. Divide by 16"]
            Div16 = 4,
            #[doc = "5: DIV32. Divide by 32"]
            Div32 = 5,
            #[doc = "6: DIV64. Divide by 164"]
            Div64 = 6,
            #[doc = "7: DIV128. Divide by 128"]
            Div128 = 7,
        }
        impl From<CDADCCLK> for u8 {
            #[inline(always)]
            fn from(variant: CDADCCLK) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CDADCCLK {
            type Ux = u8;
        }
        impl crate::IsEnum for CDADCCLK {}
        #[doc = "Field `CDADCCLK` reader - ADCCLK Divide Bits"]
        pub type CDADCCLK_R = crate::FieldReader<CDADCCLK>;
        impl CDADCCLK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CDADCCLK {
                match self.bits {
                    0 => CDADCCLK::Div1,
                    1 => CDADCCLK::Div2,
                    2 => CDADCCLK::Div4,
                    3 => CDADCCLK::Div8,
                    4 => CDADCCLK::Div16,
                    5 => CDADCCLK::Div32,
                    6 => CDADCCLK::Div64,
                    7 => CDADCCLK::Div128,
                    _ => unreachable!(),
                }
            }
            #[doc = "DIV1. Divide by 1 (ADCCLK is Equal to Root Clock)"]
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                *self == CDADCCLK::Div1
            }
            #[doc = "DIV2. Divide by 2 (ADCCLK is Half the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == CDADCCLK::Div2
            }
            #[doc = "DIV4. Divide by 4 (ADCCLK is Quarter the Frequency of Root Clock, 20 MHz)"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == CDADCCLK::Div4
            }
            #[doc = "DIV8. Divide by 8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == CDADCCLK::Div8
            }
            #[doc = "DIV16. Divide by 16"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == CDADCCLK::Div16
            }
            #[doc = "DIV32. Divide by 32"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == CDADCCLK::Div32
            }
            #[doc = "DIV64. Divide by 164"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == CDADCCLK::Div64
            }
            #[doc = "DIV128. Divide by 128"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == CDADCCLK::Div128
            }
        }
        #[doc = "Field `CDADCCLK` writer - ADCCLK Divide Bits"]
        pub type CDADCCLK_W<'a, REG> = crate::FieldWriter<'a, REG, 3, CDADCCLK, crate::Safe>;
        impl<'a, REG> CDADCCLK_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "DIV1. Divide by 1 (ADCCLK is Equal to Root Clock)"]
            #[inline(always)]
            pub fn div1(self) -> &'a mut crate::W<REG> {
                self.variant(CDADCCLK::Div1)
            }
            #[doc = "DIV2. Divide by 2 (ADCCLK is Half the Frequency of Root Clock)"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(CDADCCLK::Div2)
            }
            #[doc = "DIV4. Divide by 4 (ADCCLK is Quarter the Frequency of Root Clock, 20 MHz)"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(CDADCCLK::Div4)
            }
            #[doc = "DIV8. Divide by 8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(CDADCCLK::Div8)
            }
            #[doc = "DIV16. Divide by 16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut crate::W<REG> {
                self.variant(CDADCCLK::Div16)
            }
            #[doc = "DIV32. Divide by 32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut crate::W<REG> {
                self.variant(CDADCCLK::Div32)
            }
            #[doc = "DIV64. Divide by 164"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut crate::W<REG> {
                self.variant(CDADCCLK::Div64)
            }
            #[doc = "DIV128. Divide by 128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut crate::W<REG> {
                self.variant(CDADCCLK::Div128)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - HCLK Divide Bits"]
            #[inline(always)]
            pub fn cdhclk(&self) -> CDHCLK_R {
                CDHCLK_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:5 - APB0 PCLK Divide Bits"]
            #[inline(always)]
            pub fn cdpclk0(&self) -> CDPCLK0_R {
                CDPCLK0_R::new(((self.bits >> 3) & 7) as u8)
            }
            #[doc = "Bits 6:8 - APB1 PCLK Divide Bits"]
            #[inline(always)]
            pub fn cdpclk1(&self) -> CDPCLK1_R {
                CDPCLK1_R::new(((self.bits >> 6) & 7) as u8)
            }
            #[doc = "Bits 9:11 - ADCCLK Divide Bits"]
            #[inline(always)]
            pub fn cdadcclk(&self) -> CDADCCLK_R {
                CDADCCLK_R::new(((self.bits >> 9) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CLKCON1")
                    .field("cdhclk", &self.cdhclk())
                    .field("cdpclk0", &self.cdpclk0())
                    .field("cdpclk1", &self.cdpclk1())
                    .field("cdadcclk", &self.cdadcclk())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:2 - HCLK Divide Bits"]
            #[inline(always)]
            pub fn cdhclk(&mut self) -> CDHCLK_W<CLKCON1rs> {
                CDHCLK_W::new(self, 0)
            }
            #[doc = "Bits 3:5 - APB0 PCLK Divide Bits"]
            #[inline(always)]
            pub fn cdpclk0(&mut self) -> CDPCLK0_W<CLKCON1rs> {
                CDPCLK0_W::new(self, 3)
            }
            #[doc = "Bits 6:8 - APB1 PCLK Divide Bits"]
            #[inline(always)]
            pub fn cdpclk1(&mut self) -> CDPCLK1_W<CLKCON1rs> {
                CDPCLK1_W::new(self, 6)
            }
            #[doc = "Bits 9:11 - ADCCLK Divide Bits"]
            #[inline(always)]
            pub fn cdadcclk(&mut self) -> CDADCCLK_W<CLKCON1rs> {
                CDADCCLK_W::new(self, 9)
            }
        }
        #[doc = "Clock Dividers Register\n\nYou can [`read`](crate::Reg::read) this register and get [`clkcon1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clkcon1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CLK:CLKCON1)"]
        pub struct CLKCON1rs;
        impl crate::RegisterSpec for CLKCON1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clkcon1::R`](R) reader structure"]
        impl crate::Readable for CLKCON1rs {}
        #[doc = "`write(|w| ..)` method takes [`clkcon1::W`](W) writer structure"]
        impl crate::Writable for CLKCON1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CLKCON1 to value 0x48"]
        impl crate::Resettable for CLKCON1rs {
            const RESET_VALUE: u32 = 0x48;
        }
    }
    #[doc = "CLKSTAT0 (rw) register accessor: Clocking Status\n\nYou can [`read`](crate::Reg::read) this register and get [`clkstat0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clkstat0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CLK:CLKSTAT0)\n\nFor information about available fields see [`mod@clkstat0`]
module"]
    pub type CLKSTAT0 = crate::Reg<clkstat0::CLKSTAT0rs>;
    #[doc = "Clocking Status"]
    pub mod clkstat0 {
        #[doc = "Register `CLKSTAT0` reader"]
        pub type R = crate::R<CLKSTAT0rs>;
        #[doc = "Register `CLKSTAT0` writer"]
        pub type W = crate::W<CLKSTAT0rs>;
        #[doc = "System PLL Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SPLLSTATUS {
            #[doc = "0: The PLL is Not Locked or Not Properly Configured. the PLL is Not Ready for Use as the System Clock Source"]
            Unlocked = 0,
            #[doc = "1: The PLL is Locked and is Ready for Use as the System Clock Source"]
            Locked = 1,
        }
        impl From<SPLLSTATUS> for bool {
            #[inline(always)]
            fn from(variant: SPLLSTATUS) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SPLLSTATUS` reader - System PLL Status"]
        pub type SPLLSTATUS_R = crate::BitReader<SPLLSTATUS>;
        impl SPLLSTATUS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SPLLSTATUS {
                match self.bits {
                    false => SPLLSTATUS::Unlocked,
                    true => SPLLSTATUS::Locked,
                }
            }
            #[doc = "The PLL is Not Locked or Not Properly Configured. the PLL is Not Ready for Use as the System Clock Source"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == SPLLSTATUS::Unlocked
            }
            #[doc = "The PLL is Locked and is Ready for Use as the System Clock Source"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == SPLLSTATUS::Locked
            }
        }
        #[doc = "System PLL Lock\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SPLLLOCKCLR {
            #[doc = "0: No PLL Lock Event Was Detected"]
            Unlocked = 0,
            #[doc = "1: A PLL Lock Event Was Detected"]
            Locked = 1,
        }
        impl From<SPLLLOCKCLR> for bool {
            #[inline(always)]
            fn from(variant: SPLLLOCKCLR) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SPLLLOCKCLR` reader - System PLL Lock"]
        pub type SPLLLOCKCLR_R = crate::BitReader<SPLLLOCKCLR>;
        impl SPLLLOCKCLR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SPLLLOCKCLR {
                match self.bits {
                    false => SPLLLOCKCLR::Unlocked,
                    true => SPLLLOCKCLR::Locked,
                }
            }
            #[doc = "No PLL Lock Event Was Detected"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == SPLLLOCKCLR::Unlocked
            }
            #[doc = "A PLL Lock Event Was Detected"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == SPLLLOCKCLR::Locked
            }
        }
        #[doc = "Field `SPLLLOCKCLR` writer - System PLL Lock"]
        pub type SPLLLOCKCLR_W<'a, REG> = crate::BitWriter<'a, REG, SPLLLOCKCLR>;
        impl<'a, REG> SPLLLOCKCLR_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No PLL Lock Event Was Detected"]
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut crate::W<REG> {
                self.variant(SPLLLOCKCLR::Unlocked)
            }
            #[doc = "A PLL Lock Event Was Detected"]
            #[inline(always)]
            pub fn locked(self) -> &'a mut crate::W<REG> {
                self.variant(SPLLLOCKCLR::Locked)
            }
        }
        #[doc = "System PLL Unlock\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SPLLUNLOCKCLR {
            #[doc = "0: No Loss of PLL Lock Was Detected"]
            Noloss = 0,
            #[doc = "1: A PLL Loss of Lock Was Detected"]
            Loss = 1,
        }
        impl From<SPLLUNLOCKCLR> for bool {
            #[inline(always)]
            fn from(variant: SPLLUNLOCKCLR) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SPLLUNLOCKCLR` reader - System PLL Unlock"]
        pub type SPLLUNLOCKCLR_R = crate::BitReader<SPLLUNLOCKCLR>;
        impl SPLLUNLOCKCLR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SPLLUNLOCKCLR {
                match self.bits {
                    false => SPLLUNLOCKCLR::Noloss,
                    true => SPLLUNLOCKCLR::Loss,
                }
            }
            #[doc = "No Loss of PLL Lock Was Detected"]
            #[inline(always)]
            pub fn is_noloss(&self) -> bool {
                *self == SPLLUNLOCKCLR::Noloss
            }
            #[doc = "A PLL Loss of Lock Was Detected"]
            #[inline(always)]
            pub fn is_loss(&self) -> bool {
                *self == SPLLUNLOCKCLR::Loss
            }
        }
        #[doc = "Field `SPLLUNLOCKCLR` writer - System PLL Unlock"]
        pub type SPLLUNLOCKCLR_W<'a, REG> = crate::BitWriter<'a, REG, SPLLUNLOCKCLR>;
        impl<'a, REG> SPLLUNLOCKCLR_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No Loss of PLL Lock Was Detected"]
            #[inline(always)]
            pub fn noloss(self) -> &'a mut crate::W<REG> {
                self.variant(SPLLUNLOCKCLR::Noloss)
            }
            #[doc = "A PLL Loss of Lock Was Detected"]
            #[inline(always)]
            pub fn loss(self) -> &'a mut crate::W<REG> {
                self.variant(SPLLUNLOCKCLR::Loss)
            }
        }
        #[doc = "Sticky System PLL Lock Flag\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SPLLLOCK {
            #[doc = "0: No PLL Lock Event Was Detected"]
            Unlocked = 0,
            #[doc = "1: A PLL Lock Event Was Detected"]
            Locked = 1,
        }
        impl From<SPLLLOCK> for bool {
            #[inline(always)]
            fn from(variant: SPLLLOCK) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SPLLLOCK` reader - Sticky System PLL Lock Flag"]
        pub type SPLLLOCK_R = crate::BitReader<SPLLLOCK>;
        impl SPLLLOCK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SPLLLOCK {
                match self.bits {
                    false => SPLLLOCK::Unlocked,
                    true => SPLLLOCK::Locked,
                }
            }
            #[doc = "No PLL Lock Event Was Detected"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == SPLLLOCK::Unlocked
            }
            #[doc = "A PLL Lock Event Was Detected"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == SPLLLOCK::Locked
            }
        }
        #[doc = "Sticky System PLL Unlock Flag\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SPLLUNLOCK {
            #[doc = "0: No PLL Lock Event Was Detected"]
            Unlocked = 0,
            #[doc = "1: A PLL Lock Event Was Detected"]
            Locked = 1,
        }
        impl From<SPLLUNLOCK> for bool {
            #[inline(always)]
            fn from(variant: SPLLUNLOCK) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SPLLUNLOCK` reader - Sticky System PLL Unlock Flag"]
        pub type SPLLUNLOCK_R = crate::BitReader<SPLLUNLOCK>;
        impl SPLLUNLOCK_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SPLLUNLOCK {
                match self.bits {
                    false => SPLLUNLOCK::Unlocked,
                    true => SPLLUNLOCK::Locked,
                }
            }
            #[doc = "No PLL Lock Event Was Detected"]
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == SPLLUNLOCK::Unlocked
            }
            #[doc = "A PLL Lock Event Was Detected"]
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == SPLLUNLOCK::Locked
            }
        }
        impl R {
            #[doc = "Bit 0 - System PLL Status"]
            #[inline(always)]
            pub fn spllstatus(&self) -> SPLLSTATUS_R {
                SPLLSTATUS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - System PLL Lock"]
            #[inline(always)]
            pub fn splllockclr(&self) -> SPLLLOCKCLR_R {
                SPLLLOCKCLR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - System PLL Unlock"]
            #[inline(always)]
            pub fn spllunlockclr(&self) -> SPLLUNLOCKCLR_R {
                SPLLUNLOCKCLR_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Sticky System PLL Lock Flag"]
            #[inline(always)]
            pub fn splllock(&self) -> SPLLLOCK_R {
                SPLLLOCK_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Sticky System PLL Unlock Flag"]
            #[inline(always)]
            pub fn spllunlock(&self) -> SPLLUNLOCK_R {
                SPLLUNLOCK_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CLKSTAT0")
                    .field("spllstatus", &self.spllstatus())
                    .field("splllockclr", &self.splllockclr())
                    .field("spllunlockclr", &self.spllunlockclr())
                    .field("splllock", &self.splllock())
                    .field("spllunlock", &self.spllunlock())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 1 - System PLL Lock"]
            #[inline(always)]
            pub fn splllockclr(&mut self) -> SPLLLOCKCLR_W<CLKSTAT0rs> {
                SPLLLOCKCLR_W::new(self, 1)
            }
            #[doc = "Bit 2 - System PLL Unlock"]
            #[inline(always)]
            pub fn spllunlockclr(&mut self) -> SPLLUNLOCKCLR_W<CLKSTAT0rs> {
                SPLLUNLOCKCLR_W::new(self, 2)
            }
        }
        #[doc = "Clocking Status\n\nYou can [`read`](crate::Reg::read) this register and get [`clkstat0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clkstat0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CLK:CLKSTAT0)"]
        pub struct CLKSTAT0rs;
        impl crate::RegisterSpec for CLKSTAT0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clkstat0::R`](R) reader structure"]
        impl crate::Readable for CLKSTAT0rs {}
        #[doc = "`write(|w| ..)` method takes [`clkstat0::W`](W) writer structure"]
        impl crate::Writable for CLKSTAT0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CLKSTAT0 to value 0"]
        impl crate::Resettable for CLKSTAT0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM)"]
pub struct PWM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM {}
impl PWM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm::RegisterBlock = 0x4006_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PWM {
    type Target = pwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM").finish()
    }
}
#[doc = "Unknown"]
pub mod pwm {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        pwmcon0: PWMCON0,
        pwmcon1: PWMCON1,
        pwmiclr: PWMICLR,
        _reserved3: [u8; 0x04],
        pwm0com0: PWM0COM0,
        pwm0com1: PWM0COM1,
        pwm0com2: PWM0COM2,
        pwm0len: PWM0LEN,
        pwm1com0: PWM1COM0,
        pwm1com1: PWM1COM1,
        pwm1com2: PWM1COM2,
        pwm1len: PWM1LEN,
        pwm2com0: PWM2COM0,
        pwm2com1: PWM2COM1,
        pwm2com2: PWM2COM2,
        pwm2len: PWM2LEN,
        pwm3com0: PWM3COM0,
        pwm3com1: PWM3COM1,
        pwm3com2: PWM3COM2,
        pwm3len: PWM3LEN,
    }
    impl RegisterBlock {
        #[doc = "0x00 - PWM Control Register"]
        #[inline(always)]
        pub const fn pwmcon0(&self) -> &PWMCON0 {
            &self.pwmcon0
        }
        #[doc = "0x04 - ADC Conversion Start and Trip Control Register"]
        #[inline(always)]
        pub const fn pwmcon1(&self) -> &PWMCON1 {
            &self.pwmcon1
        }
        #[doc = "0x08 - Hardware Trip Configuration Register"]
        #[inline(always)]
        pub const fn pwmiclr(&self) -> &PWMICLR {
            &self.pwmiclr
        }
        #[doc = "0x10 - Compare Register 0 for PWM0 and PWM1"]
        #[inline(always)]
        pub const fn pwm0com0(&self) -> &PWM0COM0 {
            &self.pwm0com0
        }
        #[doc = "0x14 - Compare Register 1 for PWM0 and PWM1"]
        #[inline(always)]
        pub const fn pwm0com1(&self) -> &PWM0COM1 {
            &self.pwm0com1
        }
        #[doc = "0x18 - Compare Register 2 for PWM0 and PWM1"]
        #[inline(always)]
        pub const fn pwm0com2(&self) -> &PWM0COM2 {
            &self.pwm0com2
        }
        #[doc = "0x1c - Period Value Register for PWM0 and PWM1"]
        #[inline(always)]
        pub const fn pwm0len(&self) -> &PWM0LEN {
            &self.pwm0len
        }
        #[doc = "0x20 - Compare Register 0 for PWM2 and PWM3"]
        #[inline(always)]
        pub const fn pwm1com0(&self) -> &PWM1COM0 {
            &self.pwm1com0
        }
        #[doc = "0x24 - Compare Register 1 for PWM2 and PWM3"]
        #[inline(always)]
        pub const fn pwm1com1(&self) -> &PWM1COM1 {
            &self.pwm1com1
        }
        #[doc = "0x28 - Compare Register 2 for PWM2 and PWM3"]
        #[inline(always)]
        pub const fn pwm1com2(&self) -> &PWM1COM2 {
            &self.pwm1com2
        }
        #[doc = "0x2c - Period Value Register for PWM2 and PWM3"]
        #[inline(always)]
        pub const fn pwm1len(&self) -> &PWM1LEN {
            &self.pwm1len
        }
        #[doc = "0x30 - Compare Register 0 for PWM4 and PWM5"]
        #[inline(always)]
        pub const fn pwm2com0(&self) -> &PWM2COM0 {
            &self.pwm2com0
        }
        #[doc = "0x34 - Compare Register 1 for PWM4 and PWM5"]
        #[inline(always)]
        pub const fn pwm2com1(&self) -> &PWM2COM1 {
            &self.pwm2com1
        }
        #[doc = "0x38 - Compare Register 2 for PWM4 and PWM5"]
        #[inline(always)]
        pub const fn pwm2com2(&self) -> &PWM2COM2 {
            &self.pwm2com2
        }
        #[doc = "0x3c - Period Value Register for PWM4 and PWM5"]
        #[inline(always)]
        pub const fn pwm2len(&self) -> &PWM2LEN {
            &self.pwm2len
        }
        #[doc = "0x40 - Compare Register 0 for PWM6 and PWM7"]
        #[inline(always)]
        pub const fn pwm3com0(&self) -> &PWM3COM0 {
            &self.pwm3com0
        }
        #[doc = "0x44 - Compare Register 1 for PWM6 and PWM7"]
        #[inline(always)]
        pub const fn pwm3com1(&self) -> &PWM3COM1 {
            &self.pwm3com1
        }
        #[doc = "0x48 - Compare Register 2 for PWM6 and PWM7"]
        #[inline(always)]
        pub const fn pwm3com2(&self) -> &PWM3COM2 {
            &self.pwm3com2
        }
        #[doc = "0x4c - Period Value Register for PWM6 and PWM7"]
        #[inline(always)]
        pub const fn pwm3len(&self) -> &PWM3LEN {
            &self.pwm3len
        }
    }
    #[doc = "PWMCON0 (rw) register accessor: PWM Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pwmcon0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwmcon0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWMCON0)\n\nFor information about available fields see [`mod@pwmcon0`]
module"]
    pub type PWMCON0 = crate::Reg<pwmcon0::PWMCON0rs>;
    #[doc = "PWM Control Register"]
    pub mod pwmcon0 {
        #[doc = "Register `PWMCON0` reader"]
        pub type R = crate::R<PWMCON0rs>;
        #[doc = "Register `PWMCON0` writer"]
        pub type W = crate::W<PWMCON0rs>;
        #[doc = "Master Enable for PWM\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PWMEN {
            #[doc = "0: Disable All PWM Outputs"]
            Dis = 0,
            #[doc = "1: Enable All PWM Outputs"]
            En = 1,
        }
        impl From<PWMEN> for bool {
            #[inline(always)]
            fn from(variant: PWMEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PWMEN` reader - Master Enable for PWM"]
        pub type PWMEN_R = crate::BitReader<PWMEN>;
        impl PWMEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PWMEN {
                match self.bits {
                    false => PWMEN::Dis,
                    true => PWMEN::En,
                }
            }
            #[doc = "Disable All PWM Outputs"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == PWMEN::Dis
            }
            #[doc = "Enable All PWM Outputs"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == PWMEN::En
            }
        }
        #[doc = "Field `PWMEN` writer - Master Enable for PWM"]
        pub type PWMEN_W<'a, REG> = crate::BitWriter<'a, REG, PWMEN>;
        impl<'a, REG> PWMEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable All PWM Outputs"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(PWMEN::Dis)
            }
            #[doc = "Enable All PWM Outputs"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(PWMEN::En)
            }
        }
        #[doc = "Field `HMODE` reader - Set to Enable H-bridge Mode"]
        pub type HMODE_R = crate::BitReader;
        #[doc = "Field `HMODE` writer - Set to Enable H-bridge Mode"]
        pub type HMODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Direction Control When PWM is in H-bridge Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HDIR {
            #[doc = "0: PWM2 and PWM3 Act as Output Signals While PWM0 and PWM1 are Held Low"]
            Dis = 0,
            #[doc = "1: PWM0 and PWM1 Act as Output Signals While PWM2 and PWM3 are Held Low"]
            En = 1,
        }
        impl From<HDIR> for bool {
            #[inline(always)]
            fn from(variant: HDIR) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `HDIR` reader - Direction Control When PWM is in H-bridge Mode"]
        pub type HDIR_R = crate::BitReader<HDIR>;
        impl HDIR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> HDIR {
                match self.bits {
                    false => HDIR::Dis,
                    true => HDIR::En,
                }
            }
            #[doc = "PWM2 and PWM3 Act as Output Signals While PWM0 and PWM1 are Held Low"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == HDIR::Dis
            }
            #[doc = "PWM0 and PWM1 Act as Output Signals While PWM2 and PWM3 are Held Low"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == HDIR::En
            }
        }
        #[doc = "Field `HDIR` writer - Direction Control When PWM is in H-bridge Mode"]
        pub type HDIR_W<'a, REG> = crate::BitWriter<'a, REG, HDIR>;
        impl<'a, REG> HDIR_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PWM2 and PWM3 Act as Output Signals While PWM0 and PWM1 are Held Low"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(HDIR::Dis)
            }
            #[doc = "PWM0 and PWM1 Act as Output Signals While PWM2 and PWM3 are Held Low"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(HDIR::En)
            }
        }
        #[doc = "Signal to Load a New Set of Compare Register Values\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LCOMP {
            #[doc = "0: Use the Values Previously Store in the Compare and Length Registers"]
            Dis = 0,
            #[doc = "1: Load the Internal Compare Registers with Values Stored in the PWMxCOMx and PWMxLEN Registers"]
            En = 1,
        }
        impl From<LCOMP> for bool {
            #[inline(always)]
            fn from(variant: LCOMP) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `LCOMP` reader - Signal to Load a New Set of Compare Register Values"]
        pub type LCOMP_R = crate::BitReader<LCOMP>;
        impl LCOMP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> LCOMP {
                match self.bits {
                    false => LCOMP::Dis,
                    true => LCOMP::En,
                }
            }
            #[doc = "Use the Values Previously Store in the Compare and Length Registers"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == LCOMP::Dis
            }
            #[doc = "Load the Internal Compare Registers with Values Stored in the PWMxCOMx and PWMxLEN Registers"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == LCOMP::En
            }
        }
        #[doc = "Field `LCOMP` writer - Signal to Load a New Set of Compare Register Values"]
        pub type LCOMP_W<'a, REG> = crate::BitWriter<'a, REG, LCOMP>;
        impl<'a, REG> LCOMP_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Use the Values Previously Store in the Compare and Length Registers"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(LCOMP::Dis)
            }
            #[doc = "Load the Internal Compare Registers with Values Stored in the PWMxCOMx and PWMxLEN Registers"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(LCOMP::En)
            }
        }
        #[doc = "Field `HOFF` reader - Set to Turn off the High-side for Pair 0/1 in H-bridge Mode"]
        pub type HOFF_R = crate::BitReader;
        #[doc = "Field `HOFF` writer - Set to Turn off the High-side for Pair 0/1 in H-bridge Mode"]
        pub type HOFF_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `POINV` reader - Set to Invert PWM Outputs for Pair 0/1 in H-bridge Mode"]
        pub type POINV_R = crate::BitReader;
        #[doc = "Field `POINV` writer - Set to Invert PWM Outputs for Pair 0/1 in H-bridge Mode"]
        pub type POINV_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "PWM Clock Prescaler. Sets UCLK Divider.\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PWMCMP {
            #[doc = "0: UCLK/2"]
            Div2 = 0,
            #[doc = "1: UCLK/4"]
            Div4 = 1,
            #[doc = "2: UCLK/8"]
            Div8 = 2,
            #[doc = "3: UCLK/16"]
            Div16 = 3,
            #[doc = "4: UCLK/32"]
            Div32 = 4,
            #[doc = "5: UCLK/64"]
            Div64 = 5,
            #[doc = "6: UCLK/128"]
            Div128 = 6,
            #[doc = "7: UCLK/256"]
            Div256 = 7,
        }
        impl From<PWMCMP> for u8 {
            #[inline(always)]
            fn from(variant: PWMCMP) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PWMCMP {
            type Ux = u8;
        }
        impl crate::IsEnum for PWMCMP {}
        #[doc = "Field `PWMCMP` reader - PWM Clock Prescaler. Sets UCLK Divider."]
        pub type PWMCMP_R = crate::FieldReader<PWMCMP>;
        impl PWMCMP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PWMCMP {
                match self.bits {
                    0 => PWMCMP::Div2,
                    1 => PWMCMP::Div4,
                    2 => PWMCMP::Div8,
                    3 => PWMCMP::Div16,
                    4 => PWMCMP::Div32,
                    5 => PWMCMP::Div64,
                    6 => PWMCMP::Div128,
                    7 => PWMCMP::Div256,
                    _ => unreachable!(),
                }
            }
            #[doc = "UCLK/2"]
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PWMCMP::Div2
            }
            #[doc = "UCLK/4"]
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PWMCMP::Div4
            }
            #[doc = "UCLK/8"]
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PWMCMP::Div8
            }
            #[doc = "UCLK/16"]
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PWMCMP::Div16
            }
            #[doc = "UCLK/32"]
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == PWMCMP::Div32
            }
            #[doc = "UCLK/64"]
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == PWMCMP::Div64
            }
            #[doc = "UCLK/128"]
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == PWMCMP::Div128
            }
            #[doc = "UCLK/256"]
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == PWMCMP::Div256
            }
        }
        #[doc = "Field `PWMCMP` writer - PWM Clock Prescaler. Sets UCLK Divider."]
        pub type PWMCMP_W<'a, REG> = crate::FieldWriter<'a, REG, 3, PWMCMP, crate::Safe>;
        impl<'a, REG> PWMCMP_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "UCLK/2"]
            #[inline(always)]
            pub fn div2(self) -> &'a mut crate::W<REG> {
                self.variant(PWMCMP::Div2)
            }
            #[doc = "UCLK/4"]
            #[inline(always)]
            pub fn div4(self) -> &'a mut crate::W<REG> {
                self.variant(PWMCMP::Div4)
            }
            #[doc = "UCLK/8"]
            #[inline(always)]
            pub fn div8(self) -> &'a mut crate::W<REG> {
                self.variant(PWMCMP::Div8)
            }
            #[doc = "UCLK/16"]
            #[inline(always)]
            pub fn div16(self) -> &'a mut crate::W<REG> {
                self.variant(PWMCMP::Div16)
            }
            #[doc = "UCLK/32"]
            #[inline(always)]
            pub fn div32(self) -> &'a mut crate::W<REG> {
                self.variant(PWMCMP::Div32)
            }
            #[doc = "UCLK/64"]
            #[inline(always)]
            pub fn div64(self) -> &'a mut crate::W<REG> {
                self.variant(PWMCMP::Div64)
            }
            #[doc = "UCLK/128"]
            #[inline(always)]
            pub fn div128(self) -> &'a mut crate::W<REG> {
                self.variant(PWMCMP::Div128)
            }
            #[doc = "UCLK/256"]
            #[inline(always)]
            pub fn div256(self) -> &'a mut crate::W<REG> {
                self.variant(PWMCMP::Div256)
            }
        }
        #[doc = "Enable for Pair 0 and 1 When HOFF=0 and HMODE=1\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ENA {
            #[doc = "0: Disable Pair 0 and 1"]
            Dis = 0,
            #[doc = "1: Enable Pair 0 and 1"]
            En = 1,
        }
        impl From<ENA> for bool {
            #[inline(always)]
            fn from(variant: ENA) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ENA` reader - Enable for Pair 0 and 1 When HOFF=0 and HMODE=1"]
        pub type ENA_R = crate::BitReader<ENA>;
        impl ENA_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> ENA {
                match self.bits {
                    false => ENA::Dis,
                    true => ENA::En,
                }
            }
            #[doc = "Disable Pair 0 and 1"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == ENA::Dis
            }
            #[doc = "Enable Pair 0 and 1"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == ENA::En
            }
        }
        #[doc = "Field `ENA` writer - Enable for Pair 0 and 1 When HOFF=0 and HMODE=1"]
        pub type ENA_W<'a, REG> = crate::BitWriter<'a, REG, ENA>;
        impl<'a, REG> ENA_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable Pair 0 and 1"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(ENA::Dis)
            }
            #[doc = "Enable Pair 0 and 1"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(ENA::En)
            }
        }
        #[doc = "Field `PWMIEN` reader - Set to Enable Interrupts for PWM"]
        pub type PWMIEN_R = crate::BitReader;
        #[doc = "Field `PWMIEN` writer - Set to Enable Interrupts for PWM"]
        pub type PWMIEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM1INV` reader - Set to Invert PWM1 Output"]
        pub type PWM1INV_R = crate::BitReader;
        #[doc = "Field `PWM1INV` writer - Set to Invert PWM1 Output"]
        pub type PWM1INV_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM3INV` reader - Set to Invert PWM3 Output"]
        pub type PWM3INV_R = crate::BitReader;
        #[doc = "Field `PWM3INV` writer - Set to Invert PWM3 Output"]
        pub type PWM3INV_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM5INV` reader - Set to Invert PWM5 Output"]
        pub type PWM5INV_R = crate::BitReader;
        #[doc = "Field `PWM5INV` writer - Set to Invert PWM5 Output"]
        pub type PWM5INV_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM7INV` reader - Set to Invert PWM7 Output"]
        pub type PWM7INV_R = crate::BitReader;
        #[doc = "Field `PWM7INV` writer - Set to Invert PWM7 Output"]
        pub type PWM7INV_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Set to Enable PWM Synchronization from the SYNC Pin\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SYNC {
            #[doc = "0: Ignore Transition from the SYNC Pin"]
            Dis = 0,
            #[doc = "1: All PWM Counters are Reset on the Next Clock Cycle After Detection of a Falling Edge from SYNC Pin"]
            En = 1,
        }
        impl From<SYNC> for bool {
            #[inline(always)]
            fn from(variant: SYNC) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SYNC` reader - Set to Enable PWM Synchronization from the SYNC Pin"]
        pub type SYNC_R = crate::BitReader<SYNC>;
        impl SYNC_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SYNC {
                match self.bits {
                    false => SYNC::Dis,
                    true => SYNC::En,
                }
            }
            #[doc = "Ignore Transition from the SYNC Pin"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == SYNC::Dis
            }
            #[doc = "All PWM Counters are Reset on the Next Clock Cycle After Detection of a Falling Edge from SYNC Pin"]
            #[inline(always)]
            pub fn is_en(&self) -> bool {
                *self == SYNC::En
            }
        }
        #[doc = "Field `SYNC` writer - Set to Enable PWM Synchronization from the SYNC Pin"]
        pub type SYNC_W<'a, REG> = crate::BitWriter<'a, REG, SYNC>;
        impl<'a, REG> SYNC_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Ignore Transition from the SYNC Pin"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(SYNC::Dis)
            }
            #[doc = "All PWM Counters are Reset on the Next Clock Cycle After Detection of a Falling Edge from SYNC Pin"]
            #[inline(always)]
            pub fn en(self) -> &'a mut crate::W<REG> {
                self.variant(SYNC::En)
            }
        }
        impl R {
            #[doc = "Bit 0 - Master Enable for PWM"]
            #[inline(always)]
            pub fn pwmen(&self) -> PWMEN_R {
                PWMEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Set to Enable H-bridge Mode"]
            #[inline(always)]
            pub fn hmode(&self) -> HMODE_R {
                HMODE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Direction Control When PWM is in H-bridge Mode"]
            #[inline(always)]
            pub fn hdir(&self) -> HDIR_R {
                HDIR_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Signal to Load a New Set of Compare Register Values"]
            #[inline(always)]
            pub fn lcomp(&self) -> LCOMP_R {
                LCOMP_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Set to Turn off the High-side for Pair 0/1 in H-bridge Mode"]
            #[inline(always)]
            pub fn hoff(&self) -> HOFF_R {
                HOFF_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Set to Invert PWM Outputs for Pair 0/1 in H-bridge Mode"]
            #[inline(always)]
            pub fn poinv(&self) -> POINV_R {
                POINV_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bits 6:8 - PWM Clock Prescaler. Sets UCLK Divider."]
            #[inline(always)]
            pub fn pwmcmp(&self) -> PWMCMP_R {
                PWMCMP_R::new(((self.bits >> 6) & 7) as u8)
            }
            #[doc = "Bit 9 - Enable for Pair 0 and 1 When HOFF=0 and HMODE=1"]
            #[inline(always)]
            pub fn ena(&self) -> ENA_R {
                ENA_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Set to Enable Interrupts for PWM"]
            #[inline(always)]
            pub fn pwmien(&self) -> PWMIEN_R {
                PWMIEN_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Set to Invert PWM1 Output"]
            #[inline(always)]
            pub fn pwm1inv(&self) -> PWM1INV_R {
                PWM1INV_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Set to Invert PWM3 Output"]
            #[inline(always)]
            pub fn pwm3inv(&self) -> PWM3INV_R {
                PWM3INV_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Set to Invert PWM5 Output"]
            #[inline(always)]
            pub fn pwm5inv(&self) -> PWM5INV_R {
                PWM5INV_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Set to Invert PWM7 Output"]
            #[inline(always)]
            pub fn pwm7inv(&self) -> PWM7INV_R {
                PWM7INV_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Set to Enable PWM Synchronization from the SYNC Pin"]
            #[inline(always)]
            pub fn sync(&self) -> SYNC_R {
                SYNC_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWMCON0")
                    .field("pwmen", &self.pwmen())
                    .field("hmode", &self.hmode())
                    .field("hdir", &self.hdir())
                    .field("lcomp", &self.lcomp())
                    .field("hoff", &self.hoff())
                    .field("poinv", &self.poinv())
                    .field("pwmcmp", &self.pwmcmp())
                    .field("ena", &self.ena())
                    .field("pwmien", &self.pwmien())
                    .field("pwm1inv", &self.pwm1inv())
                    .field("pwm3inv", &self.pwm3inv())
                    .field("pwm5inv", &self.pwm5inv())
                    .field("pwm7inv", &self.pwm7inv())
                    .field("sync", &self.sync())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Master Enable for PWM"]
            #[inline(always)]
            pub fn pwmen(&mut self) -> PWMEN_W<PWMCON0rs> {
                PWMEN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Set to Enable H-bridge Mode"]
            #[inline(always)]
            pub fn hmode(&mut self) -> HMODE_W<PWMCON0rs> {
                HMODE_W::new(self, 1)
            }
            #[doc = "Bit 2 - Direction Control When PWM is in H-bridge Mode"]
            #[inline(always)]
            pub fn hdir(&mut self) -> HDIR_W<PWMCON0rs> {
                HDIR_W::new(self, 2)
            }
            #[doc = "Bit 3 - Signal to Load a New Set of Compare Register Values"]
            #[inline(always)]
            pub fn lcomp(&mut self) -> LCOMP_W<PWMCON0rs> {
                LCOMP_W::new(self, 3)
            }
            #[doc = "Bit 4 - Set to Turn off the High-side for Pair 0/1 in H-bridge Mode"]
            #[inline(always)]
            pub fn hoff(&mut self) -> HOFF_W<PWMCON0rs> {
                HOFF_W::new(self, 4)
            }
            #[doc = "Bit 5 - Set to Invert PWM Outputs for Pair 0/1 in H-bridge Mode"]
            #[inline(always)]
            pub fn poinv(&mut self) -> POINV_W<PWMCON0rs> {
                POINV_W::new(self, 5)
            }
            #[doc = "Bits 6:8 - PWM Clock Prescaler. Sets UCLK Divider."]
            #[inline(always)]
            pub fn pwmcmp(&mut self) -> PWMCMP_W<PWMCON0rs> {
                PWMCMP_W::new(self, 6)
            }
            #[doc = "Bit 9 - Enable for Pair 0 and 1 When HOFF=0 and HMODE=1"]
            #[inline(always)]
            pub fn ena(&mut self) -> ENA_W<PWMCON0rs> {
                ENA_W::new(self, 9)
            }
            #[doc = "Bit 10 - Set to Enable Interrupts for PWM"]
            #[inline(always)]
            pub fn pwmien(&mut self) -> PWMIEN_W<PWMCON0rs> {
                PWMIEN_W::new(self, 10)
            }
            #[doc = "Bit 11 - Set to Invert PWM1 Output"]
            #[inline(always)]
            pub fn pwm1inv(&mut self) -> PWM1INV_W<PWMCON0rs> {
                PWM1INV_W::new(self, 11)
            }
            #[doc = "Bit 12 - Set to Invert PWM3 Output"]
            #[inline(always)]
            pub fn pwm3inv(&mut self) -> PWM3INV_W<PWMCON0rs> {
                PWM3INV_W::new(self, 12)
            }
            #[doc = "Bit 13 - Set to Invert PWM5 Output"]
            #[inline(always)]
            pub fn pwm5inv(&mut self) -> PWM5INV_W<PWMCON0rs> {
                PWM5INV_W::new(self, 13)
            }
            #[doc = "Bit 14 - Set to Invert PWM7 Output"]
            #[inline(always)]
            pub fn pwm7inv(&mut self) -> PWM7INV_W<PWMCON0rs> {
                PWM7INV_W::new(self, 14)
            }
            #[doc = "Bit 15 - Set to Enable PWM Synchronization from the SYNC Pin"]
            #[inline(always)]
            pub fn sync(&mut self) -> SYNC_W<PWMCON0rs> {
                SYNC_W::new(self, 15)
            }
        }
        #[doc = "PWM Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pwmcon0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwmcon0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWMCON0)"]
        pub struct PWMCON0rs;
        impl crate::RegisterSpec for PWMCON0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwmcon0::R`](R) reader structure"]
        impl crate::Readable for PWMCON0rs {}
        #[doc = "`write(|w| ..)` method takes [`pwmcon0::W`](W) writer structure"]
        impl crate::Writable for PWMCON0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWMCON0 to value 0x12"]
        impl crate::Resettable for PWMCON0rs {
            const RESET_VALUE: u32 = 0x12;
        }
    }
    #[doc = "PWMCON1 (rw) register accessor: ADC Conversion Start and Trip Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pwmcon1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwmcon1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWMCON1)\n\nFor information about available fields see [`mod@pwmcon1`]
module"]
    pub type PWMCON1 = crate::Reg<pwmcon1::PWMCON1rs>;
    #[doc = "ADC Conversion Start and Trip Control Register"]
    pub mod pwmcon1 {
        #[doc = "Register `PWMCON1` reader"]
        pub type R = crate::R<PWMCON1rs>;
        #[doc = "Register `PWMCON1` writer"]
        pub type W = crate::W<PWMCON1rs>;
        #[doc = "Field `REVREG0` reader - Reserved"]
        pub type REVREG0_R = crate::FieldReader;
        #[doc = "Field `TRIP_EN` reader - Set to Enable PWM Trip Functionality"]
        pub type TRIP_EN_R = crate::BitReader;
        #[doc = "Field `TRIP_EN` writer - Set to Enable PWM Trip Functionality"]
        pub type TRIP_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `REVREG1` reader - Reserved. Return 0 on Reads"]
        pub type REVREG1_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 4:5 - Reserved"]
            #[inline(always)]
            pub fn revreg0(&self) -> REVREG0_R {
                REVREG0_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bit 6 - Set to Enable PWM Trip Functionality"]
            #[inline(always)]
            pub fn trip_en(&self) -> TRIP_EN_R {
                TRIP_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bits 8:15 - Reserved. Return 0 on Reads"]
            #[inline(always)]
            pub fn revreg1(&self) -> REVREG1_R {
                REVREG1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWMCON1")
                    .field("revreg0", &self.revreg0())
                    .field("trip_en", &self.trip_en())
                    .field("revreg1", &self.revreg1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 6 - Set to Enable PWM Trip Functionality"]
            #[inline(always)]
            pub fn trip_en(&mut self) -> TRIP_EN_W<PWMCON1rs> {
                TRIP_EN_W::new(self, 6)
            }
        }
        #[doc = "ADC Conversion Start and Trip Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pwmcon1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwmcon1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWMCON1)"]
        pub struct PWMCON1rs;
        impl crate::RegisterSpec for PWMCON1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwmcon1::R`](R) reader structure"]
        impl crate::Readable for PWMCON1rs {}
        #[doc = "`write(|w| ..)` method takes [`pwmcon1::W`](W) writer structure"]
        impl crate::Writable for PWMCON1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWMCON1 to value 0"]
        impl crate::Resettable for PWMCON1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWMICLR (rw) register accessor: Hardware Trip Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pwmiclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwmiclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWMICLR)\n\nFor information about available fields see [`mod@pwmiclr`]
module"]
    pub type PWMICLR = crate::Reg<pwmiclr::PWMICLRrs>;
    #[doc = "Hardware Trip Configuration Register"]
    pub mod pwmiclr {
        #[doc = "Register `PWMICLR` reader"]
        pub type R = crate::R<PWMICLRrs>;
        #[doc = "Register `PWMICLR` writer"]
        pub type W = crate::W<PWMICLRrs>;
        #[doc = "Field `PWM0` reader - Write a 1 to Clear Latched IRQPWM0 Interrupt."]
        pub type PWM0_R = crate::BitReader;
        #[doc = "Field `PWM0` writer - Write a 1 to Clear Latched IRQPWM0 Interrupt."]
        pub type PWM0_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM1` reader - Write a 1 to Clear Latched IRQPWM1 Interrupt."]
        pub type PWM1_R = crate::BitReader;
        #[doc = "Field `PWM1` writer - Write a 1 to Clear Latched IRQPWM1 Interrupt."]
        pub type PWM1_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM2` reader - Write a 1 to Clear Latched IRQPWM2 Interrupt."]
        pub type PWM2_R = crate::BitReader;
        #[doc = "Field `PWM2` writer - Write a 1 to Clear Latched IRQPWM2 Interrupt."]
        pub type PWM2_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM3` reader - Write a 1 to Clear Latched IRQPWM3 Interrupt."]
        pub type PWM3_R = crate::BitReader;
        #[doc = "Field `PWM3` writer - Write a 1 to Clear Latched IRQPWM3 Interrupt."]
        pub type PWM3_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TRIP` reader - Write a 1 to Clear Latched IRQPWMTrip Interrupt."]
        pub type TRIP_R = crate::BitReader;
        #[doc = "Field `TRIP` writer - Write a 1 to Clear Latched IRQPWMTrip Interrupt."]
        pub type TRIP_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `REVREG2` reader - Reserved. Return 0 on Reads"]
        pub type REVREG2_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bit 0 - Write a 1 to Clear Latched IRQPWM0 Interrupt."]
            #[inline(always)]
            pub fn pwm0(&self) -> PWM0_R {
                PWM0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Write a 1 to Clear Latched IRQPWM1 Interrupt."]
            #[inline(always)]
            pub fn pwm1(&self) -> PWM1_R {
                PWM1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Write a 1 to Clear Latched IRQPWM2 Interrupt."]
            #[inline(always)]
            pub fn pwm2(&self) -> PWM2_R {
                PWM2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Write a 1 to Clear Latched IRQPWM3 Interrupt."]
            #[inline(always)]
            pub fn pwm3(&self) -> PWM3_R {
                PWM3_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Write a 1 to Clear Latched IRQPWMTrip Interrupt."]
            #[inline(always)]
            pub fn trip(&self) -> TRIP_R {
                TRIP_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:15 - Reserved. Return 0 on Reads"]
            #[inline(always)]
            pub fn revreg2(&self) -> REVREG2_R {
                REVREG2_R::new(((self.bits >> 5) & 0x07ff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWMICLR")
                    .field("pwm0", &self.pwm0())
                    .field("pwm1", &self.pwm1())
                    .field("pwm2", &self.pwm2())
                    .field("pwm3", &self.pwm3())
                    .field("trip", &self.trip())
                    .field("revreg2", &self.revreg2())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Write a 1 to Clear Latched IRQPWM0 Interrupt."]
            #[inline(always)]
            pub fn pwm0(&mut self) -> PWM0_W<PWMICLRrs> {
                PWM0_W::new(self, 0)
            }
            #[doc = "Bit 1 - Write a 1 to Clear Latched IRQPWM1 Interrupt."]
            #[inline(always)]
            pub fn pwm1(&mut self) -> PWM1_W<PWMICLRrs> {
                PWM1_W::new(self, 1)
            }
            #[doc = "Bit 2 - Write a 1 to Clear Latched IRQPWM2 Interrupt."]
            #[inline(always)]
            pub fn pwm2(&mut self) -> PWM2_W<PWMICLRrs> {
                PWM2_W::new(self, 2)
            }
            #[doc = "Bit 3 - Write a 1 to Clear Latched IRQPWM3 Interrupt."]
            #[inline(always)]
            pub fn pwm3(&mut self) -> PWM3_W<PWMICLRrs> {
                PWM3_W::new(self, 3)
            }
            #[doc = "Bit 4 - Write a 1 to Clear Latched IRQPWMTrip Interrupt."]
            #[inline(always)]
            pub fn trip(&mut self) -> TRIP_W<PWMICLRrs> {
                TRIP_W::new(self, 4)
            }
        }
        #[doc = "Hardware Trip Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pwmiclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwmiclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWMICLR)"]
        pub struct PWMICLRrs;
        impl crate::RegisterSpec for PWMICLRrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwmiclr::R`](R) reader structure"]
        impl crate::Readable for PWMICLRrs {}
        #[doc = "`write(|w| ..)` method takes [`pwmiclr::W`](W) writer structure"]
        impl crate::Writable for PWMICLRrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWMICLR to value 0"]
        impl crate::Resettable for PWMICLRrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM0COM0 (rw) register accessor: Compare Register 0 for PWM0 and PWM1\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm0com0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm0com0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM0COM0)\n\nFor information about available fields see [`mod@pwm0com0`]
module"]
    pub type PWM0COM0 = crate::Reg<pwm0com0::PWM0COM0rs>;
    #[doc = "Compare Register 0 for PWM0 and PWM1"]
    pub mod pwm0com0 {
        #[doc = "Register `PWM0COM0` reader"]
        pub type R = crate::R<PWM0COM0rs>;
        #[doc = "Register `PWM0COM0` writer"]
        pub type W = crate::W<PWM0COM0rs>;
        #[doc = "Field `PWM0COM0` reader - Compare Register 0 for PWM0 and PWM1"]
        pub type PWM0COM0_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM0COM0` writer - Compare Register 0 for PWM0 and PWM1"]
        pub type PWM0COM0_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 0 for PWM0 and PWM1"]
            #[inline(always)]
            pub fn pwm0com0(&self) -> PWM0COM0_R {
                PWM0COM0_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM0COM0")
                    .field("pwm0com0", &self.pwm0com0())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 0 for PWM0 and PWM1"]
            #[inline(always)]
            pub fn pwm0com0(&mut self) -> PWM0COM0_W<PWM0COM0rs> {
                PWM0COM0_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 0 for PWM0 and PWM1\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm0com0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm0com0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM0COM0)"]
        pub struct PWM0COM0rs;
        impl crate::RegisterSpec for PWM0COM0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm0com0::R`](R) reader structure"]
        impl crate::Readable for PWM0COM0rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm0com0::W`](W) writer structure"]
        impl crate::Writable for PWM0COM0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM0COM0 to value 0"]
        impl crate::Resettable for PWM0COM0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM0COM1 (rw) register accessor: Compare Register 1 for PWM0 and PWM1\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm0com1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm0com1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM0COM1)\n\nFor information about available fields see [`mod@pwm0com1`]
module"]
    pub type PWM0COM1 = crate::Reg<pwm0com1::PWM0COM1rs>;
    #[doc = "Compare Register 1 for PWM0 and PWM1"]
    pub mod pwm0com1 {
        #[doc = "Register `PWM0COM1` reader"]
        pub type R = crate::R<PWM0COM1rs>;
        #[doc = "Register `PWM0COM1` writer"]
        pub type W = crate::W<PWM0COM1rs>;
        #[doc = "Field `PWM0COM1` reader - Compare Register 1 for PWM0 and PWM1"]
        pub type PWM0COM1_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM0COM1` writer - Compare Register 1 for PWM0 and PWM1"]
        pub type PWM0COM1_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 1 for PWM0 and PWM1"]
            #[inline(always)]
            pub fn pwm0com1(&self) -> PWM0COM1_R {
                PWM0COM1_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM0COM1")
                    .field("pwm0com1", &self.pwm0com1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 1 for PWM0 and PWM1"]
            #[inline(always)]
            pub fn pwm0com1(&mut self) -> PWM0COM1_W<PWM0COM1rs> {
                PWM0COM1_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 1 for PWM0 and PWM1\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm0com1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm0com1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM0COM1)"]
        pub struct PWM0COM1rs;
        impl crate::RegisterSpec for PWM0COM1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm0com1::R`](R) reader structure"]
        impl crate::Readable for PWM0COM1rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm0com1::W`](W) writer structure"]
        impl crate::Writable for PWM0COM1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM0COM1 to value 0"]
        impl crate::Resettable for PWM0COM1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM0COM2 (rw) register accessor: Compare Register 2 for PWM0 and PWM1\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm0com2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm0com2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM0COM2)\n\nFor information about available fields see [`mod@pwm0com2`]
module"]
    pub type PWM0COM2 = crate::Reg<pwm0com2::PWM0COM2rs>;
    #[doc = "Compare Register 2 for PWM0 and PWM1"]
    pub mod pwm0com2 {
        #[doc = "Register `PWM0COM2` reader"]
        pub type R = crate::R<PWM0COM2rs>;
        #[doc = "Register `PWM0COM2` writer"]
        pub type W = crate::W<PWM0COM2rs>;
        #[doc = "Field `PWM0COM2` reader - Compare Register 2 for PWM0 and PWM1"]
        pub type PWM0COM2_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM0COM2` writer - Compare Register 2 for PWM0 and PWM1"]
        pub type PWM0COM2_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 2 for PWM0 and PWM1"]
            #[inline(always)]
            pub fn pwm0com2(&self) -> PWM0COM2_R {
                PWM0COM2_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM0COM2")
                    .field("pwm0com2", &self.pwm0com2())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 2 for PWM0 and PWM1"]
            #[inline(always)]
            pub fn pwm0com2(&mut self) -> PWM0COM2_W<PWM0COM2rs> {
                PWM0COM2_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 2 for PWM0 and PWM1\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm0com2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm0com2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM0COM2)"]
        pub struct PWM0COM2rs;
        impl crate::RegisterSpec for PWM0COM2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm0com2::R`](R) reader structure"]
        impl crate::Readable for PWM0COM2rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm0com2::W`](W) writer structure"]
        impl crate::Writable for PWM0COM2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM0COM2 to value 0"]
        impl crate::Resettable for PWM0COM2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM0LEN (rw) register accessor: Period Value Register for PWM0 and PWM1\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm0len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm0len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM0LEN)\n\nFor information about available fields see [`mod@pwm0len`]
module"]
    pub type PWM0LEN = crate::Reg<pwm0len::PWM0LENrs>;
    #[doc = "Period Value Register for PWM0 and PWM1"]
    pub mod pwm0len {
        #[doc = "Register `PWM0LEN` reader"]
        pub type R = crate::R<PWM0LENrs>;
        #[doc = "Register `PWM0LEN` writer"]
        pub type W = crate::W<PWM0LENrs>;
        #[doc = "Field `PWM0LEN` reader - Period Value Register for PWM0 and PWM1"]
        pub type PWM0LEN_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM0LEN` writer - Period Value Register for PWM0 and PWM1"]
        pub type PWM0LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Period Value Register for PWM0 and PWM1"]
            #[inline(always)]
            pub fn pwm0len(&self) -> PWM0LEN_R {
                PWM0LEN_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM0LEN")
                    .field("pwm0len", &self.pwm0len())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Period Value Register for PWM0 and PWM1"]
            #[inline(always)]
            pub fn pwm0len(&mut self) -> PWM0LEN_W<PWM0LENrs> {
                PWM0LEN_W::new(self, 0)
            }
        }
        #[doc = "Period Value Register for PWM0 and PWM1\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm0len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm0len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM0LEN)"]
        pub struct PWM0LENrs;
        impl crate::RegisterSpec for PWM0LENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm0len::R`](R) reader structure"]
        impl crate::Readable for PWM0LENrs {}
        #[doc = "`write(|w| ..)` method takes [`pwm0len::W`](W) writer structure"]
        impl crate::Writable for PWM0LENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM0LEN to value 0"]
        impl crate::Resettable for PWM0LENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM1COM0 (rw) register accessor: Compare Register 0 for PWM2 and PWM3\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm1com0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm1com0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM1COM0)\n\nFor information about available fields see [`mod@pwm1com0`]
module"]
    pub type PWM1COM0 = crate::Reg<pwm1com0::PWM1COM0rs>;
    #[doc = "Compare Register 0 for PWM2 and PWM3"]
    pub mod pwm1com0 {
        #[doc = "Register `PWM1COM0` reader"]
        pub type R = crate::R<PWM1COM0rs>;
        #[doc = "Register `PWM1COM0` writer"]
        pub type W = crate::W<PWM1COM0rs>;
        #[doc = "Field `PWM1COM0` reader - Compare Register 0 for PWM2 and PWM3"]
        pub type PWM1COM0_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM1COM0` writer - Compare Register 0 for PWM2 and PWM3"]
        pub type PWM1COM0_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 0 for PWM2 and PWM3"]
            #[inline(always)]
            pub fn pwm1com0(&self) -> PWM1COM0_R {
                PWM1COM0_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM1COM0")
                    .field("pwm1com0", &self.pwm1com0())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 0 for PWM2 and PWM3"]
            #[inline(always)]
            pub fn pwm1com0(&mut self) -> PWM1COM0_W<PWM1COM0rs> {
                PWM1COM0_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 0 for PWM2 and PWM3\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm1com0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm1com0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM1COM0)"]
        pub struct PWM1COM0rs;
        impl crate::RegisterSpec for PWM1COM0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm1com0::R`](R) reader structure"]
        impl crate::Readable for PWM1COM0rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm1com0::W`](W) writer structure"]
        impl crate::Writable for PWM1COM0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM1COM0 to value 0"]
        impl crate::Resettable for PWM1COM0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM1COM1 (rw) register accessor: Compare Register 1 for PWM2 and PWM3\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm1com1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm1com1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM1COM1)\n\nFor information about available fields see [`mod@pwm1com1`]
module"]
    pub type PWM1COM1 = crate::Reg<pwm1com1::PWM1COM1rs>;
    #[doc = "Compare Register 1 for PWM2 and PWM3"]
    pub mod pwm1com1 {
        #[doc = "Register `PWM1COM1` reader"]
        pub type R = crate::R<PWM1COM1rs>;
        #[doc = "Register `PWM1COM1` writer"]
        pub type W = crate::W<PWM1COM1rs>;
        #[doc = "Field `PWM1COM1` reader - Compare Register 1 for PWM2 and PWM3"]
        pub type PWM1COM1_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM1COM1` writer - Compare Register 1 for PWM2 and PWM3"]
        pub type PWM1COM1_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 1 for PWM2 and PWM3"]
            #[inline(always)]
            pub fn pwm1com1(&self) -> PWM1COM1_R {
                PWM1COM1_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM1COM1")
                    .field("pwm1com1", &self.pwm1com1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 1 for PWM2 and PWM3"]
            #[inline(always)]
            pub fn pwm1com1(&mut self) -> PWM1COM1_W<PWM1COM1rs> {
                PWM1COM1_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 1 for PWM2 and PWM3\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm1com1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm1com1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM1COM1)"]
        pub struct PWM1COM1rs;
        impl crate::RegisterSpec for PWM1COM1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm1com1::R`](R) reader structure"]
        impl crate::Readable for PWM1COM1rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm1com1::W`](W) writer structure"]
        impl crate::Writable for PWM1COM1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM1COM1 to value 0"]
        impl crate::Resettable for PWM1COM1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM1COM2 (rw) register accessor: Compare Register 2 for PWM2 and PWM3\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm1com2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm1com2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM1COM2)\n\nFor information about available fields see [`mod@pwm1com2`]
module"]
    pub type PWM1COM2 = crate::Reg<pwm1com2::PWM1COM2rs>;
    #[doc = "Compare Register 2 for PWM2 and PWM3"]
    pub mod pwm1com2 {
        #[doc = "Register `PWM1COM2` reader"]
        pub type R = crate::R<PWM1COM2rs>;
        #[doc = "Register `PWM1COM2` writer"]
        pub type W = crate::W<PWM1COM2rs>;
        #[doc = "Field `PWM1COM2` reader - Compare Register 2 for PWM2 and PWM3"]
        pub type PWM1COM2_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM1COM2` writer - Compare Register 2 for PWM2 and PWM3"]
        pub type PWM1COM2_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 2 for PWM2 and PWM3"]
            #[inline(always)]
            pub fn pwm1com2(&self) -> PWM1COM2_R {
                PWM1COM2_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM1COM2")
                    .field("pwm1com2", &self.pwm1com2())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 2 for PWM2 and PWM3"]
            #[inline(always)]
            pub fn pwm1com2(&mut self) -> PWM1COM2_W<PWM1COM2rs> {
                PWM1COM2_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 2 for PWM2 and PWM3\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm1com2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm1com2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM1COM2)"]
        pub struct PWM1COM2rs;
        impl crate::RegisterSpec for PWM1COM2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm1com2::R`](R) reader structure"]
        impl crate::Readable for PWM1COM2rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm1com2::W`](W) writer structure"]
        impl crate::Writable for PWM1COM2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM1COM2 to value 0"]
        impl crate::Resettable for PWM1COM2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM1LEN (rw) register accessor: Period Value Register for PWM2 and PWM3\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm1len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm1len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM1LEN)\n\nFor information about available fields see [`mod@pwm1len`]
module"]
    pub type PWM1LEN = crate::Reg<pwm1len::PWM1LENrs>;
    #[doc = "Period Value Register for PWM2 and PWM3"]
    pub mod pwm1len {
        #[doc = "Register `PWM1LEN` reader"]
        pub type R = crate::R<PWM1LENrs>;
        #[doc = "Register `PWM1LEN` writer"]
        pub type W = crate::W<PWM1LENrs>;
        #[doc = "Field `PWM1LEN` reader - Period Value Register for PWM2 and PWM3"]
        pub type PWM1LEN_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM1LEN` writer - Period Value Register for PWM2 and PWM3"]
        pub type PWM1LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Period Value Register for PWM2 and PWM3"]
            #[inline(always)]
            pub fn pwm1len(&self) -> PWM1LEN_R {
                PWM1LEN_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM1LEN")
                    .field("pwm1len", &self.pwm1len())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Period Value Register for PWM2 and PWM3"]
            #[inline(always)]
            pub fn pwm1len(&mut self) -> PWM1LEN_W<PWM1LENrs> {
                PWM1LEN_W::new(self, 0)
            }
        }
        #[doc = "Period Value Register for PWM2 and PWM3\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm1len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm1len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM1LEN)"]
        pub struct PWM1LENrs;
        impl crate::RegisterSpec for PWM1LENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm1len::R`](R) reader structure"]
        impl crate::Readable for PWM1LENrs {}
        #[doc = "`write(|w| ..)` method takes [`pwm1len::W`](W) writer structure"]
        impl crate::Writable for PWM1LENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM1LEN to value 0"]
        impl crate::Resettable for PWM1LENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM2COM0 (rw) register accessor: Compare Register 0 for PWM4 and PWM5\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm2com0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm2com0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM2COM0)\n\nFor information about available fields see [`mod@pwm2com0`]
module"]
    pub type PWM2COM0 = crate::Reg<pwm2com0::PWM2COM0rs>;
    #[doc = "Compare Register 0 for PWM4 and PWM5"]
    pub mod pwm2com0 {
        #[doc = "Register `PWM2COM0` reader"]
        pub type R = crate::R<PWM2COM0rs>;
        #[doc = "Register `PWM2COM0` writer"]
        pub type W = crate::W<PWM2COM0rs>;
        #[doc = "Field `PWM2COM0` reader - Compare Register 0 for PWM4 and PWM5"]
        pub type PWM2COM0_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM2COM0` writer - Compare Register 0 for PWM4 and PWM5"]
        pub type PWM2COM0_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 0 for PWM4 and PWM5"]
            #[inline(always)]
            pub fn pwm2com0(&self) -> PWM2COM0_R {
                PWM2COM0_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM2COM0")
                    .field("pwm2com0", &self.pwm2com0())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 0 for PWM4 and PWM5"]
            #[inline(always)]
            pub fn pwm2com0(&mut self) -> PWM2COM0_W<PWM2COM0rs> {
                PWM2COM0_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 0 for PWM4 and PWM5\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm2com0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm2com0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM2COM0)"]
        pub struct PWM2COM0rs;
        impl crate::RegisterSpec for PWM2COM0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm2com0::R`](R) reader structure"]
        impl crate::Readable for PWM2COM0rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm2com0::W`](W) writer structure"]
        impl crate::Writable for PWM2COM0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM2COM0 to value 0"]
        impl crate::Resettable for PWM2COM0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM2COM1 (rw) register accessor: Compare Register 1 for PWM4 and PWM5\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm2com1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm2com1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM2COM1)\n\nFor information about available fields see [`mod@pwm2com1`]
module"]
    pub type PWM2COM1 = crate::Reg<pwm2com1::PWM2COM1rs>;
    #[doc = "Compare Register 1 for PWM4 and PWM5"]
    pub mod pwm2com1 {
        #[doc = "Register `PWM2COM1` reader"]
        pub type R = crate::R<PWM2COM1rs>;
        #[doc = "Register `PWM2COM1` writer"]
        pub type W = crate::W<PWM2COM1rs>;
        #[doc = "Field `PWM2COM1` reader - Compare Register 1 for PWM4 and PWM5"]
        pub type PWM2COM1_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM2COM1` writer - Compare Register 1 for PWM4 and PWM5"]
        pub type PWM2COM1_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 1 for PWM4 and PWM5"]
            #[inline(always)]
            pub fn pwm2com1(&self) -> PWM2COM1_R {
                PWM2COM1_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM2COM1")
                    .field("pwm2com1", &self.pwm2com1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 1 for PWM4 and PWM5"]
            #[inline(always)]
            pub fn pwm2com1(&mut self) -> PWM2COM1_W<PWM2COM1rs> {
                PWM2COM1_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 1 for PWM4 and PWM5\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm2com1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm2com1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM2COM1)"]
        pub struct PWM2COM1rs;
        impl crate::RegisterSpec for PWM2COM1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm2com1::R`](R) reader structure"]
        impl crate::Readable for PWM2COM1rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm2com1::W`](W) writer structure"]
        impl crate::Writable for PWM2COM1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM2COM1 to value 0"]
        impl crate::Resettable for PWM2COM1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM2COM2 (rw) register accessor: Compare Register 2 for PWM4 and PWM5\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm2com2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm2com2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM2COM2)\n\nFor information about available fields see [`mod@pwm2com2`]
module"]
    pub type PWM2COM2 = crate::Reg<pwm2com2::PWM2COM2rs>;
    #[doc = "Compare Register 2 for PWM4 and PWM5"]
    pub mod pwm2com2 {
        #[doc = "Register `PWM2COM2` reader"]
        pub type R = crate::R<PWM2COM2rs>;
        #[doc = "Register `PWM2COM2` writer"]
        pub type W = crate::W<PWM2COM2rs>;
        #[doc = "Field `PWM2COM2` reader - Compare Register 2 for PWM4 and PWM5"]
        pub type PWM2COM2_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM2COM2` writer - Compare Register 2 for PWM4 and PWM5"]
        pub type PWM2COM2_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 2 for PWM4 and PWM5"]
            #[inline(always)]
            pub fn pwm2com2(&self) -> PWM2COM2_R {
                PWM2COM2_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM2COM2")
                    .field("pwm2com2", &self.pwm2com2())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 2 for PWM4 and PWM5"]
            #[inline(always)]
            pub fn pwm2com2(&mut self) -> PWM2COM2_W<PWM2COM2rs> {
                PWM2COM2_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 2 for PWM4 and PWM5\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm2com2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm2com2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM2COM2)"]
        pub struct PWM2COM2rs;
        impl crate::RegisterSpec for PWM2COM2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm2com2::R`](R) reader structure"]
        impl crate::Readable for PWM2COM2rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm2com2::W`](W) writer structure"]
        impl crate::Writable for PWM2COM2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM2COM2 to value 0"]
        impl crate::Resettable for PWM2COM2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM2LEN (rw) register accessor: Period Value Register for PWM4 and PWM5\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm2len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm2len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM2LEN)\n\nFor information about available fields see [`mod@pwm2len`]
module"]
    pub type PWM2LEN = crate::Reg<pwm2len::PWM2LENrs>;
    #[doc = "Period Value Register for PWM4 and PWM5"]
    pub mod pwm2len {
        #[doc = "Register `PWM2LEN` reader"]
        pub type R = crate::R<PWM2LENrs>;
        #[doc = "Register `PWM2LEN` writer"]
        pub type W = crate::W<PWM2LENrs>;
        #[doc = "Field `PWM2LEN` reader - Period Value Register for PWM4 and PWM5"]
        pub type PWM2LEN_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM2LEN` writer - Period Value Register for PWM4 and PWM5"]
        pub type PWM2LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Period Value Register for PWM4 and PWM5"]
            #[inline(always)]
            pub fn pwm2len(&self) -> PWM2LEN_R {
                PWM2LEN_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM2LEN")
                    .field("pwm2len", &self.pwm2len())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Period Value Register for PWM4 and PWM5"]
            #[inline(always)]
            pub fn pwm2len(&mut self) -> PWM2LEN_W<PWM2LENrs> {
                PWM2LEN_W::new(self, 0)
            }
        }
        #[doc = "Period Value Register for PWM4 and PWM5\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm2len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm2len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM2LEN)"]
        pub struct PWM2LENrs;
        impl crate::RegisterSpec for PWM2LENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm2len::R`](R) reader structure"]
        impl crate::Readable for PWM2LENrs {}
        #[doc = "`write(|w| ..)` method takes [`pwm2len::W`](W) writer structure"]
        impl crate::Writable for PWM2LENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM2LEN to value 0"]
        impl crate::Resettable for PWM2LENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM3COM0 (rw) register accessor: Compare Register 0 for PWM6 and PWM7\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm3com0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm3com0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM3COM0)\n\nFor information about available fields see [`mod@pwm3com0`]
module"]
    pub type PWM3COM0 = crate::Reg<pwm3com0::PWM3COM0rs>;
    #[doc = "Compare Register 0 for PWM6 and PWM7"]
    pub mod pwm3com0 {
        #[doc = "Register `PWM3COM0` reader"]
        pub type R = crate::R<PWM3COM0rs>;
        #[doc = "Register `PWM3COM0` writer"]
        pub type W = crate::W<PWM3COM0rs>;
        #[doc = "Field `PWM3COM0` reader - Compare Register 0 for PWM6 and PWM7"]
        pub type PWM3COM0_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM3COM0` writer - Compare Register 0 for PWM6 and PWM7"]
        pub type PWM3COM0_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 0 for PWM6 and PWM7"]
            #[inline(always)]
            pub fn pwm3com0(&self) -> PWM3COM0_R {
                PWM3COM0_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM3COM0")
                    .field("pwm3com0", &self.pwm3com0())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 0 for PWM6 and PWM7"]
            #[inline(always)]
            pub fn pwm3com0(&mut self) -> PWM3COM0_W<PWM3COM0rs> {
                PWM3COM0_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 0 for PWM6 and PWM7\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm3com0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm3com0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM3COM0)"]
        pub struct PWM3COM0rs;
        impl crate::RegisterSpec for PWM3COM0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm3com0::R`](R) reader structure"]
        impl crate::Readable for PWM3COM0rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm3com0::W`](W) writer structure"]
        impl crate::Writable for PWM3COM0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM3COM0 to value 0"]
        impl crate::Resettable for PWM3COM0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM3COM1 (rw) register accessor: Compare Register 1 for PWM6 and PWM7\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm3com1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm3com1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM3COM1)\n\nFor information about available fields see [`mod@pwm3com1`]
module"]
    pub type PWM3COM1 = crate::Reg<pwm3com1::PWM3COM1rs>;
    #[doc = "Compare Register 1 for PWM6 and PWM7"]
    pub mod pwm3com1 {
        #[doc = "Register `PWM3COM1` reader"]
        pub type R = crate::R<PWM3COM1rs>;
        #[doc = "Register `PWM3COM1` writer"]
        pub type W = crate::W<PWM3COM1rs>;
        #[doc = "Field `PWM3COM1` reader - Compare Register 1 for PWM6 and PWM7"]
        pub type PWM3COM1_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM3COM1` writer - Compare Register 1 for PWM6 and PWM7"]
        pub type PWM3COM1_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 1 for PWM6 and PWM7"]
            #[inline(always)]
            pub fn pwm3com1(&self) -> PWM3COM1_R {
                PWM3COM1_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM3COM1")
                    .field("pwm3com1", &self.pwm3com1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 1 for PWM6 and PWM7"]
            #[inline(always)]
            pub fn pwm3com1(&mut self) -> PWM3COM1_W<PWM3COM1rs> {
                PWM3COM1_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 1 for PWM6 and PWM7\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm3com1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm3com1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM3COM1)"]
        pub struct PWM3COM1rs;
        impl crate::RegisterSpec for PWM3COM1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm3com1::R`](R) reader structure"]
        impl crate::Readable for PWM3COM1rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm3com1::W`](W) writer structure"]
        impl crate::Writable for PWM3COM1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM3COM1 to value 0"]
        impl crate::Resettable for PWM3COM1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM3COM2 (rw) register accessor: Compare Register 2 for PWM6 and PWM7\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm3com2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm3com2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM3COM2)\n\nFor information about available fields see [`mod@pwm3com2`]
module"]
    pub type PWM3COM2 = crate::Reg<pwm3com2::PWM3COM2rs>;
    #[doc = "Compare Register 2 for PWM6 and PWM7"]
    pub mod pwm3com2 {
        #[doc = "Register `PWM3COM2` reader"]
        pub type R = crate::R<PWM3COM2rs>;
        #[doc = "Register `PWM3COM2` writer"]
        pub type W = crate::W<PWM3COM2rs>;
        #[doc = "Field `PWM3COM2` reader - Compare Register 2 for PWM6 and PWM7"]
        pub type PWM3COM2_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM3COM2` writer - Compare Register 2 for PWM6 and PWM7"]
        pub type PWM3COM2_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Compare Register 2 for PWM6 and PWM7"]
            #[inline(always)]
            pub fn pwm3com2(&self) -> PWM3COM2_R {
                PWM3COM2_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM3COM2")
                    .field("pwm3com2", &self.pwm3com2())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Register 2 for PWM6 and PWM7"]
            #[inline(always)]
            pub fn pwm3com2(&mut self) -> PWM3COM2_W<PWM3COM2rs> {
                PWM3COM2_W::new(self, 0)
            }
        }
        #[doc = "Compare Register 2 for PWM6 and PWM7\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm3com2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm3com2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM3COM2)"]
        pub struct PWM3COM2rs;
        impl crate::RegisterSpec for PWM3COM2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm3com2::R`](R) reader structure"]
        impl crate::Readable for PWM3COM2rs {}
        #[doc = "`write(|w| ..)` method takes [`pwm3com2::W`](W) writer structure"]
        impl crate::Writable for PWM3COM2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM3COM2 to value 0"]
        impl crate::Resettable for PWM3COM2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM3LEN (rw) register accessor: Period Value Register for PWM6 and PWM7\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm3len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm3len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM3LEN)\n\nFor information about available fields see [`mod@pwm3len`]
module"]
    pub type PWM3LEN = crate::Reg<pwm3len::PWM3LENrs>;
    #[doc = "Period Value Register for PWM6 and PWM7"]
    pub mod pwm3len {
        #[doc = "Register `PWM3LEN` reader"]
        pub type R = crate::R<PWM3LENrs>;
        #[doc = "Register `PWM3LEN` writer"]
        pub type W = crate::W<PWM3LENrs>;
        #[doc = "Field `PWM3LEN` reader - Period Value Register for PWM6 and PWM7"]
        pub type PWM3LEN_R = crate::FieldReader<u16>;
        #[doc = "Field `PWM3LEN` writer - Period Value Register for PWM6 and PWM7"]
        pub type PWM3LEN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Period Value Register for PWM6 and PWM7"]
            #[inline(always)]
            pub fn pwm3len(&self) -> PWM3LEN_R {
                PWM3LEN_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PWM3LEN")
                    .field("pwm3len", &self.pwm3len())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Period Value Register for PWM6 and PWM7"]
            #[inline(always)]
            pub fn pwm3len(&mut self) -> PWM3LEN_W<PWM3LENrs> {
                PWM3LEN_W::new(self, 0)
            }
        }
        #[doc = "Period Value Register for PWM6 and PWM7\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm3len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm3len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PWM:PWM3LEN)"]
        pub struct PWM3LENrs;
        impl crate::RegisterSpec for PWM3LENrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm3len::R`](R) reader structure"]
        impl crate::Readable for PWM3LENrs {}
        #[doc = "`write(|w| ..)` method takes [`pwm3len::W`](W) writer structure"]
        impl crate::Writable for PWM3LENrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM3LEN to value 0"]
        impl crate::Resettable for PWM3LENrs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM)"]
pub struct SRAM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SRAM {}
impl SRAM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sram::RegisterBlock = 0x4006_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SRAM {
    type Target = sram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SRAM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SRAM").finish()
    }
}
#[doc = "Unknown"]
pub mod sram {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        sramcon: SRAMCON,
        _reserved1: [u8; 0x08],
        sramecccon: SRAMECCCON,
        srameccsta: SRAMECCSTA,
        sramecca0: SRAMECCA0,
        srameccd0: SRAMECCD0,
        srameccp0: SRAMECCP0,
        sramecca1: SRAMECCA1,
        srameccd1: SRAMECCD1,
        srameccp1: SRAMECCP1,
        sramecca2: SRAMECCA2,
        srameccd2: SRAMECCD2,
        srameccp2: SRAMECCP2,
    }
    impl RegisterBlock {
        #[doc = "0x00 - SRAM Control Register"]
        #[inline(always)]
        pub const fn sramcon(&self) -> &SRAMCON {
            &self.sramcon
        }
        #[doc = "0x0c - SRAM ECC Control Register"]
        #[inline(always)]
        pub const fn sramecccon(&self) -> &SRAMECCCON {
            &self.sramecccon
        }
        #[doc = "0x10 - SRAM ECC Status Register"]
        #[inline(always)]
        pub const fn srameccsta(&self) -> &SRAMECCSTA {
            &self.srameccsta
        }
        #[doc = "0x14 - SRAM0 ECC Error Address Register"]
        #[inline(always)]
        pub const fn sramecca0(&self) -> &SRAMECCA0 {
            &self.sramecca0
        }
        #[doc = "0x18 - SRAM0 ECC Error Data Register"]
        #[inline(always)]
        pub const fn srameccd0(&self) -> &SRAMECCD0 {
            &self.srameccd0
        }
        #[doc = "0x1c - SRAM0 ECC Error Parity Register"]
        #[inline(always)]
        pub const fn srameccp0(&self) -> &SRAMECCP0 {
            &self.srameccp0
        }
        #[doc = "0x20 - SRAM1 ECC Error Address Register"]
        #[inline(always)]
        pub const fn sramecca1(&self) -> &SRAMECCA1 {
            &self.sramecca1
        }
        #[doc = "0x24 - SRAM1 ECC Error Data Register"]
        #[inline(always)]
        pub const fn srameccd1(&self) -> &SRAMECCD1 {
            &self.srameccd1
        }
        #[doc = "0x28 - SRAM1 ECC Error Parity Register"]
        #[inline(always)]
        pub const fn srameccp1(&self) -> &SRAMECCP1 {
            &self.srameccp1
        }
        #[doc = "0x2c - SRAM2 ECC Error Address Register"]
        #[inline(always)]
        pub const fn sramecca2(&self) -> &SRAMECCA2 {
            &self.sramecca2
        }
        #[doc = "0x30 - SRAM2 ECC Error Data Register"]
        #[inline(always)]
        pub const fn srameccd2(&self) -> &SRAMECCD2 {
            &self.srameccd2
        }
        #[doc = "0x34 - SRAM2 ECC Error Parity Register"]
        #[inline(always)]
        pub const fn srameccp2(&self) -> &SRAMECCP2 {
            &self.srameccp2
        }
    }
    #[doc = "SRAMCON (rw) register accessor: SRAM Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMCON)\n\nFor information about available fields see [`mod@sramcon`]
module"]
    pub type SRAMCON = crate::Reg<sramcon::SRAMCONrs>;
    #[doc = "SRAM Control Register"]
    pub mod sramcon {
        #[doc = "Register `SRAMCON` reader"]
        pub type R = crate::R<SRAMCONrs>;
        #[doc = "Register `SRAMCON` writer"]
        pub type W = crate::W<SRAMCONrs>;
        #[doc = "Using SRAM0 as Instruction SRAM\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum REMAP {
            #[doc = "0: Using as Code SRAM"]
            Codram = 0,
            #[doc = "1: Using as System SRAM"]
            Sysram = 1,
        }
        impl From<REMAP> for bool {
            #[inline(always)]
            fn from(variant: REMAP) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `REMAP` reader - Using SRAM0 as Instruction SRAM"]
        pub type REMAP_R = crate::BitReader<REMAP>;
        impl REMAP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> REMAP {
                match self.bits {
                    false => REMAP::Codram,
                    true => REMAP::Sysram,
                }
            }
            #[doc = "Using as Code SRAM"]
            #[inline(always)]
            pub fn is_codram(&self) -> bool {
                *self == REMAP::Codram
            }
            #[doc = "Using as System SRAM"]
            #[inline(always)]
            pub fn is_sysram(&self) -> bool {
                *self == REMAP::Sysram
            }
        }
        #[doc = "Field `REMAP` writer - Using SRAM0 as Instruction SRAM"]
        pub type REMAP_W<'a, REG> = crate::BitWriter<'a, REG, REMAP>;
        impl<'a, REG> REMAP_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Using as Code SRAM"]
            #[inline(always)]
            pub fn codram(self) -> &'a mut crate::W<REG> {
                self.variant(REMAP::Codram)
            }
            #[doc = "Using as System SRAM"]
            #[inline(always)]
            pub fn sysram(self) -> &'a mut crate::W<REG> {
                self.variant(REMAP::Sysram)
            }
        }
        #[doc = "Use Cache as a Part of SRAM0\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CSEL {
            #[doc = "0: Cache not as SRAM"]
            Ncas = 0,
            #[doc = "1: Cache as SRAM"]
            Cas = 1,
        }
        impl From<CSEL> for bool {
            #[inline(always)]
            fn from(variant: CSEL) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CSEL` reader - Use Cache as a Part of SRAM0"]
        pub type CSEL_R = crate::BitReader<CSEL>;
        impl CSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CSEL {
                match self.bits {
                    false => CSEL::Ncas,
                    true => CSEL::Cas,
                }
            }
            #[doc = "Cache not as SRAM"]
            #[inline(always)]
            pub fn is_ncas(&self) -> bool {
                *self == CSEL::Ncas
            }
            #[doc = "Cache as SRAM"]
            #[inline(always)]
            pub fn is_cas(&self) -> bool {
                *self == CSEL::Cas
            }
        }
        #[doc = "Field `CSEL` writer - Use Cache as a Part of SRAM0"]
        pub type CSEL_W<'a, REG> = crate::BitWriter<'a, REG, CSEL>;
        impl<'a, REG> CSEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Cache not as SRAM"]
            #[inline(always)]
            pub fn ncas(self) -> &'a mut crate::W<REG> {
                self.variant(CSEL::Ncas)
            }
            #[doc = "Cache as SRAM"]
            #[inline(always)]
            pub fn cas(self) -> &'a mut crate::W<REG> {
                self.variant(CSEL::Cas)
            }
        }
        impl R {
            #[doc = "Bit 0 - Using SRAM0 as Instruction SRAM"]
            #[inline(always)]
            pub fn remap(&self) -> REMAP_R {
                REMAP_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Use Cache as a Part of SRAM0"]
            #[inline(always)]
            pub fn csel(&self) -> CSEL_R {
                CSEL_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMCON")
                    .field("remap", &self.remap())
                    .field("csel", &self.csel())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Using SRAM0 as Instruction SRAM"]
            #[inline(always)]
            pub fn remap(&mut self) -> REMAP_W<SRAMCONrs> {
                REMAP_W::new(self, 0)
            }
            #[doc = "Bit 1 - Use Cache as a Part of SRAM0"]
            #[inline(always)]
            pub fn csel(&mut self) -> CSEL_W<SRAMCONrs> {
                CSEL_W::new(self, 1)
            }
        }
        #[doc = "SRAM Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMCON)"]
        pub struct SRAMCONrs;
        impl crate::RegisterSpec for SRAMCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sramcon::R`](R) reader structure"]
        impl crate::Readable for SRAMCONrs {}
        #[doc = "`write(|w| ..)` method takes [`sramcon::W`](W) writer structure"]
        impl crate::Writable for SRAMCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMCON to value 0x02"]
        impl crate::Resettable for SRAMCONrs {
            const RESET_VALUE: u32 = 0x02;
        }
    }
    #[doc = "SRAMECCCON (rw) register accessor: SRAM ECC Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramecccon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramecccon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCCON)\n\nFor information about available fields see [`mod@sramecccon`]
module"]
    pub type SRAMECCCON = crate::Reg<sramecccon::SRAMECCCONrs>;
    #[doc = "SRAM ECC Control Register"]
    pub mod sramecccon {
        #[doc = "Register `SRAMECCCON` reader"]
        pub type R = crate::R<SRAMECCCONrs>;
        #[doc = "Register `SRAMECCCON` writer"]
        pub type W = crate::W<SRAMECCCONrs>;
        #[doc = "ECC Check Enable\n\nValue on reset: 7"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EN {
            #[doc = "0: None SRAM ECC Enable"]
            Enna = 0,
            #[doc = "1: SRAM0 ECC Enable"]
            En0 = 1,
            #[doc = "2: SRAM1 ECC Enable"]
            En1 = 2,
            #[doc = "3: SRAM0 and SRAM1 ECC Enable"]
            En01 = 3,
            #[doc = "4: SRAM2 ECC Enable"]
            En2 = 4,
            #[doc = "5: SRAM0 and SRAM2 ECC Enable"]
            En02 = 5,
            #[doc = "6: SRAM1 and SRAM2 ECC Enable"]
            En12 = 6,
            #[doc = "7: SRAM0 and SRAM1 and SRAM2 ECC Enable"]
            En012 = 7,
        }
        impl From<EN> for u8 {
            #[inline(always)]
            fn from(variant: EN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for EN {
            type Ux = u8;
        }
        impl crate::IsEnum for EN {}
        #[doc = "Field `EN` reader - ECC Check Enable"]
        pub type EN_R = crate::FieldReader<EN>;
        impl EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> EN {
                match self.bits {
                    0 => EN::Enna,
                    1 => EN::En0,
                    2 => EN::En1,
                    3 => EN::En01,
                    4 => EN::En2,
                    5 => EN::En02,
                    6 => EN::En12,
                    7 => EN::En012,
                    _ => unreachable!(),
                }
            }
            #[doc = "None SRAM ECC Enable"]
            #[inline(always)]
            pub fn is_enna(&self) -> bool {
                *self == EN::Enna
            }
            #[doc = "SRAM0 ECC Enable"]
            #[inline(always)]
            pub fn is_en0(&self) -> bool {
                *self == EN::En0
            }
            #[doc = "SRAM1 ECC Enable"]
            #[inline(always)]
            pub fn is_en1(&self) -> bool {
                *self == EN::En1
            }
            #[doc = "SRAM0 and SRAM1 ECC Enable"]
            #[inline(always)]
            pub fn is_en01(&self) -> bool {
                *self == EN::En01
            }
            #[doc = "SRAM2 ECC Enable"]
            #[inline(always)]
            pub fn is_en2(&self) -> bool {
                *self == EN::En2
            }
            #[doc = "SRAM0 and SRAM2 ECC Enable"]
            #[inline(always)]
            pub fn is_en02(&self) -> bool {
                *self == EN::En02
            }
            #[doc = "SRAM1 and SRAM2 ECC Enable"]
            #[inline(always)]
            pub fn is_en12(&self) -> bool {
                *self == EN::En12
            }
            #[doc = "SRAM0 and SRAM1 and SRAM2 ECC Enable"]
            #[inline(always)]
            pub fn is_en012(&self) -> bool {
                *self == EN::En012
            }
        }
        #[doc = "Field `EN` writer - ECC Check Enable"]
        pub type EN_W<'a, REG> = crate::FieldWriter<'a, REG, 3, EN, crate::Safe>;
        impl<'a, REG> EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "None SRAM ECC Enable"]
            #[inline(always)]
            pub fn enna(self) -> &'a mut crate::W<REG> {
                self.variant(EN::Enna)
            }
            #[doc = "SRAM0 ECC Enable"]
            #[inline(always)]
            pub fn en0(self) -> &'a mut crate::W<REG> {
                self.variant(EN::En0)
            }
            #[doc = "SRAM1 ECC Enable"]
            #[inline(always)]
            pub fn en1(self) -> &'a mut crate::W<REG> {
                self.variant(EN::En1)
            }
            #[doc = "SRAM0 and SRAM1 ECC Enable"]
            #[inline(always)]
            pub fn en01(self) -> &'a mut crate::W<REG> {
                self.variant(EN::En01)
            }
            #[doc = "SRAM2 ECC Enable"]
            #[inline(always)]
            pub fn en2(self) -> &'a mut crate::W<REG> {
                self.variant(EN::En2)
            }
            #[doc = "SRAM0 and SRAM2 ECC Enable"]
            #[inline(always)]
            pub fn en02(self) -> &'a mut crate::W<REG> {
                self.variant(EN::En02)
            }
            #[doc = "SRAM1 and SRAM2 ECC Enable"]
            #[inline(always)]
            pub fn en12(self) -> &'a mut crate::W<REG> {
                self.variant(EN::En12)
            }
            #[doc = "SRAM0 and SRAM1 and SRAM2 ECC Enable"]
            #[inline(always)]
            pub fn en012(self) -> &'a mut crate::W<REG> {
                self.variant(EN::En012)
            }
        }
        #[doc = "ECC AHB Bus Error Response Type\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum BUSERRTYPE {
            #[doc = "0: No Error Report"]
            Noerr = 0,
            #[doc = "1: 2 Bits Error Report"]
            Err2b = 1,
            #[doc = "2: 1 Bit Error Report"]
            Err1b = 2,
            #[doc = "3: 1 or 2 Bits Error Report"]
            Alerr = 3,
        }
        impl From<BUSERRTYPE> for u8 {
            #[inline(always)]
            fn from(variant: BUSERRTYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for BUSERRTYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for BUSERRTYPE {}
        #[doc = "Field `BUSERRTYPE` reader - ECC AHB Bus Error Response Type"]
        pub type BUSERRTYPE_R = crate::FieldReader<BUSERRTYPE>;
        impl BUSERRTYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BUSERRTYPE {
                match self.bits {
                    0 => BUSERRTYPE::Noerr,
                    1 => BUSERRTYPE::Err2b,
                    2 => BUSERRTYPE::Err1b,
                    3 => BUSERRTYPE::Alerr,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error Report"]
            #[inline(always)]
            pub fn is_noerr(&self) -> bool {
                *self == BUSERRTYPE::Noerr
            }
            #[doc = "2 Bits Error Report"]
            #[inline(always)]
            pub fn is_err2b(&self) -> bool {
                *self == BUSERRTYPE::Err2b
            }
            #[doc = "1 Bit Error Report"]
            #[inline(always)]
            pub fn is_err1b(&self) -> bool {
                *self == BUSERRTYPE::Err1b
            }
            #[doc = "1 or 2 Bits Error Report"]
            #[inline(always)]
            pub fn is_alerr(&self) -> bool {
                *self == BUSERRTYPE::Alerr
            }
        }
        #[doc = "Field `BUSERRTYPE` writer - ECC AHB Bus Error Response Type"]
        pub type BUSERRTYPE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, BUSERRTYPE, crate::Safe>;
        impl<'a, REG> BUSERRTYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "No Error Report"]
            #[inline(always)]
            pub fn noerr(self) -> &'a mut crate::W<REG> {
                self.variant(BUSERRTYPE::Noerr)
            }
            #[doc = "2 Bits Error Report"]
            #[inline(always)]
            pub fn err2b(self) -> &'a mut crate::W<REG> {
                self.variant(BUSERRTYPE::Err2b)
            }
            #[doc = "1 Bit Error Report"]
            #[inline(always)]
            pub fn err1b(self) -> &'a mut crate::W<REG> {
                self.variant(BUSERRTYPE::Err1b)
            }
            #[doc = "1 or 2 Bits Error Report"]
            #[inline(always)]
            pub fn alerr(self) -> &'a mut crate::W<REG> {
                self.variant(BUSERRTYPE::Alerr)
            }
        }
        #[doc = "ECC Interrupt Error Response Type\n\nValue on reset: 2"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum INTERRTYPE {
            #[doc = "0: No Error Report"]
            Noerr = 0,
            #[doc = "1: 2 Bits Error Report"]
            Err2b = 1,
            #[doc = "2: 1 Bit Error Report"]
            Err1b = 2,
            #[doc = "3: 1 or 2 Bits Error Report"]
            Alerr = 3,
        }
        impl From<INTERRTYPE> for u8 {
            #[inline(always)]
            fn from(variant: INTERRTYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for INTERRTYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for INTERRTYPE {}
        #[doc = "Field `INTERRTYPE` reader - ECC Interrupt Error Response Type"]
        pub type INTERRTYPE_R = crate::FieldReader<INTERRTYPE>;
        impl INTERRTYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> INTERRTYPE {
                match self.bits {
                    0 => INTERRTYPE::Noerr,
                    1 => INTERRTYPE::Err2b,
                    2 => INTERRTYPE::Err1b,
                    3 => INTERRTYPE::Alerr,
                    _ => unreachable!(),
                }
            }
            #[doc = "No Error Report"]
            #[inline(always)]
            pub fn is_noerr(&self) -> bool {
                *self == INTERRTYPE::Noerr
            }
            #[doc = "2 Bits Error Report"]
            #[inline(always)]
            pub fn is_err2b(&self) -> bool {
                *self == INTERRTYPE::Err2b
            }
            #[doc = "1 Bit Error Report"]
            #[inline(always)]
            pub fn is_err1b(&self) -> bool {
                *self == INTERRTYPE::Err1b
            }
            #[doc = "1 or 2 Bits Error Report"]
            #[inline(always)]
            pub fn is_alerr(&self) -> bool {
                *self == INTERRTYPE::Alerr
            }
        }
        #[doc = "Field `INTERRTYPE` writer - ECC Interrupt Error Response Type"]
        pub type INTERRTYPE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, INTERRTYPE, crate::Safe>;
        impl<'a, REG> INTERRTYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "No Error Report"]
            #[inline(always)]
            pub fn noerr(self) -> &'a mut crate::W<REG> {
                self.variant(INTERRTYPE::Noerr)
            }
            #[doc = "2 Bits Error Report"]
            #[inline(always)]
            pub fn err2b(self) -> &'a mut crate::W<REG> {
                self.variant(INTERRTYPE::Err2b)
            }
            #[doc = "1 Bit Error Report"]
            #[inline(always)]
            pub fn err1b(self) -> &'a mut crate::W<REG> {
                self.variant(INTERRTYPE::Err1b)
            }
            #[doc = "1 or 2 Bits Error Report"]
            #[inline(always)]
            pub fn alerr(self) -> &'a mut crate::W<REG> {
                self.variant(INTERRTYPE::Alerr)
            }
        }
        #[doc = "ECC Error Address and Data Record Type\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum RECERRTYPE {
            #[doc = "0: Return Current Error Address and Data Information"]
            Curerr = 0,
            #[doc = "1: Return Stored Error Address and Data Information"]
            Strerr0 = 1,
            #[doc = "2: Return Stored Error Address and Data Information"]
            Strerr12 = 2,
            #[doc = "3: Return Stored Error Address and Data Information"]
            Strerr13 = 3,
        }
        impl From<RECERRTYPE> for u8 {
            #[inline(always)]
            fn from(variant: RECERRTYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for RECERRTYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for RECERRTYPE {}
        #[doc = "Field `RECERRTYPE` reader - ECC Error Address and Data Record Type"]
        pub type RECERRTYPE_R = crate::FieldReader<RECERRTYPE>;
        impl RECERRTYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RECERRTYPE {
                match self.bits {
                    0 => RECERRTYPE::Curerr,
                    1 => RECERRTYPE::Strerr0,
                    2 => RECERRTYPE::Strerr12,
                    3 => RECERRTYPE::Strerr13,
                    _ => unreachable!(),
                }
            }
            #[doc = "Return Current Error Address and Data Information"]
            #[inline(always)]
            pub fn is_curerr(&self) -> bool {
                *self == RECERRTYPE::Curerr
            }
            #[doc = "Return Stored Error Address and Data Information"]
            #[inline(always)]
            pub fn is_strerr0(&self) -> bool {
                *self == RECERRTYPE::Strerr0
            }
            #[doc = "Return Stored Error Address and Data Information"]
            #[inline(always)]
            pub fn is_strerr12(&self) -> bool {
                *self == RECERRTYPE::Strerr12
            }
            #[doc = "Return Stored Error Address and Data Information"]
            #[inline(always)]
            pub fn is_strerr13(&self) -> bool {
                *self == RECERRTYPE::Strerr13
            }
        }
        #[doc = "Field `RECERRTYPE` writer - ECC Error Address and Data Record Type"]
        pub type RECERRTYPE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, RECERRTYPE, crate::Safe>;
        impl<'a, REG> RECERRTYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Return Current Error Address and Data Information"]
            #[inline(always)]
            pub fn curerr(self) -> &'a mut crate::W<REG> {
                self.variant(RECERRTYPE::Curerr)
            }
            #[doc = "Return Stored Error Address and Data Information"]
            #[inline(always)]
            pub fn strerr0(self) -> &'a mut crate::W<REG> {
                self.variant(RECERRTYPE::Strerr0)
            }
            #[doc = "Return Stored Error Address and Data Information"]
            #[inline(always)]
            pub fn strerr12(self) -> &'a mut crate::W<REG> {
                self.variant(RECERRTYPE::Strerr12)
            }
            #[doc = "Return Stored Error Address and Data Information"]
            #[inline(always)]
            pub fn strerr13(self) -> &'a mut crate::W<REG> {
                self.variant(RECERRTYPE::Strerr13)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - ECC Check Enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bits 3:4 - ECC AHB Bus Error Response Type"]
            #[inline(always)]
            pub fn buserrtype(&self) -> BUSERRTYPE_R {
                BUSERRTYPE_R::new(((self.bits >> 3) & 3) as u8)
            }
            #[doc = "Bits 5:6 - ECC Interrupt Error Response Type"]
            #[inline(always)]
            pub fn interrtype(&self) -> INTERRTYPE_R {
                INTERRTYPE_R::new(((self.bits >> 5) & 3) as u8)
            }
            #[doc = "Bits 7:8 - ECC Error Address and Data Record Type"]
            #[inline(always)]
            pub fn recerrtype(&self) -> RECERRTYPE_R {
                RECERRTYPE_R::new(((self.bits >> 7) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCCON")
                    .field("en", &self.en())
                    .field("buserrtype", &self.buserrtype())
                    .field("interrtype", &self.interrtype())
                    .field("recerrtype", &self.recerrtype())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:2 - ECC Check Enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<SRAMECCCONrs> {
                EN_W::new(self, 0)
            }
            #[doc = "Bits 3:4 - ECC AHB Bus Error Response Type"]
            #[inline(always)]
            pub fn buserrtype(&mut self) -> BUSERRTYPE_W<SRAMECCCONrs> {
                BUSERRTYPE_W::new(self, 3)
            }
            #[doc = "Bits 5:6 - ECC Interrupt Error Response Type"]
            #[inline(always)]
            pub fn interrtype(&mut self) -> INTERRTYPE_W<SRAMECCCONrs> {
                INTERRTYPE_W::new(self, 5)
            }
            #[doc = "Bits 7:8 - ECC Error Address and Data Record Type"]
            #[inline(always)]
            pub fn recerrtype(&mut self) -> RECERRTYPE_W<SRAMECCCONrs> {
                RECERRTYPE_W::new(self, 7)
            }
        }
        #[doc = "SRAM ECC Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramecccon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramecccon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCCON)"]
        pub struct SRAMECCCONrs;
        impl crate::RegisterSpec for SRAMECCCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sramecccon::R`](R) reader structure"]
        impl crate::Readable for SRAMECCCONrs {}
        #[doc = "`write(|w| ..)` method takes [`sramecccon::W`](W) writer structure"]
        impl crate::Writable for SRAMECCCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCCON to value 0xcf"]
        impl crate::Resettable for SRAMECCCONrs {
            const RESET_VALUE: u32 = 0xcf;
        }
    }
    #[doc = "SRAMECCSTA (rw) register accessor: SRAM ECC Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccsta::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccsta::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCSTA)\n\nFor information about available fields see [`mod@srameccsta`]
module"]
    pub type SRAMECCSTA = crate::Reg<srameccsta::SRAMECCSTArs>;
    #[doc = "SRAM ECC Status Register"]
    pub mod srameccsta {
        #[doc = "Register `SRAMECCSTA` reader"]
        pub type R = crate::R<SRAMECCSTArs>;
        #[doc = "Register `SRAMECCSTA` writer"]
        pub type W = crate::W<SRAMECCSTArs>;
        #[doc = "Field `S0ERR2B` reader - SRAM0 ECC 2 Bits Error"]
        pub type S0ERR2B_R = crate::BitReader;
        #[doc = "Field `S0ERR1B` reader - SRAM0 ECC 1 Bit Error"]
        pub type S0ERR1B_R = crate::BitReader;
        #[doc = "Field `S1ERR2B` reader - SRAM1 ECC 2 Bits Error"]
        pub type S1ERR2B_R = crate::BitReader;
        #[doc = "Field `S1ERR1B` reader - SRAM1 ECC 1 Bit Error"]
        pub type S1ERR1B_R = crate::BitReader;
        #[doc = "Field `S2ERR2B` reader - SRAM2 ECC 2 Bits Error"]
        pub type S2ERR2B_R = crate::BitReader;
        #[doc = "Field `S2ERR1B` reader - SRAM2 ECC 1 Bits Error"]
        pub type S2ERR1B_R = crate::BitReader;
        #[doc = "Field `ERRCNT` reader - ECC Error Counter"]
        pub type ERRCNT_R = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - SRAM0 ECC 2 Bits Error"]
            #[inline(always)]
            pub fn s0err2b(&self) -> S0ERR2B_R {
                S0ERR2B_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - SRAM0 ECC 1 Bit Error"]
            #[inline(always)]
            pub fn s0err1b(&self) -> S0ERR1B_R {
                S0ERR1B_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - SRAM1 ECC 2 Bits Error"]
            #[inline(always)]
            pub fn s1err2b(&self) -> S1ERR2B_R {
                S1ERR2B_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - SRAM1 ECC 1 Bit Error"]
            #[inline(always)]
            pub fn s1err1b(&self) -> S1ERR1B_R {
                S1ERR1B_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - SRAM2 ECC 2 Bits Error"]
            #[inline(always)]
            pub fn s2err2b(&self) -> S2ERR2B_R {
                S2ERR2B_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - SRAM2 ECC 1 Bits Error"]
            #[inline(always)]
            pub fn s2err1b(&self) -> S2ERR1B_R {
                S2ERR1B_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bits 8:10 - ECC Error Counter"]
            #[inline(always)]
            pub fn errcnt(&self) -> ERRCNT_R {
                ERRCNT_R::new(((self.bits >> 8) & 7) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCSTA")
                    .field("s0err2b", &self.s0err2b())
                    .field("s0err1b", &self.s0err1b())
                    .field("s1err2b", &self.s1err2b())
                    .field("s1err1b", &self.s1err1b())
                    .field("s2err2b", &self.s2err2b())
                    .field("s2err1b", &self.s2err1b())
                    .field("errcnt", &self.errcnt())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM ECC Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccsta::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccsta::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCSTA)"]
        pub struct SRAMECCSTArs;
        impl crate::RegisterSpec for SRAMECCSTArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srameccsta::R`](R) reader structure"]
        impl crate::Readable for SRAMECCSTArs {}
        #[doc = "`write(|w| ..)` method takes [`srameccsta::W`](W) writer structure"]
        impl crate::Writable for SRAMECCSTArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCSTA to value 0"]
        impl crate::Resettable for SRAMECCSTArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRAMECCA0 (rw) register accessor: SRAM0 ECC Error Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramecca0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramecca0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCA0)\n\nFor information about available fields see [`mod@sramecca0`]
module"]
    pub type SRAMECCA0 = crate::Reg<sramecca0::SRAMECCA0rs>;
    #[doc = "SRAM0 ECC Error Address Register"]
    pub mod sramecca0 {
        #[doc = "Register `SRAMECCA0` reader"]
        pub type R = crate::R<SRAMECCA0rs>;
        #[doc = "Register `SRAMECCA0` writer"]
        pub type W = crate::W<SRAMECCA0rs>;
        #[doc = "Field `ADDR` reader - ECC Error Address"]
        pub type ADDR_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - ECC Error Address"]
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCA0")
                    .field("addr", &self.addr())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM0 ECC Error Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramecca0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramecca0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCA0)"]
        pub struct SRAMECCA0rs;
        impl crate::RegisterSpec for SRAMECCA0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sramecca0::R`](R) reader structure"]
        impl crate::Readable for SRAMECCA0rs {}
        #[doc = "`write(|w| ..)` method takes [`sramecca0::W`](W) writer structure"]
        impl crate::Writable for SRAMECCA0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCA0 to value 0"]
        impl crate::Resettable for SRAMECCA0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRAMECCD0 (rw) register accessor: SRAM0 ECC Error Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccd0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccd0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCD0)\n\nFor information about available fields see [`mod@srameccd0`]
module"]
    pub type SRAMECCD0 = crate::Reg<srameccd0::SRAMECCD0rs>;
    #[doc = "SRAM0 ECC Error Data Register"]
    pub mod srameccd0 {
        #[doc = "Register `SRAMECCD0` reader"]
        pub type R = crate::R<SRAMECCD0rs>;
        #[doc = "Register `SRAMECCD0` writer"]
        pub type W = crate::W<SRAMECCD0rs>;
        #[doc = "Field `DATA` reader - ECC Error Raw Data"]
        pub type DATA_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - ECC Error Raw Data"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCD0")
                    .field("data", &self.data())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM0 ECC Error Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccd0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccd0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCD0)"]
        pub struct SRAMECCD0rs;
        impl crate::RegisterSpec for SRAMECCD0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srameccd0::R`](R) reader structure"]
        impl crate::Readable for SRAMECCD0rs {}
        #[doc = "`write(|w| ..)` method takes [`srameccd0::W`](W) writer structure"]
        impl crate::Writable for SRAMECCD0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCD0 to value 0"]
        impl crate::Resettable for SRAMECCD0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRAMECCP0 (rw) register accessor: SRAM0 ECC Error Parity Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccp0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccp0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCP0)\n\nFor information about available fields see [`mod@srameccp0`]
module"]
    pub type SRAMECCP0 = crate::Reg<srameccp0::SRAMECCP0rs>;
    #[doc = "SRAM0 ECC Error Parity Register"]
    pub mod srameccp0 {
        #[doc = "Register `SRAMECCP0` reader"]
        pub type R = crate::R<SRAMECCP0rs>;
        #[doc = "Register `SRAMECCP0` writer"]
        pub type W = crate::W<SRAMECCP0rs>;
        #[doc = "Field `PARITY` reader - ECC Error Raw Parity"]
        pub type PARITY_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:6 - ECC Error Raw Parity"]
            #[inline(always)]
            pub fn parity(&self) -> PARITY_R {
                PARITY_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCP0")
                    .field("parity", &self.parity())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM0 ECC Error Parity Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccp0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccp0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCP0)"]
        pub struct SRAMECCP0rs;
        impl crate::RegisterSpec for SRAMECCP0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srameccp0::R`](R) reader structure"]
        impl crate::Readable for SRAMECCP0rs {}
        #[doc = "`write(|w| ..)` method takes [`srameccp0::W`](W) writer structure"]
        impl crate::Writable for SRAMECCP0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCP0 to value 0"]
        impl crate::Resettable for SRAMECCP0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRAMECCA1 (rw) register accessor: SRAM1 ECC Error Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramecca1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramecca1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCA1)\n\nFor information about available fields see [`mod@sramecca1`]
module"]
    pub type SRAMECCA1 = crate::Reg<sramecca1::SRAMECCA1rs>;
    #[doc = "SRAM1 ECC Error Address Register"]
    pub mod sramecca1 {
        #[doc = "Register `SRAMECCA1` reader"]
        pub type R = crate::R<SRAMECCA1rs>;
        #[doc = "Register `SRAMECCA1` writer"]
        pub type W = crate::W<SRAMECCA1rs>;
        #[doc = "Field `ADDR` reader - ECC Error Address"]
        pub type ADDR_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - ECC Error Address"]
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCA1")
                    .field("addr", &self.addr())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM1 ECC Error Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramecca1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramecca1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCA1)"]
        pub struct SRAMECCA1rs;
        impl crate::RegisterSpec for SRAMECCA1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sramecca1::R`](R) reader structure"]
        impl crate::Readable for SRAMECCA1rs {}
        #[doc = "`write(|w| ..)` method takes [`sramecca1::W`](W) writer structure"]
        impl crate::Writable for SRAMECCA1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCA1 to value 0"]
        impl crate::Resettable for SRAMECCA1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRAMECCD1 (rw) register accessor: SRAM1 ECC Error Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccd1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccd1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCD1)\n\nFor information about available fields see [`mod@srameccd1`]
module"]
    pub type SRAMECCD1 = crate::Reg<srameccd1::SRAMECCD1rs>;
    #[doc = "SRAM1 ECC Error Data Register"]
    pub mod srameccd1 {
        #[doc = "Register `SRAMECCD1` reader"]
        pub type R = crate::R<SRAMECCD1rs>;
        #[doc = "Register `SRAMECCD1` writer"]
        pub type W = crate::W<SRAMECCD1rs>;
        #[doc = "Field `DATA` reader - ECC Error Raw Data"]
        pub type DATA_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - ECC Error Raw Data"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCD1")
                    .field("data", &self.data())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM1 ECC Error Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccd1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccd1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCD1)"]
        pub struct SRAMECCD1rs;
        impl crate::RegisterSpec for SRAMECCD1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srameccd1::R`](R) reader structure"]
        impl crate::Readable for SRAMECCD1rs {}
        #[doc = "`write(|w| ..)` method takes [`srameccd1::W`](W) writer structure"]
        impl crate::Writable for SRAMECCD1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCD1 to value 0"]
        impl crate::Resettable for SRAMECCD1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRAMECCP1 (rw) register accessor: SRAM1 ECC Error Parity Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccp1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccp1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCP1)\n\nFor information about available fields see [`mod@srameccp1`]
module"]
    pub type SRAMECCP1 = crate::Reg<srameccp1::SRAMECCP1rs>;
    #[doc = "SRAM1 ECC Error Parity Register"]
    pub mod srameccp1 {
        #[doc = "Register `SRAMECCP1` reader"]
        pub type R = crate::R<SRAMECCP1rs>;
        #[doc = "Register `SRAMECCP1` writer"]
        pub type W = crate::W<SRAMECCP1rs>;
        #[doc = "Field `PARITY` reader - ECC Error Raw Parity"]
        pub type PARITY_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:6 - ECC Error Raw Parity"]
            #[inline(always)]
            pub fn parity(&self) -> PARITY_R {
                PARITY_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCP1")
                    .field("parity", &self.parity())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM1 ECC Error Parity Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccp1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccp1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCP1)"]
        pub struct SRAMECCP1rs;
        impl crate::RegisterSpec for SRAMECCP1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srameccp1::R`](R) reader structure"]
        impl crate::Readable for SRAMECCP1rs {}
        #[doc = "`write(|w| ..)` method takes [`srameccp1::W`](W) writer structure"]
        impl crate::Writable for SRAMECCP1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCP1 to value 0"]
        impl crate::Resettable for SRAMECCP1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRAMECCA2 (rw) register accessor: SRAM2 ECC Error Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramecca2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramecca2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCA2)\n\nFor information about available fields see [`mod@sramecca2`]
module"]
    pub type SRAMECCA2 = crate::Reg<sramecca2::SRAMECCA2rs>;
    #[doc = "SRAM2 ECC Error Address Register"]
    pub mod sramecca2 {
        #[doc = "Register `SRAMECCA2` reader"]
        pub type R = crate::R<SRAMECCA2rs>;
        #[doc = "Register `SRAMECCA2` writer"]
        pub type W = crate::W<SRAMECCA2rs>;
        #[doc = "Field `ADDR` reader - ECC Error Address"]
        pub type ADDR_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - ECC Error Address"]
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCA2")
                    .field("addr", &self.addr())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM2 ECC Error Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sramecca2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sramecca2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCA2)"]
        pub struct SRAMECCA2rs;
        impl crate::RegisterSpec for SRAMECCA2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sramecca2::R`](R) reader structure"]
        impl crate::Readable for SRAMECCA2rs {}
        #[doc = "`write(|w| ..)` method takes [`sramecca2::W`](W) writer structure"]
        impl crate::Writable for SRAMECCA2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCA2 to value 0"]
        impl crate::Resettable for SRAMECCA2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRAMECCD2 (rw) register accessor: SRAM2 ECC Error Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccd2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccd2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCD2)\n\nFor information about available fields see [`mod@srameccd2`]
module"]
    pub type SRAMECCD2 = crate::Reg<srameccd2::SRAMECCD2rs>;
    #[doc = "SRAM2 ECC Error Data Register"]
    pub mod srameccd2 {
        #[doc = "Register `SRAMECCD2` reader"]
        pub type R = crate::R<SRAMECCD2rs>;
        #[doc = "Register `SRAMECCD2` writer"]
        pub type W = crate::W<SRAMECCD2rs>;
        #[doc = "Field `DATA` reader - ECC Error Raw Data"]
        pub type DATA_R = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - ECC Error Raw Data"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCD2")
                    .field("data", &self.data())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM2 ECC Error Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccd2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccd2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCD2)"]
        pub struct SRAMECCD2rs;
        impl crate::RegisterSpec for SRAMECCD2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srameccd2::R`](R) reader structure"]
        impl crate::Readable for SRAMECCD2rs {}
        #[doc = "`write(|w| ..)` method takes [`srameccd2::W`](W) writer structure"]
        impl crate::Writable for SRAMECCD2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCD2 to value 0"]
        impl crate::Resettable for SRAMECCD2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRAMECCP2 (rw) register accessor: SRAM2 ECC Error Parity Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccp2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccp2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCP2)\n\nFor information about available fields see [`mod@srameccp2`]
module"]
    pub type SRAMECCP2 = crate::Reg<srameccp2::SRAMECCP2rs>;
    #[doc = "SRAM2 ECC Error Parity Register"]
    pub mod srameccp2 {
        #[doc = "Register `SRAMECCP2` reader"]
        pub type R = crate::R<SRAMECCP2rs>;
        #[doc = "Register `SRAMECCP2` writer"]
        pub type W = crate::W<SRAMECCP2rs>;
        #[doc = "Field `PARITY` reader - ECC Error Raw Parity"]
        pub type PARITY_R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:6 - ECC Error Raw Parity"]
            #[inline(always)]
            pub fn parity(&self) -> PARITY_R {
                PARITY_R::new((self.bits & 0x7f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SRAMECCP2")
                    .field("parity", &self.parity())
                    .finish()
            }
        }
        impl W {}
        #[doc = "SRAM2 ECC Error Parity Register\n\nYou can [`read`](crate::Reg::read) this register and get [`srameccp2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srameccp2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#SRAM:SRAMECCP2)"]
        pub struct SRAMECCP2rs;
        impl crate::RegisterSpec for SRAMECCP2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srameccp2::R`](R) reader structure"]
        impl crate::Readable for SRAMECCP2rs {}
        #[doc = "`write(|w| ..)` method takes [`srameccp2::W`](W) writer structure"]
        impl crate::Writable for SRAMECCP2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRAMECCP2 to value 0"]
        impl crate::Resettable for SRAMECCP2rs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CRC)"]
pub struct CRC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRC {}
impl CRC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crc::RegisterBlock = 0x4006_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CRC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRC").finish()
    }
}
#[doc = "Unknown"]
pub mod crc {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctl: CTL,
        ipdata: IPDATA,
        result: RESULT,
        poly: POLY,
    }
    impl RegisterBlock {
        #[doc = "0x00 - CRC Control Register"]
        #[inline(always)]
        pub const fn ctl(&self) -> &CTL {
            &self.ctl
        }
        #[doc = "0x04 - Input Data Word Register"]
        #[inline(always)]
        pub const fn ipdata(&self) -> &IPDATA {
            &self.ipdata
        }
        #[doc = "0x08 - CRC Result Register"]
        #[inline(always)]
        pub const fn result(&self) -> &RESULT {
            &self.result
        }
        #[doc = "0x0c - Programmable CRC Polynomial"]
        #[inline(always)]
        pub const fn poly(&self) -> &POLY {
            &self.poly
        }
    }
    #[doc = "CTL (rw) register accessor: CRC Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CRC:CTL)\n\nFor information about available fields see [`mod@ctl`]
module"]
    pub type CTL = crate::Reg<ctl::CTLrs>;
    #[doc = "CRC Control Register"]
    pub mod ctl {
        #[doc = "Register `CTL` reader"]
        pub type R = crate::R<CTLrs>;
        #[doc = "Register `CTL` writer"]
        pub type W = crate::W<CTLrs>;
        #[doc = "Field `EN` reader - CRC Peripheral Enable"]
        pub type EN_R = crate::BitReader;
        #[doc = "Field `EN` writer - CRC Peripheral Enable"]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LSBFIRST` reader - LSB First Calculation Order"]
        pub type LSBFIRST_R = crate::BitReader;
        #[doc = "Field `LSBFIRST` writer - LSB First Calculation Order"]
        pub type LSBFIRST_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BITMIRR` reader - Bit Mirroring"]
        pub type BITMIRR_R = crate::BitReader;
        #[doc = "Field `BITMIRR` writer - Bit Mirroring"]
        pub type BITMIRR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BYTMIRR` reader - Byte Mirroring"]
        pub type BYTMIRR_R = crate::BitReader;
        #[doc = "Field `BYTMIRR` writer - Byte Mirroring"]
        pub type BYTMIRR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `W16SWP` reader - Word16 Swap"]
        pub type W16SWP_R = crate::BitReader;
        #[doc = "Field `W16SWP` writer - Word16 Swap"]
        pub type W16SWP_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RevID` reader - Revision ID"]
        pub type REV_ID_R = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - CRC Peripheral Enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - LSB First Calculation Order"]
            #[inline(always)]
            pub fn lsbfirst(&self) -> LSBFIRST_R {
                LSBFIRST_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Bit Mirroring"]
            #[inline(always)]
            pub fn bitmirr(&self) -> BITMIRR_R {
                BITMIRR_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Byte Mirroring"]
            #[inline(always)]
            pub fn bytmirr(&self) -> BYTMIRR_R {
                BYTMIRR_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Word16 Swap"]
            #[inline(always)]
            pub fn w16swp(&self) -> W16SWP_R {
                W16SWP_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 28:31 - Revision ID"]
            #[inline(always)]
            pub fn rev_id(&self) -> REV_ID_R {
                REV_ID_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CTL")
                    .field("en", &self.en())
                    .field("lsbfirst", &self.lsbfirst())
                    .field("bitmirr", &self.bitmirr())
                    .field("bytmirr", &self.bytmirr())
                    .field("w16swp", &self.w16swp())
                    .field("rev_id", &self.rev_id())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - CRC Peripheral Enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<CTLrs> {
                EN_W::new(self, 0)
            }
            #[doc = "Bit 1 - LSB First Calculation Order"]
            #[inline(always)]
            pub fn lsbfirst(&mut self) -> LSBFIRST_W<CTLrs> {
                LSBFIRST_W::new(self, 1)
            }
            #[doc = "Bit 2 - Bit Mirroring"]
            #[inline(always)]
            pub fn bitmirr(&mut self) -> BITMIRR_W<CTLrs> {
                BITMIRR_W::new(self, 2)
            }
            #[doc = "Bit 3 - Byte Mirroring"]
            #[inline(always)]
            pub fn bytmirr(&mut self) -> BYTMIRR_W<CTLrs> {
                BYTMIRR_W::new(self, 3)
            }
            #[doc = "Bit 4 - Word16 Swap"]
            #[inline(always)]
            pub fn w16swp(&mut self) -> W16SWP_W<CTLrs> {
                W16SWP_W::new(self, 4)
            }
        }
        #[doc = "CRC Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CRC:CTL)"]
        pub struct CTLrs;
        impl crate::RegisterSpec for CTLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctl::R`](R) reader structure"]
        impl crate::Readable for CTLrs {}
        #[doc = "`write(|w| ..)` method takes [`ctl::W`](W) writer structure"]
        impl crate::Writable for CTLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CTL to value 0x1000_0000"]
        impl crate::Resettable for CTLrs {
            const RESET_VALUE: u32 = 0x1000_0000;
        }
    }
    #[doc = "IPDATA (rw) register accessor: Input Data Word Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipdata::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipdata::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CRC:IPDATA)\n\nFor information about available fields see [`mod@ipdata`]
module"]
    pub type IPDATA = crate::Reg<ipdata::IPDATArs>;
    #[doc = "Input Data Word Register"]
    pub mod ipdata {
        #[doc = "Register `IPDATA` reader"]
        pub type R = crate::R<IPDATArs>;
        #[doc = "Register `IPDATA` writer"]
        pub type W = crate::W<IPDATArs>;
        #[doc = "Field `DATA_WORD` writer - Data Input."]
        pub type DATA_WORD_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IPDATA").finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Data Input."]
            #[inline(always)]
            pub fn data_word(&mut self) -> DATA_WORD_W<IPDATArs> {
                DATA_WORD_W::new(self, 0)
            }
        }
        #[doc = "Input Data Word Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipdata::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipdata::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CRC:IPDATA)"]
        pub struct IPDATArs;
        impl crate::RegisterSpec for IPDATArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ipdata::R`](R) reader structure"]
        impl crate::Readable for IPDATArs {}
        #[doc = "`write(|w| ..)` method takes [`ipdata::W`](W) writer structure"]
        impl crate::Writable for IPDATArs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets IPDATA to value 0"]
        impl crate::Resettable for IPDATArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RESULT (rw) register accessor: CRC Result Register\n\nYou can [`read`](crate::Reg::read) this register and get [`result::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`result::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CRC:RESULT)\n\nFor information about available fields see [`mod@result`]
module"]
    pub type RESULT = crate::Reg<result::RESULTrs>;
    #[doc = "CRC Result Register"]
    pub mod result {
        #[doc = "Register `RESULT` reader"]
        pub type R = crate::R<RESULTrs>;
        #[doc = "Register `RESULT` writer"]
        pub type W = crate::W<RESULTrs>;
        #[doc = "Field `RESIDUE` reader - CRC Residue"]
        pub type RESIDUE_R = crate::FieldReader<u32>;
        #[doc = "Field `RESIDUE` writer - CRC Residue"]
        pub type RESIDUE_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - CRC Residue"]
            #[inline(always)]
            pub fn residue(&self) -> RESIDUE_R {
                RESIDUE_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RESULT")
                    .field("residue", &self.residue())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - CRC Residue"]
            #[inline(always)]
            pub fn residue(&mut self) -> RESIDUE_W<RESULTrs> {
                RESIDUE_W::new(self, 0)
            }
        }
        #[doc = "CRC Result Register\n\nYou can [`read`](crate::Reg::read) this register and get [`result::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`result::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CRC:RESULT)"]
        pub struct RESULTrs;
        impl crate::RegisterSpec for RESULTrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`result::R`](R) reader structure"]
        impl crate::Readable for RESULTrs {}
        #[doc = "`write(|w| ..)` method takes [`result::W`](W) writer structure"]
        impl crate::Writable for RESULTrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RESULT to value 0"]
        impl crate::Resettable for RESULTrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "POLY (rw) register accessor: Programmable CRC Polynomial\n\nYou can [`read`](crate::Reg::read) this register and get [`poly::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`poly::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CRC:POLY)\n\nFor information about available fields see [`mod@poly`]
module"]
    pub type POLY = crate::Reg<poly::POLYrs>;
    #[doc = "Programmable CRC Polynomial"]
    pub mod poly {
        #[doc = "Register `POLY` reader"]
        pub type R = crate::R<POLYrs>;
        #[doc = "Register `POLY` writer"]
        pub type W = crate::W<POLYrs>;
        #[doc = "Field `REDUCTION_POLY` reader - CRC Reduction Polynomial"]
        pub type REDUCTION_POLY_R = crate::FieldReader<u32>;
        #[doc = "Field `REDUCTION_POLY` writer - CRC Reduction Polynomial"]
        pub type REDUCTION_POLY_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - CRC Reduction Polynomial"]
            #[inline(always)]
            pub fn reduction_poly(&self) -> REDUCTION_POLY_R {
                REDUCTION_POLY_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("POLY")
                    .field("reduction_poly", &self.reduction_poly())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - CRC Reduction Polynomial"]
            #[inline(always)]
            pub fn reduction_poly(&mut self) -> REDUCTION_POLY_W<POLYrs> {
                REDUCTION_POLY_W::new(self, 0)
            }
        }
        #[doc = "Programmable CRC Polynomial\n\nYou can [`read`](crate::Reg::read) this register and get [`poly::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`poly::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#CRC:POLY)"]
        pub struct POLYrs;
        impl crate::RegisterSpec for POLYrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`poly::R`](R) reader structure"]
        impl crate::Readable for POLYrs {}
        #[doc = "`write(|w| ..)` method takes [`poly::W`](W) writer structure"]
        impl crate::Writable for POLYrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets POLY to value 0x04c1_1db7"]
        impl crate::Resettable for POLYrs {
            const RESET_VALUE: u32 = 0x04c1_1db7;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC)"]
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc::RegisterBlock = 0x4006_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC").finish()
    }
}
#[doc = "Unknown"]
pub mod adc {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        adcdat: [ADCDAT; 30],
        adccon: ADCCON,
        prebufcon: PREBUFCON,
        adccnvc: ADCCNVC,
        adccnvcslow: ADCCNVCSLOW,
        adccha: ADCCHA,
        adcirqstat: ADCIRQSTAT,
        adcseq: ADCSEQ,
        adcseqc: ADCSEQC,
        adcseqs: ADCSEQS,
        adcseqch: ADCSEQCH,
        adcseqchmux0: ADCSEQCHMUX0,
        adcseqchmux1: ADCSEQCHMUX1,
        adccmp: ADCCMP,
        adccmpirqstat: ADCCMPIRQSTAT,
        adcofgndiff: ADCOFGNDIFF,
        adcoftemp: ADCOFTEMP,
        adcgntemp: ADCGNTEMP,
        adcofgnpga0: ADCOFGNPGA0,
        adcofgnpga1: ADCOFGNPGA1,
        adcofgnpga2: ADCOFGNPGA2,
        adcofgnpga3: ADCOFGNPGA3,
        adcofgnpga0tia: ADCOFGNPGA0TIA,
        adcofgnpga1tia: ADCOFGNPGA1TIA,
        adcofgnpga2tia: ADCOFGNPGA2TIA,
        adcofgnpga3tia: ADCOFGNPGA3TIA,
        _reserved26: [u8; 0x78],
        adccmp1: ADCCMP1,
        adccmp2: ADCCMP2,
        adccmp3: ADCCMP3,
    }
    impl RegisterBlock {
        #[doc = "0x00..0x78 - ADCx Data and Flags"]
        #[inline(always)]
        pub const fn adcdat(&self, n: usize) -> &ADCDAT {
            &self.adcdat[n]
        }
        #[doc = "Iterator for array of:"]
        #[doc = "0x00..0x78 - ADCx Data and Flags"]
        #[inline(always)]
        pub fn adcdat_iter(&self) -> impl Iterator<Item = &ADCDAT> {
            self.adcdat.iter()
        }
        #[doc = "0x78 - ADC Configuration"]
        #[inline(always)]
        pub const fn adccon(&self) -> &ADCCON {
            &self.adccon
        }
        #[doc = "0x7c - Pre-charge Buffer Control"]
        #[inline(always)]
        pub const fn prebufcon(&self) -> &PREBUFCON {
            &self.prebufcon
        }
        #[doc = "0x80 - ADC Conversion Cycle for Positive Input Channels"]
        #[inline(always)]
        pub const fn adccnvc(&self) -> &ADCCNVC {
            &self.adccnvc
        }
        #[doc = "0x84 - ADC Conversion Cycle for Positive Input Channels"]
        #[inline(always)]
        pub const fn adccnvcslow(&self) -> &ADCCNVCSLOW {
            &self.adccnvcslow
        }
        #[doc = "0x88 - ADC Channel Select"]
        #[inline(always)]
        pub const fn adccha(&self) -> &ADCCHA {
            &self.adccha
        }
        #[doc = "0x8c - ADC Interrupt Status"]
        #[inline(always)]
        pub const fn adcirqstat(&self) -> &ADCIRQSTAT {
            &self.adcirqstat
        }
        #[doc = "0x90 - ADC Sequencer Control"]
        #[inline(always)]
        pub const fn adcseq(&self) -> &ADCSEQ {
            &self.adcseq
        }
        #[doc = "0x94 - ADC Sequencer Configuration"]
        #[inline(always)]
        pub const fn adcseqc(&self) -> &ADCSEQC {
            &self.adcseqc
        }
        #[doc = "0x98 - ADC Sequencer Status"]
        #[inline(always)]
        pub const fn adcseqs(&self) -> &ADCSEQS {
            &self.adcseqs
        }
        #[doc = "0x9c - ADC Sequencer Channel 0"]
        #[inline(always)]
        pub const fn adcseqch(&self) -> &ADCSEQCH {
            &self.adcseqch
        }
        #[doc = "0xa0 - ADC Sequencer Channel 1"]
        #[inline(always)]
        pub const fn adcseqchmux0(&self) -> &ADCSEQCHMUX0 {
            &self.adcseqchmux0
        }
        #[doc = "0xa4 - ADC Sequencer Channel 1"]
        #[inline(always)]
        pub const fn adcseqchmux1(&self) -> &ADCSEQCHMUX1 {
            &self.adcseqchmux1
        }
        #[doc = "0xa8 - Digital Comparator 0 Configuration"]
        #[inline(always)]
        pub const fn adccmp(&self) -> &ADCCMP {
            &self.adccmp
        }
        #[doc = "0xac - Digital Comparator Interrupt Status"]
        #[inline(always)]
        pub const fn adccmpirqstat(&self) -> &ADCCMPIRQSTAT {
            &self.adccmpirqstat
        }
        #[doc = "0xb0 - ADC Offset Gain Differential Channel Error Correction"]
        #[inline(always)]
        pub const fn adcofgndiff(&self) -> &ADCOFGNDIFF {
            &self.adcofgndiff
        }
        #[doc = "0xb4 - ADC Offset Gain Temp Sensor Channel Error Correction"]
        #[inline(always)]
        pub const fn adcoftemp(&self) -> &ADCOFTEMP {
            &self.adcoftemp
        }
        #[doc = "0xb8 - ADC Offset Gain Temp Sensor Channel Error Correction"]
        #[inline(always)]
        pub const fn adcgntemp(&self) -> &ADCGNTEMP {
            &self.adcgntemp
        }
        #[doc = "0xbc - ADC Offset Gain PGA0 Channel Error Correction"]
        #[inline(always)]
        pub const fn adcofgnpga0(&self) -> &ADCOFGNPGA0 {
            &self.adcofgnpga0
        }
        #[doc = "0xc0 - ADC Offset Gain PGA1 Channel Error Correction"]
        #[inline(always)]
        pub const fn adcofgnpga1(&self) -> &ADCOFGNPGA1 {
            &self.adcofgnpga1
        }
        #[doc = "0xc4 - ADC Offset Gain PGA2 Channel Error Correction"]
        #[inline(always)]
        pub const fn adcofgnpga2(&self) -> &ADCOFGNPGA2 {
            &self.adcofgnpga2
        }
        #[doc = "0xc8 - ADC Offset Gain PGA3 Channel Error Correction"]
        #[inline(always)]
        pub const fn adcofgnpga3(&self) -> &ADCOFGNPGA3 {
            &self.adcofgnpga3
        }
        #[doc = "0xcc - ADC Offset Gain PGA0 Channel Error Correction"]
        #[inline(always)]
        pub const fn adcofgnpga0tia(&self) -> &ADCOFGNPGA0TIA {
            &self.adcofgnpga0tia
        }
        #[doc = "0xd0 - ADC Offset Gain PGA1 Channel Error Correction"]
        #[inline(always)]
        pub const fn adcofgnpga1tia(&self) -> &ADCOFGNPGA1TIA {
            &self.adcofgnpga1tia
        }
        #[doc = "0xd4 - ADC Offset Gain PGA2 Channel Error Correction"]
        #[inline(always)]
        pub const fn adcofgnpga2tia(&self) -> &ADCOFGNPGA2TIA {
            &self.adcofgnpga2tia
        }
        #[doc = "0xd8 - ADC Offset Gain PGA3 Channel Error Correction"]
        #[inline(always)]
        pub const fn adcofgnpga3tia(&self) -> &ADCOFGNPGA3TIA {
            &self.adcofgnpga3tia
        }
        #[doc = "0x154 - Digital Comparator 1 Configuration"]
        #[inline(always)]
        pub const fn adccmp1(&self) -> &ADCCMP1 {
            &self.adccmp1
        }
        #[doc = "0x158 - Digital Comparator 2 Configuration"]
        #[inline(always)]
        pub const fn adccmp2(&self) -> &ADCCMP2 {
            &self.adccmp2
        }
        #[doc = "0x15c - Digital Comparator 3 Configuration"]
        #[inline(always)]
        pub const fn adccmp3(&self) -> &ADCCMP3 {
            &self.adccmp3
        }
    }
    #[doc = "ADCDAT (rw) register accessor: ADCx Data and Flags\n\nYou can [`read`](crate::Reg::read) this register and get [`adcdat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcdat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCDAT[0])\n\nFor information about available fields see [`mod@adcdat`]
module"]
    pub type ADCDAT = crate::Reg<adcdat::ADCDATrs>;
    #[doc = "ADCx Data and Flags"]
    pub mod adcdat {
        #[doc = "Register `ADCDAT[%s]` reader"]
        pub type R = crate::R<ADCDATrs>;
        #[doc = "Register `ADCDAT[%s]` writer"]
        pub type W = crate::W<ADCDATrs>;
        #[doc = "Overflow Flag\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OVF {
            #[doc = "0: Not Overflow"]
            Novf = 0,
            #[doc = "1: Overflow"]
            Ovf = 1,
        }
        impl From<OVF> for bool {
            #[inline(always)]
            fn from(variant: OVF) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OVF` reader - Overflow Flag"]
        pub type OVF_R = crate::BitReader<OVF>;
        impl OVF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OVF {
                match self.bits {
                    false => OVF::Novf,
                    true => OVF::Ovf,
                }
            }
            #[doc = "Not Overflow"]
            #[inline(always)]
            pub fn is_novf(&self) -> bool {
                *self == OVF::Novf
            }
            #[doc = "Overflow"]
            #[inline(always)]
            pub fn is_ovf(&self) -> bool {
                *self == OVF::Ovf
            }
        }
        #[doc = "Underflow Flag\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UVF {
            #[doc = "0: Not Underflow"]
            Nunf = 0,
            #[doc = "1: Underflow"]
            Unf = 1,
        }
        impl From<UVF> for bool {
            #[inline(always)]
            fn from(variant: UVF) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UVF` reader - Underflow Flag"]
        pub type UVF_R = crate::BitReader<UVF>;
        impl UVF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> UVF {
                match self.bits {
                    false => UVF::Nunf,
                    true => UVF::Unf,
                }
            }
            #[doc = "Not Underflow"]
            #[inline(always)]
            pub fn is_nunf(&self) -> bool {
                *self == UVF::Nunf
            }
            #[doc = "Underflow"]
            #[inline(always)]
            pub fn is_unf(&self) -> bool {
                *self == UVF::Unf
            }
        }
        #[doc = "Data Read Flag\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RDY {
            #[doc = "0: Data is Not Ready or Has Been Read Out"]
            Nordy = 0,
            #[doc = "1: Data is Ready to Be Read"]
            Rdy = 1,
        }
        impl From<RDY> for bool {
            #[inline(always)]
            fn from(variant: RDY) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RDY` reader - Data Read Flag"]
        pub type RDY_R = crate::BitReader<RDY>;
        impl RDY_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RDY {
                match self.bits {
                    false => RDY::Nordy,
                    true => RDY::Rdy,
                }
            }
            #[doc = "Data is Not Ready or Has Been Read Out"]
            #[inline(always)]
            pub fn is_nordy(&self) -> bool {
                *self == RDY::Nordy
            }
            #[doc = "Data is Ready to Be Read"]
            #[inline(always)]
            pub fn is_rdy(&self) -> bool {
                *self == RDY::Rdy
            }
        }
        #[doc = "Field `DAT` reader - ADCx Data"]
        pub type DAT_R = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bit 0 - Overflow Flag"]
            #[inline(always)]
            pub fn ovf(&self) -> OVF_R {
                OVF_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Underflow Flag"]
            #[inline(always)]
            pub fn uvf(&self) -> UVF_R {
                UVF_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Data Read Flag"]
            #[inline(always)]
            pub fn rdy(&self) -> RDY_R {
                RDY_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 4:19 - ADCx Data"]
            #[inline(always)]
            pub fn dat(&self) -> DAT_R {
                DAT_R::new(((self.bits >> 4) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCDAT")
                    .field("ovf", &self.ovf())
                    .field("uvf", &self.uvf())
                    .field("rdy", &self.rdy())
                    .field("dat", &self.dat())
                    .finish()
            }
        }
        impl W {}
        #[doc = "ADCx Data and Flags\n\nYou can [`read`](crate::Reg::read) this register and get [`adcdat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcdat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCDAT[0])"]
        pub struct ADCDATrs;
        impl crate::RegisterSpec for ADCDATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcdat::R`](R) reader structure"]
        impl crate::Readable for ADCDATrs {}
        #[doc = "`write(|w| ..)` method takes [`adcdat::W`](W) writer structure"]
        impl crate::Writable for ADCDATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCDAT[%s]
to value 0"]
        impl crate::Resettable for ADCDATrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCCON (rw) register accessor: ADC Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCON)\n\nFor information about available fields see [`mod@adccon`]
module"]
    pub type ADCCON = crate::Reg<adccon::ADCCONrs>;
    #[doc = "ADC Configuration"]
    pub mod adccon {
        #[doc = "Register `ADCCON` reader"]
        pub type R = crate::R<ADCCONrs>;
        #[doc = "Register `ADCCON` writer"]
        pub type W = crate::W<ADCCONrs>;
        #[doc = "ADC Conversion Type Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CONVTYPE {
            #[doc = "0: No Conversion"]
            Idle = 0,
            #[doc = "1: ADC Controlled by GPIO Pin"]
            Gpio = 1,
            #[doc = "2: Software Single Conversion"]
            Singl = 2,
            #[doc = "3: Software Continue Conversion"]
            Cont = 3,
            #[doc = "4: PLA Conversion"]
            Pla = 4,
            #[doc = "5: GPT Triggered Conversion"]
            Gpt = 5,
        }
        impl From<CONVTYPE> for u8 {
            #[inline(always)]
            fn from(variant: CONVTYPE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CONVTYPE {
            type Ux = u8;
        }
        impl crate::IsEnum for CONVTYPE {}
        #[doc = "Field `CONVTYPE` reader - ADC Conversion Type Selection"]
        pub type CONVTYPE_R = crate::FieldReader<CONVTYPE>;
        impl CONVTYPE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CONVTYPE> {
                match self.bits {
                    0 => Some(CONVTYPE::Idle),
                    1 => Some(CONVTYPE::Gpio),
                    2 => Some(CONVTYPE::Singl),
                    3 => Some(CONVTYPE::Cont),
                    4 => Some(CONVTYPE::Pla),
                    5 => Some(CONVTYPE::Gpt),
                    _ => None,
                }
            }
            #[doc = "No Conversion"]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == CONVTYPE::Idle
            }
            #[doc = "ADC Controlled by GPIO Pin"]
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == CONVTYPE::Gpio
            }
            #[doc = "Software Single Conversion"]
            #[inline(always)]
            pub fn is_singl(&self) -> bool {
                *self == CONVTYPE::Singl
            }
            #[doc = "Software Continue Conversion"]
            #[inline(always)]
            pub fn is_cont(&self) -> bool {
                *self == CONVTYPE::Cont
            }
            #[doc = "PLA Conversion"]
            #[inline(always)]
            pub fn is_pla(&self) -> bool {
                *self == CONVTYPE::Pla
            }
            #[doc = "GPT Triggered Conversion"]
            #[inline(always)]
            pub fn is_gpt(&self) -> bool {
                *self == CONVTYPE::Gpt
            }
        }
        #[doc = "Field `CONVTYPE` writer - ADC Conversion Type Selection"]
        pub type CONVTYPE_W<'a, REG> = crate::FieldWriter<'a, REG, 3, CONVTYPE>;
        impl<'a, REG> CONVTYPE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "No Conversion"]
            #[inline(always)]
            pub fn idle(self) -> &'a mut crate::W<REG> {
                self.variant(CONVTYPE::Idle)
            }
            #[doc = "ADC Controlled by GPIO Pin"]
            #[inline(always)]
            pub fn gpio(self) -> &'a mut crate::W<REG> {
                self.variant(CONVTYPE::Gpio)
            }
            #[doc = "Software Single Conversion"]
            #[inline(always)]
            pub fn singl(self) -> &'a mut crate::W<REG> {
                self.variant(CONVTYPE::Singl)
            }
            #[doc = "Software Continue Conversion"]
            #[inline(always)]
            pub fn cont(self) -> &'a mut crate::W<REG> {
                self.variant(CONVTYPE::Cont)
            }
            #[doc = "PLA Conversion"]
            #[inline(always)]
            pub fn pla(self) -> &'a mut crate::W<REG> {
                self.variant(CONVTYPE::Pla)
            }
            #[doc = "GPT Triggered Conversion"]
            #[inline(always)]
            pub fn gpt(self) -> &'a mut crate::W<REG> {
                self.variant(CONVTYPE::Gpt)
            }
        }
        #[doc = "Field `CNVDMA` reader - DMA Request Enable for ADC Non-sequence Conversion"]
        pub type CNVDMA_R = crate::BitReader;
        #[doc = "Field `CNVDMA` writer - DMA Request Enable for ADC Non-sequence Conversion"]
        pub type CNVDMA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SEQDMA` reader - DMA Request Enable for ADC Sequence Conversion"]
        pub type SEQDMA_R = crate::BitReader;
        #[doc = "Field `SEQDMA` writer - DMA Request Enable for ADC Sequence Conversion"]
        pub type SEQDMA_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "PIN Conversion Mode Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PINMOD {
            #[doc = "0: CNV is Controlled by PIN Level"]
            PinLvl = 0,
            #[doc = "1: CNV is Controlled by PIN Edge"]
            PinEdge = 1,
        }
        impl From<PINMOD> for bool {
            #[inline(always)]
            fn from(variant: PINMOD) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PINMOD` reader - PIN Conversion Mode Selection"]
        pub type PINMOD_R = crate::BitReader<PINMOD>;
        impl PINMOD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PINMOD {
                match self.bits {
                    false => PINMOD::PinLvl,
                    true => PINMOD::PinEdge,
                }
            }
            #[doc = "CNV is Controlled by PIN Level"]
            #[inline(always)]
            pub fn is_pin_lvl(&self) -> bool {
                *self == PINMOD::PinLvl
            }
            #[doc = "CNV is Controlled by PIN Edge"]
            #[inline(always)]
            pub fn is_pin_edge(&self) -> bool {
                *self == PINMOD::PinEdge
            }
        }
        #[doc = "Field `PINMOD` writer - PIN Conversion Mode Selection"]
        pub type PINMOD_W<'a, REG> = crate::BitWriter<'a, REG, PINMOD>;
        impl<'a, REG> PINMOD_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "CNV is Controlled by PIN Level"]
            #[inline(always)]
            pub fn pin_lvl(self) -> &'a mut crate::W<REG> {
                self.variant(PINMOD::PinLvl)
            }
            #[doc = "CNV is Controlled by PIN Edge"]
            #[inline(always)]
            pub fn pin_edge(self) -> &'a mut crate::W<REG> {
                self.variant(PINMOD::PinEdge)
            }
        }
        #[doc = "Restart ADC, Reset Analog Part of ADC\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RESTARTADC {
            #[doc = "0: Not Power Down ADC"]
            Adcpu = 0,
            #[doc = "1: Power Down ADC"]
            Adcpd = 1,
        }
        impl From<RESTARTADC> for bool {
            #[inline(always)]
            fn from(variant: RESTARTADC) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RESTARTADC` reader - Restart ADC, Reset Analog Part of ADC"]
        pub type RESTARTADC_R = crate::BitReader<RESTARTADC>;
        impl RESTARTADC_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> RESTARTADC {
                match self.bits {
                    false => RESTARTADC::Adcpu,
                    true => RESTARTADC::Adcpd,
                }
            }
            #[doc = "Not Power Down ADC"]
            #[inline(always)]
            pub fn is_adcpu(&self) -> bool {
                *self == RESTARTADC::Adcpu
            }
            #[doc = "Power Down ADC"]
            #[inline(always)]
            pub fn is_adcpd(&self) -> bool {
                *self == RESTARTADC::Adcpd
            }
        }
        #[doc = "Field `RESTARTADC` writer - Restart ADC, Reset Analog Part of ADC"]
        pub type RESTARTADC_W<'a, REG> = crate::BitWriter<'a, REG, RESTARTADC>;
        impl<'a, REG> RESTARTADC_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Not Power Down ADC"]
            #[inline(always)]
            pub fn adcpu(self) -> &'a mut crate::W<REG> {
                self.variant(RESTARTADC::Adcpu)
            }
            #[doc = "Power Down ADC"]
            #[inline(always)]
            pub fn adcpd(self) -> &'a mut crate::W<REG> {
                self.variant(RESTARTADC::Adcpd)
            }
        }
        #[doc = "ADC Refbuf Power Down\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PDREFBUF {
            #[doc = "0: Normal Mode"]
            Refbufpu = 0,
            #[doc = "1: Power Down Reference Mode"]
            Refbufpd = 1,
        }
        impl From<PDREFBUF> for bool {
            #[inline(always)]
            fn from(variant: PDREFBUF) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PDREFBUF` reader - ADC Refbuf Power Down"]
        pub type PDREFBUF_R = crate::BitReader<PDREFBUF>;
        impl PDREFBUF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PDREFBUF {
                match self.bits {
                    false => PDREFBUF::Refbufpu,
                    true => PDREFBUF::Refbufpd,
                }
            }
            #[doc = "Normal Mode"]
            #[inline(always)]
            pub fn is_refbufpu(&self) -> bool {
                *self == PDREFBUF::Refbufpu
            }
            #[doc = "Power Down Reference Mode"]
            #[inline(always)]
            pub fn is_refbufpd(&self) -> bool {
                *self == PDREFBUF::Refbufpd
            }
        }
        #[doc = "Field `PDREFBUF` writer - ADC Refbuf Power Down"]
        pub type PDREFBUF_W<'a, REG> = crate::BitWriter<'a, REG, PDREFBUF>;
        impl<'a, REG> PDREFBUF_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Normal Mode"]
            #[inline(always)]
            pub fn refbufpu(self) -> &'a mut crate::W<REG> {
                self.variant(PDREFBUF::Refbufpu)
            }
            #[doc = "Power Down Reference Mode"]
            #[inline(always)]
            pub fn refbufpd(self) -> &'a mut crate::W<REG> {
                self.variant(PDREFBUF::Refbufpd)
            }
        }
        #[doc = "Select Whether Channel 29 is DVDD Channel or AVDD Channel\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum VDDSEL {
            #[doc = "0: Channel 29 is Half of DVDD Channel"]
            Dvdd = 0,
            #[doc = "1: Channel 29 is AVSS Channel"]
            Avss = 1,
        }
        impl From<VDDSEL> for bool {
            #[inline(always)]
            fn from(variant: VDDSEL) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VDDSEL` reader - Select Whether Channel 29 is DVDD Channel or AVDD Channel"]
        pub type VDDSEL_R = crate::BitReader<VDDSEL>;
        impl VDDSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> VDDSEL {
                match self.bits {
                    false => VDDSEL::Dvdd,
                    true => VDDSEL::Avss,
                }
            }
            #[doc = "Channel 29 is Half of DVDD Channel"]
            #[inline(always)]
            pub fn is_dvdd(&self) -> bool {
                *self == VDDSEL::Dvdd
            }
            #[doc = "Channel 29 is AVSS Channel"]
            #[inline(always)]
            pub fn is_avss(&self) -> bool {
                *self == VDDSEL::Avss
            }
        }
        #[doc = "Field `VDDSEL` writer - Select Whether Channel 29 is DVDD Channel or AVDD Channel"]
        pub type VDDSEL_W<'a, REG> = crate::BitWriter<'a, REG, VDDSEL>;
        impl<'a, REG> VDDSEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Channel 29 is Half of DVDD Channel"]
            #[inline(always)]
            pub fn dvdd(self) -> &'a mut crate::W<REG> {
                self.variant(VDDSEL::Dvdd)
            }
            #[doc = "Channel 29 is AVSS Channel"]
            #[inline(always)]
            pub fn avss(self) -> &'a mut crate::W<REG> {
                self.variant(VDDSEL::Avss)
            }
        }
        #[doc = "ADC Power Down\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PDADC {
            #[doc = "0: Not Power Down ADC"]
            Adcpu = 0,
            #[doc = "1: Power Down ADC"]
            Adcpd = 1,
        }
        impl From<PDADC> for bool {
            #[inline(always)]
            fn from(variant: PDADC) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PDADC` reader - ADC Power Down"]
        pub type PDADC_R = crate::BitReader<PDADC>;
        impl PDADC_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PDADC {
                match self.bits {
                    false => PDADC::Adcpu,
                    true => PDADC::Adcpd,
                }
            }
            #[doc = "Not Power Down ADC"]
            #[inline(always)]
            pub fn is_adcpu(&self) -> bool {
                *self == PDADC::Adcpu
            }
            #[doc = "Power Down ADC"]
            #[inline(always)]
            pub fn is_adcpd(&self) -> bool {
                *self == PDADC::Adcpd
            }
        }
        #[doc = "Field `PDADC` writer - ADC Power Down"]
        pub type PDADC_W<'a, REG> = crate::BitWriter<'a, REG, PDADC>;
        impl<'a, REG> PDADC_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Not Power Down ADC"]
            #[inline(always)]
            pub fn adcpu(self) -> &'a mut crate::W<REG> {
                self.variant(PDADC::Adcpu)
            }
            #[doc = "Power Down ADC"]
            #[inline(always)]
            pub fn adcpd(self) -> &'a mut crate::W<REG> {
                self.variant(PDADC::Adcpd)
            }
        }
        #[doc = "Oversampling Ratio\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OSR {
            #[doc = "0: Oversampling Disable"]
            OsrNs1 = 0,
            #[doc = "1: Oversampling X2"]
            Osr2 = 1,
            #[doc = "2: Oversampling X4"]
            Osr4 = 2,
            #[doc = "3: Oversampling X8"]
            Osr8 = 3,
            #[doc = "4: Oversampling X16"]
            Osr16 = 4,
            #[doc = "5: Oversampling X32"]
            OsrNs32 = 5,
            #[doc = "6: Oversampling Disable"]
            OsrNs64 = 6,
            #[doc = "7: Oversampling Disable"]
            OsrNs128 = 7,
        }
        impl From<OSR> for u8 {
            #[inline(always)]
            fn from(variant: OSR) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for OSR {
            type Ux = u8;
        }
        impl crate::IsEnum for OSR {}
        #[doc = "Field `OSR` reader - Oversampling Ratio"]
        pub type OSR_R = crate::FieldReader<OSR>;
        impl OSR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OSR {
                match self.bits {
                    0 => OSR::OsrNs1,
                    1 => OSR::Osr2,
                    2 => OSR::Osr4,
                    3 => OSR::Osr8,
                    4 => OSR::Osr16,
                    5 => OSR::OsrNs32,
                    6 => OSR::OsrNs64,
                    7 => OSR::OsrNs128,
                    _ => unreachable!(),
                }
            }
            #[doc = "Oversampling Disable"]
            #[inline(always)]
            pub fn is_osr_ns1(&self) -> bool {
                *self == OSR::OsrNs1
            }
            #[doc = "Oversampling X2"]
            #[inline(always)]
            pub fn is_osr2(&self) -> bool {
                *self == OSR::Osr2
            }
            #[doc = "Oversampling X4"]
            #[inline(always)]
            pub fn is_osr4(&self) -> bool {
                *self == OSR::Osr4
            }
            #[doc = "Oversampling X8"]
            #[inline(always)]
            pub fn is_osr8(&self) -> bool {
                *self == OSR::Osr8
            }
            #[doc = "Oversampling X16"]
            #[inline(always)]
            pub fn is_osr16(&self) -> bool {
                *self == OSR::Osr16
            }
            #[doc = "Oversampling X32"]
            #[inline(always)]
            pub fn is_osr_ns32(&self) -> bool {
                *self == OSR::OsrNs32
            }
            #[doc = "Oversampling Disable"]
            #[inline(always)]
            pub fn is_osr_ns64(&self) -> bool {
                *self == OSR::OsrNs64
            }
            #[doc = "Oversampling Disable"]
            #[inline(always)]
            pub fn is_osr_ns128(&self) -> bool {
                *self == OSR::OsrNs128
            }
        }
        #[doc = "Field `OSR` writer - Oversampling Ratio"]
        pub type OSR_W<'a, REG> = crate::FieldWriter<'a, REG, 3, OSR, crate::Safe>;
        impl<'a, REG> OSR_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Oversampling Disable"]
            #[inline(always)]
            pub fn osr_ns1(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::OsrNs1)
            }
            #[doc = "Oversampling X2"]
            #[inline(always)]
            pub fn osr2(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::Osr2)
            }
            #[doc = "Oversampling X4"]
            #[inline(always)]
            pub fn osr4(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::Osr4)
            }
            #[doc = "Oversampling X8"]
            #[inline(always)]
            pub fn osr8(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::Osr8)
            }
            #[doc = "Oversampling X16"]
            #[inline(always)]
            pub fn osr16(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::Osr16)
            }
            #[doc = "Oversampling X32"]
            #[inline(always)]
            pub fn osr_ns32(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::OsrNs32)
            }
            #[doc = "Oversampling Disable"]
            #[inline(always)]
            pub fn osr_ns64(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::OsrNs64)
            }
            #[doc = "Oversampling Disable"]
            #[inline(always)]
            pub fn osr_ns128(self) -> &'a mut crate::W<REG> {
                self.variant(OSR::OsrNs128)
            }
        }
        #[doc = "Field `CNVIRQEN` reader - Enable Conversion Interrupt Generation"]
        pub type CNVIRQEN_R = crate::BitReader;
        #[doc = "Field `CNVIRQEN` writer - Enable Conversion Interrupt Generation"]
        pub type CNVIRQEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `GPTEVENTEN` reader - Enable GPT Event to Trigger Conversion"]
        pub type GPTEVENTEN_R = crate::FieldReader;
        #[doc = "Field `GPTEVENTEN` writer - Enable GPT Event to Trigger Conversion"]
        pub type GPTEVENTEN_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        #[doc = "Mux Select GP Timer Trigger Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum GPTTRIGMD {
            #[doc = "0: Two Timeout Events Trigger One Conversion"]
            Md0 = 0,
            #[doc = "1: One Timeout Events Trigger One Conversion"]
            Md1 = 1,
        }
        impl From<GPTTRIGMD> for bool {
            #[inline(always)]
            fn from(variant: GPTTRIGMD) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `GPTTRIGMD` reader - Mux Select GP Timer Trigger Mode"]
        pub type GPTTRIGMD_R = crate::BitReader<GPTTRIGMD>;
        impl GPTTRIGMD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> GPTTRIGMD {
                match self.bits {
                    false => GPTTRIGMD::Md0,
                    true => GPTTRIGMD::Md1,
                }
            }
            #[doc = "Two Timeout Events Trigger One Conversion"]
            #[inline(always)]
            pub fn is_md0(&self) -> bool {
                *self == GPTTRIGMD::Md0
            }
            #[doc = "One Timeout Events Trigger One Conversion"]
            #[inline(always)]
            pub fn is_md1(&self) -> bool {
                *self == GPTTRIGMD::Md1
            }
        }
        #[doc = "Field `GPTTRIGMD` writer - Mux Select GP Timer Trigger Mode"]
        pub type GPTTRIGMD_W<'a, REG> = crate::BitWriter<'a, REG, GPTTRIGMD>;
        impl<'a, REG> GPTTRIGMD_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Two Timeout Events Trigger One Conversion"]
            #[inline(always)]
            pub fn md0(self) -> &'a mut crate::W<REG> {
                self.variant(GPTTRIGMD::Md0)
            }
            #[doc = "One Timeout Events Trigger One Conversion"]
            #[inline(always)]
            pub fn md1(self) -> &'a mut crate::W<REG> {
                self.variant(GPTTRIGMD::Md1)
            }
        }
        impl R {
            #[doc = "Bits 0:2 - ADC Conversion Type Selection"]
            #[inline(always)]
            pub fn convtype(&self) -> CONVTYPE_R {
                CONVTYPE_R::new((self.bits & 7) as u8)
            }
            #[doc = "Bit 3 - DMA Request Enable for ADC Non-sequence Conversion"]
            #[inline(always)]
            pub fn cnvdma(&self) -> CNVDMA_R {
                CNVDMA_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - DMA Request Enable for ADC Sequence Conversion"]
            #[inline(always)]
            pub fn seqdma(&self) -> SEQDMA_R {
                SEQDMA_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - PIN Conversion Mode Selection"]
            #[inline(always)]
            pub fn pinmod(&self) -> PINMOD_R {
                PINMOD_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Restart ADC, Reset Analog Part of ADC"]
            #[inline(always)]
            pub fn restartadc(&self) -> RESTARTADC_R {
                RESTARTADC_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - ADC Refbuf Power Down"]
            #[inline(always)]
            pub fn pdrefbuf(&self) -> PDREFBUF_R {
                PDREFBUF_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Select Whether Channel 29 is DVDD Channel or AVDD Channel"]
            #[inline(always)]
            pub fn vddsel(&self) -> VDDSEL_R {
                VDDSEL_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - ADC Power Down"]
            #[inline(always)]
            pub fn pdadc(&self) -> PDADC_R {
                PDADC_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bits 10:12 - Oversampling Ratio"]
            #[inline(always)]
            pub fn osr(&self) -> OSR_R {
                OSR_R::new(((self.bits >> 10) & 7) as u8)
            }
            #[doc = "Bit 14 - Enable Conversion Interrupt Generation"]
            #[inline(always)]
            pub fn cnvirqen(&self) -> CNVIRQEN_R {
                CNVIRQEN_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bits 15:19 - Enable GPT Event to Trigger Conversion"]
            #[inline(always)]
            pub fn gpteventen(&self) -> GPTEVENTEN_R {
                GPTEVENTEN_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            #[doc = "Bit 20 - Mux Select GP Timer Trigger Mode"]
            #[inline(always)]
            pub fn gpttrigmd(&self) -> GPTTRIGMD_R {
                GPTTRIGMD_R::new(((self.bits >> 20) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCCON")
                    .field("convtype", &self.convtype())
                    .field("cnvdma", &self.cnvdma())
                    .field("seqdma", &self.seqdma())
                    .field("pinmod", &self.pinmod())
                    .field("restartadc", &self.restartadc())
                    .field("pdrefbuf", &self.pdrefbuf())
                    .field("vddsel", &self.vddsel())
                    .field("pdadc", &self.pdadc())
                    .field("osr", &self.osr())
                    .field("cnvirqen", &self.cnvirqen())
                    .field("gpteventen", &self.gpteventen())
                    .field("gpttrigmd", &self.gpttrigmd())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:2 - ADC Conversion Type Selection"]
            #[inline(always)]
            pub fn convtype(&mut self) -> CONVTYPE_W<ADCCONrs> {
                CONVTYPE_W::new(self, 0)
            }
            #[doc = "Bit 3 - DMA Request Enable for ADC Non-sequence Conversion"]
            #[inline(always)]
            pub fn cnvdma(&mut self) -> CNVDMA_W<ADCCONrs> {
                CNVDMA_W::new(self, 3)
            }
            #[doc = "Bit 4 - DMA Request Enable for ADC Sequence Conversion"]
            #[inline(always)]
            pub fn seqdma(&mut self) -> SEQDMA_W<ADCCONrs> {
                SEQDMA_W::new(self, 4)
            }
            #[doc = "Bit 5 - PIN Conversion Mode Selection"]
            #[inline(always)]
            pub fn pinmod(&mut self) -> PINMOD_W<ADCCONrs> {
                PINMOD_W::new(self, 5)
            }
            #[doc = "Bit 6 - Restart ADC, Reset Analog Part of ADC"]
            #[inline(always)]
            pub fn restartadc(&mut self) -> RESTARTADC_W<ADCCONrs> {
                RESTARTADC_W::new(self, 6)
            }
            #[doc = "Bit 7 - ADC Refbuf Power Down"]
            #[inline(always)]
            pub fn pdrefbuf(&mut self) -> PDREFBUF_W<ADCCONrs> {
                PDREFBUF_W::new(self, 7)
            }
            #[doc = "Bit 8 - Select Whether Channel 29 is DVDD Channel or AVDD Channel"]
            #[inline(always)]
            pub fn vddsel(&mut self) -> VDDSEL_W<ADCCONrs> {
                VDDSEL_W::new(self, 8)
            }
            #[doc = "Bit 9 - ADC Power Down"]
            #[inline(always)]
            pub fn pdadc(&mut self) -> PDADC_W<ADCCONrs> {
                PDADC_W::new(self, 9)
            }
            #[doc = "Bits 10:12 - Oversampling Ratio"]
            #[inline(always)]
            pub fn osr(&mut self) -> OSR_W<ADCCONrs> {
                OSR_W::new(self, 10)
            }
            #[doc = "Bit 14 - Enable Conversion Interrupt Generation"]
            #[inline(always)]
            pub fn cnvirqen(&mut self) -> CNVIRQEN_W<ADCCONrs> {
                CNVIRQEN_W::new(self, 14)
            }
            #[doc = "Bits 15:19 - Enable GPT Event to Trigger Conversion"]
            #[inline(always)]
            pub fn gpteventen(&mut self) -> GPTEVENTEN_W<ADCCONrs> {
                GPTEVENTEN_W::new(self, 15)
            }
            #[doc = "Bit 20 - Mux Select GP Timer Trigger Mode"]
            #[inline(always)]
            pub fn gpttrigmd(&mut self) -> GPTTRIGMD_W<ADCCONrs> {
                GPTTRIGMD_W::new(self, 20)
            }
        }
        #[doc = "ADC Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCON)"]
        pub struct ADCCONrs;
        impl crate::RegisterSpec for ADCCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adccon::R`](R) reader structure"]
        impl crate::Readable for ADCCONrs {}
        #[doc = "`write(|w| ..)` method takes [`adccon::W`](W) writer structure"]
        impl crate::Writable for ADCCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCCON to value 0x0200"]
        impl crate::Resettable for ADCCONrs {
            const RESET_VALUE: u32 = 0x0200;
        }
    }
    #[doc = "PREBUFCON (rw) register accessor: Pre-charge Buffer Control\n\nYou can [`read`](crate::Reg::read) this register and get [`prebufcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prebufcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:PREBUFCON)\n\nFor information about available fields see [`mod@prebufcon`]
module"]
    pub type PREBUFCON = crate::Reg<prebufcon::PREBUFCONrs>;
    #[doc = "Pre-charge Buffer Control"]
    pub mod prebufcon {
        #[doc = "Register `PREBUFCON` reader"]
        pub type R = crate::R<PREBUFCONrs>;
        #[doc = "Register `PREBUFCON` writer"]
        pub type W = crate::W<PREBUFCONrs>;
        #[doc = "Field `PRGBYPP` reader - Bypass P Channel Pre_buf"]
        pub type PRGBYPP_R = crate::BitReader;
        #[doc = "Field `PRGBYPP` writer - Bypass P Channel Pre_buf"]
        pub type PRGBYPP_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PRGBYPN` reader - Bypass N Channel Pre_buf"]
        pub type PRGBYPN_R = crate::BitReader;
        #[doc = "Field `PRGBYPN` writer - Bypass N Channel Pre_buf"]
        pub type PRGBYPN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Bypass P Channel Pre_buf"]
            #[inline(always)]
            pub fn prgbypp(&self) -> PRGBYPP_R {
                PRGBYPP_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Bypass N Channel Pre_buf"]
            #[inline(always)]
            pub fn prgbypn(&self) -> PRGBYPN_R {
                PRGBYPN_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PREBUFCON")
                    .field("prgbypp", &self.prgbypp())
                    .field("prgbypn", &self.prgbypn())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Bypass P Channel Pre_buf"]
            #[inline(always)]
            pub fn prgbypp(&mut self) -> PRGBYPP_W<PREBUFCONrs> {
                PRGBYPP_W::new(self, 0)
            }
            #[doc = "Bit 1 - Bypass N Channel Pre_buf"]
            #[inline(always)]
            pub fn prgbypn(&mut self) -> PRGBYPN_W<PREBUFCONrs> {
                PRGBYPN_W::new(self, 1)
            }
        }
        #[doc = "Pre-charge Buffer Control\n\nYou can [`read`](crate::Reg::read) this register and get [`prebufcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prebufcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:PREBUFCON)"]
        pub struct PREBUFCONrs;
        impl crate::RegisterSpec for PREBUFCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`prebufcon::R`](R) reader structure"]
        impl crate::Readable for PREBUFCONrs {}
        #[doc = "`write(|w| ..)` method takes [`prebufcon::W`](W) writer structure"]
        impl crate::Writable for PREBUFCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PREBUFCON to value 0x03"]
        impl crate::Resettable for PREBUFCONrs {
            const RESET_VALUE: u32 = 0x03;
        }
    }
    #[doc = "ADCCNVC (rw) register accessor: ADC Conversion Cycle for Positive Input Channels\n\nYou can [`read`](crate::Reg::read) this register and get [`adccnvc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccnvc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCNVC)\n\nFor information about available fields see [`mod@adccnvc`]
module"]
    pub type ADCCNVC = crate::Reg<adccnvc::ADCCNVCrs>;
    #[doc = "ADC Conversion Cycle for Positive Input Channels"]
    pub mod adccnvc {
        #[doc = "Register `ADCCNVC` reader"]
        pub type R = crate::R<ADCCNVCrs>;
        #[doc = "Register `ADCCNVC` writer"]
        pub type W = crate::W<ADCCNVCrs>;
        #[doc = "Field `CNVC` reader - CNV Frequency Configuration for Positive Channels"]
        pub type CNVC_R = crate::FieldReader<u32>;
        #[doc = "Field `CNVC` writer - CNV Frequency Configuration for Positive Channels"]
        pub type CNVC_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - CNV Frequency Configuration for Positive Channels"]
            #[inline(always)]
            pub fn cnvc(&self) -> CNVC_R {
                CNVC_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCCNVC")
                    .field("cnvc", &self.cnvc())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - CNV Frequency Configuration for Positive Channels"]
            #[inline(always)]
            pub fn cnvc(&mut self) -> CNVC_W<ADCCNVCrs> {
                CNVC_W::new(self, 0)
            }
        }
        #[doc = "ADC Conversion Cycle for Positive Input Channels\n\nYou can [`read`](crate::Reg::read) this register and get [`adccnvc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccnvc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCNVC)"]
        pub struct ADCCNVCrs;
        impl crate::RegisterSpec for ADCCNVCrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adccnvc::R`](R) reader structure"]
        impl crate::Readable for ADCCNVCrs {}
        #[doc = "`write(|w| ..)` method takes [`adccnvc::W`](W) writer structure"]
        impl crate::Writable for ADCCNVCrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCCNVC to value 0x10"]
        impl crate::Resettable for ADCCNVCrs {
            const RESET_VALUE: u32 = 0x10;
        }
    }
    #[doc = "ADCCNVCSLOW (rw) register accessor: ADC Conversion Cycle for Positive Input Channels\n\nYou can [`read`](crate::Reg::read) this register and get [`adccnvcslow::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccnvcslow::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCNVCSLOW)\n\nFor information about available fields see [`mod@adccnvcslow`]
module"]
    pub type ADCCNVCSLOW = crate::Reg<adccnvcslow::ADCCNVCSLOWrs>;
    #[doc = "ADC Conversion Cycle for Positive Input Channels"]
    pub mod adccnvcslow {
        #[doc = "Register `ADCCNVCSLOW` reader"]
        pub type R = crate::R<ADCCNVCSLOWrs>;
        #[doc = "Register `ADCCNVCSLOW` writer"]
        pub type W = crate::W<ADCCNVCSLOWrs>;
        #[doc = "Field `CNVCSLOW` reader - CNV Frequency Configuration for 100KSPS Channels"]
        pub type CNVCSLOW_R = crate::FieldReader<u32>;
        #[doc = "Field `CNVCSLOW` writer - CNV Frequency Configuration for 100KSPS Channels"]
        pub type CNVCSLOW_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:31 - CNV Frequency Configuration for 100KSPS Channels"]
            #[inline(always)]
            pub fn cnvcslow(&self) -> CNVCSLOW_R {
                CNVCSLOW_R::new(self.bits)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCCNVCSLOW")
                    .field("cnvcslow", &self.cnvcslow())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:31 - CNV Frequency Configuration for 100KSPS Channels"]
            #[inline(always)]
            pub fn cnvcslow(&mut self) -> CNVCSLOW_W<ADCCNVCSLOWrs> {
                CNVCSLOW_W::new(self, 0)
            }
        }
        #[doc = "ADC Conversion Cycle for Positive Input Channels\n\nYou can [`read`](crate::Reg::read) this register and get [`adccnvcslow::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccnvcslow::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCNVCSLOW)"]
        pub struct ADCCNVCSLOWrs;
        impl crate::RegisterSpec for ADCCNVCSLOWrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adccnvcslow::R`](R) reader structure"]
        impl crate::Readable for ADCCNVCSLOWrs {}
        #[doc = "`write(|w| ..)` method takes [`adccnvcslow::W`](W) writer structure"]
        impl crate::Writable for ADCCNVCSLOWrs {
            type Safety = crate::Safe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCCNVCSLOW to value 0x0140"]
        impl crate::Resettable for ADCCNVCSLOWrs {
            const RESET_VALUE: u32 = 0x0140;
        }
    }
    #[doc = "ADCCHA (rw) register accessor: ADC Channel Select\n\nYou can [`read`](crate::Reg::read) this register and get [`adccha::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccha::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCHA)\n\nFor information about available fields see [`mod@adccha`]
module"]
    pub type ADCCHA = crate::Reg<adccha::ADCCHArs>;
    #[doc = "ADC Channel Select"]
    pub mod adccha {
        #[doc = "Register `ADCCHA` reader"]
        pub type R = crate::R<ADCCHArs>;
        #[doc = "Register `ADCCHA` writer"]
        pub type W = crate::W<ADCCHArs>;
        #[doc = "ADC P Channel Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ADCCP {
            #[doc = "0: Unknown"]
            Ain0 = 0,
            #[doc = "1: Unknown"]
            Ain1 = 1,
            #[doc = "2: Unknown"]
            Ain2 = 2,
            #[doc = "3: Unknown"]
            Ain3 = 3,
            #[doc = "4: Unknown"]
            Ain4 = 4,
            #[doc = "5: Unknown"]
            Ain5 = 5,
            #[doc = "6: Unknown"]
            Ain6 = 6,
            #[doc = "7: Unknown"]
            Ain7 = 7,
            #[doc = "8: Unknown"]
            Ain8 = 8,
            #[doc = "9: Unknown"]
            Ain9 = 9,
            #[doc = "10: Unknown"]
            Ain10 = 10,
            #[doc = "11: Unknown"]
            Ain11 = 11,
            #[doc = "12: Unknown"]
            Ain12 = 12,
            #[doc = "13: Unknown"]
            Ain13 = 13,
            #[doc = "14: Unknown"]
            Ain14 = 14,
            #[doc = "15: Unknown"]
            Ain15 = 15,
            #[doc = "16: Unknown"]
            Pga0 = 16,
            #[doc = "17: Unknown"]
            Pga1 = 17,
            #[doc = "18: Unknown"]
            Pga2 = 18,
            #[doc = "19: Unknown"]
            Pga3 = 19,
            #[doc = "20: Unknown"]
            Tempsns = 20,
            #[doc = "21: Unknown"]
            Avdddiv2 = 21,
            #[doc = "22: Unknown"]
            Iovdd0div2 = 22,
            #[doc = "23: Unknown"]
            Iovdd1 = 23,
            #[doc = "24: Unknown"]
            Hvtia0 = 24,
            #[doc = "25: Unknown"]
            Hvtia1 = 25,
            #[doc = "26: Unknown"]
            Hvtia2 = 26,
            #[doc = "27: Unknown"]
            Hvtia3 = 27,
            #[doc = "28: Unknown"]
            Hvtia4 = 28,
            #[doc = "29: Unknown"]
            Avss = 29,
        }
        impl From<ADCCP> for u8 {
            #[inline(always)]
            fn from(variant: ADCCP) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for ADCCP {
            type Ux = u8;
        }
        impl crate::IsEnum for ADCCP {}
        #[doc = "Field `ADCCP` reader - ADC P Channel Selection"]
        pub type ADCCP_R = crate::FieldReader<ADCCP>;
        impl ADCCP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<ADCCP> {
                match self.bits {
                    0 => Some(ADCCP::Ain0),
                    1 => Some(ADCCP::Ain1),
                    2 => Some(ADCCP::Ain2),
                    3 => Some(ADCCP::Ain3),
                    4 => Some(ADCCP::Ain4),
                    5 => Some(ADCCP::Ain5),
                    6 => Some(ADCCP::Ain6),
                    7 => Some(ADCCP::Ain7),
                    8 => Some(ADCCP::Ain8),
                    9 => Some(ADCCP::Ain9),
                    10 => Some(ADCCP::Ain10),
                    11 => Some(ADCCP::Ain11),
                    12 => Some(ADCCP::Ain12),
                    13 => Some(ADCCP::Ain13),
                    14 => Some(ADCCP::Ain14),
                    15 => Some(ADCCP::Ain15),
                    16 => Some(ADCCP::Pga0),
                    17 => Some(ADCCP::Pga1),
                    18 => Some(ADCCP::Pga2),
                    19 => Some(ADCCP::Pga3),
                    20 => Some(ADCCP::Tempsns),
                    21 => Some(ADCCP::Avdddiv2),
                    22 => Some(ADCCP::Iovdd0div2),
                    23 => Some(ADCCP::Iovdd1),
                    24 => Some(ADCCP::Hvtia0),
                    25 => Some(ADCCP::Hvtia1),
                    26 => Some(ADCCP::Hvtia2),
                    27 => Some(ADCCP::Hvtia3),
                    28 => Some(ADCCP::Hvtia4),
                    29 => Some(ADCCP::Avss),
                    _ => None,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain0(&self) -> bool {
                *self == ADCCP::Ain0
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain1(&self) -> bool {
                *self == ADCCP::Ain1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain2(&self) -> bool {
                *self == ADCCP::Ain2
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain3(&self) -> bool {
                *self == ADCCP::Ain3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain4(&self) -> bool {
                *self == ADCCP::Ain4
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain5(&self) -> bool {
                *self == ADCCP::Ain5
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain6(&self) -> bool {
                *self == ADCCP::Ain6
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain7(&self) -> bool {
                *self == ADCCP::Ain7
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain8(&self) -> bool {
                *self == ADCCP::Ain8
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain9(&self) -> bool {
                *self == ADCCP::Ain9
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain10(&self) -> bool {
                *self == ADCCP::Ain10
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain11(&self) -> bool {
                *self == ADCCP::Ain11
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain12(&self) -> bool {
                *self == ADCCP::Ain12
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain13(&self) -> bool {
                *self == ADCCP::Ain13
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain14(&self) -> bool {
                *self == ADCCP::Ain14
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain15(&self) -> bool {
                *self == ADCCP::Ain15
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_pga0(&self) -> bool {
                *self == ADCCP::Pga0
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_pga1(&self) -> bool {
                *self == ADCCP::Pga1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_pga2(&self) -> bool {
                *self == ADCCP::Pga2
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_pga3(&self) -> bool {
                *self == ADCCP::Pga3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_tempsns(&self) -> bool {
                *self == ADCCP::Tempsns
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_avdddiv2(&self) -> bool {
                *self == ADCCP::Avdddiv2
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_iovdd0div2(&self) -> bool {
                *self == ADCCP::Iovdd0div2
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_iovdd1(&self) -> bool {
                *self == ADCCP::Iovdd1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_hvtia0(&self) -> bool {
                *self == ADCCP::Hvtia0
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_hvtia1(&self) -> bool {
                *self == ADCCP::Hvtia1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_hvtia2(&self) -> bool {
                *self == ADCCP::Hvtia2
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_hvtia3(&self) -> bool {
                *self == ADCCP::Hvtia3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_hvtia4(&self) -> bool {
                *self == ADCCP::Hvtia4
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_avss(&self) -> bool {
                *self == ADCCP::Avss
            }
        }
        #[doc = "Field `ADCCP` writer - ADC P Channel Selection"]
        pub type ADCCP_W<'a, REG> = crate::FieldWriter<'a, REG, 5, ADCCP>;
        impl<'a, REG> ADCCP_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain0(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain0)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain1(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain2(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain2)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain3(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain4(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain4)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain5(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain5)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain6(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain6)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain7(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain7)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain8(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain8)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain9(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain9)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain10(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain10)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain11(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain11)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain12(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain12)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain13(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain13)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain14(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain14)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain15(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Ain15)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn pga0(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Pga0)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn pga1(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Pga1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn pga2(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Pga2)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn pga3(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Pga3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn tempsns(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Tempsns)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn avdddiv2(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Avdddiv2)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn iovdd0div2(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Iovdd0div2)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn iovdd1(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Iovdd1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn hvtia0(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Hvtia0)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn hvtia1(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Hvtia1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn hvtia2(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Hvtia2)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn hvtia3(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Hvtia3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn hvtia4(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Hvtia4)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn avss(self) -> &'a mut crate::W<REG> {
                self.variant(ADCCP::Avss)
            }
        }
        #[doc = "Field `ADCCN` reader - ADC N Channel Selection"]
        pub type ADCCN_R = crate::FieldReader;
        #[doc = "Field `ADCCN` writer - ADC N Channel Selection"]
        pub type ADCCN_W<'a, REG> = crate::FieldWriter<'a, REG, 4, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:4 - ADC P Channel Selection"]
            #[inline(always)]
            pub fn adccp(&self) -> ADCCP_R {
                ADCCP_R::new((self.bits & 0x1f) as u8)
            }
            #[doc = "Bits 5:8 - ADC N Channel Selection"]
            #[inline(always)]
            pub fn adccn(&self) -> ADCCN_R {
                ADCCN_R::new(((self.bits >> 5) & 0x0f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCCHA")
                    .field("adccp", &self.adccp())
                    .field("adccn", &self.adccn())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:4 - ADC P Channel Selection"]
            #[inline(always)]
            pub fn adccp(&mut self) -> ADCCP_W<ADCCHArs> {
                ADCCP_W::new(self, 0)
            }
            #[doc = "Bits 5:8 - ADC N Channel Selection"]
            #[inline(always)]
            pub fn adccn(&mut self) -> ADCCN_W<ADCCHArs> {
                ADCCN_W::new(self, 5)
            }
        }
        #[doc = "ADC Channel Select\n\nYou can [`read`](crate::Reg::read) this register and get [`adccha::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccha::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCHA)"]
        pub struct ADCCHArs;
        impl crate::RegisterSpec for ADCCHArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adccha::R`](R) reader structure"]
        impl crate::Readable for ADCCHArs {}
        #[doc = "`write(|w| ..)` method takes [`adccha::W`](W) writer structure"]
        impl crate::Writable for ADCCHArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCCHA to value 0"]
        impl crate::Resettable for ADCCHArs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCIRQSTAT (rw) register accessor: ADC Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`adcirqstat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcirqstat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCIRQSTAT)\n\nFor information about available fields see [`mod@adcirqstat`]
module"]
    pub type ADCIRQSTAT = crate::Reg<adcirqstat::ADCIRQSTATrs>;
    #[doc = "ADC Interrupt Status"]
    pub mod adcirqstat {
        #[doc = "Register `ADCIRQSTAT` reader"]
        pub type R = crate::R<ADCIRQSTATrs>;
        #[doc = "Register `ADCIRQSTAT` writer"]
        pub type W = crate::W<ADCIRQSTATrs>;
        #[doc = "Single Conversion IRQ Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CNVIRQSTAT {
            #[doc = "0: Interrupt Clear"]
            Irqclr = 0,
            #[doc = "1: Interrupt Set"]
            Irqset = 1,
        }
        impl From<CNVIRQSTAT> for bool {
            #[inline(always)]
            fn from(variant: CNVIRQSTAT) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CNVIRQSTAT` reader - Single Conversion IRQ Status"]
        pub type CNVIRQSTAT_R = crate::BitReader<CNVIRQSTAT>;
        impl CNVIRQSTAT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CNVIRQSTAT {
                match self.bits {
                    false => CNVIRQSTAT::Irqclr,
                    true => CNVIRQSTAT::Irqset,
                }
            }
            #[doc = "Interrupt Clear"]
            #[inline(always)]
            pub fn is_irqclr(&self) -> bool {
                *self == CNVIRQSTAT::Irqclr
            }
            #[doc = "Interrupt Set"]
            #[inline(always)]
            pub fn is_irqset(&self) -> bool {
                *self == CNVIRQSTAT::Irqset
            }
        }
        #[doc = "Sequence Conversion IRQ Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SEQIRQSTAT {
            #[doc = "0: Interrupt Clear"]
            Irqclr = 0,
            #[doc = "1: Interrupt Set"]
            Irqset = 1,
        }
        impl From<SEQIRQSTAT> for bool {
            #[inline(always)]
            fn from(variant: SEQIRQSTAT) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SEQIRQSTAT` reader - Sequence Conversion IRQ Status"]
        pub type SEQIRQSTAT_R = crate::BitReader<SEQIRQSTAT>;
        impl SEQIRQSTAT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SEQIRQSTAT {
                match self.bits {
                    false => SEQIRQSTAT::Irqclr,
                    true => SEQIRQSTAT::Irqset,
                }
            }
            #[doc = "Interrupt Clear"]
            #[inline(always)]
            pub fn is_irqclr(&self) -> bool {
                *self == SEQIRQSTAT::Irqclr
            }
            #[doc = "Interrupt Set"]
            #[inline(always)]
            pub fn is_irqset(&self) -> bool {
                *self == SEQIRQSTAT::Irqset
            }
        }
        impl R {
            #[doc = "Bit 0 - Single Conversion IRQ Status"]
            #[inline(always)]
            pub fn cnvirqstat(&self) -> CNVIRQSTAT_R {
                CNVIRQSTAT_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Sequence Conversion IRQ Status"]
            #[inline(always)]
            pub fn seqirqstat(&self) -> SEQIRQSTAT_R {
                SEQIRQSTAT_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCIRQSTAT")
                    .field("cnvirqstat", &self.cnvirqstat())
                    .field("seqirqstat", &self.seqirqstat())
                    .finish()
            }
        }
        impl W {}
        #[doc = "ADC Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`adcirqstat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcirqstat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCIRQSTAT)"]
        pub struct ADCIRQSTATrs;
        impl crate::RegisterSpec for ADCIRQSTATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcirqstat::R`](R) reader structure"]
        impl crate::Readable for ADCIRQSTATrs {}
        #[doc = "`write(|w| ..)` method takes [`adcirqstat::W`](W) writer structure"]
        impl crate::Writable for ADCIRQSTATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCIRQSTAT to value 0"]
        impl crate::Resettable for ADCIRQSTATrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCSEQ (rw) register accessor: ADC Sequencer Control\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseq::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseq::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQ)\n\nFor information about available fields see [`mod@adcseq`]
module"]
    pub type ADCSEQ = crate::Reg<adcseq::ADCSEQrs>;
    #[doc = "ADC Sequencer Control"]
    pub mod adcseq {
        #[doc = "Register `ADCSEQ` reader"]
        pub type R = crate::R<ADCSEQrs>;
        #[doc = "Register `ADCSEQ` writer"]
        pub type W = crate::W<ADCSEQrs>;
        #[doc = "Field `SEQEN` writer - Sequence Enable"]
        pub type SEQEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SEQREN` writer - Sequence Restart"]
        pub type SEQREN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Sequence Stall\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SEQSTL {
            #[doc = "0: Running Sequence"]
            Seqnstall = 0,
            #[doc = "1: Stalling Sequence"]
            Seqstall = 1,
        }
        impl From<SEQSTL> for bool {
            #[inline(always)]
            fn from(variant: SEQSTL) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SEQSTL` reader - Sequence Stall"]
        pub type SEQSTL_R = crate::BitReader<SEQSTL>;
        impl SEQSTL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SEQSTL {
                match self.bits {
                    false => SEQSTL::Seqnstall,
                    true => SEQSTL::Seqstall,
                }
            }
            #[doc = "Running Sequence"]
            #[inline(always)]
            pub fn is_seqnstall(&self) -> bool {
                *self == SEQSTL::Seqnstall
            }
            #[doc = "Stalling Sequence"]
            #[inline(always)]
            pub fn is_seqstall(&self) -> bool {
                *self == SEQSTL::Seqstall
            }
        }
        #[doc = "Field `SEQSTL` writer - Sequence Stall"]
        pub type SEQSTL_W<'a, REG> = crate::BitWriter<'a, REG, SEQSTL>;
        impl<'a, REG> SEQSTL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Running Sequence"]
            #[inline(always)]
            pub fn seqnstall(self) -> &'a mut crate::W<REG> {
                self.variant(SEQSTL::Seqnstall)
            }
            #[doc = "Stalling Sequence"]
            #[inline(always)]
            pub fn seqstall(self) -> &'a mut crate::W<REG> {
                self.variant(SEQSTL::Seqstall)
            }
        }
        #[doc = "Field `SEQIRQEN` reader - Enable Sequencer Interrupt Generation"]
        pub type SEQIRQEN_R = crate::BitReader;
        #[doc = "Field `SEQIRQEN` writer - Enable Sequencer Interrupt Generation"]
        pub type SEQIRQEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 2 - Sequence Stall"]
            #[inline(always)]
            pub fn seqstl(&self) -> SEQSTL_R {
                SEQSTL_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Enable Sequencer Interrupt Generation"]
            #[inline(always)]
            pub fn seqirqen(&self) -> SEQIRQEN_R {
                SEQIRQEN_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCSEQ")
                    .field("seqstl", &self.seqstl())
                    .field("seqirqen", &self.seqirqen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Sequence Enable"]
            #[inline(always)]
            pub fn seqen(&mut self) -> SEQEN_W<ADCSEQrs> {
                SEQEN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Sequence Restart"]
            #[inline(always)]
            pub fn seqren(&mut self) -> SEQREN_W<ADCSEQrs> {
                SEQREN_W::new(self, 1)
            }
            #[doc = "Bit 2 - Sequence Stall"]
            #[inline(always)]
            pub fn seqstl(&mut self) -> SEQSTL_W<ADCSEQrs> {
                SEQSTL_W::new(self, 2)
            }
            #[doc = "Bit 3 - Enable Sequencer Interrupt Generation"]
            #[inline(always)]
            pub fn seqirqen(&mut self) -> SEQIRQEN_W<ADCSEQrs> {
                SEQIRQEN_W::new(self, 3)
            }
        }
        #[doc = "ADC Sequencer Control\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseq::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseq::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQ)"]
        pub struct ADCSEQrs;
        impl crate::RegisterSpec for ADCSEQrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcseq::R`](R) reader structure"]
        impl crate::Readable for ADCSEQrs {}
        #[doc = "`write(|w| ..)` method takes [`adcseq::W`](W) writer structure"]
        impl crate::Writable for ADCSEQrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCSEQ to value 0"]
        impl crate::Resettable for ADCSEQrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCSEQC (rw) register accessor: ADC Sequencer Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQC)\n\nFor information about available fields see [`mod@adcseqc`]
module"]
    pub type ADCSEQC = crate::Reg<adcseqc::ADCSEQCrs>;
    #[doc = "ADC Sequencer Configuration"]
    pub mod adcseqc {
        #[doc = "Register `ADCSEQC` reader"]
        pub type R = crate::R<ADCSEQCrs>;
        #[doc = "Register `ADCSEQC` writer"]
        pub type W = crate::W<ADCSEQCrs>;
        #[doc = "Field `SEQT` reader - Repeat Sequence Interval"]
        pub type SEQT_R = crate::FieldReader;
        #[doc = "Field `SEQT` writer - Repeat Sequence Interval"]
        pub type SEQT_W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Repeat Sequence Interval"]
            #[inline(always)]
            pub fn seqt(&self) -> SEQT_R {
                SEQT_R::new((self.bits & 0xff) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCSEQC")
                    .field("seqt", &self.seqt())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Repeat Sequence Interval"]
            #[inline(always)]
            pub fn seqt(&mut self) -> SEQT_W<ADCSEQCrs> {
                SEQT_W::new(self, 0)
            }
        }
        #[doc = "ADC Sequencer Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQC)"]
        pub struct ADCSEQCrs;
        impl crate::RegisterSpec for ADCSEQCrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcseqc::R`](R) reader structure"]
        impl crate::Readable for ADCSEQCrs {}
        #[doc = "`write(|w| ..)` method takes [`adcseqc::W`](W) writer structure"]
        impl crate::Writable for ADCSEQCrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCSEQC to value 0"]
        impl crate::Resettable for ADCSEQCrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCSEQS (rw) register accessor: ADC Sequencer Status\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqs::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqs::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQS)\n\nFor information about available fields see [`mod@adcseqs`]
module"]
    pub type ADCSEQS = crate::Reg<adcseqs::ADCSEQSrs>;
    #[doc = "ADC Sequencer Status"]
    pub mod adcseqs {
        #[doc = "Register `ADCSEQS` reader"]
        pub type R = crate::R<ADCSEQSrs>;
        #[doc = "Register `ADCSEQS` writer"]
        pub type W = crate::W<ADCSEQSrs>;
        #[doc = "ADC Conversion Idle/Busy Flag\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CNVSTAT {
            #[doc = "0: ADC Conversion is Idle"]
            Cnvidle = 0,
            #[doc = "1: ADC Conversion is Busy"]
            Cnvbusy = 1,
        }
        impl From<CNVSTAT> for bool {
            #[inline(always)]
            fn from(variant: CNVSTAT) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CNVSTAT` reader - ADC Conversion Idle/Busy Flag"]
        pub type CNVSTAT_R = crate::BitReader<CNVSTAT>;
        impl CNVSTAT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CNVSTAT {
                match self.bits {
                    false => CNVSTAT::Cnvidle,
                    true => CNVSTAT::Cnvbusy,
                }
            }
            #[doc = "ADC Conversion is Idle"]
            #[inline(always)]
            pub fn is_cnvidle(&self) -> bool {
                *self == CNVSTAT::Cnvidle
            }
            #[doc = "ADC Conversion is Busy"]
            #[inline(always)]
            pub fn is_cnvbusy(&self) -> bool {
                *self == CNVSTAT::Cnvbusy
            }
        }
        #[doc = "Stall Sequencer Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SEQSTLSTAT {
            #[doc = "0: Sequence Still Run"]
            Seqnstop = 0,
            #[doc = "1: Sequence Has Stalled"]
            Seqstop = 1,
        }
        impl From<SEQSTLSTAT> for bool {
            #[inline(always)]
            fn from(variant: SEQSTLSTAT) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SEQSTLSTAT` reader - Stall Sequencer Status"]
        pub type SEQSTLSTAT_R = crate::BitReader<SEQSTLSTAT>;
        impl SEQSTLSTAT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SEQSTLSTAT {
                match self.bits {
                    false => SEQSTLSTAT::Seqnstop,
                    true => SEQSTLSTAT::Seqstop,
                }
            }
            #[doc = "Sequence Still Run"]
            #[inline(always)]
            pub fn is_seqnstop(&self) -> bool {
                *self == SEQSTLSTAT::Seqnstop
            }
            #[doc = "Sequence Has Stalled"]
            #[inline(always)]
            pub fn is_seqstop(&self) -> bool {
                *self == SEQSTLSTAT::Seqstop
            }
        }
        #[doc = "Sequencer Status\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SEQSTAT {
            #[doc = "0: Sequence is Idle"]
            Seqnbusy = 0,
            #[doc = "1: Sequence is Busy"]
            Seqbusy = 1,
        }
        impl From<SEQSTAT> for bool {
            #[inline(always)]
            fn from(variant: SEQSTAT) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SEQSTAT` reader - Sequencer Status"]
        pub type SEQSTAT_R = crate::BitReader<SEQSTAT>;
        impl SEQSTAT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> SEQSTAT {
                match self.bits {
                    false => SEQSTAT::Seqnbusy,
                    true => SEQSTAT::Seqbusy,
                }
            }
            #[doc = "Sequence is Idle"]
            #[inline(always)]
            pub fn is_seqnbusy(&self) -> bool {
                *self == SEQSTAT::Seqnbusy
            }
            #[doc = "Sequence is Busy"]
            #[inline(always)]
            pub fn is_seqbusy(&self) -> bool {
                *self == SEQSTAT::Seqbusy
            }
        }
        impl R {
            #[doc = "Bit 0 - ADC Conversion Idle/Busy Flag"]
            #[inline(always)]
            pub fn cnvstat(&self) -> CNVSTAT_R {
                CNVSTAT_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Stall Sequencer Status"]
            #[inline(always)]
            pub fn seqstlstat(&self) -> SEQSTLSTAT_R {
                SEQSTLSTAT_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Sequencer Status"]
            #[inline(always)]
            pub fn seqstat(&self) -> SEQSTAT_R {
                SEQSTAT_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCSEQS")
                    .field("cnvstat", &self.cnvstat())
                    .field("seqstlstat", &self.seqstlstat())
                    .field("seqstat", &self.seqstat())
                    .finish()
            }
        }
        impl W {}
        #[doc = "ADC Sequencer Status\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqs::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqs::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQS)"]
        pub struct ADCSEQSrs;
        impl crate::RegisterSpec for ADCSEQSrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcseqs::R`](R) reader structure"]
        impl crate::Readable for ADCSEQSrs {}
        #[doc = "`write(|w| ..)` method takes [`adcseqs::W`](W) writer structure"]
        impl crate::Writable for ADCSEQSrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCSEQS to value 0"]
        impl crate::Resettable for ADCSEQSrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCSEQCH (rw) register accessor: ADC Sequencer Channel 0\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqch::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqch::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQCH)\n\nFor information about available fields see [`mod@adcseqch`]
module"]
    pub type ADCSEQCH = crate::Reg<adcseqch::ADCSEQCHrs>;
    #[doc = "ADC Sequencer Channel 0"]
    pub mod adcseqch {
        #[doc = "Register `ADCSEQCH` reader"]
        pub type R = crate::R<ADCSEQCHrs>;
        #[doc = "Register `ADCSEQCH` writer"]
        pub type W = crate::W<ADCSEQCHrs>;
        #[doc = "Field `SEQCH` reader - Sequence Channel Selection"]
        pub type SEQCH_R = crate::FieldReader<u32>;
        #[doc = "Field `SEQCH` writer - Sequence Channel Selection"]
        pub type SEQCH_W<'a, REG> = crate::FieldWriter<'a, REG, 30, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:29 - Sequence Channel Selection"]
            #[inline(always)]
            pub fn seqch(&self) -> SEQCH_R {
                SEQCH_R::new(self.bits & 0x3fff_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCSEQCH")
                    .field("seqch", &self.seqch())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:29 - Sequence Channel Selection"]
            #[inline(always)]
            pub fn seqch(&mut self) -> SEQCH_W<ADCSEQCHrs> {
                SEQCH_W::new(self, 0)
            }
        }
        #[doc = "ADC Sequencer Channel 0\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqch::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqch::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQCH)"]
        pub struct ADCSEQCHrs;
        impl crate::RegisterSpec for ADCSEQCHrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcseqch::R`](R) reader structure"]
        impl crate::Readable for ADCSEQCHrs {}
        #[doc = "`write(|w| ..)` method takes [`adcseqch::W`](W) writer structure"]
        impl crate::Writable for ADCSEQCHrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCSEQCH to value 0"]
        impl crate::Resettable for ADCSEQCHrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCSEQCHMUX0 (rw) register accessor: ADC Sequencer Channel 1\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqchmux0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqchmux0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQCHMUX0)\n\nFor information about available fields see [`mod@adcseqchmux0`]
module"]
    pub type ADCSEQCHMUX0 = crate::Reg<adcseqchmux0::ADCSEQCHMUX0rs>;
    #[doc = "ADC Sequencer Channel 1"]
    pub mod adcseqchmux0 {
        #[doc = "Register `ADCSEQCHMUX0` reader"]
        pub type R = crate::R<ADCSEQCHMUX0rs>;
        #[doc = "Register `ADCSEQCHMUX0` writer"]
        pub type W = crate::W<ADCSEQCHMUX0rs>;
        #[doc = "When AIN0 is P Ch. N Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DIF0 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
            #[doc = "2: Unknown"]
            Ain1 = 2,
            #[doc = "3: Unknown"]
            Ain3 = 3,
            #[doc = "4: Unknown"]
            Ain5 = 4,
            #[doc = "5: Unknown"]
            Ain7 = 5,
            #[doc = "6: Unknown"]
            Ain9 = 6,
            #[doc = "7: Unknown"]
            Ain11 = 7,
            #[doc = "8: Unknown"]
            Ain13 = 8,
            #[doc = "9: Unknown"]
            Ain15 = 9,
        }
        impl From<DIF0> for u8 {
            #[inline(always)]
            fn from(variant: DIF0) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DIF0 {
            type Ux = u8;
        }
        impl crate::IsEnum for DIF0 {}
        #[doc = "Field `DIF0` reader - When AIN0 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF0_R = crate::FieldReader<DIF0>;
        impl DIF0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DIF0> {
                match self.bits {
                    0 => Some(DIF0::Refn),
                    1 => Some(DIF0::Refp),
                    2 => Some(DIF0::Ain1),
                    3 => Some(DIF0::Ain3),
                    4 => Some(DIF0::Ain5),
                    5 => Some(DIF0::Ain7),
                    6 => Some(DIF0::Ain9),
                    7 => Some(DIF0::Ain11),
                    8 => Some(DIF0::Ain13),
                    9 => Some(DIF0::Ain15),
                    _ => None,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF0::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF0::Refp
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain1(&self) -> bool {
                *self == DIF0::Ain1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain3(&self) -> bool {
                *self == DIF0::Ain3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain5(&self) -> bool {
                *self == DIF0::Ain5
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain7(&self) -> bool {
                *self == DIF0::Ain7
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain9(&self) -> bool {
                *self == DIF0::Ain9
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain11(&self) -> bool {
                *self == DIF0::Ain11
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain13(&self) -> bool {
                *self == DIF0::Ain13
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain15(&self) -> bool {
                *self == DIF0::Ain15
            }
        }
        #[doc = "Field `DIF0` writer - When AIN0 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF0_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DIF0>;
        impl<'a, REG> DIF0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Refp)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain1(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Ain1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain3(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Ain3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain5(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Ain5)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain7(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Ain7)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain9(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Ain9)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain11(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Ain11)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain13(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Ain13)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain15(self) -> &'a mut crate::W<REG> {
                self.variant(DIF0::Ain15)
            }
        }
        #[doc = "When AIN1 is N Ch. P Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIF1 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
        }
        impl From<DIF1> for bool {
            #[inline(always)]
            fn from(variant: DIF1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIF1` reader - When AIN1 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF1_R = crate::BitReader<DIF1>;
        impl DIF1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DIF1 {
                match self.bits {
                    false => DIF1::Refn,
                    true => DIF1::Refp,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF1::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF1::Refp
            }
        }
        #[doc = "Field `DIF1` writer - When AIN1 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF1_W<'a, REG> = crate::BitWriter<'a, REG, DIF1>;
        impl<'a, REG> DIF1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF1::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF1::Refp)
            }
        }
        #[doc = "When AIN2 is P Ch. N Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DIF2 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
            #[doc = "2: Unknown"]
            Ain1 = 2,
            #[doc = "3: Unknown"]
            Ain3 = 3,
            #[doc = "4: Unknown"]
            Ain5 = 4,
            #[doc = "5: Unknown"]
            Ain7 = 5,
            #[doc = "6: Unknown"]
            Ain9 = 6,
            #[doc = "7: Unknown"]
            Ain11 = 7,
            #[doc = "8: Unknown"]
            Ain13 = 8,
            #[doc = "9: Unknown"]
            Ain15 = 9,
        }
        impl From<DIF2> for u8 {
            #[inline(always)]
            fn from(variant: DIF2) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DIF2 {
            type Ux = u8;
        }
        impl crate::IsEnum for DIF2 {}
        #[doc = "Field `DIF2` reader - When AIN2 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF2_R = crate::FieldReader<DIF2>;
        impl DIF2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DIF2> {
                match self.bits {
                    0 => Some(DIF2::Refn),
                    1 => Some(DIF2::Refp),
                    2 => Some(DIF2::Ain1),
                    3 => Some(DIF2::Ain3),
                    4 => Some(DIF2::Ain5),
                    5 => Some(DIF2::Ain7),
                    6 => Some(DIF2::Ain9),
                    7 => Some(DIF2::Ain11),
                    8 => Some(DIF2::Ain13),
                    9 => Some(DIF2::Ain15),
                    _ => None,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF2::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF2::Refp
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain1(&self) -> bool {
                *self == DIF2::Ain1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain3(&self) -> bool {
                *self == DIF2::Ain3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain5(&self) -> bool {
                *self == DIF2::Ain5
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain7(&self) -> bool {
                *self == DIF2::Ain7
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain9(&self) -> bool {
                *self == DIF2::Ain9
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain11(&self) -> bool {
                *self == DIF2::Ain11
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain13(&self) -> bool {
                *self == DIF2::Ain13
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain15(&self) -> bool {
                *self == DIF2::Ain15
            }
        }
        #[doc = "Field `DIF2` writer - When AIN2 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF2_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DIF2>;
        impl<'a, REG> DIF2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Refp)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain1(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Ain1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain3(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Ain3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain5(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Ain5)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain7(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Ain7)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain9(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Ain9)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain11(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Ain11)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain13(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Ain13)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain15(self) -> &'a mut crate::W<REG> {
                self.variant(DIF2::Ain15)
            }
        }
        #[doc = "When AIN3 is N Ch. P Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIF3 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
        }
        impl From<DIF3> for bool {
            #[inline(always)]
            fn from(variant: DIF3) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIF3` reader - When AIN3 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF3_R = crate::BitReader<DIF3>;
        impl DIF3_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DIF3 {
                match self.bits {
                    false => DIF3::Refn,
                    true => DIF3::Refp,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF3::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF3::Refp
            }
        }
        #[doc = "Field `DIF3` writer - When AIN3 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF3_W<'a, REG> = crate::BitWriter<'a, REG, DIF3>;
        impl<'a, REG> DIF3_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF3::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF3::Refp)
            }
        }
        #[doc = "When AIN4 is P Ch. N Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DIF4 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
            #[doc = "2: Unknown"]
            Ain1 = 2,
            #[doc = "3: Unknown"]
            Ain3 = 3,
            #[doc = "4: Unknown"]
            Ain5 = 4,
            #[doc = "5: Unknown"]
            Ain7 = 5,
            #[doc = "6: Unknown"]
            Ain9 = 6,
            #[doc = "7: Unknown"]
            Ain11 = 7,
            #[doc = "8: Unknown"]
            Ain13 = 8,
            #[doc = "9: Unknown"]
            Ain15 = 9,
        }
        impl From<DIF4> for u8 {
            #[inline(always)]
            fn from(variant: DIF4) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DIF4 {
            type Ux = u8;
        }
        impl crate::IsEnum for DIF4 {}
        #[doc = "Field `DIF4` reader - When AIN4 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF4_R = crate::FieldReader<DIF4>;
        impl DIF4_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DIF4> {
                match self.bits {
                    0 => Some(DIF4::Refn),
                    1 => Some(DIF4::Refp),
                    2 => Some(DIF4::Ain1),
                    3 => Some(DIF4::Ain3),
                    4 => Some(DIF4::Ain5),
                    5 => Some(DIF4::Ain7),
                    6 => Some(DIF4::Ain9),
                    7 => Some(DIF4::Ain11),
                    8 => Some(DIF4::Ain13),
                    9 => Some(DIF4::Ain15),
                    _ => None,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF4::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF4::Refp
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain1(&self) -> bool {
                *self == DIF4::Ain1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain3(&self) -> bool {
                *self == DIF4::Ain3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain5(&self) -> bool {
                *self == DIF4::Ain5
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain7(&self) -> bool {
                *self == DIF4::Ain7
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain9(&self) -> bool {
                *self == DIF4::Ain9
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain11(&self) -> bool {
                *self == DIF4::Ain11
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain13(&self) -> bool {
                *self == DIF4::Ain13
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain15(&self) -> bool {
                *self == DIF4::Ain15
            }
        }
        #[doc = "Field `DIF4` writer - When AIN4 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF4_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DIF4>;
        impl<'a, REG> DIF4_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Refp)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain1(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Ain1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain3(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Ain3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain5(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Ain5)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain7(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Ain7)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain9(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Ain9)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain11(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Ain11)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain13(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Ain13)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain15(self) -> &'a mut crate::W<REG> {
                self.variant(DIF4::Ain15)
            }
        }
        #[doc = "When AIN5 is N Ch. P Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIF5 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
        }
        impl From<DIF5> for bool {
            #[inline(always)]
            fn from(variant: DIF5) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIF5` reader - When AIN5 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF5_R = crate::BitReader<DIF5>;
        impl DIF5_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DIF5 {
                match self.bits {
                    false => DIF5::Refn,
                    true => DIF5::Refp,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF5::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF5::Refp
            }
        }
        #[doc = "Field `DIF5` writer - When AIN5 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF5_W<'a, REG> = crate::BitWriter<'a, REG, DIF5>;
        impl<'a, REG> DIF5_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF5::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF5::Refp)
            }
        }
        #[doc = "When AIN6 is P Ch. N Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DIF6 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
            #[doc = "2: Unknown"]
            Ain1 = 2,
            #[doc = "3: Unknown"]
            Ain3 = 3,
            #[doc = "4: Unknown"]
            Ain5 = 4,
            #[doc = "5: Unknown"]
            Ain7 = 5,
            #[doc = "6: Unknown"]
            Ain9 = 6,
            #[doc = "7: Unknown"]
            Ain11 = 7,
            #[doc = "8: Unknown"]
            Ain13 = 8,
            #[doc = "9: Unknown"]
            Ain15 = 9,
        }
        impl From<DIF6> for u8 {
            #[inline(always)]
            fn from(variant: DIF6) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DIF6 {
            type Ux = u8;
        }
        impl crate::IsEnum for DIF6 {}
        #[doc = "Field `DIF6` reader - When AIN6 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF6_R = crate::FieldReader<DIF6>;
        impl DIF6_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DIF6> {
                match self.bits {
                    0 => Some(DIF6::Refn),
                    1 => Some(DIF6::Refp),
                    2 => Some(DIF6::Ain1),
                    3 => Some(DIF6::Ain3),
                    4 => Some(DIF6::Ain5),
                    5 => Some(DIF6::Ain7),
                    6 => Some(DIF6::Ain9),
                    7 => Some(DIF6::Ain11),
                    8 => Some(DIF6::Ain13),
                    9 => Some(DIF6::Ain15),
                    _ => None,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF6::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF6::Refp
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain1(&self) -> bool {
                *self == DIF6::Ain1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain3(&self) -> bool {
                *self == DIF6::Ain3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain5(&self) -> bool {
                *self == DIF6::Ain5
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain7(&self) -> bool {
                *self == DIF6::Ain7
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain9(&self) -> bool {
                *self == DIF6::Ain9
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain11(&self) -> bool {
                *self == DIF6::Ain11
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain13(&self) -> bool {
                *self == DIF6::Ain13
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain15(&self) -> bool {
                *self == DIF6::Ain15
            }
        }
        #[doc = "Field `DIF6` writer - When AIN6 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF6_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DIF6>;
        impl<'a, REG> DIF6_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Refp)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain1(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Ain1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain3(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Ain3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain5(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Ain5)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain7(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Ain7)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain9(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Ain9)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain11(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Ain11)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain13(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Ain13)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain15(self) -> &'a mut crate::W<REG> {
                self.variant(DIF6::Ain15)
            }
        }
        #[doc = "When AIN7 is N Ch. P Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIF7 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
        }
        impl From<DIF7> for bool {
            #[inline(always)]
            fn from(variant: DIF7) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIF7` reader - When AIN7 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF7_R = crate::BitReader<DIF7>;
        impl DIF7_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DIF7 {
                match self.bits {
                    false => DIF7::Refn,
                    true => DIF7::Refp,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF7::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF7::Refp
            }
        }
        #[doc = "Field `DIF7` writer - When AIN7 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF7_W<'a, REG> = crate::BitWriter<'a, REG, DIF7>;
        impl<'a, REG> DIF7_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF7::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF7::Refp)
            }
        }
        #[doc = "When AIN8 is P Ch. N Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DIF8 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
            #[doc = "2: Unknown"]
            Ain1 = 2,
            #[doc = "3: Unknown"]
            Ain3 = 3,
            #[doc = "4: Unknown"]
            Ain5 = 4,
            #[doc = "5: Unknown"]
            Ain7 = 5,
            #[doc = "6: Unknown"]
            Ain9 = 6,
            #[doc = "7: Unknown"]
            Ain11 = 7,
            #[doc = "8: Unknown"]
            Ain13 = 8,
            #[doc = "9: Unknown"]
            Ain15 = 9,
        }
        impl From<DIF8> for u8 {
            #[inline(always)]
            fn from(variant: DIF8) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DIF8 {
            type Ux = u8;
        }
        impl crate::IsEnum for DIF8 {}
        #[doc = "Field `DIF8` reader - When AIN8 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF8_R = crate::FieldReader<DIF8>;
        impl DIF8_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DIF8> {
                match self.bits {
                    0 => Some(DIF8::Refn),
                    1 => Some(DIF8::Refp),
                    2 => Some(DIF8::Ain1),
                    3 => Some(DIF8::Ain3),
                    4 => Some(DIF8::Ain5),
                    5 => Some(DIF8::Ain7),
                    6 => Some(DIF8::Ain9),
                    7 => Some(DIF8::Ain11),
                    8 => Some(DIF8::Ain13),
                    9 => Some(DIF8::Ain15),
                    _ => None,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF8::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF8::Refp
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain1(&self) -> bool {
                *self == DIF8::Ain1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain3(&self) -> bool {
                *self == DIF8::Ain3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain5(&self) -> bool {
                *self == DIF8::Ain5
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain7(&self) -> bool {
                *self == DIF8::Ain7
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain9(&self) -> bool {
                *self == DIF8::Ain9
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain11(&self) -> bool {
                *self == DIF8::Ain11
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain13(&self) -> bool {
                *self == DIF8::Ain13
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain15(&self) -> bool {
                *self == DIF8::Ain15
            }
        }
        #[doc = "Field `DIF8` writer - When AIN8 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF8_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DIF8>;
        impl<'a, REG> DIF8_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Refp)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain1(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Ain1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain3(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Ain3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain5(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Ain5)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain7(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Ain7)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain9(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Ain9)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain11(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Ain11)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain13(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Ain13)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain15(self) -> &'a mut crate::W<REG> {
                self.variant(DIF8::Ain15)
            }
        }
        #[doc = "When AIN9 is N Ch. P Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIF9 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
        }
        impl From<DIF9> for bool {
            #[inline(always)]
            fn from(variant: DIF9) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIF9` reader - When AIN9 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF9_R = crate::BitReader<DIF9>;
        impl DIF9_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DIF9 {
                match self.bits {
                    false => DIF9::Refn,
                    true => DIF9::Refp,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF9::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF9::Refp
            }
        }
        #[doc = "Field `DIF9` writer - When AIN9 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF9_W<'a, REG> = crate::BitWriter<'a, REG, DIF9>;
        impl<'a, REG> DIF9_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF9::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF9::Refp)
            }
        }
        #[doc = "When AIN10 is P Ch. N Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DIF10 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
            #[doc = "2: Unknown"]
            Ain1 = 2,
            #[doc = "3: Unknown"]
            Ain3 = 3,
            #[doc = "4: Unknown"]
            Ain5 = 4,
            #[doc = "5: Unknown"]
            Ain7 = 5,
            #[doc = "6: Unknown"]
            Ain9 = 6,
            #[doc = "7: Unknown"]
            Ain11 = 7,
            #[doc = "8: Unknown"]
            Ain13 = 8,
            #[doc = "9: Unknown"]
            Ain15 = 9,
        }
        impl From<DIF10> for u8 {
            #[inline(always)]
            fn from(variant: DIF10) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DIF10 {
            type Ux = u8;
        }
        impl crate::IsEnum for DIF10 {}
        #[doc = "Field `DIF10` reader - When AIN10 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF10_R = crate::FieldReader<DIF10>;
        impl DIF10_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DIF10> {
                match self.bits {
                    0 => Some(DIF10::Refn),
                    1 => Some(DIF10::Refp),
                    2 => Some(DIF10::Ain1),
                    3 => Some(DIF10::Ain3),
                    4 => Some(DIF10::Ain5),
                    5 => Some(DIF10::Ain7),
                    6 => Some(DIF10::Ain9),
                    7 => Some(DIF10::Ain11),
                    8 => Some(DIF10::Ain13),
                    9 => Some(DIF10::Ain15),
                    _ => None,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF10::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF10::Refp
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain1(&self) -> bool {
                *self == DIF10::Ain1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain3(&self) -> bool {
                *self == DIF10::Ain3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain5(&self) -> bool {
                *self == DIF10::Ain5
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain7(&self) -> bool {
                *self == DIF10::Ain7
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain9(&self) -> bool {
                *self == DIF10::Ain9
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain11(&self) -> bool {
                *self == DIF10::Ain11
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain13(&self) -> bool {
                *self == DIF10::Ain13
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain15(&self) -> bool {
                *self == DIF10::Ain15
            }
        }
        #[doc = "Field `DIF10` writer - When AIN10 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF10_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DIF10>;
        impl<'a, REG> DIF10_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Refp)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain1(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Ain1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain3(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Ain3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain5(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Ain5)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain7(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Ain7)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain9(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Ain9)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain11(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Ain11)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain13(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Ain13)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain15(self) -> &'a mut crate::W<REG> {
                self.variant(DIF10::Ain15)
            }
        }
        #[doc = "When AIN11 is N Ch. P Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIF11 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
        }
        impl From<DIF11> for bool {
            #[inline(always)]
            fn from(variant: DIF11) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIF11` reader - When AIN11 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF11_R = crate::BitReader<DIF11>;
        impl DIF11_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DIF11 {
                match self.bits {
                    false => DIF11::Refn,
                    true => DIF11::Refp,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF11::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF11::Refp
            }
        }
        #[doc = "Field `DIF11` writer - When AIN11 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF11_W<'a, REG> = crate::BitWriter<'a, REG, DIF11>;
        impl<'a, REG> DIF11_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF11::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF11::Refp)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - When AIN0 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif0(&self) -> DIF0_R {
                DIF0_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bit 4 - When AIN1 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif1(&self) -> DIF1_R {
                DIF1_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:8 - When AIN2 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif2(&self) -> DIF2_R {
                DIF2_R::new(((self.bits >> 5) & 0x0f) as u8)
            }
            #[doc = "Bit 9 - When AIN3 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif3(&self) -> DIF3_R {
                DIF3_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bits 10:13 - When AIN4 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif4(&self) -> DIF4_R {
                DIF4_R::new(((self.bits >> 10) & 0x0f) as u8)
            }
            #[doc = "Bit 14 - When AIN5 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif5(&self) -> DIF5_R {
                DIF5_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bits 15:18 - When AIN6 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif6(&self) -> DIF6_R {
                DIF6_R::new(((self.bits >> 15) & 0x0f) as u8)
            }
            #[doc = "Bit 19 - When AIN7 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif7(&self) -> DIF7_R {
                DIF7_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bits 20:23 - When AIN8 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif8(&self) -> DIF8_R {
                DIF8_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bit 24 - When AIN9 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif9(&self) -> DIF9_R {
                DIF9_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bits 25:28 - When AIN10 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif10(&self) -> DIF10_R {
                DIF10_R::new(((self.bits >> 25) & 0x0f) as u8)
            }
            #[doc = "Bit 29 - When AIN11 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif11(&self) -> DIF11_R {
                DIF11_R::new(((self.bits >> 29) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCSEQCHMUX0")
                    .field("dif0", &self.dif0())
                    .field("dif1", &self.dif1())
                    .field("dif2", &self.dif2())
                    .field("dif3", &self.dif3())
                    .field("dif4", &self.dif4())
                    .field("dif5", &self.dif5())
                    .field("dif6", &self.dif6())
                    .field("dif7", &self.dif7())
                    .field("dif8", &self.dif8())
                    .field("dif9", &self.dif9())
                    .field("dif10", &self.dif10())
                    .field("dif11", &self.dif11())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:3 - When AIN0 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif0(&mut self) -> DIF0_W<ADCSEQCHMUX0rs> {
                DIF0_W::new(self, 0)
            }
            #[doc = "Bit 4 - When AIN1 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif1(&mut self) -> DIF1_W<ADCSEQCHMUX0rs> {
                DIF1_W::new(self, 4)
            }
            #[doc = "Bits 5:8 - When AIN2 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif2(&mut self) -> DIF2_W<ADCSEQCHMUX0rs> {
                DIF2_W::new(self, 5)
            }
            #[doc = "Bit 9 - When AIN3 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif3(&mut self) -> DIF3_W<ADCSEQCHMUX0rs> {
                DIF3_W::new(self, 9)
            }
            #[doc = "Bits 10:13 - When AIN4 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif4(&mut self) -> DIF4_W<ADCSEQCHMUX0rs> {
                DIF4_W::new(self, 10)
            }
            #[doc = "Bit 14 - When AIN5 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif5(&mut self) -> DIF5_W<ADCSEQCHMUX0rs> {
                DIF5_W::new(self, 14)
            }
            #[doc = "Bits 15:18 - When AIN6 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif6(&mut self) -> DIF6_W<ADCSEQCHMUX0rs> {
                DIF6_W::new(self, 15)
            }
            #[doc = "Bit 19 - When AIN7 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif7(&mut self) -> DIF7_W<ADCSEQCHMUX0rs> {
                DIF7_W::new(self, 19)
            }
            #[doc = "Bits 20:23 - When AIN8 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif8(&mut self) -> DIF8_W<ADCSEQCHMUX0rs> {
                DIF8_W::new(self, 20)
            }
            #[doc = "Bit 24 - When AIN9 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif9(&mut self) -> DIF9_W<ADCSEQCHMUX0rs> {
                DIF9_W::new(self, 24)
            }
            #[doc = "Bits 25:28 - When AIN10 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif10(&mut self) -> DIF10_W<ADCSEQCHMUX0rs> {
                DIF10_W::new(self, 25)
            }
            #[doc = "Bit 29 - When AIN11 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif11(&mut self) -> DIF11_W<ADCSEQCHMUX0rs> {
                DIF11_W::new(self, 29)
            }
        }
        #[doc = "ADC Sequencer Channel 1\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqchmux0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqchmux0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQCHMUX0)"]
        pub struct ADCSEQCHMUX0rs;
        impl crate::RegisterSpec for ADCSEQCHMUX0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcseqchmux0::R`](R) reader structure"]
        impl crate::Readable for ADCSEQCHMUX0rs {}
        #[doc = "`write(|w| ..)` method takes [`adcseqchmux0::W`](W) writer structure"]
        impl crate::Writable for ADCSEQCHMUX0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCSEQCHMUX0 to value 0"]
        impl crate::Resettable for ADCSEQCHMUX0rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCSEQCHMUX1 (rw) register accessor: ADC Sequencer Channel 1\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqchmux1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqchmux1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQCHMUX1)\n\nFor information about available fields see [`mod@adcseqchmux1`]
module"]
    pub type ADCSEQCHMUX1 = crate::Reg<adcseqchmux1::ADCSEQCHMUX1rs>;
    #[doc = "ADC Sequencer Channel 1"]
    pub mod adcseqchmux1 {
        #[doc = "Register `ADCSEQCHMUX1` reader"]
        pub type R = crate::R<ADCSEQCHMUX1rs>;
        #[doc = "Register `ADCSEQCHMUX1` writer"]
        pub type W = crate::W<ADCSEQCHMUX1rs>;
        #[doc = "When AIN12 is P Ch. N Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DIF12 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
            #[doc = "2: Unknown"]
            Ain1 = 2,
            #[doc = "3: Unknown"]
            Ain3 = 3,
            #[doc = "4: Unknown"]
            Ain5 = 4,
            #[doc = "5: Unknown"]
            Ain7 = 5,
            #[doc = "6: Unknown"]
            Ain9 = 6,
            #[doc = "7: Unknown"]
            Ain11 = 7,
            #[doc = "8: Unknown"]
            Ain13 = 8,
            #[doc = "9: Unknown"]
            Ain15 = 9,
        }
        impl From<DIF12> for u8 {
            #[inline(always)]
            fn from(variant: DIF12) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DIF12 {
            type Ux = u8;
        }
        impl crate::IsEnum for DIF12 {}
        #[doc = "Field `DIF12` reader - When AIN12 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF12_R = crate::FieldReader<DIF12>;
        impl DIF12_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DIF12> {
                match self.bits {
                    0 => Some(DIF12::Refn),
                    1 => Some(DIF12::Refp),
                    2 => Some(DIF12::Ain1),
                    3 => Some(DIF12::Ain3),
                    4 => Some(DIF12::Ain5),
                    5 => Some(DIF12::Ain7),
                    6 => Some(DIF12::Ain9),
                    7 => Some(DIF12::Ain11),
                    8 => Some(DIF12::Ain13),
                    9 => Some(DIF12::Ain15),
                    _ => None,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF12::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF12::Refp
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain1(&self) -> bool {
                *self == DIF12::Ain1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain3(&self) -> bool {
                *self == DIF12::Ain3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain5(&self) -> bool {
                *self == DIF12::Ain5
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain7(&self) -> bool {
                *self == DIF12::Ain7
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain9(&self) -> bool {
                *self == DIF12::Ain9
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain11(&self) -> bool {
                *self == DIF12::Ain11
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain13(&self) -> bool {
                *self == DIF12::Ain13
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain15(&self) -> bool {
                *self == DIF12::Ain15
            }
        }
        #[doc = "Field `DIF12` writer - When AIN12 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF12_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DIF12>;
        impl<'a, REG> DIF12_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Refp)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain1(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Ain1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain3(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Ain3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain5(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Ain5)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain7(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Ain7)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain9(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Ain9)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain11(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Ain11)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain13(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Ain13)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain15(self) -> &'a mut crate::W<REG> {
                self.variant(DIF12::Ain15)
            }
        }
        #[doc = "When AIN13 is N Ch. P Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIF13 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
        }
        impl From<DIF13> for bool {
            #[inline(always)]
            fn from(variant: DIF13) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIF13` reader - When AIN13 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF13_R = crate::BitReader<DIF13>;
        impl DIF13_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DIF13 {
                match self.bits {
                    false => DIF13::Refn,
                    true => DIF13::Refp,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF13::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF13::Refp
            }
        }
        #[doc = "Field `DIF13` writer - When AIN13 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF13_W<'a, REG> = crate::BitWriter<'a, REG, DIF13>;
        impl<'a, REG> DIF13_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF13::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF13::Refp)
            }
        }
        #[doc = "When AIN14 is P Ch. N Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DIF14 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
            #[doc = "2: Unknown"]
            Ain1 = 2,
            #[doc = "3: Unknown"]
            Ain3 = 3,
            #[doc = "4: Unknown"]
            Ain5 = 4,
            #[doc = "5: Unknown"]
            Ain7 = 5,
            #[doc = "6: Unknown"]
            Ain9 = 6,
            #[doc = "7: Unknown"]
            Ain11 = 7,
            #[doc = "8: Unknown"]
            Ain13 = 8,
            #[doc = "9: Unknown"]
            Ain15 = 9,
        }
        impl From<DIF14> for u8 {
            #[inline(always)]
            fn from(variant: DIF14) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for DIF14 {
            type Ux = u8;
        }
        impl crate::IsEnum for DIF14 {}
        #[doc = "Field `DIF14` reader - When AIN14 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF14_R = crate::FieldReader<DIF14>;
        impl DIF14_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<DIF14> {
                match self.bits {
                    0 => Some(DIF14::Refn),
                    1 => Some(DIF14::Refp),
                    2 => Some(DIF14::Ain1),
                    3 => Some(DIF14::Ain3),
                    4 => Some(DIF14::Ain5),
                    5 => Some(DIF14::Ain7),
                    6 => Some(DIF14::Ain9),
                    7 => Some(DIF14::Ain11),
                    8 => Some(DIF14::Ain13),
                    9 => Some(DIF14::Ain15),
                    _ => None,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF14::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF14::Refp
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain1(&self) -> bool {
                *self == DIF14::Ain1
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain3(&self) -> bool {
                *self == DIF14::Ain3
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain5(&self) -> bool {
                *self == DIF14::Ain5
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain7(&self) -> bool {
                *self == DIF14::Ain7
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain9(&self) -> bool {
                *self == DIF14::Ain9
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain11(&self) -> bool {
                *self == DIF14::Ain11
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain13(&self) -> bool {
                *self == DIF14::Ain13
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_ain15(&self) -> bool {
                *self == DIF14::Ain15
            }
        }
        #[doc = "Field `DIF14` writer - When AIN14 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
        pub type DIF14_W<'a, REG> = crate::FieldWriter<'a, REG, 4, DIF14>;
        impl<'a, REG> DIF14_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Refp)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain1(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Ain1)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain3(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Ain3)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain5(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Ain5)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain7(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Ain7)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain9(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Ain9)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain11(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Ain11)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain13(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Ain13)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn ain15(self) -> &'a mut crate::W<REG> {
                self.variant(DIF14::Ain15)
            }
        }
        #[doc = "When AIN15 is N Ch. P Ch. Mux Selection in Sequencer Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIF15 {
            #[doc = "0: Unknown"]
            Refn = 0,
            #[doc = "1: Unknown"]
            Refp = 1,
        }
        impl From<DIF15> for bool {
            #[inline(always)]
            fn from(variant: DIF15) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIF15` reader - When AIN15 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF15_R = crate::BitReader<DIF15>;
        impl DIF15_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DIF15 {
                match self.bits {
                    false => DIF15::Refn,
                    true => DIF15::Refp,
                }
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refn(&self) -> bool {
                *self == DIF15::Refn
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn is_refp(&self) -> bool {
                *self == DIF15::Refp
            }
        }
        #[doc = "Field `DIF15` writer - When AIN15 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
        pub type DIF15_W<'a, REG> = crate::BitWriter<'a, REG, DIF15>;
        impl<'a, REG> DIF15_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refn(self) -> &'a mut crate::W<REG> {
                self.variant(DIF15::Refn)
            }
            #[doc = "Unknown"]
            #[inline(always)]
            pub fn refp(self) -> &'a mut crate::W<REG> {
                self.variant(DIF15::Refp)
            }
        }
        impl R {
            #[doc = "Bits 0:3 - When AIN12 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif12(&self) -> DIF12_R {
                DIF12_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bit 4 - When AIN13 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif13(&self) -> DIF13_R {
                DIF13_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:8 - When AIN14 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif14(&self) -> DIF14_R {
                DIF14_R::new(((self.bits >> 5) & 0x0f) as u8)
            }
            #[doc = "Bit 9 - When AIN15 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif15(&self) -> DIF15_R {
                DIF15_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCSEQCHMUX1")
                    .field("dif12", &self.dif12())
                    .field("dif13", &self.dif13())
                    .field("dif14", &self.dif14())
                    .field("dif15", &self.dif15())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:3 - When AIN12 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif12(&mut self) -> DIF12_W<ADCSEQCHMUX1rs> {
                DIF12_W::new(self, 0)
            }
            #[doc = "Bit 4 - When AIN13 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif13(&mut self) -> DIF13_W<ADCSEQCHMUX1rs> {
                DIF13_W::new(self, 4)
            }
            #[doc = "Bits 5:8 - When AIN14 is P Ch. N Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif14(&mut self) -> DIF14_W<ADCSEQCHMUX1rs> {
                DIF14_W::new(self, 5)
            }
            #[doc = "Bit 9 - When AIN15 is N Ch. P Ch. Mux Selection in Sequencer Mode"]
            #[inline(always)]
            pub fn dif15(&mut self) -> DIF15_W<ADCSEQCHMUX1rs> {
                DIF15_W::new(self, 9)
            }
        }
        #[doc = "ADC Sequencer Channel 1\n\nYou can [`read`](crate::Reg::read) this register and get [`adcseqchmux1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcseqchmux1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCSEQCHMUX1)"]
        pub struct ADCSEQCHMUX1rs;
        impl crate::RegisterSpec for ADCSEQCHMUX1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcseqchmux1::R`](R) reader structure"]
        impl crate::Readable for ADCSEQCHMUX1rs {}
        #[doc = "`write(|w| ..)` method takes [`adcseqchmux1::W`](W) writer structure"]
        impl crate::Writable for ADCSEQCHMUX1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCSEQCHMUX1 to value 0"]
        impl crate::Resettable for ADCSEQCHMUX1rs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCCMP (rw) register accessor: Digital Comparator 0 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMP)\n\nFor information about available fields see [`mod@adccmp`]
module"]
    pub type ADCCMP = crate::Reg<adccmp::ADCCMPrs>;
    #[doc = "Digital Comparator 0 Configuration"]
    pub mod adccmp {
        #[doc = "Register `ADCCMP` reader"]
        pub type R = crate::R<ADCCMPrs>;
        #[doc = "Register `ADCCMP` writer"]
        pub type W = crate::W<ADCCMPrs>;
        #[doc = "Field `EN` reader - Digital Comparator Enable"]
        pub type EN_R = crate::BitReader;
        #[doc = "Field `EN` writer - Digital Comparator Enable"]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMPDIR` reader - Select Digital Comparator Direction"]
        pub type CMPDIR_R = crate::BitReader;
        #[doc = "Field `CMPDIR` writer - Select Digital Comparator Direction"]
        pub type CMPDIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `THR` reader - Compare Threshold"]
        pub type THR_R = crate::FieldReader<u16>;
        #[doc = "Field `THR` writer - Compare Threshold"]
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        #[doc = "Field `IRQEN` reader - Enable IRQ Generation"]
        pub type IRQEN_R = crate::BitReader;
        #[doc = "Field `IRQEN` writer - Enable IRQ Generation"]
        pub type IRQEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH` reader - Channel Index for Data Comparison"]
        pub type CH_R = crate::FieldReader;
        #[doc = "Field `CH` writer - Channel Index for Data Comparison"]
        pub type CH_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        impl R {
            #[doc = "Bit 0 - Digital Comparator Enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Select Digital Comparator Direction"]
            #[inline(always)]
            pub fn cmpdir(&self) -> CMPDIR_R {
                CMPDIR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:17 - Compare Threshold"]
            #[inline(always)]
            pub fn thr(&self) -> THR_R {
                THR_R::new(((self.bits >> 2) & 0xffff) as u16)
            }
            #[doc = "Bit 18 - Enable IRQ Generation"]
            #[inline(always)]
            pub fn irqen(&self) -> IRQEN_R {
                IRQEN_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bits 19:23 - Channel Index for Data Comparison"]
            #[inline(always)]
            pub fn ch(&self) -> CH_R {
                CH_R::new(((self.bits >> 19) & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCCMP")
                    .field("en", &self.en())
                    .field("cmpdir", &self.cmpdir())
                    .field("thr", &self.thr())
                    .field("irqen", &self.irqen())
                    .field("ch", &self.ch())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Digital Comparator Enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<ADCCMPrs> {
                EN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Select Digital Comparator Direction"]
            #[inline(always)]
            pub fn cmpdir(&mut self) -> CMPDIR_W<ADCCMPrs> {
                CMPDIR_W::new(self, 1)
            }
            #[doc = "Bits 2:17 - Compare Threshold"]
            #[inline(always)]
            pub fn thr(&mut self) -> THR_W<ADCCMPrs> {
                THR_W::new(self, 2)
            }
            #[doc = "Bit 18 - Enable IRQ Generation"]
            #[inline(always)]
            pub fn irqen(&mut self) -> IRQEN_W<ADCCMPrs> {
                IRQEN_W::new(self, 18)
            }
            #[doc = "Bits 19:23 - Channel Index for Data Comparison"]
            #[inline(always)]
            pub fn ch(&mut self) -> CH_W<ADCCMPrs> {
                CH_W::new(self, 19)
            }
        }
        #[doc = "Digital Comparator 0 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMP)"]
        pub struct ADCCMPrs;
        impl crate::RegisterSpec for ADCCMPrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adccmp::R`](R) reader structure"]
        impl crate::Readable for ADCCMPrs {}
        #[doc = "`write(|w| ..)` method takes [`adccmp::W`](W) writer structure"]
        impl crate::Writable for ADCCMPrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCCMP to value 0x0004_0000"]
        impl crate::Resettable for ADCCMPrs {
            const RESET_VALUE: u32 = 0x0004_0000;
        }
    }
    #[doc = "ADCCMPIRQSTAT (rw) register accessor: Digital Comparator Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmpirqstat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmpirqstat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMPIRQSTAT)\n\nFor information about available fields see [`mod@adccmpirqstat`]
module"]
    pub type ADCCMPIRQSTAT = crate::Reg<adccmpirqstat::ADCCMPIRQSTATrs>;
    #[doc = "Digital Comparator Interrupt Status"]
    pub mod adccmpirqstat {
        #[doc = "Register `ADCCMPIRQSTAT` reader"]
        pub type R = crate::R<ADCCMPIRQSTATrs>;
        #[doc = "Register `ADCCMPIRQSTAT` writer"]
        pub type W = crate::W<ADCCMPIRQSTATrs>;
        #[doc = "Field `COMP0IRQSTA` reader - Comparator0 Interrupt Status"]
        pub type COMP0IRQSTA_R = crate::BitReader;
        #[doc = "Field `COMP1IRQSTA` reader - Comparator1 Interrupt Status"]
        pub type COMP1IRQSTA_R = crate::BitReader;
        #[doc = "Field `COMP2IRQSTA` reader - Comparator2 Interrupt Status"]
        pub type COMP2IRQSTA_R = crate::BitReader;
        #[doc = "Field `COMP3IRQSTA` reader - Comparator3 Interrupt Status"]
        pub type COMP3IRQSTA_R = crate::BitReader;
        #[doc = "Field `COMP0IRQCLR` reader - Comparator0 Interrupt Clear"]
        pub type COMP0IRQCLR_R = crate::BitReader;
        #[doc = "Field `COMP0IRQCLR` writer - Comparator0 Interrupt Clear"]
        pub type COMP0IRQCLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COMP1IRQCLR` reader - Comparator1 Interrupt Clear"]
        pub type COMP1IRQCLR_R = crate::BitReader;
        #[doc = "Field `COMP1IRQCLR` writer - Comparator1 Interrupt Clear"]
        pub type COMP1IRQCLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COMP2IRQCLR` reader - Comparator2 Interrupt Clear"]
        pub type COMP2IRQCLR_R = crate::BitReader;
        #[doc = "Field `COMP2IRQCLR` writer - Comparator2 Interrupt Clear"]
        pub type COMP2IRQCLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COMP3IRQCLR` reader - Comparator3 Interrupt Clear"]
        pub type COMP3IRQCLR_R = crate::BitReader;
        #[doc = "Field `COMP3IRQCLR` writer - Comparator3 Interrupt Clear"]
        pub type COMP3IRQCLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COMP0PLACLR` reader - Comparator0 to PLA Clear"]
        pub type COMP0PLACLR_R = crate::BitReader;
        #[doc = "Field `COMP0PLACLR` writer - Comparator0 to PLA Clear"]
        pub type COMP0PLACLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COMP1PLACLR` reader - Comparator1 to PLA Clear"]
        pub type COMP1PLACLR_R = crate::BitReader;
        #[doc = "Field `COMP1PLACLR` writer - Comparator1 to PLA Clear"]
        pub type COMP1PLACLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COMP2PLACLR` reader - Comparator2 to PLA Clear"]
        pub type COMP2PLACLR_R = crate::BitReader;
        #[doc = "Field `COMP2PLACLR` writer - Comparator2 to PLA Clear"]
        pub type COMP2PLACLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COMP3PLACLR` reader - Comparator3 to PLA Clear"]
        pub type COMP3PLACLR_R = crate::BitReader;
        #[doc = "Field `COMP3PLACLR` writer - Comparator3 to PLA Clear"]
        pub type COMP3PLACLR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Comparator0 Interrupt Status"]
            #[inline(always)]
            pub fn comp0irqsta(&self) -> COMP0IRQSTA_R {
                COMP0IRQSTA_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Comparator1 Interrupt Status"]
            #[inline(always)]
            pub fn comp1irqsta(&self) -> COMP1IRQSTA_R {
                COMP1IRQSTA_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Comparator2 Interrupt Status"]
            #[inline(always)]
            pub fn comp2irqsta(&self) -> COMP2IRQSTA_R {
                COMP2IRQSTA_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Comparator3 Interrupt Status"]
            #[inline(always)]
            pub fn comp3irqsta(&self) -> COMP3IRQSTA_R {
                COMP3IRQSTA_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Comparator0 Interrupt Clear"]
            #[inline(always)]
            pub fn comp0irqclr(&self) -> COMP0IRQCLR_R {
                COMP0IRQCLR_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Comparator1 Interrupt Clear"]
            #[inline(always)]
            pub fn comp1irqclr(&self) -> COMP1IRQCLR_R {
                COMP1IRQCLR_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Comparator2 Interrupt Clear"]
            #[inline(always)]
            pub fn comp2irqclr(&self) -> COMP2IRQCLR_R {
                COMP2IRQCLR_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Comparator3 Interrupt Clear"]
            #[inline(always)]
            pub fn comp3irqclr(&self) -> COMP3IRQCLR_R {
                COMP3IRQCLR_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Comparator0 to PLA Clear"]
            #[inline(always)]
            pub fn comp0placlr(&self) -> COMP0PLACLR_R {
                COMP0PLACLR_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Comparator1 to PLA Clear"]
            #[inline(always)]
            pub fn comp1placlr(&self) -> COMP1PLACLR_R {
                COMP1PLACLR_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Comparator2 to PLA Clear"]
            #[inline(always)]
            pub fn comp2placlr(&self) -> COMP2PLACLR_R {
                COMP2PLACLR_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Comparator3 to PLA Clear"]
            #[inline(always)]
            pub fn comp3placlr(&self) -> COMP3PLACLR_R {
                COMP3PLACLR_R::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCCMPIRQSTAT")
                    .field("comp0irqsta", &self.comp0irqsta())
                    .field("comp1irqsta", &self.comp1irqsta())
                    .field("comp2irqsta", &self.comp2irqsta())
                    .field("comp3irqsta", &self.comp3irqsta())
                    .field("comp0irqclr", &self.comp0irqclr())
                    .field("comp1irqclr", &self.comp1irqclr())
                    .field("comp2irqclr", &self.comp2irqclr())
                    .field("comp3irqclr", &self.comp3irqclr())
                    .field("comp0placlr", &self.comp0placlr())
                    .field("comp1placlr", &self.comp1placlr())
                    .field("comp2placlr", &self.comp2placlr())
                    .field("comp3placlr", &self.comp3placlr())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 4 - Comparator0 Interrupt Clear"]
            #[inline(always)]
            pub fn comp0irqclr(&mut self) -> COMP0IRQCLR_W<ADCCMPIRQSTATrs> {
                COMP0IRQCLR_W::new(self, 4)
            }
            #[doc = "Bit 5 - Comparator1 Interrupt Clear"]
            #[inline(always)]
            pub fn comp1irqclr(&mut self) -> COMP1IRQCLR_W<ADCCMPIRQSTATrs> {
                COMP1IRQCLR_W::new(self, 5)
            }
            #[doc = "Bit 6 - Comparator2 Interrupt Clear"]
            #[inline(always)]
            pub fn comp2irqclr(&mut self) -> COMP2IRQCLR_W<ADCCMPIRQSTATrs> {
                COMP2IRQCLR_W::new(self, 6)
            }
            #[doc = "Bit 7 - Comparator3 Interrupt Clear"]
            #[inline(always)]
            pub fn comp3irqclr(&mut self) -> COMP3IRQCLR_W<ADCCMPIRQSTATrs> {
                COMP3IRQCLR_W::new(self, 7)
            }
            #[doc = "Bit 8 - Comparator0 to PLA Clear"]
            #[inline(always)]
            pub fn comp0placlr(&mut self) -> COMP0PLACLR_W<ADCCMPIRQSTATrs> {
                COMP0PLACLR_W::new(self, 8)
            }
            #[doc = "Bit 9 - Comparator1 to PLA Clear"]
            #[inline(always)]
            pub fn comp1placlr(&mut self) -> COMP1PLACLR_W<ADCCMPIRQSTATrs> {
                COMP1PLACLR_W::new(self, 9)
            }
            #[doc = "Bit 10 - Comparator2 to PLA Clear"]
            #[inline(always)]
            pub fn comp2placlr(&mut self) -> COMP2PLACLR_W<ADCCMPIRQSTATrs> {
                COMP2PLACLR_W::new(self, 10)
            }
            #[doc = "Bit 11 - Comparator3 to PLA Clear"]
            #[inline(always)]
            pub fn comp3placlr(&mut self) -> COMP3PLACLR_W<ADCCMPIRQSTATrs> {
                COMP3PLACLR_W::new(self, 11)
            }
        }
        #[doc = "Digital Comparator Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmpirqstat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmpirqstat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMPIRQSTAT)"]
        pub struct ADCCMPIRQSTATrs;
        impl crate::RegisterSpec for ADCCMPIRQSTATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adccmpirqstat::R`](R) reader structure"]
        impl crate::Readable for ADCCMPIRQSTATrs {}
        #[doc = "`write(|w| ..)` method takes [`adccmpirqstat::W`](W) writer structure"]
        impl crate::Writable for ADCCMPIRQSTATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCCMPIRQSTAT to value 0"]
        impl crate::Resettable for ADCCMPIRQSTATrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCOFGNDIFF (rw) register accessor: ADC Offset Gain Differential Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgndiff::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgndiff::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNDIFF)\n\nFor information about available fields see [`mod@adcofgndiff`]
module"]
    pub type ADCOFGNDIFF = crate::Reg<adcofgndiff::ADCOFGNDIFFrs>;
    #[doc = "ADC Offset Gain Differential Channel Error Correction"]
    pub mod adcofgndiff {
        #[doc = "Register `ADCOFGNDIFF` reader"]
        pub type R = crate::R<ADCOFGNDIFFrs>;
        #[doc = "Register `ADCOFGNDIFF` writer"]
        pub type W = crate::W<ADCOFGNDIFFrs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16, crate::Safe>;
        #[doc = "Field `OFFSET` reader - Offset Error Correction"]
        pub type OFFSET_R = crate::FieldReader<u32>;
        #[doc = "Field `OFFSET` writer - Offset Error Correction"]
        pub type OFFSET_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new((self.bits & 0x7fff) as u16)
            }
            #[doc = "Bits 15:31 - Offset Error Correction"]
            #[inline(always)]
            pub fn offset(&self) -> OFFSET_R {
                OFFSET_R::new((self.bits >> 15) & 0x0001_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFGNDIFF")
                    .field("gain", &self.gain())
                    .field("offset", &self.offset())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCOFGNDIFFrs> {
                GAIN_W::new(self, 0)
            }
            #[doc = "Bits 15:31 - Offset Error Correction"]
            #[inline(always)]
            pub fn offset(&mut self) -> OFFSET_W<ADCOFGNDIFFrs> {
                OFFSET_W::new(self, 15)
            }
        }
        #[doc = "ADC Offset Gain Differential Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgndiff::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgndiff::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNDIFF)"]
        pub struct ADCOFGNDIFFrs;
        impl crate::RegisterSpec for ADCOFGNDIFFrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcofgndiff::R`](R) reader structure"]
        impl crate::Readable for ADCOFGNDIFFrs {}
        #[doc = "`write(|w| ..)` method takes [`adcofgndiff::W`](W) writer structure"]
        impl crate::Writable for ADCOFGNDIFFrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFGNDIFF to value 0x4000"]
        impl crate::Resettable for ADCOFGNDIFFrs {
            const RESET_VALUE: u32 = 0x4000;
        }
    }
    #[doc = "ADCOFTEMP (rw) register accessor: ADC Offset Gain Temp Sensor Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcoftemp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcoftemp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFTEMP)\n\nFor information about available fields see [`mod@adcoftemp`]
module"]
    pub type ADCOFTEMP = crate::Reg<adcoftemp::ADCOFTEMPrs>;
    #[doc = "ADC Offset Gain Temp Sensor Channel Error Correction"]
    pub mod adcoftemp {
        #[doc = "Register `ADCOFTEMP` reader"]
        pub type R = crate::R<ADCOFTEMPrs>;
        #[doc = "Register `ADCOFTEMP` writer"]
        pub type W = crate::W<ADCOFTEMPrs>;
        #[doc = "Field `OFFSET` reader - Offset Error Correction"]
        pub type OFFSET_R = crate::FieldReader<u32>;
        #[doc = "Field `OFFSET` writer - Offset Error Correction"]
        pub type OFFSET_W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:16 - Offset Error Correction"]
            #[inline(always)]
            pub fn offset(&self) -> OFFSET_R {
                OFFSET_R::new(self.bits & 0x0001_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFTEMP")
                    .field("offset", &self.offset())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:16 - Offset Error Correction"]
            #[inline(always)]
            pub fn offset(&mut self) -> OFFSET_W<ADCOFTEMPrs> {
                OFFSET_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain Temp Sensor Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcoftemp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcoftemp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFTEMP)"]
        pub struct ADCOFTEMPrs;
        impl crate::RegisterSpec for ADCOFTEMPrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcoftemp::R`](R) reader structure"]
        impl crate::Readable for ADCOFTEMPrs {}
        #[doc = "`write(|w| ..)` method takes [`adcoftemp::W`](W) writer structure"]
        impl crate::Writable for ADCOFTEMPrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFTEMP to value 0"]
        impl crate::Resettable for ADCOFTEMPrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "ADCGNTEMP (rw) register accessor: ADC Offset Gain Temp Sensor Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcgntemp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcgntemp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCGNTEMP)\n\nFor information about available fields see [`mod@adcgntemp`]
module"]
    pub type ADCGNTEMP = crate::Reg<adcgntemp::ADCGNTEMPrs>;
    #[doc = "ADC Offset Gain Temp Sensor Channel Error Correction"]
    pub mod adcgntemp {
        #[doc = "Register `ADCGNTEMP` reader"]
        pub type R = crate::R<ADCGNTEMPrs>;
        #[doc = "Register `ADCGNTEMP` writer"]
        pub type W = crate::W<ADCGNTEMPrs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u32>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32, crate::Safe>;
        impl R {
            #[doc = "Bits 0:19 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new(self.bits & 0x000f_ffff)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCGNTEMP")
                    .field("gain", &self.gain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:19 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCGNTEMPrs> {
                GAIN_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain Temp Sensor Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcgntemp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcgntemp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCGNTEMP)"]
        pub struct ADCGNTEMPrs;
        impl crate::RegisterSpec for ADCGNTEMPrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcgntemp::R`](R) reader structure"]
        impl crate::Readable for ADCGNTEMPrs {}
        #[doc = "`write(|w| ..)` method takes [`adcgntemp::W`](W) writer structure"]
        impl crate::Writable for ADCGNTEMPrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCGNTEMP to value 0x0008_0000"]
        impl crate::Resettable for ADCGNTEMPrs {
            const RESET_VALUE: u32 = 0x0008_0000;
        }
    }
    #[doc = "ADCOFGNPGA0 (rw) register accessor: ADC Offset Gain PGA0 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA0)\n\nFor information about available fields see [`mod@adcofgnpga0`]
module"]
    pub type ADCOFGNPGA0 = crate::Reg<adcofgnpga0::ADCOFGNPGA0rs>;
    #[doc = "ADC Offset Gain PGA0 Channel Error Correction"]
    pub mod adcofgnpga0 {
        #[doc = "Register `ADCOFGNPGA0` reader"]
        pub type R = crate::R<ADCOFGNPGA0rs>;
        #[doc = "Register `ADCOFGNPGA0` writer"]
        pub type W = crate::W<ADCOFGNPGA0rs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFGNPGA0")
                    .field("gain", &self.gain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCOFGNPGA0rs> {
                GAIN_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain PGA0 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA0)"]
        pub struct ADCOFGNPGA0rs;
        impl crate::RegisterSpec for ADCOFGNPGA0rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcofgnpga0::R`](R) reader structure"]
        impl crate::Readable for ADCOFGNPGA0rs {}
        #[doc = "`write(|w| ..)` method takes [`adcofgnpga0::W`](W) writer structure"]
        impl crate::Writable for ADCOFGNPGA0rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFGNPGA0 to value 0x4000"]
        impl crate::Resettable for ADCOFGNPGA0rs {
            const RESET_VALUE: u32 = 0x4000;
        }
    }
    #[doc = "ADCOFGNPGA1 (rw) register accessor: ADC Offset Gain PGA1 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA1)\n\nFor information about available fields see [`mod@adcofgnpga1`]
module"]
    pub type ADCOFGNPGA1 = crate::Reg<adcofgnpga1::ADCOFGNPGA1rs>;
    #[doc = "ADC Offset Gain PGA1 Channel Error Correction"]
    pub mod adcofgnpga1 {
        #[doc = "Register `ADCOFGNPGA1` reader"]
        pub type R = crate::R<ADCOFGNPGA1rs>;
        #[doc = "Register `ADCOFGNPGA1` writer"]
        pub type W = crate::W<ADCOFGNPGA1rs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFGNPGA1")
                    .field("gain", &self.gain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCOFGNPGA1rs> {
                GAIN_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain PGA1 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA1)"]
        pub struct ADCOFGNPGA1rs;
        impl crate::RegisterSpec for ADCOFGNPGA1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcofgnpga1::R`](R) reader structure"]
        impl crate::Readable for ADCOFGNPGA1rs {}
        #[doc = "`write(|w| ..)` method takes [`adcofgnpga1::W`](W) writer structure"]
        impl crate::Writable for ADCOFGNPGA1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFGNPGA1 to value 0x4000"]
        impl crate::Resettable for ADCOFGNPGA1rs {
            const RESET_VALUE: u32 = 0x4000;
        }
    }
    #[doc = "ADCOFGNPGA2 (rw) register accessor: ADC Offset Gain PGA2 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA2)\n\nFor information about available fields see [`mod@adcofgnpga2`]
module"]
    pub type ADCOFGNPGA2 = crate::Reg<adcofgnpga2::ADCOFGNPGA2rs>;
    #[doc = "ADC Offset Gain PGA2 Channel Error Correction"]
    pub mod adcofgnpga2 {
        #[doc = "Register `ADCOFGNPGA2` reader"]
        pub type R = crate::R<ADCOFGNPGA2rs>;
        #[doc = "Register `ADCOFGNPGA2` writer"]
        pub type W = crate::W<ADCOFGNPGA2rs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFGNPGA2")
                    .field("gain", &self.gain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCOFGNPGA2rs> {
                GAIN_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain PGA2 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA2)"]
        pub struct ADCOFGNPGA2rs;
        impl crate::RegisterSpec for ADCOFGNPGA2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcofgnpga2::R`](R) reader structure"]
        impl crate::Readable for ADCOFGNPGA2rs {}
        #[doc = "`write(|w| ..)` method takes [`adcofgnpga2::W`](W) writer structure"]
        impl crate::Writable for ADCOFGNPGA2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFGNPGA2 to value 0x4000"]
        impl crate::Resettable for ADCOFGNPGA2rs {
            const RESET_VALUE: u32 = 0x4000;
        }
    }
    #[doc = "ADCOFGNPGA3 (rw) register accessor: ADC Offset Gain PGA3 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA3)\n\nFor information about available fields see [`mod@adcofgnpga3`]
module"]
    pub type ADCOFGNPGA3 = crate::Reg<adcofgnpga3::ADCOFGNPGA3rs>;
    #[doc = "ADC Offset Gain PGA3 Channel Error Correction"]
    pub mod adcofgnpga3 {
        #[doc = "Register `ADCOFGNPGA3` reader"]
        pub type R = crate::R<ADCOFGNPGA3rs>;
        #[doc = "Register `ADCOFGNPGA3` writer"]
        pub type W = crate::W<ADCOFGNPGA3rs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFGNPGA3")
                    .field("gain", &self.gain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCOFGNPGA3rs> {
                GAIN_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain PGA3 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA3)"]
        pub struct ADCOFGNPGA3rs;
        impl crate::RegisterSpec for ADCOFGNPGA3rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcofgnpga3::R`](R) reader structure"]
        impl crate::Readable for ADCOFGNPGA3rs {}
        #[doc = "`write(|w| ..)` method takes [`adcofgnpga3::W`](W) writer structure"]
        impl crate::Writable for ADCOFGNPGA3rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFGNPGA3 to value 0x4000"]
        impl crate::Resettable for ADCOFGNPGA3rs {
            const RESET_VALUE: u32 = 0x4000;
        }
    }
    #[doc = "ADCOFGNPGA0TIA (rw) register accessor: ADC Offset Gain PGA0 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga0tia::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga0tia::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA0TIA)\n\nFor information about available fields see [`mod@adcofgnpga0tia`]
module"]
    pub type ADCOFGNPGA0TIA = crate::Reg<adcofgnpga0tia::ADCOFGNPGA0TIArs>;
    #[doc = "ADC Offset Gain PGA0 Channel Error Correction"]
    pub mod adcofgnpga0tia {
        #[doc = "Register `ADCOFGNPGA0TIA` reader"]
        pub type R = crate::R<ADCOFGNPGA0TIArs>;
        #[doc = "Register `ADCOFGNPGA0TIA` writer"]
        pub type W = crate::W<ADCOFGNPGA0TIArs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFGNPGA0TIA")
                    .field("gain", &self.gain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCOFGNPGA0TIArs> {
                GAIN_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain PGA0 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga0tia::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga0tia::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA0TIA)"]
        pub struct ADCOFGNPGA0TIArs;
        impl crate::RegisterSpec for ADCOFGNPGA0TIArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcofgnpga0tia::R`](R) reader structure"]
        impl crate::Readable for ADCOFGNPGA0TIArs {}
        #[doc = "`write(|w| ..)` method takes [`adcofgnpga0tia::W`](W) writer structure"]
        impl crate::Writable for ADCOFGNPGA0TIArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFGNPGA0TIA to value 0x4000"]
        impl crate::Resettable for ADCOFGNPGA0TIArs {
            const RESET_VALUE: u32 = 0x4000;
        }
    }
    #[doc = "ADCOFGNPGA1TIA (rw) register accessor: ADC Offset Gain PGA1 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga1tia::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga1tia::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA1TIA)\n\nFor information about available fields see [`mod@adcofgnpga1tia`]
module"]
    pub type ADCOFGNPGA1TIA = crate::Reg<adcofgnpga1tia::ADCOFGNPGA1TIArs>;
    #[doc = "ADC Offset Gain PGA1 Channel Error Correction"]
    pub mod adcofgnpga1tia {
        #[doc = "Register `ADCOFGNPGA1TIA` reader"]
        pub type R = crate::R<ADCOFGNPGA1TIArs>;
        #[doc = "Register `ADCOFGNPGA1TIA` writer"]
        pub type W = crate::W<ADCOFGNPGA1TIArs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFGNPGA1TIA")
                    .field("gain", &self.gain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCOFGNPGA1TIArs> {
                GAIN_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain PGA1 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga1tia::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga1tia::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA1TIA)"]
        pub struct ADCOFGNPGA1TIArs;
        impl crate::RegisterSpec for ADCOFGNPGA1TIArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcofgnpga1tia::R`](R) reader structure"]
        impl crate::Readable for ADCOFGNPGA1TIArs {}
        #[doc = "`write(|w| ..)` method takes [`adcofgnpga1tia::W`](W) writer structure"]
        impl crate::Writable for ADCOFGNPGA1TIArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFGNPGA1TIA to value 0x4000"]
        impl crate::Resettable for ADCOFGNPGA1TIArs {
            const RESET_VALUE: u32 = 0x4000;
        }
    }
    #[doc = "ADCOFGNPGA2TIA (rw) register accessor: ADC Offset Gain PGA2 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga2tia::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga2tia::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA2TIA)\n\nFor information about available fields see [`mod@adcofgnpga2tia`]
module"]
    pub type ADCOFGNPGA2TIA = crate::Reg<adcofgnpga2tia::ADCOFGNPGA2TIArs>;
    #[doc = "ADC Offset Gain PGA2 Channel Error Correction"]
    pub mod adcofgnpga2tia {
        #[doc = "Register `ADCOFGNPGA2TIA` reader"]
        pub type R = crate::R<ADCOFGNPGA2TIArs>;
        #[doc = "Register `ADCOFGNPGA2TIA` writer"]
        pub type W = crate::W<ADCOFGNPGA2TIArs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFGNPGA2TIA")
                    .field("gain", &self.gain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCOFGNPGA2TIArs> {
                GAIN_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain PGA2 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga2tia::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga2tia::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA2TIA)"]
        pub struct ADCOFGNPGA2TIArs;
        impl crate::RegisterSpec for ADCOFGNPGA2TIArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcofgnpga2tia::R`](R) reader structure"]
        impl crate::Readable for ADCOFGNPGA2TIArs {}
        #[doc = "`write(|w| ..)` method takes [`adcofgnpga2tia::W`](W) writer structure"]
        impl crate::Writable for ADCOFGNPGA2TIArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFGNPGA2TIA to value 0x4000"]
        impl crate::Resettable for ADCOFGNPGA2TIArs {
            const RESET_VALUE: u32 = 0x4000;
        }
    }
    #[doc = "ADCOFGNPGA3TIA (rw) register accessor: ADC Offset Gain PGA3 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga3tia::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga3tia::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA3TIA)\n\nFor information about available fields see [`mod@adcofgnpga3tia`]
module"]
    pub type ADCOFGNPGA3TIA = crate::Reg<adcofgnpga3tia::ADCOFGNPGA3TIArs>;
    #[doc = "ADC Offset Gain PGA3 Channel Error Correction"]
    pub mod adcofgnpga3tia {
        #[doc = "Register `ADCOFGNPGA3TIA` reader"]
        pub type R = crate::R<ADCOFGNPGA3TIArs>;
        #[doc = "Register `ADCOFGNPGA3TIA` writer"]
        pub type W = crate::W<ADCOFGNPGA3TIArs>;
        #[doc = "Field `GAIN` reader - Gain Error Correction"]
        pub type GAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `GAIN` writer - Gain Error Correction"]
        pub type GAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 15, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&self) -> GAIN_R {
                GAIN_R::new((self.bits & 0x7fff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCOFGNPGA3TIA")
                    .field("gain", &self.gain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:14 - Gain Error Correction"]
            #[inline(always)]
            pub fn gain(&mut self) -> GAIN_W<ADCOFGNPGA3TIArs> {
                GAIN_W::new(self, 0)
            }
        }
        #[doc = "ADC Offset Gain PGA3 Channel Error Correction\n\nYou can [`read`](crate::Reg::read) this register and get [`adcofgnpga3tia::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adcofgnpga3tia::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCOFGNPGA3TIA)"]
        pub struct ADCOFGNPGA3TIArs;
        impl crate::RegisterSpec for ADCOFGNPGA3TIArs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adcofgnpga3tia::R`](R) reader structure"]
        impl crate::Readable for ADCOFGNPGA3TIArs {}
        #[doc = "`write(|w| ..)` method takes [`adcofgnpga3tia::W`](W) writer structure"]
        impl crate::Writable for ADCOFGNPGA3TIArs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCOFGNPGA3TIA to value 0x4000"]
        impl crate::Resettable for ADCOFGNPGA3TIArs {
            const RESET_VALUE: u32 = 0x4000;
        }
    }
    #[doc = "ADCCMP1 (rw) register accessor: Digital Comparator 1 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmp1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmp1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMP1)\n\nFor information about available fields see [`mod@adccmp1`]
module"]
    pub type ADCCMP1 = crate::Reg<adccmp1::ADCCMP1rs>;
    #[doc = "Digital Comparator 1 Configuration"]
    pub mod adccmp1 {
        #[doc = "Register `ADCCMP1` reader"]
        pub type R = crate::R<ADCCMP1rs>;
        #[doc = "Register `ADCCMP1` writer"]
        pub type W = crate::W<ADCCMP1rs>;
        #[doc = "Field `EN` reader - Digital Comparator Enable"]
        pub type EN_R = crate::BitReader;
        #[doc = "Field `EN` writer - Digital Comparator Enable"]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMPDIR` reader - Select Digital Comparator Direction"]
        pub type CMPDIR_R = crate::BitReader;
        #[doc = "Field `CMPDIR` writer - Select Digital Comparator Direction"]
        pub type CMPDIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `THR` reader - Compare Threshold"]
        pub type THR_R = crate::FieldReader<u16>;
        #[doc = "Field `THR` writer - Compare Threshold"]
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        #[doc = "Field `IRQEN` reader - Enable IRQ Generation"]
        pub type IRQEN_R = crate::BitReader;
        #[doc = "Field `IRQEN` writer - Enable IRQ Generation"]
        pub type IRQEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH` reader - Channel Index for Data Comparison"]
        pub type CH_R = crate::FieldReader;
        #[doc = "Field `CH` writer - Channel Index for Data Comparison"]
        pub type CH_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        impl R {
            #[doc = "Bit 0 - Digital Comparator Enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Select Digital Comparator Direction"]
            #[inline(always)]
            pub fn cmpdir(&self) -> CMPDIR_R {
                CMPDIR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:17 - Compare Threshold"]
            #[inline(always)]
            pub fn thr(&self) -> THR_R {
                THR_R::new(((self.bits >> 2) & 0xffff) as u16)
            }
            #[doc = "Bit 18 - Enable IRQ Generation"]
            #[inline(always)]
            pub fn irqen(&self) -> IRQEN_R {
                IRQEN_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bits 19:23 - Channel Index for Data Comparison"]
            #[inline(always)]
            pub fn ch(&self) -> CH_R {
                CH_R::new(((self.bits >> 19) & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCCMP1")
                    .field("en", &self.en())
                    .field("cmpdir", &self.cmpdir())
                    .field("thr", &self.thr())
                    .field("irqen", &self.irqen())
                    .field("ch", &self.ch())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Digital Comparator Enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<ADCCMP1rs> {
                EN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Select Digital Comparator Direction"]
            #[inline(always)]
            pub fn cmpdir(&mut self) -> CMPDIR_W<ADCCMP1rs> {
                CMPDIR_W::new(self, 1)
            }
            #[doc = "Bits 2:17 - Compare Threshold"]
            #[inline(always)]
            pub fn thr(&mut self) -> THR_W<ADCCMP1rs> {
                THR_W::new(self, 2)
            }
            #[doc = "Bit 18 - Enable IRQ Generation"]
            #[inline(always)]
            pub fn irqen(&mut self) -> IRQEN_W<ADCCMP1rs> {
                IRQEN_W::new(self, 18)
            }
            #[doc = "Bits 19:23 - Channel Index for Data Comparison"]
            #[inline(always)]
            pub fn ch(&mut self) -> CH_W<ADCCMP1rs> {
                CH_W::new(self, 19)
            }
        }
        #[doc = "Digital Comparator 1 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmp1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmp1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMP1)"]
        pub struct ADCCMP1rs;
        impl crate::RegisterSpec for ADCCMP1rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adccmp1::R`](R) reader structure"]
        impl crate::Readable for ADCCMP1rs {}
        #[doc = "`write(|w| ..)` method takes [`adccmp1::W`](W) writer structure"]
        impl crate::Writable for ADCCMP1rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCCMP1 to value 0x0004_0000"]
        impl crate::Resettable for ADCCMP1rs {
            const RESET_VALUE: u32 = 0x0004_0000;
        }
    }
    #[doc = "ADCCMP2 (rw) register accessor: Digital Comparator 2 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmp2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmp2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMP2)\n\nFor information about available fields see [`mod@adccmp2`]
module"]
    pub type ADCCMP2 = crate::Reg<adccmp2::ADCCMP2rs>;
    #[doc = "Digital Comparator 2 Configuration"]
    pub mod adccmp2 {
        #[doc = "Register `ADCCMP2` reader"]
        pub type R = crate::R<ADCCMP2rs>;
        #[doc = "Register `ADCCMP2` writer"]
        pub type W = crate::W<ADCCMP2rs>;
        #[doc = "Field `EN` reader - Digital Comparator Enable"]
        pub type EN_R = crate::BitReader;
        #[doc = "Field `EN` writer - Digital Comparator Enable"]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMPDIR` reader - Select Digital Comparator Direction"]
        pub type CMPDIR_R = crate::BitReader;
        #[doc = "Field `CMPDIR` writer - Select Digital Comparator Direction"]
        pub type CMPDIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `THR` reader - Compare Threshold"]
        pub type THR_R = crate::FieldReader<u16>;
        #[doc = "Field `THR` writer - Compare Threshold"]
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        #[doc = "Field `IRQEN` reader - Enable IRQ Generation"]
        pub type IRQEN_R = crate::BitReader;
        #[doc = "Field `IRQEN` writer - Enable IRQ Generation"]
        pub type IRQEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH` reader - Channel Index for Data Comparison"]
        pub type CH_R = crate::FieldReader;
        #[doc = "Field `CH` writer - Channel Index for Data Comparison"]
        pub type CH_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        impl R {
            #[doc = "Bit 0 - Digital Comparator Enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Select Digital Comparator Direction"]
            #[inline(always)]
            pub fn cmpdir(&self) -> CMPDIR_R {
                CMPDIR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:17 - Compare Threshold"]
            #[inline(always)]
            pub fn thr(&self) -> THR_R {
                THR_R::new(((self.bits >> 2) & 0xffff) as u16)
            }
            #[doc = "Bit 18 - Enable IRQ Generation"]
            #[inline(always)]
            pub fn irqen(&self) -> IRQEN_R {
                IRQEN_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bits 19:23 - Channel Index for Data Comparison"]
            #[inline(always)]
            pub fn ch(&self) -> CH_R {
                CH_R::new(((self.bits >> 19) & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCCMP2")
                    .field("en", &self.en())
                    .field("cmpdir", &self.cmpdir())
                    .field("thr", &self.thr())
                    .field("irqen", &self.irqen())
                    .field("ch", &self.ch())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Digital Comparator Enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<ADCCMP2rs> {
                EN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Select Digital Comparator Direction"]
            #[inline(always)]
            pub fn cmpdir(&mut self) -> CMPDIR_W<ADCCMP2rs> {
                CMPDIR_W::new(self, 1)
            }
            #[doc = "Bits 2:17 - Compare Threshold"]
            #[inline(always)]
            pub fn thr(&mut self) -> THR_W<ADCCMP2rs> {
                THR_W::new(self, 2)
            }
            #[doc = "Bit 18 - Enable IRQ Generation"]
            #[inline(always)]
            pub fn irqen(&mut self) -> IRQEN_W<ADCCMP2rs> {
                IRQEN_W::new(self, 18)
            }
            #[doc = "Bits 19:23 - Channel Index for Data Comparison"]
            #[inline(always)]
            pub fn ch(&mut self) -> CH_W<ADCCMP2rs> {
                CH_W::new(self, 19)
            }
        }
        #[doc = "Digital Comparator 2 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmp2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmp2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMP2)"]
        pub struct ADCCMP2rs;
        impl crate::RegisterSpec for ADCCMP2rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adccmp2::R`](R) reader structure"]
        impl crate::Readable for ADCCMP2rs {}
        #[doc = "`write(|w| ..)` method takes [`adccmp2::W`](W) writer structure"]
        impl crate::Writable for ADCCMP2rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCCMP2 to value 0x0004_0000"]
        impl crate::Resettable for ADCCMP2rs {
            const RESET_VALUE: u32 = 0x0004_0000;
        }
    }
    #[doc = "ADCCMP3 (rw) register accessor: Digital Comparator 3 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmp3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmp3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMP3)\n\nFor information about available fields see [`mod@adccmp3`]
module"]
    pub type ADCCMP3 = crate::Reg<adccmp3::ADCCMP3rs>;
    #[doc = "Digital Comparator 3 Configuration"]
    pub mod adccmp3 {
        #[doc = "Register `ADCCMP3` reader"]
        pub type R = crate::R<ADCCMP3rs>;
        #[doc = "Register `ADCCMP3` writer"]
        pub type W = crate::W<ADCCMP3rs>;
        #[doc = "Field `EN` reader - Digital Comparator Enable"]
        pub type EN_R = crate::BitReader;
        #[doc = "Field `EN` writer - Digital Comparator Enable"]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CMPDIR` reader - Select Digital Comparator Direction"]
        pub type CMPDIR_R = crate::BitReader;
        #[doc = "Field `CMPDIR` writer - Select Digital Comparator Direction"]
        pub type CMPDIR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `THR` reader - Compare Threshold"]
        pub type THR_R = crate::FieldReader<u16>;
        #[doc = "Field `THR` writer - Compare Threshold"]
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        #[doc = "Field `IRQEN` reader - Enable IRQ Generation"]
        pub type IRQEN_R = crate::BitReader;
        #[doc = "Field `IRQEN` writer - Enable IRQ Generation"]
        pub type IRQEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CH` reader - Channel Index for Data Comparison"]
        pub type CH_R = crate::FieldReader;
        #[doc = "Field `CH` writer - Channel Index for Data Comparison"]
        pub type CH_W<'a, REG> = crate::FieldWriter<'a, REG, 5, u8, crate::Safe>;
        impl R {
            #[doc = "Bit 0 - Digital Comparator Enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Select Digital Comparator Direction"]
            #[inline(always)]
            pub fn cmpdir(&self) -> CMPDIR_R {
                CMPDIR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:17 - Compare Threshold"]
            #[inline(always)]
            pub fn thr(&self) -> THR_R {
                THR_R::new(((self.bits >> 2) & 0xffff) as u16)
            }
            #[doc = "Bit 18 - Enable IRQ Generation"]
            #[inline(always)]
            pub fn irqen(&self) -> IRQEN_R {
                IRQEN_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bits 19:23 - Channel Index for Data Comparison"]
            #[inline(always)]
            pub fn ch(&self) -> CH_R {
                CH_R::new(((self.bits >> 19) & 0x1f) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ADCCMP3")
                    .field("en", &self.en())
                    .field("cmpdir", &self.cmpdir())
                    .field("thr", &self.thr())
                    .field("irqen", &self.irqen())
                    .field("ch", &self.ch())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Digital Comparator Enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<ADCCMP3rs> {
                EN_W::new(self, 0)
            }
            #[doc = "Bit 1 - Select Digital Comparator Direction"]
            #[inline(always)]
            pub fn cmpdir(&mut self) -> CMPDIR_W<ADCCMP3rs> {
                CMPDIR_W::new(self, 1)
            }
            #[doc = "Bits 2:17 - Compare Threshold"]
            #[inline(always)]
            pub fn thr(&mut self) -> THR_W<ADCCMP3rs> {
                THR_W::new(self, 2)
            }
            #[doc = "Bit 18 - Enable IRQ Generation"]
            #[inline(always)]
            pub fn irqen(&mut self) -> IRQEN_W<ADCCMP3rs> {
                IRQEN_W::new(self, 18)
            }
            #[doc = "Bits 19:23 - Channel Index for Data Comparison"]
            #[inline(always)]
            pub fn ch(&mut self) -> CH_W<ADCCMP3rs> {
                CH_W::new(self, 19)
            }
        }
        #[doc = "Digital Comparator 3 Configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`adccmp3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adccmp3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#ADC:ADCCMP3)"]
        pub struct ADCCMP3rs;
        impl crate::RegisterSpec for ADCCMP3rs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`adccmp3::R`](R) reader structure"]
        impl crate::Readable for ADCCMP3rs {}
        #[doc = "`write(|w| ..)` method takes [`adccmp3::W`](W) writer structure"]
        impl crate::Writable for ADCCMP3rs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets ADCCMP3 to value 0x0004_0000"]
        impl crate::Resettable for ADCCMP3rs {
            const RESET_VALUE: u32 = 0x0004_0000;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#COMP)"]
pub struct COMP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for COMP {}
impl COMP {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const comp::RegisterBlock = 0x4006_8a00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const comp::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for COMP {
    type Target = comp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for COMP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("COMP").finish()
    }
}
#[doc = "Unknown"]
pub mod comp {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        compcon: [COMPCON; 4],
        compirqstat: COMPIRQSTAT,
    }
    impl RegisterBlock {
        #[doc = "0x00..0x10 - Unknown"]
        #[inline(always)]
        pub const fn compcon(&self, n: usize) -> &COMPCON {
            &self.compcon[n]
        }
        #[doc = "Iterator for array of:"]
        #[doc = "0x00..0x10 - Unknown"]
        #[inline(always)]
        pub fn compcon_iter(&self) -> impl Iterator<Item = &COMPCON> {
            self.compcon.iter()
        }
        #[doc = "0x10 - Unknown"]
        #[inline(always)]
        pub const fn compirqstat(&self) -> &COMPIRQSTAT {
            &self.compirqstat
        }
    }
    #[doc = "COMPCON (rw) register accessor: Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`compcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`compcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#COMP:COMPCON[0])\n\nFor information about available fields see [`mod@compcon`]
module"]
    pub type COMPCON = crate::Reg<compcon::COMPCONrs>;
    #[doc = "Unknown"]
    pub mod compcon {
        #[doc = "Register `COMPCON[%s]` reader"]
        pub type R = crate::R<COMPCONrs>;
        #[doc = "Register `COMPCON[%s]` writer"]
        pub type W = crate::W<COMPCONrs>;
        #[doc = "Comp Hysteresis Register\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum HYS {
            #[doc = "0: hysteresis disabled"]
            Dis = 0,
            #[doc = "1: 10mv hysteresis enabled"]
            En10mv = 1,
            #[doc = "2: 25mv hysteresis"]
            En25mv = 2,
            #[doc = "3: 35mv hysteresis"]
            En35mv = 3,
            #[doc = "6: 50mv hysteresis"]
            En50mv = 6,
            #[doc = "7: 60mv hysteresis"]
            En60mv = 7,
            #[doc = "12: 75mv hysteresis"]
            En75mv = 12,
            #[doc = "13: 85mv hysteresis"]
            En85mv = 13,
            #[doc = "14: 100mv hysteresis"]
            En100mv = 14,
            #[doc = "17: 110mv hysteresis"]
            En110mv = 17,
            #[doc = "18: 125mv hysteresis"]
            En125mv = 18,
            #[doc = "19: 135mv hysteresis"]
            En135mv = 19,
            #[doc = "22: 150mv hysteresis"]
            En150mv = 22,
            #[doc = "23: 160mv hysteresis"]
            En160mv = 23,
            #[doc = "28: 175mv hysteresis"]
            En175mv = 28,
            #[doc = "29: 185mv hysteresis"]
            En185mv = 29,
            #[doc = "30: 200mv hysteresis"]
            En200mv = 30,
            #[doc = "31: 210mv hysteresis"]
            En210mv = 31,
        }
        impl From<HYS> for u8 {
            #[inline(always)]
            fn from(variant: HYS) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for HYS {
            type Ux = u8;
        }
        impl crate::IsEnum for HYS {}
        #[doc = "Field `HYS` reader - Comp Hysteresis Register"]
        pub type HYS_R = crate::FieldReader<HYS>;
        impl HYS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<HYS> {
                match self.bits {
                    0 => Some(HYS::Dis),
                    1 => Some(HYS::En10mv),
                    2 => Some(HYS::En25mv),
                    3 => Some(HYS::En35mv),
                    6 => Some(HYS::En50mv),
                    7 => Some(HYS::En60mv),
                    12 => Some(HYS::En75mv),
                    13 => Some(HYS::En85mv),
                    14 => Some(HYS::En100mv),
                    17 => Some(HYS::En110mv),
                    18 => Some(HYS::En125mv),
                    19 => Some(HYS::En135mv),
                    22 => Some(HYS::En150mv),
                    23 => Some(HYS::En160mv),
                    28 => Some(HYS::En175mv),
                    29 => Some(HYS::En185mv),
                    30 => Some(HYS::En200mv),
                    31 => Some(HYS::En210mv),
                    _ => None,
                }
            }
            #[doc = "hysteresis disabled"]
            #[inline(always)]
            pub fn is_dis(&self) -> bool {
                *self == HYS::Dis
            }
            #[doc = "10mv hysteresis enabled"]
            #[inline(always)]
            pub fn is_en10mv(&self) -> bool {
                *self == HYS::En10mv
            }
            #[doc = "25mv hysteresis"]
            #[inline(always)]
            pub fn is_en25mv(&self) -> bool {
                *self == HYS::En25mv
            }
            #[doc = "35mv hysteresis"]
            #[inline(always)]
            pub fn is_en35mv(&self) -> bool {
                *self == HYS::En35mv
            }
            #[doc = "50mv hysteresis"]
            #[inline(always)]
            pub fn is_en50mv(&self) -> bool {
                *self == HYS::En50mv
            }
            #[doc = "60mv hysteresis"]
            #[inline(always)]
            pub fn is_en60mv(&self) -> bool {
                *self == HYS::En60mv
            }
            #[doc = "75mv hysteresis"]
            #[inline(always)]
            pub fn is_en75mv(&self) -> bool {
                *self == HYS::En75mv
            }
            #[doc = "85mv hysteresis"]
            #[inline(always)]
            pub fn is_en85mv(&self) -> bool {
                *self == HYS::En85mv
            }
            #[doc = "100mv hysteresis"]
            #[inline(always)]
            pub fn is_en100mv(&self) -> bool {
                *self == HYS::En100mv
            }
            #[doc = "110mv hysteresis"]
            #[inline(always)]
            pub fn is_en110mv(&self) -> bool {
                *self == HYS::En110mv
            }
            #[doc = "125mv hysteresis"]
            #[inline(always)]
            pub fn is_en125mv(&self) -> bool {
                *self == HYS::En125mv
            }
            #[doc = "135mv hysteresis"]
            #[inline(always)]
            pub fn is_en135mv(&self) -> bool {
                *self == HYS::En135mv
            }
            #[doc = "150mv hysteresis"]
            #[inline(always)]
            pub fn is_en150mv(&self) -> bool {
                *self == HYS::En150mv
            }
            #[doc = "160mv hysteresis"]
            #[inline(always)]
            pub fn is_en160mv(&self) -> bool {
                *self == HYS::En160mv
            }
            #[doc = "175mv hysteresis"]
            #[inline(always)]
            pub fn is_en175mv(&self) -> bool {
                *self == HYS::En175mv
            }
            #[doc = "185mv hysteresis"]
            #[inline(always)]
            pub fn is_en185mv(&self) -> bool {
                *self == HYS::En185mv
            }
            #[doc = "200mv hysteresis"]
            #[inline(always)]
            pub fn is_en200mv(&self) -> bool {
                *self == HYS::En200mv
            }
            #[doc = "210mv hysteresis"]
            #[inline(always)]
            pub fn is_en210mv(&self) -> bool {
                *self == HYS::En210mv
            }
        }
        #[doc = "Field `HYS` writer - Comp Hysteresis Register"]
        pub type HYS_W<'a, REG> = crate::FieldWriter<'a, REG, 5, HYS>;
        impl<'a, REG> HYS_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "hysteresis disabled"]
            #[inline(always)]
            pub fn dis(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::Dis)
            }
            #[doc = "10mv hysteresis enabled"]
            #[inline(always)]
            pub fn en10mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En10mv)
            }
            #[doc = "25mv hysteresis"]
            #[inline(always)]
            pub fn en25mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En25mv)
            }
            #[doc = "35mv hysteresis"]
            #[inline(always)]
            pub fn en35mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En35mv)
            }
            #[doc = "50mv hysteresis"]
            #[inline(always)]
            pub fn en50mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En50mv)
            }
            #[doc = "60mv hysteresis"]
            #[inline(always)]
            pub fn en60mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En60mv)
            }
            #[doc = "75mv hysteresis"]
            #[inline(always)]
            pub fn en75mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En75mv)
            }
            #[doc = "85mv hysteresis"]
            #[inline(always)]
            pub fn en85mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En85mv)
            }
            #[doc = "100mv hysteresis"]
            #[inline(always)]
            pub fn en100mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En100mv)
            }
            #[doc = "110mv hysteresis"]
            #[inline(always)]
            pub fn en110mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En110mv)
            }
            #[doc = "125mv hysteresis"]
            #[inline(always)]
            pub fn en125mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En125mv)
            }
            #[doc = "135mv hysteresis"]
            #[inline(always)]
            pub fn en135mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En135mv)
            }
            #[doc = "150mv hysteresis"]
            #[inline(always)]
            pub fn en150mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En150mv)
            }
            #[doc = "160mv hysteresis"]
            #[inline(always)]
            pub fn en160mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En160mv)
            }
            #[doc = "175mv hysteresis"]
            #[inline(always)]
            pub fn en175mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En175mv)
            }
            #[doc = "185mv hysteresis"]
            #[inline(always)]
            pub fn en185mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En185mv)
            }
            #[doc = "200mv hysteresis"]
            #[inline(always)]
            pub fn en200mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En200mv)
            }
            #[doc = "210mv hysteresis"]
            #[inline(always)]
            pub fn en210mv(self) -> &'a mut crate::W<REG> {
                self.variant(HYS::En210mv)
            }
        }
        #[doc = "Select Output Logic State\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum INV {
            #[doc = "0: Output is High if +ve is higher than -ve input"]
            Nom = 0,
            #[doc = "1: Output is High if -ve is higher than +ve input"]
            Cov = 1,
        }
        impl From<INV> for bool {
            #[inline(always)]
            fn from(variant: INV) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `INV` reader - Select Output Logic State"]
        pub type INV_R = crate::BitReader<INV>;
        impl INV_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> INV {
                match self.bits {
                    false => INV::Nom,
                    true => INV::Cov,
                }
            }
            #[doc = "Output is High if +ve is higher than -ve input"]
            #[inline(always)]
            pub fn is_nom(&self) -> bool {
                *self == INV::Nom
            }
            #[doc = "Output is High if -ve is higher than +ve input"]
            #[inline(always)]
            pub fn is_cov(&self) -> bool {
                *self == INV::Cov
            }
        }
        #[doc = "Field `INV` writer - Select Output Logic State"]
        pub type INV_W<'a, REG> = crate::BitWriter<'a, REG, INV>;
        impl<'a, REG> INV_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Output is High if +ve is higher than -ve input"]
            #[inline(always)]
            pub fn nom(self) -> &'a mut crate::W<REG> {
                self.variant(INV::Nom)
            }
            #[doc = "Output is High if -ve is higher than +ve input"]
            #[inline(always)]
            pub fn cov(self) -> &'a mut crate::W<REG> {
                self.variant(INV::Cov)
            }
        }
        #[doc = "Comp Interrupt Select\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OUT {
            #[doc = "0: Output to Test Pad Disable"]
            Dis00 = 0,
            #[doc = "1: Output to Test Pad Disable"]
            Dis01 = 1,
            #[doc = "2: Output to Test Pad Enable"]
            En10 = 2,
            #[doc = "3: Output to Test Pad Disable"]
            Dis11 = 3,
        }
        impl From<OUT> for u8 {
            #[inline(always)]
            fn from(variant: OUT) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for OUT {
            type Ux = u8;
        }
        impl crate::IsEnum for OUT {}
        #[doc = "Field `OUT` reader - Comp Interrupt Select"]
        pub type OUT_R = crate::FieldReader<OUT>;
        impl OUT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> OUT {
                match self.bits {
                    0 => OUT::Dis00,
                    1 => OUT::Dis01,
                    2 => OUT::En10,
                    3 => OUT::Dis11,
                    _ => unreachable!(),
                }
            }
            #[doc = "Output to Test Pad Disable"]
            #[inline(always)]
            pub fn is_dis00(&self) -> bool {
                *self == OUT::Dis00
            }
            #[doc = "Output to Test Pad Disable"]
            #[inline(always)]
            pub fn is_dis01(&self) -> bool {
                *self == OUT::Dis01
            }
            #[doc = "Output to Test Pad Enable"]
            #[inline(always)]
            pub fn is_en10(&self) -> bool {
                *self == OUT::En10
            }
            #[doc = "Output to Test Pad Disable"]
            #[inline(always)]
            pub fn is_dis11(&self) -> bool {
                *self == OUT::Dis11
            }
        }
        #[doc = "Field `OUT` writer - Comp Interrupt Select"]
        pub type OUT_W<'a, REG> = crate::FieldWriter<'a, REG, 2, OUT, crate::Safe>;
        impl<'a, REG> OUT_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Output to Test Pad Disable"]
            #[inline(always)]
            pub fn dis00(self) -> &'a mut crate::W<REG> {
                self.variant(OUT::Dis00)
            }
            #[doc = "Output to Test Pad Disable"]
            #[inline(always)]
            pub fn dis01(self) -> &'a mut crate::W<REG> {
                self.variant(OUT::Dis01)
            }
            #[doc = "Output to Test Pad Enable"]
            #[inline(always)]
            pub fn en10(self) -> &'a mut crate::W<REG> {
                self.variant(OUT::En10)
            }
            #[doc = "Output to Test Pad Disable"]
            #[inline(always)]
            pub fn dis11(self) -> &'a mut crate::W<REG> {
                self.variant(OUT::Dis11)
            }
        }
        #[doc = "Select Comparator Negative Input Source\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum INNEG {
            #[doc = "0: All Input Switches Off"]
            NoInput = 0,
            #[doc = "1: Enable Half Avdd Input"]
            Ahidiv2in = 1,
            #[doc = "2: Enable AIN9/11/13/15 for Comp 0/1/2/3"]
            AinxN = 2,
            #[doc = "3: Enable VDAC8 Input"]
            Vdac8in = 3,
            #[doc = "4: Enable VDAC9 Input"]
            Vdac9in = 4,
            #[doc = "5: Enable VDAC10 Input"]
            Vdac10in = 5,
            #[doc = "6: Enable VDAC11 Input"]
            Vdac11in = 6,
            #[doc = "7: Enable 1.25V Ref Input from AIN15(BUF1)"]
            V1p25refin = 7,
        }
        impl From<INNEG> for u8 {
            #[inline(always)]
            fn from(variant: INNEG) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for INNEG {
            type Ux = u8;
        }
        impl crate::IsEnum for INNEG {}
        #[doc = "Field `INNEG` reader - Select Comparator Negative Input Source"]
        pub type INNEG_R = crate::FieldReader<INNEG>;
        impl INNEG_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> INNEG {
                match self.bits {
                    0 => INNEG::NoInput,
                    1 => INNEG::Ahidiv2in,
                    2 => INNEG::AinxN,
                    3 => INNEG::Vdac8in,
                    4 => INNEG::Vdac9in,
                    5 => INNEG::Vdac10in,
                    6 => INNEG::Vdac11in,
                    7 => INNEG::V1p25refin,
                    _ => unreachable!(),
                }
            }
            #[doc = "All Input Switches Off"]
            #[inline(always)]
            pub fn is_no_input(&self) -> bool {
                *self == INNEG::NoInput
            }
            #[doc = "Enable Half Avdd Input"]
            #[inline(always)]
            pub fn is_ahidiv2in(&self) -> bool {
                *self == INNEG::Ahidiv2in
            }
            #[doc = "Enable AIN9/11/13/15 for Comp 0/1/2/3"]
            #[inline(always)]
            pub fn is_ainx_n(&self) -> bool {
                *self == INNEG::AinxN
            }
            #[doc = "Enable VDAC8 Input"]
            #[inline(always)]
            pub fn is_vdac8in(&self) -> bool {
                *self == INNEG::Vdac8in
            }
            #[doc = "Enable VDAC9 Input"]
            #[inline(always)]
            pub fn is_vdac9in(&self) -> bool {
                *self == INNEG::Vdac9in
            }
            #[doc = "Enable VDAC10 Input"]
            #[inline(always)]
            pub fn is_vdac10in(&self) -> bool {
                *self == INNEG::Vdac10in
            }
            #[doc = "Enable VDAC11 Input"]
            #[inline(always)]
            pub fn is_vdac11in(&self) -> bool {
                *self == INNEG::Vdac11in
            }
            #[doc = "Enable 1.25V Ref Input from AIN15(BUF1)"]
            #[inline(always)]
            pub fn is_v1p25refin(&self) -> bool {
                *self == INNEG::V1p25refin
            }
        }
        #[doc = "Field `INNEG` writer - Select Comparator Negative Input Source"]
        pub type INNEG_W<'a, REG> = crate::FieldWriter<'a, REG, 3, INNEG, crate::Safe>;
        impl<'a, REG> INNEG_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "All Input Switches Off"]
            #[inline(always)]
            pub fn no_input(self) -> &'a mut crate::W<REG> {
                self.variant(INNEG::NoInput)
            }
            #[doc = "Enable Half Avdd Input"]
            #[inline(always)]
            pub fn ahidiv2in(self) -> &'a mut crate::W<REG> {
                self.variant(INNEG::Ahidiv2in)
            }
            #[doc = "Enable AIN9/11/13/15 for Comp 0/1/2/3"]
            #[inline(always)]
            pub fn ainx_n(self) -> &'a mut crate::W<REG> {
                self.variant(INNEG::AinxN)
            }
            #[doc = "Enable VDAC8 Input"]
            #[inline(always)]
            pub fn vdac8in(self) -> &'a mut crate::W<REG> {
                self.variant(INNEG::Vdac8in)
            }
            #[doc = "Enable VDAC9 Input"]
            #[inline(always)]
            pub fn vdac9in(self) -> &'a mut crate::W<REG> {
                self.variant(INNEG::Vdac9in)
            }
            #[doc = "Enable VDAC10 Input"]
            #[inline(always)]
            pub fn vdac10in(self) -> &'a mut crate::W<REG> {
                self.variant(INNEG::Vdac10in)
            }
            #[doc = "Enable VDAC11 Input"]
            #[inline(always)]
            pub fn vdac11in(self) -> &'a mut crate::W<REG> {
                self.variant(INNEG::Vdac11in)
            }
            #[doc = "Enable 1.25V Ref Input from AIN15(BUF1)"]
            #[inline(always)]
            pub fn v1p25refin(self) -> &'a mut crate::W<REG> {
                self.variant(INNEG::V1p25refin)
            }
        }
        #[doc = "Select Comparator Positive Input Source\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum INPOS {
            #[doc = "0: All Input Switches Off"]
            NoInput = 0,
            #[doc = "1: Enable AIN8/10/12/14 for comp 0/1/2/3"]
            AinxP = 1,
            #[doc = "2: Enable PGA0/1/2/3 for comp 0/1/2/3"]
            Pgain = 2,
            #[doc = "3: Enable GPIO0.6/0.7/2.0/2.1 Analog Signal Input for comp 0/1/2/3"]
            GpioAnain = 3,
        }
        impl From<INPOS> for u8 {
            #[inline(always)]
            fn from(variant: INPOS) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for INPOS {
            type Ux = u8;
        }
        impl crate::IsEnum for INPOS {}
        #[doc = "Field `INPOS` reader - Select Comparator Positive Input Source"]
        pub type INPOS_R = crate::FieldReader<INPOS>;
        impl INPOS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<INPOS> {
                match self.bits {
                    0 => Some(INPOS::NoInput),
                    1 => Some(INPOS::AinxP),
                    2 => Some(INPOS::Pgain),
                    3 => Some(INPOS::GpioAnain),
                    _ => None,
                }
            }
            #[doc = "All Input Switches Off"]
            #[inline(always)]
            pub fn is_no_input(&self) -> bool {
                *self == INPOS::NoInput
            }
            #[doc = "Enable AIN8/10/12/14 for comp 0/1/2/3"]
            #[inline(always)]
            pub fn is_ainx_p(&self) -> bool {
                *self == INPOS::AinxP
            }
            #[doc = "Enable PGA0/1/2/3 for comp 0/1/2/3"]
            #[inline(always)]
            pub fn is_pgain(&self) -> bool {
                *self == INPOS::Pgain
            }
            #[doc = "Enable GPIO0.6/0.7/2.0/2.1 Analog Signal Input for comp 0/1/2/3"]
            #[inline(always)]
            pub fn is_gpio_anain(&self) -> bool {
                *self == INPOS::GpioAnain
            }
        }
        #[doc = "Field `INPOS` writer - Select Comparator Positive Input Source"]
        pub type INPOS_W<'a, REG> = crate::FieldWriter<'a, REG, 3, INPOS>;
        impl<'a, REG> INPOS_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "All Input Switches Off"]
            #[inline(always)]
            pub fn no_input(self) -> &'a mut crate::W<REG> {
                self.variant(INPOS::NoInput)
            }
            #[doc = "Enable AIN8/10/12/14 for comp 0/1/2/3"]
            #[inline(always)]
            pub fn ainx_p(self) -> &'a mut crate::W<REG> {
                self.variant(INPOS::AinxP)
            }
            #[doc = "Enable PGA0/1/2/3 for comp 0/1/2/3"]
            #[inline(always)]
            pub fn pgain(self) -> &'a mut crate::W<REG> {
                self.variant(INPOS::Pgain)
            }
            #[doc = "Enable GPIO0.6/0.7/2.0/2.1 Analog Signal Input for comp 0/1/2/3"]
            #[inline(always)]
            pub fn gpio_anain(self) -> &'a mut crate::W<REG> {
                self.variant(INPOS::GpioAnain)
            }
        }
        #[doc = "Field `EN` reader - Enable Comparator"]
        pub type EN_R = crate::BitReader;
        #[doc = "Field `EN` writer - Enable Comparator"]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `INTEN` reader - Interrupt Enable"]
        pub type INTEN_R = crate::BitReader;
        #[doc = "Field `INTEN` writer - Interrupt Enable"]
        pub type INTEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Interrupt Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum INTMODE {
            #[doc = "0: Generate Interrupt if Rising Edge Happens"]
            Riseedge = 0,
            #[doc = "1: Generate Interrupt if Falling Edge Happens"]
            Falledge = 1,
            #[doc = "2: Generate Interrupt if Low Level Happens"]
            Lowlevel = 2,
            #[doc = "3: Generate Interrupt if High Level Happens"]
            Highlevel = 3,
        }
        impl From<INTMODE> for u8 {
            #[inline(always)]
            fn from(variant: INTMODE) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for INTMODE {
            type Ux = u8;
        }
        impl crate::IsEnum for INTMODE {}
        #[doc = "Field `INTMODE` reader - Interrupt Mode"]
        pub type INTMODE_R = crate::FieldReader<INTMODE>;
        impl INTMODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> INTMODE {
                match self.bits {
                    0 => INTMODE::Riseedge,
                    1 => INTMODE::Falledge,
                    2 => INTMODE::Lowlevel,
                    3 => INTMODE::Highlevel,
                    _ => unreachable!(),
                }
            }
            #[doc = "Generate Interrupt if Rising Edge Happens"]
            #[inline(always)]
            pub fn is_riseedge(&self) -> bool {
                *self == INTMODE::Riseedge
            }
            #[doc = "Generate Interrupt if Falling Edge Happens"]
            #[inline(always)]
            pub fn is_falledge(&self) -> bool {
                *self == INTMODE::Falledge
            }
            #[doc = "Generate Interrupt if Low Level Happens"]
            #[inline(always)]
            pub fn is_lowlevel(&self) -> bool {
                *self == INTMODE::Lowlevel
            }
            #[doc = "Generate Interrupt if High Level Happens"]
            #[inline(always)]
            pub fn is_highlevel(&self) -> bool {
                *self == INTMODE::Highlevel
            }
        }
        #[doc = "Field `INTMODE` writer - Interrupt Mode"]
        pub type INTMODE_W<'a, REG> = crate::FieldWriter<'a, REG, 2, INTMODE, crate::Safe>;
        impl<'a, REG> INTMODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Generate Interrupt if Rising Edge Happens"]
            #[inline(always)]
            pub fn riseedge(self) -> &'a mut crate::W<REG> {
                self.variant(INTMODE::Riseedge)
            }
            #[doc = "Generate Interrupt if Falling Edge Happens"]
            #[inline(always)]
            pub fn falledge(self) -> &'a mut crate::W<REG> {
                self.variant(INTMODE::Falledge)
            }
            #[doc = "Generate Interrupt if Low Level Happens"]
            #[inline(always)]
            pub fn lowlevel(self) -> &'a mut crate::W<REG> {
                self.variant(INTMODE::Lowlevel)
            }
            #[doc = "Generate Interrupt if High Level Happens"]
            #[inline(always)]
            pub fn highlevel(self) -> &'a mut crate::W<REG> {
                self.variant(INTMODE::Highlevel)
            }
        }
        impl R {
            #[doc = "Bits 0:4 - Comp Hysteresis Register"]
            #[inline(always)]
            pub fn hys(&self) -> HYS_R {
                HYS_R::new((self.bits & 0x1f) as u8)
            }
            #[doc = "Bit 7 - Select Output Logic State"]
            #[inline(always)]
            pub fn inv(&self) -> INV_R {
                INV_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bits 8:9 - Comp Interrupt Select"]
            #[inline(always)]
            pub fn out(&self) -> OUT_R {
                OUT_R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:12 - Select Comparator Negative Input Source"]
            #[inline(always)]
            pub fn inneg(&self) -> INNEG_R {
                INNEG_R::new(((self.bits >> 10) & 7) as u8)
            }
            #[doc = "Bits 13:15 - Select Comparator Positive Input Source"]
            #[inline(always)]
            pub fn inpos(&self) -> INPOS_R {
                INPOS_R::new(((self.bits >> 13) & 7) as u8)
            }
            #[doc = "Bit 17 - Enable Comparator"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Interrupt Enable"]
            #[inline(always)]
            pub fn inten(&self) -> INTEN_R {
                INTEN_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bits 19:20 - Interrupt Mode"]
            #[inline(always)]
            pub fn intmode(&self) -> INTMODE_R {
                INTMODE_R::new(((self.bits >> 19) & 3) as u8)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("COMPCON")
                    .field("hys", &self.hys())
                    .field("inv", &self.inv())
                    .field("out", &self.out())
                    .field("inneg", &self.inneg())
                    .field("inpos", &self.inpos())
                    .field("en", &self.en())
                    .field("inten", &self.inten())
                    .field("intmode", &self.intmode())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 0:4 - Comp Hysteresis Register"]
            #[inline(always)]
            pub fn hys(&mut self) -> HYS_W<COMPCONrs> {
                HYS_W::new(self, 0)
            }
            #[doc = "Bit 7 - Select Output Logic State"]
            #[inline(always)]
            pub fn inv(&mut self) -> INV_W<COMPCONrs> {
                INV_W::new(self, 7)
            }
            #[doc = "Bits 8:9 - Comp Interrupt Select"]
            #[inline(always)]
            pub fn out(&mut self) -> OUT_W<COMPCONrs> {
                OUT_W::new(self, 8)
            }
            #[doc = "Bits 10:12 - Select Comparator Negative Input Source"]
            #[inline(always)]
            pub fn inneg(&mut self) -> INNEG_W<COMPCONrs> {
                INNEG_W::new(self, 10)
            }
            #[doc = "Bits 13:15 - Select Comparator Positive Input Source"]
            #[inline(always)]
            pub fn inpos(&mut self) -> INPOS_W<COMPCONrs> {
                INPOS_W::new(self, 13)
            }
            #[doc = "Bit 17 - Enable Comparator"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<COMPCONrs> {
                EN_W::new(self, 17)
            }
            #[doc = "Bit 18 - Interrupt Enable"]
            #[inline(always)]
            pub fn inten(&mut self) -> INTEN_W<COMPCONrs> {
                INTEN_W::new(self, 18)
            }
            #[doc = "Bits 19:20 - Interrupt Mode"]
            #[inline(always)]
            pub fn intmode(&mut self) -> INTMODE_W<COMPCONrs> {
                INTMODE_W::new(self, 19)
            }
        }
        #[doc = "Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`compcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`compcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#COMP:COMPCON[0])"]
        pub struct COMPCONrs;
        impl crate::RegisterSpec for COMPCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`compcon::R`](R) reader structure"]
        impl crate::Readable for COMPCONrs {}
        #[doc = "`write(|w| ..)` method takes [`compcon::W`](W) writer structure"]
        impl crate::Writable for COMPCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets COMPCON[%s]
to value 0x60"]
        impl crate::Resettable for COMPCONrs {
            const RESET_VALUE: u32 = 0x60;
        }
    }
    #[doc = "COMPIRQSTAT (rw) register accessor: Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`compirqstat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`compirqstat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#COMP:COMPIRQSTAT)\n\nFor information about available fields see [`mod@compirqstat`]
module"]
    pub type COMPIRQSTAT = crate::Reg<compirqstat::COMPIRQSTATrs>;
    #[doc = "Unknown"]
    pub mod compirqstat {
        #[doc = "Register `COMPIRQSTAT` reader"]
        pub type R = crate::R<COMPIRQSTATrs>;
        #[doc = "Register `COMPIRQSTAT` writer"]
        pub type W = crate::W<COMPIRQSTATrs>;
        #[doc = "Field `COMP0` reader - Comparator 0 Interrupt Status"]
        pub type COMP0_R = crate::BitReader;
        #[doc = "Field `COMP1` reader - Comparator 1 Interrupt Status"]
        pub type COMP1_R = crate::BitReader;
        #[doc = "Field `COMP2` reader - Comparator 2 Interrupt Status"]
        pub type COMP2_R = crate::BitReader;
        #[doc = "Field `COMP3` reader - Comparator 3 Interrupt Status"]
        pub type COMP3_R = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - Comparator 0 Interrupt Status"]
            #[inline(always)]
            pub fn comp0(&self) -> COMP0_R {
                COMP0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Comparator 1 Interrupt Status"]
            #[inline(always)]
            pub fn comp1(&self) -> COMP1_R {
                COMP1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Comparator 2 Interrupt Status"]
            #[inline(always)]
            pub fn comp2(&self) -> COMP2_R {
                COMP2_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Comparator 3 Interrupt Status"]
            #[inline(always)]
            pub fn comp3(&self) -> COMP3_R {
                COMP3_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("COMPIRQSTAT")
                    .field("comp0", &self.comp0())
                    .field("comp1", &self.comp1())
                    .field("comp2", &self.comp2())
                    .field("comp3", &self.comp3())
                    .finish()
            }
        }
        impl W {}
        #[doc = "Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`compirqstat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`compirqstat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#COMP:COMPIRQSTAT)"]
        pub struct COMPIRQSTATrs;
        impl crate::RegisterSpec for COMPIRQSTATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`compirqstat::R`](R) reader structure"]
        impl crate::Readable for COMPIRQSTATrs {}
        #[doc = "`write(|w| ..)` method takes [`compirqstat::W`](W) writer structure"]
        impl crate::Writable for COMPIRQSTATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets COMPIRQSTAT to value 0"]
        impl crate::Resettable for COMPIRQSTATrs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA)"]
pub struct PGA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PGA {}
impl PGA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pga::RegisterBlock = 0x4006_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pga::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PGA {
    type Target = pga::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PGA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PGA").finish()
    }
}
#[doc = "Unknown"]
pub mod pga {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        pgabiascon: PGABIASCON,
        _reserved1: [u8; 0x1c],
        pga0con: PGA0CON,
        pga0chpcon: PGA0CHPCON,
        pga3chpcon: PGA3CHPCON,
        _reserved4: [u8; 0x44],
        pga1con: PGA1CON,
        pga1chpcon: PGA1CHPCON,
        _reserved6: [u8; 0x28],
        pga2con: PGA2CON,
        pga2chpcon: PGA2CHPCON,
        _reserved8: [u8; 0x28],
        pga3con: PGA3CON,
    }
    impl RegisterBlock {
        #[doc = "0x00 - PGA Bias Circuit Control Signal"]
        #[inline(always)]
        pub const fn pgabiascon(&self) -> &PGABIASCON {
            &self.pgabiascon
        }
        #[doc = "0x20 - PGA0 Control Register"]
        #[inline(always)]
        pub const fn pga0con(&self) -> &PGA0CON {
            &self.pga0con
        }
        #[doc = "0x24 - PGA0 Chop Function Ctrl"]
        #[inline(always)]
        pub const fn pga0chpcon(&self) -> &PGA0CHPCON {
            &self.pga0chpcon
        }
        #[doc = "0x28 - PGA3 Chop Function Ctrl"]
        #[inline(always)]
        pub const fn pga3chpcon(&self) -> &PGA3CHPCON {
            &self.pga3chpcon
        }
        #[doc = "0x70 - PGA1 Control Register"]
        #[inline(always)]
        pub const fn pga1con(&self) -> &PGA1CON {
            &self.pga1con
        }
        #[doc = "0x74 - PGA1 Chop Function Ctrl"]
        #[inline(always)]
        pub const fn pga1chpcon(&self) -> &PGA1CHPCON {
            &self.pga1chpcon
        }
        #[doc = "0xa0 - PGA2 Control Register"]
        #[inline(always)]
        pub const fn pga2con(&self) -> &PGA2CON {
            &self.pga2con
        }
        #[doc = "0xa4 - PGA2 Chop Function Ctrl"]
        #[inline(always)]
        pub const fn pga2chpcon(&self) -> &PGA2CHPCON {
            &self.pga2chpcon
        }
        #[doc = "0xd0 - PGA3 Control Register"]
        #[inline(always)]
        pub const fn pga3con(&self) -> &PGA3CON {
            &self.pga3con
        }
    }
    #[doc = "PGABIASCON (rw) register accessor: PGA Bias Circuit Control Signal\n\nYou can [`read`](crate::Reg::read) this register and get [`pgabiascon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pgabiascon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGABIASCON)\n\nFor information about available fields see [`mod@pgabiascon`]
module"]
    pub type PGABIASCON = crate::Reg<pgabiascon::PGABIASCONrs>;
    #[doc = "PGA Bias Circuit Control Signal"]
    pub mod pgabiascon {
        #[doc = "Register `PGABIASCON` reader"]
        pub type R = crate::R<PGABIASCONrs>;
        #[doc = "Register `PGABIASCON` writer"]
        pub type W = crate::W<PGABIASCONrs>;
        #[doc = "Buf_200mv Power Down\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PD0BUF0P2 {
            #[doc = "0: Buf_200mV Enable"]
            Enable = 0,
            #[doc = "1: Buf_200mv Power Down"]
            Off = 1,
        }
        impl From<PD0BUF0P2> for bool {
            #[inline(always)]
            fn from(variant: PD0BUF0P2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PD0BUF0P2` reader - Buf_200mv Power Down"]
        pub type PD0BUF0P2_R = crate::BitReader<PD0BUF0P2>;
        impl PD0BUF0P2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PD0BUF0P2 {
                match self.bits {
                    false => PD0BUF0P2::Enable,
                    true => PD0BUF0P2::Off,
                }
            }
            #[doc = "Buf_200mV Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == PD0BUF0P2::Enable
            }
            #[doc = "Buf_200mv Power Down"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == PD0BUF0P2::Off
            }
        }
        #[doc = "Field `PD0BUF0P2` writer - Buf_200mv Power Down"]
        pub type PD0BUF0P2_W<'a, REG> = crate::BitWriter<'a, REG, PD0BUF0P2>;
        impl<'a, REG> PD0BUF0P2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Buf_200mV Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(PD0BUF0P2::Enable)
            }
            #[doc = "Buf_200mv Power Down"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(PD0BUF0P2::Off)
            }
        }
        #[doc = "Buf_200mv Power Down\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PD1BUF0P2 {
            #[doc = "0: Buf_200mV Enable"]
            Enable = 0,
            #[doc = "1: Buf_200mv Power Down"]
            Off = 1,
        }
        impl From<PD1BUF0P2> for bool {
            #[inline(always)]
            fn from(variant: PD1BUF0P2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PD1BUF0P2` reader - Buf_200mv Power Down"]
        pub type PD1BUF0P2_R = crate::BitReader<PD1BUF0P2>;
        impl PD1BUF0P2_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PD1BUF0P2 {
                match self.bits {
                    false => PD1BUF0P2::Enable,
                    true => PD1BUF0P2::Off,
                }
            }
            #[doc = "Buf_200mV Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == PD1BUF0P2::Enable
            }
            #[doc = "Buf_200mv Power Down"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == PD1BUF0P2::Off
            }
        }
        #[doc = "Field `PD1BUF0P2` writer - Buf_200mv Power Down"]
        pub type PD1BUF0P2_W<'a, REG> = crate::BitWriter<'a, REG, PD1BUF0P2>;
        impl<'a, REG> PD1BUF0P2_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Buf_200mV Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(PD1BUF0P2::Enable)
            }
            #[doc = "Buf_200mv Power Down"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(PD1BUF0P2::Off)
            }
        }
        #[doc = "BUF1P25 Power Down\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PD0BUF1P25 {
            #[doc = "0: BUF1p25 Enable"]
            Enable = 0,
            #[doc = "1: BUF1p25 Power Down"]
            Off = 1,
        }
        impl From<PD0BUF1P25> for bool {
            #[inline(always)]
            fn from(variant: PD0BUF1P25) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PD0BUF1P25` reader - BUF1P25 Power Down"]
        pub type PD0BUF1P25_R = crate::BitReader<PD0BUF1P25>;
        impl PD0BUF1P25_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PD0BUF1P25 {
                match self.bits {
                    false => PD0BUF1P25::Enable,
                    true => PD0BUF1P25::Off,
                }
            }
            #[doc = "BUF1p25 Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == PD0BUF1P25::Enable
            }
            #[doc = "BUF1p25 Power Down"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == PD0BUF1P25::Off
            }
        }
        #[doc = "Field `PD0BUF1P25` writer - BUF1P25 Power Down"]
        pub type PD0BUF1P25_W<'a, REG> = crate::BitWriter<'a, REG, PD0BUF1P25>;
        impl<'a, REG> PD0BUF1P25_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "BUF1p25 Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(PD0BUF1P25::Enable)
            }
            #[doc = "BUF1p25 Power Down"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(PD0BUF1P25::Off)
            }
        }
        #[doc = "BUF1P25 Power Down\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PD1BUF1P25 {
            #[doc = "0: BUF1p25 Enable"]
            Enable = 0,
            #[doc = "1: BUF1p25 Power Down"]
            Off = 1,
        }
        impl From<PD1BUF1P25> for bool {
            #[inline(always)]
            fn from(variant: PD1BUF1P25) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PD1BUF1P25` reader - BUF1P25 Power Down"]
        pub type PD1BUF1P25_R = crate::BitReader<PD1BUF1P25>;
        impl PD1BUF1P25_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PD1BUF1P25 {
                match self.bits {
                    false => PD1BUF1P25::Enable,
                    true => PD1BUF1P25::Off,
                }
            }
            #[doc = "BUF1p25 Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == PD1BUF1P25::Enable
            }
            #[doc = "BUF1p25 Power Down"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == PD1BUF1P25::Off
            }
        }
        #[doc = "Field `PD1BUF1P25` writer - BUF1P25 Power Down"]
        pub type PD1BUF1P25_W<'a, REG> = crate::BitWriter<'a, REG, PD1BUF1P25>;
        impl<'a, REG> PD1BUF1P25_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "BUF1p25 Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(PD1BUF1P25::Enable)
            }
            #[doc = "BUF1p25 Power Down"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(PD1BUF1P25::Off)
            }
        }
        #[doc = "BUF1P25 Power Down\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PD2BUF1P25 {
            #[doc = "0: BUF1p25 Enable"]
            Enable = 0,
            #[doc = "1: BUF1p25 Power Down"]
            Off = 1,
        }
        impl From<PD2BUF1P25> for bool {
            #[inline(always)]
            fn from(variant: PD2BUF1P25) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PD2BUF1P25` reader - BUF1P25 Power Down"]
        pub type PD2BUF1P25_R = crate::BitReader<PD2BUF1P25>;
        impl PD2BUF1P25_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PD2BUF1P25 {
                match self.bits {
                    false => PD2BUF1P25::Enable,
                    true => PD2BUF1P25::Off,
                }
            }
            #[doc = "BUF1p25 Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == PD2BUF1P25::Enable
            }
            #[doc = "BUF1p25 Power Down"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == PD2BUF1P25::Off
            }
        }
        #[doc = "Field `PD2BUF1P25` writer - BUF1P25 Power Down"]
        pub type PD2BUF1P25_W<'a, REG> = crate::BitWriter<'a, REG, PD2BUF1P25>;
        impl<'a, REG> PD2BUF1P25_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "BUF1p25 Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(PD2BUF1P25::Enable)
            }
            #[doc = "BUF1p25 Power Down"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(PD2BUF1P25::Off)
            }
        }
        #[doc = "BUF1P25 Power Down\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PD3BUF1P25 {
            #[doc = "0: BUF1p25 Enable"]
            Enable = 0,
            #[doc = "1: BUF1p25 Power Down"]
            Off = 1,
        }
        impl From<PD3BUF1P25> for bool {
            #[inline(always)]
            fn from(variant: PD3BUF1P25) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PD3BUF1P25` reader - BUF1P25 Power Down"]
        pub type PD3BUF1P25_R = crate::BitReader<PD3BUF1P25>;
        impl PD3BUF1P25_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PD3BUF1P25 {
                match self.bits {
                    false => PD3BUF1P25::Enable,
                    true => PD3BUF1P25::Off,
                }
            }
            #[doc = "BUF1p25 Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == PD3BUF1P25::Enable
            }
            #[doc = "BUF1p25 Power Down"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == PD3BUF1P25::Off
            }
        }
        #[doc = "Field `PD3BUF1P25` writer - BUF1P25 Power Down"]
        pub type PD3BUF1P25_W<'a, REG> = crate::BitWriter<'a, REG, PD3BUF1P25>;
        impl<'a, REG> PD3BUF1P25_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "BUF1p25 Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(PD3BUF1P25::Enable)
            }
            #[doc = "BUF1p25 Power Down"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(PD3BUF1P25::Off)
            }
        }
        impl R {
            #[doc = "Bit 0 - Buf_200mv Power Down"]
            #[inline(always)]
            pub fn pd0buf0p2(&self) -> PD0BUF0P2_R {
                PD0BUF0P2_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Buf_200mv Power Down"]
            #[inline(always)]
            pub fn pd1buf0p2(&self) -> PD1BUF0P2_R {
                PD1BUF0P2_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - BUF1P25 Power Down"]
            #[inline(always)]
            pub fn pd0buf1p25(&self) -> PD0BUF1P25_R {
                PD0BUF1P25_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - BUF1P25 Power Down"]
            #[inline(always)]
            pub fn pd1buf1p25(&self) -> PD1BUF1P25_R {
                PD1BUF1P25_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - BUF1P25 Power Down"]
            #[inline(always)]
            pub fn pd2buf1p25(&self) -> PD2BUF1P25_R {
                PD2BUF1P25_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - BUF1P25 Power Down"]
            #[inline(always)]
            pub fn pd3buf1p25(&self) -> PD3BUF1P25_R {
                PD3BUF1P25_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PGABIASCON")
                    .field("pd0buf0p2", &self.pd0buf0p2())
                    .field("pd1buf0p2", &self.pd1buf0p2())
                    .field("pd0buf1p25", &self.pd0buf1p25())
                    .field("pd1buf1p25", &self.pd1buf1p25())
                    .field("pd2buf1p25", &self.pd2buf1p25())
                    .field("pd3buf1p25", &self.pd3buf1p25())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Buf_200mv Power Down"]
            #[inline(always)]
            pub fn pd0buf0p2(&mut self) -> PD0BUF0P2_W<PGABIASCONrs> {
                PD0BUF0P2_W::new(self, 0)
            }
            #[doc = "Bit 1 - Buf_200mv Power Down"]
            #[inline(always)]
            pub fn pd1buf0p2(&mut self) -> PD1BUF0P2_W<PGABIASCONrs> {
                PD1BUF0P2_W::new(self, 1)
            }
            #[doc = "Bit 2 - BUF1P25 Power Down"]
            #[inline(always)]
            pub fn pd0buf1p25(&mut self) -> PD0BUF1P25_W<PGABIASCONrs> {
                PD0BUF1P25_W::new(self, 2)
            }
            #[doc = "Bit 3 - BUF1P25 Power Down"]
            #[inline(always)]
            pub fn pd1buf1p25(&mut self) -> PD1BUF1P25_W<PGABIASCONrs> {
                PD1BUF1P25_W::new(self, 3)
            }
            #[doc = "Bit 4 - BUF1P25 Power Down"]
            #[inline(always)]
            pub fn pd2buf1p25(&mut self) -> PD2BUF1P25_W<PGABIASCONrs> {
                PD2BUF1P25_W::new(self, 4)
            }
            #[doc = "Bit 5 - BUF1P25 Power Down"]
            #[inline(always)]
            pub fn pd3buf1p25(&mut self) -> PD3BUF1P25_W<PGABIASCONrs> {
                PD3BUF1P25_W::new(self, 5)
            }
        }
        #[doc = "PGA Bias Circuit Control Signal\n\nYou can [`read`](crate::Reg::read) this register and get [`pgabiascon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pgabiascon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGABIASCON)"]
        pub struct PGABIASCONrs;
        impl crate::RegisterSpec for PGABIASCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pgabiascon::R`](R) reader structure"]
        impl crate::Readable for PGABIASCONrs {}
        #[doc = "`write(|w| ..)` method takes [`pgabiascon::W`](W) writer structure"]
        impl crate::Writable for PGABIASCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PGABIASCON to value 0x3f"]
        impl crate::Resettable for PGABIASCONrs {
            const RESET_VALUE: u32 = 0x3f;
        }
    }
    #[doc = "PGA0CON (rw) register accessor: PGA0 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pga0con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga0con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA0CON)\n\nFor information about available fields see [`mod@pga0con`]
module"]
    pub type PGA0CON = crate::Reg<pga0con::PGA0CONrs>;
    #[doc = "PGA0 Control Register"]
    pub mod pga0con {
        #[doc = "Register `PGA0CON` reader"]
        pub type R = crate::R<PGA0CONrs>;
        #[doc = "Register `PGA0CON` writer"]
        pub type W = crate::W<PGA0CONrs>;
        #[doc = "Field `PDPGACORE` reader - PGA Core Power Down"]
        pub type PDPGACORE_R = crate::BitReader;
        #[doc = "Field `PDPGACORE` writer - PGA Core Power Down"]
        pub type PDPGACORE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "PGA or TIA Mode Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE {
            #[doc = "0: PGA Mode Enable"]
            Pgamode = 0,
            #[doc = "1: TIA Mode Enable"]
            Tiamode = 1,
        }
        impl From<MODE> for bool {
            #[inline(always)]
            fn from(variant: MODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MODE` reader - PGA or TIA Mode Selection"]
        pub type MODE_R = crate::BitReader<MODE>;
        impl MODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MODE {
                match self.bits {
                    false => MODE::Pgamode,
                    true => MODE::Tiamode,
                }
            }
            #[doc = "PGA Mode Enable"]
            #[inline(always)]
            pub fn is_pgamode(&self) -> bool {
                *self == MODE::Pgamode
            }
            #[doc = "TIA Mode Enable"]
            #[inline(always)]
            pub fn is_tiamode(&self) -> bool {
                *self == MODE::Tiamode
            }
        }
        #[doc = "Field `MODE` writer - PGA or TIA Mode Selection"]
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG, MODE>;
        impl<'a, REG> MODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PGA Mode Enable"]
            #[inline(always)]
            pub fn pgamode(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Pgamode)
            }
            #[doc = "TIA Mode Enable"]
            #[inline(always)]
            pub fn tiamode(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Tiamode)
            }
        }
        #[doc = "PGA DC Mode or AC Couple Mode Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PGAMODE {
            #[doc = "0: PGA DC Mode Enable"]
            Dccouple = 0,
            #[doc = "1: PGA AC Coupling Mode Enable"]
            Accouple = 1,
        }
        impl From<PGAMODE> for bool {
            #[inline(always)]
            fn from(variant: PGAMODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PGAMODE` reader - PGA DC Mode or AC Couple Mode Selection"]
        pub type PGAMODE_R = crate::BitReader<PGAMODE>;
        impl PGAMODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PGAMODE {
                match self.bits {
                    false => PGAMODE::Dccouple,
                    true => PGAMODE::Accouple,
                }
            }
            #[doc = "PGA DC Mode Enable"]
            #[inline(always)]
            pub fn is_dccouple(&self) -> bool {
                *self == PGAMODE::Dccouple
            }
            #[doc = "PGA AC Coupling Mode Enable"]
            #[inline(always)]
            pub fn is_accouple(&self) -> bool {
                *self == PGAMODE::Accouple
            }
        }
        #[doc = "Field `PGAMODE` writer - PGA DC Mode or AC Couple Mode Selection"]
        pub type PGAMODE_W<'a, REG> = crate::BitWriter<'a, REG, PGAMODE>;
        impl<'a, REG> PGAMODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PGA DC Mode Enable"]
            #[inline(always)]
            pub fn dccouple(self) -> &'a mut crate::W<REG> {
                self.variant(PGAMODE::Dccouple)
            }
            #[doc = "PGA AC Coupling Mode Enable"]
            #[inline(always)]
            pub fn accouple(self) -> &'a mut crate::W<REG> {
                self.variant(PGAMODE::Accouple)
            }
        }
        #[doc = "Bypass the External Cap\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CAPBYPASS {
            #[doc = "0: Select the External CAP"]
            Bypdisable = 0,
            #[doc = "1: Bypass the External Cap"]
            Bypen = 1,
        }
        impl From<CAPBYPASS> for bool {
            #[inline(always)]
            fn from(variant: CAPBYPASS) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CAPBYPASS` reader - Bypass the External Cap"]
        pub type CAPBYPASS_R = crate::BitReader<CAPBYPASS>;
        impl CAPBYPASS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CAPBYPASS {
                match self.bits {
                    false => CAPBYPASS::Bypdisable,
                    true => CAPBYPASS::Bypen,
                }
            }
            #[doc = "Select the External CAP"]
            #[inline(always)]
            pub fn is_bypdisable(&self) -> bool {
                *self == CAPBYPASS::Bypdisable
            }
            #[doc = "Bypass the External Cap"]
            #[inline(always)]
            pub fn is_bypen(&self) -> bool {
                *self == CAPBYPASS::Bypen
            }
        }
        #[doc = "Field `CAPBYPASS` writer - Bypass the External Cap"]
        pub type CAPBYPASS_W<'a, REG> = crate::BitWriter<'a, REG, CAPBYPASS>;
        impl<'a, REG> CAPBYPASS_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Select the External CAP"]
            #[inline(always)]
            pub fn bypdisable(self) -> &'a mut crate::W<REG> {
                self.variant(CAPBYPASS::Bypdisable)
            }
            #[doc = "Bypass the External Cap"]
            #[inline(always)]
            pub fn bypen(self) -> &'a mut crate::W<REG> {
                self.variant(CAPBYPASS::Bypen)
            }
        }
        #[doc = "PGA Gain Configuration\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PGAGAIN {
            #[doc = "0: Gain=1"]
            Gain1 = 0,
            #[doc = "1: GAIN=2"]
            Gain2 = 1,
            #[doc = "2: GAIN=4"]
            Gain4 = 2,
            #[doc = "3: GAIN=6"]
            Gain6 = 3,
            #[doc = "4: GAIN=8"]
            Gain8 = 4,
            #[doc = "5: GAIN=10"]
            Gain10 = 5,
        }
        impl From<PGAGAIN> for u8 {
            #[inline(always)]
            fn from(variant: PGAGAIN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PGAGAIN {
            type Ux = u8;
        }
        impl crate::IsEnum for PGAGAIN {}
        #[doc = "Field `PGAGAIN` reader - PGA Gain Configuration"]
        pub type PGAGAIN_R = crate::FieldReader<PGAGAIN>;
        impl PGAGAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<PGAGAIN> {
                match self.bits {
                    0 => Some(PGAGAIN::Gain1),
                    1 => Some(PGAGAIN::Gain2),
                    2 => Some(PGAGAIN::Gain4),
                    3 => Some(PGAGAIN::Gain6),
                    4 => Some(PGAGAIN::Gain8),
                    5 => Some(PGAGAIN::Gain10),
                    _ => None,
                }
            }
            #[doc = "Gain=1"]
            #[inline(always)]
            pub fn is_gain1(&self) -> bool {
                *self == PGAGAIN::Gain1
            }
            #[doc = "GAIN=2"]
            #[inline(always)]
            pub fn is_gain2(&self) -> bool {
                *self == PGAGAIN::Gain2
            }
            #[doc = "GAIN=4"]
            #[inline(always)]
            pub fn is_gain4(&self) -> bool {
                *self == PGAGAIN::Gain4
            }
            #[doc = "GAIN=6"]
            #[inline(always)]
            pub fn is_gain6(&self) -> bool {
                *self == PGAGAIN::Gain6
            }
            #[doc = "GAIN=8"]
            #[inline(always)]
            pub fn is_gain8(&self) -> bool {
                *self == PGAGAIN::Gain8
            }
            #[doc = "GAIN=10"]
            #[inline(always)]
            pub fn is_gain10(&self) -> bool {
                *self == PGAGAIN::Gain10
            }
        }
        #[doc = "Field `PGAGAIN` writer - PGA Gain Configuration"]
        pub type PGAGAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 3, PGAGAIN>;
        impl<'a, REG> PGAGAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Gain=1"]
            #[inline(always)]
            pub fn gain1(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain1)
            }
            #[doc = "GAIN=2"]
            #[inline(always)]
            pub fn gain2(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain2)
            }
            #[doc = "GAIN=4"]
            #[inline(always)]
            pub fn gain4(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain4)
            }
            #[doc = "GAIN=6"]
            #[inline(always)]
            pub fn gain6(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain6)
            }
            #[doc = "GAIN=8"]
            #[inline(always)]
            pub fn gain8(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain8)
            }
            #[doc = "GAIN=10"]
            #[inline(always)]
            pub fn gain10(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain10)
            }
        }
        #[doc = "TIA Gain Configuration\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIAGAIN {
            #[doc = "0: TIARES=250ohm"]
            Res250 = 0,
            #[doc = "1: TIARES=750ohm"]
            Res750 = 1,
            #[doc = "2: TIARES=2kohm"]
            Res2k = 2,
            #[doc = "3: TIARES=5kohm"]
            Res5k = 3,
            #[doc = "4: TIARES=10kohm"]
            Res10k = 4,
            #[doc = "5: TIARES=20kohm"]
            Res20k = 5,
            #[doc = "6: TIARES=100kohm"]
            Res100k = 6,
        }
        impl From<TIAGAIN> for u8 {
            #[inline(always)]
            fn from(variant: TIAGAIN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TIAGAIN {
            type Ux = u8;
        }
        impl crate::IsEnum for TIAGAIN {}
        #[doc = "Field `TIAGAIN` reader - TIA Gain Configuration"]
        pub type TIAGAIN_R = crate::FieldReader<TIAGAIN>;
        impl TIAGAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<TIAGAIN> {
                match self.bits {
                    0 => Some(TIAGAIN::Res250),
                    1 => Some(TIAGAIN::Res750),
                    2 => Some(TIAGAIN::Res2k),
                    3 => Some(TIAGAIN::Res5k),
                    4 => Some(TIAGAIN::Res10k),
                    5 => Some(TIAGAIN::Res20k),
                    6 => Some(TIAGAIN::Res100k),
                    _ => None,
                }
            }
            #[doc = "TIARES=250ohm"]
            #[inline(always)]
            pub fn is_res250(&self) -> bool {
                *self == TIAGAIN::Res250
            }
            #[doc = "TIARES=750ohm"]
            #[inline(always)]
            pub fn is_res750(&self) -> bool {
                *self == TIAGAIN::Res750
            }
            #[doc = "TIARES=2kohm"]
            #[inline(always)]
            pub fn is_res2k(&self) -> bool {
                *self == TIAGAIN::Res2k
            }
            #[doc = "TIARES=5kohm"]
            #[inline(always)]
            pub fn is_res5k(&self) -> bool {
                *self == TIAGAIN::Res5k
            }
            #[doc = "TIARES=10kohm"]
            #[inline(always)]
            pub fn is_res10k(&self) -> bool {
                *self == TIAGAIN::Res10k
            }
            #[doc = "TIARES=20kohm"]
            #[inline(always)]
            pub fn is_res20k(&self) -> bool {
                *self == TIAGAIN::Res20k
            }
            #[doc = "TIARES=100kohm"]
            #[inline(always)]
            pub fn is_res100k(&self) -> bool {
                *self == TIAGAIN::Res100k
            }
        }
        #[doc = "Field `TIAGAIN` writer - TIA Gain Configuration"]
        pub type TIAGAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 3, TIAGAIN>;
        impl<'a, REG> TIAGAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "TIARES=250ohm"]
            #[inline(always)]
            pub fn res250(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res250)
            }
            #[doc = "TIARES=750ohm"]
            #[inline(always)]
            pub fn res750(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res750)
            }
            #[doc = "TIARES=2kohm"]
            #[inline(always)]
            pub fn res2k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res2k)
            }
            #[doc = "TIARES=5kohm"]
            #[inline(always)]
            pub fn res5k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res5k)
            }
            #[doc = "TIARES=10kohm"]
            #[inline(always)]
            pub fn res10k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res10k)
            }
            #[doc = "TIARES=20kohm"]
            #[inline(always)]
            pub fn res20k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res20k)
            }
            #[doc = "TIARES=100kohm"]
            #[inline(always)]
            pub fn res100k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res100k)
            }
        }
        #[doc = "TIA Vbias Selection of VDAC Channel\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIAVDACSEL {
            #[doc = "0: Select VDAC8 as TIA Vbias"]
            Vdac8sel = 0,
            #[doc = "1: Select VDAC9 as TIA Vbias"]
            Vdac9sel = 1,
            #[doc = "2: Select VDAC10 as TIA Vbias"]
            Vdac10sel = 2,
            #[doc = "3: Select VDAC11 as TIA Vbias"]
            Vdac11sel = 3,
        }
        impl From<TIAVDACSEL> for u8 {
            #[inline(always)]
            fn from(variant: TIAVDACSEL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TIAVDACSEL {
            type Ux = u8;
        }
        impl crate::IsEnum for TIAVDACSEL {}
        #[doc = "Field `TIAVDACSEL` reader - TIA Vbias Selection of VDAC Channel"]
        pub type TIAVDACSEL_R = crate::FieldReader<TIAVDACSEL>;
        impl TIAVDACSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TIAVDACSEL {
                match self.bits {
                    0 => TIAVDACSEL::Vdac8sel,
                    1 => TIAVDACSEL::Vdac9sel,
                    2 => TIAVDACSEL::Vdac10sel,
                    3 => TIAVDACSEL::Vdac11sel,
                    _ => unreachable!(),
                }
            }
            #[doc = "Select VDAC8 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac8sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac8sel
            }
            #[doc = "Select VDAC9 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac9sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac9sel
            }
            #[doc = "Select VDAC10 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac10sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac10sel
            }
            #[doc = "Select VDAC11 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac11sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac11sel
            }
        }
        #[doc = "Field `TIAVDACSEL` writer - TIA Vbias Selection of VDAC Channel"]
        pub type TIAVDACSEL_W<'a, REG> = crate::FieldWriter<'a, REG, 2, TIAVDACSEL, crate::Safe>;
        impl<'a, REG> TIAVDACSEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Select VDAC8 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac8sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac8sel)
            }
            #[doc = "Select VDAC9 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac9sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac9sel)
            }
            #[doc = "Select VDAC10 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac10sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac10sel)
            }
            #[doc = "Select VDAC11 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac11sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac11sel)
            }
        }
        #[doc = "Sink Current Ability Improve\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DRVEN {
            #[doc = "0: Disable Isink Ability Improvement, Normal Drive"]
            Drvdisable = 0,
            #[doc = "1: Enable Isink Ability Improvement"]
            Drvenable = 1,
        }
        impl From<DRVEN> for bool {
            #[inline(always)]
            fn from(variant: DRVEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DRVEN` reader - Sink Current Ability Improve"]
        pub type DRVEN_R = crate::BitReader<DRVEN>;
        impl DRVEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DRVEN {
                match self.bits {
                    false => DRVEN::Drvdisable,
                    true => DRVEN::Drvenable,
                }
            }
            #[doc = "Disable Isink Ability Improvement, Normal Drive"]
            #[inline(always)]
            pub fn is_drvdisable(&self) -> bool {
                *self == DRVEN::Drvdisable
            }
            #[doc = "Enable Isink Ability Improvement"]
            #[inline(always)]
            pub fn is_drvenable(&self) -> bool {
                *self == DRVEN::Drvenable
            }
        }
        #[doc = "Field `DRVEN` writer - Sink Current Ability Improve"]
        pub type DRVEN_W<'a, REG> = crate::BitWriter<'a, REG, DRVEN>;
        impl<'a, REG> DRVEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable Isink Ability Improvement, Normal Drive"]
            #[inline(always)]
            pub fn drvdisable(self) -> &'a mut crate::W<REG> {
                self.variant(DRVEN::Drvdisable)
            }
            #[doc = "Enable Isink Ability Improvement"]
            #[inline(always)]
            pub fn drvenable(self) -> &'a mut crate::W<REG> {
                self.variant(DRVEN::Drvenable)
            }
        }
        #[doc = "Select Between Source Mode and Sink Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TIASRCEN {
            #[doc = "0: Sink Mode"]
            Sinkmd = 0,
            #[doc = "1: Source Mode"]
            Sourcemd = 1,
        }
        impl From<TIASRCEN> for bool {
            #[inline(always)]
            fn from(variant: TIASRCEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIASRCEN` reader - Select Between Source Mode and Sink Mode"]
        pub type TIASRCEN_R = crate::BitReader<TIASRCEN>;
        impl TIASRCEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TIASRCEN {
                match self.bits {
                    false => TIASRCEN::Sinkmd,
                    true => TIASRCEN::Sourcemd,
                }
            }
            #[doc = "Sink Mode"]
            #[inline(always)]
            pub fn is_sinkmd(&self) -> bool {
                *self == TIASRCEN::Sinkmd
            }
            #[doc = "Source Mode"]
            #[inline(always)]
            pub fn is_sourcemd(&self) -> bool {
                *self == TIASRCEN::Sourcemd
            }
        }
        #[doc = "Field `TIASRCEN` writer - Select Between Source Mode and Sink Mode"]
        pub type TIASRCEN_W<'a, REG> = crate::BitWriter<'a, REG, TIASRCEN>;
        impl<'a, REG> TIASRCEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Sink Mode"]
            #[inline(always)]
            pub fn sinkmd(self) -> &'a mut crate::W<REG> {
                self.variant(TIASRCEN::Sinkmd)
            }
            #[doc = "Source Mode"]
            #[inline(always)]
            pub fn sourcemd(self) -> &'a mut crate::W<REG> {
                self.variant(TIASRCEN::Sourcemd)
            }
        }
        impl R {
            #[doc = "Bit 0 - PGA Core Power Down"]
            #[inline(always)]
            pub fn pdpgacore(&self) -> PDPGACORE_R {
                PDPGACORE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - PGA or TIA Mode Selection"]
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - PGA DC Mode or AC Couple Mode Selection"]
            #[inline(always)]
            pub fn pgamode(&self) -> PGAMODE_R {
                PGAMODE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Bypass the External Cap"]
            #[inline(always)]
            pub fn capbypass(&self) -> CAPBYPASS_R {
                CAPBYPASS_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 5:7 - PGA Gain Configuration"]
            #[inline(always)]
            pub fn pgagain(&self) -> PGAGAIN_R {
                PGAGAIN_R::new(((self.bits >> 5) & 7) as u8)
            }
            #[doc = "Bits 8:10 - TIA Gain Configuration"]
            #[inline(always)]
            pub fn tiagain(&self) -> TIAGAIN_R {
                TIAGAIN_R::new(((self.bits >> 8) & 7) as u8)
            }
            #[doc = "Bits 11:12 - TIA Vbias Selection of VDAC Channel"]
            #[inline(always)]
            pub fn tiavdacsel(&self) -> TIAVDACSEL_R {
                TIAVDACSEL_R::new(((self.bits >> 11) & 3) as u8)
            }
            #[doc = "Bit 14 - Sink Current Ability Improve"]
            #[inline(always)]
            pub fn drven(&self) -> DRVEN_R {
                DRVEN_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Select Between Source Mode and Sink Mode"]
            #[inline(always)]
            pub fn tiasrcen(&self) -> TIASRCEN_R {
                TIASRCEN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PGA0CON")
                    .field("pdpgacore", &self.pdpgacore())
                    .field("mode", &self.mode())
                    .field("pgamode", &self.pgamode())
                    .field("capbypass", &self.capbypass())
                    .field("pgagain", &self.pgagain())
                    .field("tiagain", &self.tiagain())
                    .field("tiavdacsel", &self.tiavdacsel())
                    .field("drven", &self.drven())
                    .field("tiasrcen", &self.tiasrcen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - PGA Core Power Down"]
            #[inline(always)]
            pub fn pdpgacore(&mut self) -> PDPGACORE_W<PGA0CONrs> {
                PDPGACORE_W::new(self, 0)
            }
            #[doc = "Bit 1 - PGA or TIA Mode Selection"]
            #[inline(always)]
            pub fn mode(&mut self) -> MODE_W<PGA0CONrs> {
                MODE_W::new(self, 1)
            }
            #[doc = "Bit 2 - PGA DC Mode or AC Couple Mode Selection"]
            #[inline(always)]
            pub fn pgamode(&mut self) -> PGAMODE_W<PGA0CONrs> {
                PGAMODE_W::new(self, 2)
            }
            #[doc = "Bit 3 - Bypass the External Cap"]
            #[inline(always)]
            pub fn capbypass(&mut self) -> CAPBYPASS_W<PGA0CONrs> {
                CAPBYPASS_W::new(self, 3)
            }
            #[doc = "Bits 5:7 - PGA Gain Configuration"]
            #[inline(always)]
            pub fn pgagain(&mut self) -> PGAGAIN_W<PGA0CONrs> {
                PGAGAIN_W::new(self, 5)
            }
            #[doc = "Bits 8:10 - TIA Gain Configuration"]
            #[inline(always)]
            pub fn tiagain(&mut self) -> TIAGAIN_W<PGA0CONrs> {
                TIAGAIN_W::new(self, 8)
            }
            #[doc = "Bits 11:12 - TIA Vbias Selection of VDAC Channel"]
            #[inline(always)]
            pub fn tiavdacsel(&mut self) -> TIAVDACSEL_W<PGA0CONrs> {
                TIAVDACSEL_W::new(self, 11)
            }
            #[doc = "Bit 14 - Sink Current Ability Improve"]
            #[inline(always)]
            pub fn drven(&mut self) -> DRVEN_W<PGA0CONrs> {
                DRVEN_W::new(self, 14)
            }
            #[doc = "Bit 15 - Select Between Source Mode and Sink Mode"]
            #[inline(always)]
            pub fn tiasrcen(&mut self) -> TIASRCEN_W<PGA0CONrs> {
                TIASRCEN_W::new(self, 15)
            }
        }
        #[doc = "PGA0 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pga0con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga0con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA0CON)"]
        pub struct PGA0CONrs;
        impl crate::RegisterSpec for PGA0CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pga0con::R`](R) reader structure"]
        impl crate::Readable for PGA0CONrs {}
        #[doc = "`write(|w| ..)` method takes [`pga0con::W`](W) writer structure"]
        impl crate::Writable for PGA0CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PGA0CON to value 0x19"]
        impl crate::Resettable for PGA0CONrs {
            const RESET_VALUE: u32 = 0x19;
        }
    }
    #[doc = "PGA0CHPCON (rw) register accessor: PGA0 Chop Function Ctrl\n\nYou can [`read`](crate::Reg::read) this register and get [`pga0chpcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga0chpcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA0CHPCON)\n\nFor information about available fields see [`mod@pga0chpcon`]
module"]
    pub type PGA0CHPCON = crate::Reg<pga0chpcon::PGA0CHPCONrs>;
    #[doc = "PGA0 Chop Function Ctrl"]
    pub mod pga0chpcon {
        #[doc = "Register `PGA0CHPCON` reader"]
        pub type R = crate::R<PGA0CHPCONrs>;
        #[doc = "Register `PGA0CHPCON` writer"]
        pub type W = crate::W<PGA0CHPCONrs>;
        #[doc = "Disable Chop Function\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CHOPOFF {
            #[doc = "0: Enable Chop Function"]
            Chopen = 0,
            #[doc = "1: Disable Chop Function"]
            Chopdis = 1,
        }
        impl From<CHOPOFF> for bool {
            #[inline(always)]
            fn from(variant: CHOPOFF) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CHOPOFF` reader - Disable Chop Function"]
        pub type CHOPOFF_R = crate::BitReader<CHOPOFF>;
        impl CHOPOFF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CHOPOFF {
                match self.bits {
                    false => CHOPOFF::Chopen,
                    true => CHOPOFF::Chopdis,
                }
            }
            #[doc = "Enable Chop Function"]
            #[inline(always)]
            pub fn is_chopen(&self) -> bool {
                *self == CHOPOFF::Chopen
            }
            #[doc = "Disable Chop Function"]
            #[inline(always)]
            pub fn is_chopdis(&self) -> bool {
                *self == CHOPOFF::Chopdis
            }
        }
        #[doc = "Field `CHOPOFF` writer - Disable Chop Function"]
        pub type CHOPOFF_W<'a, REG> = crate::BitWriter<'a, REG, CHOPOFF>;
        impl<'a, REG> CHOPOFF_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Enable Chop Function"]
            #[inline(always)]
            pub fn chopen(self) -> &'a mut crate::W<REG> {
                self.variant(CHOPOFF::Chopen)
            }
            #[doc = "Disable Chop Function"]
            #[inline(always)]
            pub fn chopdis(self) -> &'a mut crate::W<REG> {
                self.variant(CHOPOFF::Chopdis)
            }
        }
        impl R {
            #[doc = "Bit 0 - Disable Chop Function"]
            #[inline(always)]
            pub fn chopoff(&self) -> CHOPOFF_R {
                CHOPOFF_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PGA0CHPCON")
                    .field("chopoff", &self.chopoff())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Disable Chop Function"]
            #[inline(always)]
            pub fn chopoff(&mut self) -> CHOPOFF_W<PGA0CHPCONrs> {
                CHOPOFF_W::new(self, 0)
            }
        }
        #[doc = "PGA0 Chop Function Ctrl\n\nYou can [`read`](crate::Reg::read) this register and get [`pga0chpcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga0chpcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA0CHPCON)"]
        pub struct PGA0CHPCONrs;
        impl crate::RegisterSpec for PGA0CHPCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pga0chpcon::R`](R) reader structure"]
        impl crate::Readable for PGA0CHPCONrs {}
        #[doc = "`write(|w| ..)` method takes [`pga0chpcon::W`](W) writer structure"]
        impl crate::Writable for PGA0CHPCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PGA0CHPCON to value 0x01"]
        impl crate::Resettable for PGA0CHPCONrs {
            const RESET_VALUE: u32 = 0x01;
        }
    }
    #[doc = "PGA3CHPCON (rw) register accessor: PGA3 Chop Function Ctrl\n\nYou can [`read`](crate::Reg::read) this register and get [`pga3chpcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga3chpcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA3CHPCON)\n\nFor information about available fields see [`mod@pga3chpcon`]
module"]
    pub type PGA3CHPCON = crate::Reg<pga3chpcon::PGA3CHPCONrs>;
    #[doc = "PGA3 Chop Function Ctrl"]
    pub mod pga3chpcon {
        #[doc = "Register `PGA3CHPCON` reader"]
        pub type R = crate::R<PGA3CHPCONrs>;
        #[doc = "Register `PGA3CHPCON` writer"]
        pub type W = crate::W<PGA3CHPCONrs>;
        #[doc = "Disable Chop Function\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CHOPOFF {
            #[doc = "0: Enable Chop Function"]
            Chopen = 0,
            #[doc = "1: Disable Chop Function"]
            Chopdis = 1,
        }
        impl From<CHOPOFF> for bool {
            #[inline(always)]
            fn from(variant: CHOPOFF) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CHOPOFF` reader - Disable Chop Function"]
        pub type CHOPOFF_R = crate::BitReader<CHOPOFF>;
        impl CHOPOFF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CHOPOFF {
                match self.bits {
                    false => CHOPOFF::Chopen,
                    true => CHOPOFF::Chopdis,
                }
            }
            #[doc = "Enable Chop Function"]
            #[inline(always)]
            pub fn is_chopen(&self) -> bool {
                *self == CHOPOFF::Chopen
            }
            #[doc = "Disable Chop Function"]
            #[inline(always)]
            pub fn is_chopdis(&self) -> bool {
                *self == CHOPOFF::Chopdis
            }
        }
        #[doc = "Field `CHOPOFF` writer - Disable Chop Function"]
        pub type CHOPOFF_W<'a, REG> = crate::BitWriter<'a, REG, CHOPOFF>;
        impl<'a, REG> CHOPOFF_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Enable Chop Function"]
            #[inline(always)]
            pub fn chopen(self) -> &'a mut crate::W<REG> {
                self.variant(CHOPOFF::Chopen)
            }
            #[doc = "Disable Chop Function"]
            #[inline(always)]
            pub fn chopdis(self) -> &'a mut crate::W<REG> {
                self.variant(CHOPOFF::Chopdis)
            }
        }
        impl R {
            #[doc = "Bit 0 - Disable Chop Function"]
            #[inline(always)]
            pub fn chopoff(&self) -> CHOPOFF_R {
                CHOPOFF_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PGA3CHPCON")
                    .field("chopoff", &self.chopoff())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Disable Chop Function"]
            #[inline(always)]
            pub fn chopoff(&mut self) -> CHOPOFF_W<PGA3CHPCONrs> {
                CHOPOFF_W::new(self, 0)
            }
        }
        #[doc = "PGA3 Chop Function Ctrl\n\nYou can [`read`](crate::Reg::read) this register and get [`pga3chpcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga3chpcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA3CHPCON)"]
        pub struct PGA3CHPCONrs;
        impl crate::RegisterSpec for PGA3CHPCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pga3chpcon::R`](R) reader structure"]
        impl crate::Readable for PGA3CHPCONrs {}
        #[doc = "`write(|w| ..)` method takes [`pga3chpcon::W`](W) writer structure"]
        impl crate::Writable for PGA3CHPCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PGA3CHPCON to value 0x01"]
        impl crate::Resettable for PGA3CHPCONrs {
            const RESET_VALUE: u32 = 0x01;
        }
    }
    #[doc = "PGA1CON (rw) register accessor: PGA1 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pga1con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga1con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA1CON)\n\nFor information about available fields see [`mod@pga1con`]
module"]
    pub type PGA1CON = crate::Reg<pga1con::PGA1CONrs>;
    #[doc = "PGA1 Control Register"]
    pub mod pga1con {
        #[doc = "Register `PGA1CON` reader"]
        pub type R = crate::R<PGA1CONrs>;
        #[doc = "Register `PGA1CON` writer"]
        pub type W = crate::W<PGA1CONrs>;
        #[doc = "Field `PDPGACORE` reader - PGA Core Power Down"]
        pub type PDPGACORE_R = crate::BitReader;
        #[doc = "Field `PDPGACORE` writer - PGA Core Power Down"]
        pub type PDPGACORE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "PGA or TIA Mode Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE {
            #[doc = "0: PGA Mode Enable"]
            Pgamode = 0,
            #[doc = "1: TIA Mode Enable"]
            Tiamode = 1,
        }
        impl From<MODE> for bool {
            #[inline(always)]
            fn from(variant: MODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MODE` reader - PGA or TIA Mode Selection"]
        pub type MODE_R = crate::BitReader<MODE>;
        impl MODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MODE {
                match self.bits {
                    false => MODE::Pgamode,
                    true => MODE::Tiamode,
                }
            }
            #[doc = "PGA Mode Enable"]
            #[inline(always)]
            pub fn is_pgamode(&self) -> bool {
                *self == MODE::Pgamode
            }
            #[doc = "TIA Mode Enable"]
            #[inline(always)]
            pub fn is_tiamode(&self) -> bool {
                *self == MODE::Tiamode
            }
        }
        #[doc = "Field `MODE` writer - PGA or TIA Mode Selection"]
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG, MODE>;
        impl<'a, REG> MODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PGA Mode Enable"]
            #[inline(always)]
            pub fn pgamode(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Pgamode)
            }
            #[doc = "TIA Mode Enable"]
            #[inline(always)]
            pub fn tiamode(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Tiamode)
            }
        }
        #[doc = "PGA DC Mode or AC Couple Mode Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PGAMODE {
            #[doc = "0: PGA DC Mode Enable"]
            Dccouple = 0,
            #[doc = "1: PGA AC Coupling Mode Enable"]
            Accouple = 1,
        }
        impl From<PGAMODE> for bool {
            #[inline(always)]
            fn from(variant: PGAMODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PGAMODE` reader - PGA DC Mode or AC Couple Mode Selection"]
        pub type PGAMODE_R = crate::BitReader<PGAMODE>;
        impl PGAMODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PGAMODE {
                match self.bits {
                    false => PGAMODE::Dccouple,
                    true => PGAMODE::Accouple,
                }
            }
            #[doc = "PGA DC Mode Enable"]
            #[inline(always)]
            pub fn is_dccouple(&self) -> bool {
                *self == PGAMODE::Dccouple
            }
            #[doc = "PGA AC Coupling Mode Enable"]
            #[inline(always)]
            pub fn is_accouple(&self) -> bool {
                *self == PGAMODE::Accouple
            }
        }
        #[doc = "Field `PGAMODE` writer - PGA DC Mode or AC Couple Mode Selection"]
        pub type PGAMODE_W<'a, REG> = crate::BitWriter<'a, REG, PGAMODE>;
        impl<'a, REG> PGAMODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PGA DC Mode Enable"]
            #[inline(always)]
            pub fn dccouple(self) -> &'a mut crate::W<REG> {
                self.variant(PGAMODE::Dccouple)
            }
            #[doc = "PGA AC Coupling Mode Enable"]
            #[inline(always)]
            pub fn accouple(self) -> &'a mut crate::W<REG> {
                self.variant(PGAMODE::Accouple)
            }
        }
        #[doc = "PGA Gain Configuration\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PGAGAIN {
            #[doc = "0: Gain=1"]
            Gain1 = 0,
            #[doc = "1: GAIN=2"]
            Gain2 = 1,
            #[doc = "2: GAIN=4"]
            Gain4 = 2,
            #[doc = "3: GAIN=6"]
            Gain6 = 3,
            #[doc = "4: GAIN=8"]
            Gain8 = 4,
            #[doc = "5: GAIN=10"]
            Gain10 = 5,
        }
        impl From<PGAGAIN> for u8 {
            #[inline(always)]
            fn from(variant: PGAGAIN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PGAGAIN {
            type Ux = u8;
        }
        impl crate::IsEnum for PGAGAIN {}
        #[doc = "Field `PGAGAIN` reader - PGA Gain Configuration"]
        pub type PGAGAIN_R = crate::FieldReader<PGAGAIN>;
        impl PGAGAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<PGAGAIN> {
                match self.bits {
                    0 => Some(PGAGAIN::Gain1),
                    1 => Some(PGAGAIN::Gain2),
                    2 => Some(PGAGAIN::Gain4),
                    3 => Some(PGAGAIN::Gain6),
                    4 => Some(PGAGAIN::Gain8),
                    5 => Some(PGAGAIN::Gain10),
                    _ => None,
                }
            }
            #[doc = "Gain=1"]
            #[inline(always)]
            pub fn is_gain1(&self) -> bool {
                *self == PGAGAIN::Gain1
            }
            #[doc = "GAIN=2"]
            #[inline(always)]
            pub fn is_gain2(&self) -> bool {
                *self == PGAGAIN::Gain2
            }
            #[doc = "GAIN=4"]
            #[inline(always)]
            pub fn is_gain4(&self) -> bool {
                *self == PGAGAIN::Gain4
            }
            #[doc = "GAIN=6"]
            #[inline(always)]
            pub fn is_gain6(&self) -> bool {
                *self == PGAGAIN::Gain6
            }
            #[doc = "GAIN=8"]
            #[inline(always)]
            pub fn is_gain8(&self) -> bool {
                *self == PGAGAIN::Gain8
            }
            #[doc = "GAIN=10"]
            #[inline(always)]
            pub fn is_gain10(&self) -> bool {
                *self == PGAGAIN::Gain10
            }
        }
        #[doc = "Field `PGAGAIN` writer - PGA Gain Configuration"]
        pub type PGAGAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 3, PGAGAIN>;
        impl<'a, REG> PGAGAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Gain=1"]
            #[inline(always)]
            pub fn gain1(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain1)
            }
            #[doc = "GAIN=2"]
            #[inline(always)]
            pub fn gain2(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain2)
            }
            #[doc = "GAIN=4"]
            #[inline(always)]
            pub fn gain4(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain4)
            }
            #[doc = "GAIN=6"]
            #[inline(always)]
            pub fn gain6(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain6)
            }
            #[doc = "GAIN=8"]
            #[inline(always)]
            pub fn gain8(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain8)
            }
            #[doc = "GAIN=10"]
            #[inline(always)]
            pub fn gain10(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain10)
            }
        }
        #[doc = "TIA Gain Configuration\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIAGAIN {
            #[doc = "0: TIARES=250ohm"]
            Res250 = 0,
            #[doc = "1: TIARES=750ohm"]
            Res750 = 1,
            #[doc = "2: TIARES=2kohm"]
            Res2k = 2,
            #[doc = "3: TIARES=5kohm"]
            Res5k = 3,
            #[doc = "4: TIARES=10kohm"]
            Res10k = 4,
            #[doc = "5: TIARES=20kohm"]
            Res20k = 5,
            #[doc = "6: TIARES=100kohm"]
            Res100k = 6,
        }
        impl From<TIAGAIN> for u8 {
            #[inline(always)]
            fn from(variant: TIAGAIN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TIAGAIN {
            type Ux = u8;
        }
        impl crate::IsEnum for TIAGAIN {}
        #[doc = "Field `TIAGAIN` reader - TIA Gain Configuration"]
        pub type TIAGAIN_R = crate::FieldReader<TIAGAIN>;
        impl TIAGAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<TIAGAIN> {
                match self.bits {
                    0 => Some(TIAGAIN::Res250),
                    1 => Some(TIAGAIN::Res750),
                    2 => Some(TIAGAIN::Res2k),
                    3 => Some(TIAGAIN::Res5k),
                    4 => Some(TIAGAIN::Res10k),
                    5 => Some(TIAGAIN::Res20k),
                    6 => Some(TIAGAIN::Res100k),
                    _ => None,
                }
            }
            #[doc = "TIARES=250ohm"]
            #[inline(always)]
            pub fn is_res250(&self) -> bool {
                *self == TIAGAIN::Res250
            }
            #[doc = "TIARES=750ohm"]
            #[inline(always)]
            pub fn is_res750(&self) -> bool {
                *self == TIAGAIN::Res750
            }
            #[doc = "TIARES=2kohm"]
            #[inline(always)]
            pub fn is_res2k(&self) -> bool {
                *self == TIAGAIN::Res2k
            }
            #[doc = "TIARES=5kohm"]
            #[inline(always)]
            pub fn is_res5k(&self) -> bool {
                *self == TIAGAIN::Res5k
            }
            #[doc = "TIARES=10kohm"]
            #[inline(always)]
            pub fn is_res10k(&self) -> bool {
                *self == TIAGAIN::Res10k
            }
            #[doc = "TIARES=20kohm"]
            #[inline(always)]
            pub fn is_res20k(&self) -> bool {
                *self == TIAGAIN::Res20k
            }
            #[doc = "TIARES=100kohm"]
            #[inline(always)]
            pub fn is_res100k(&self) -> bool {
                *self == TIAGAIN::Res100k
            }
        }
        #[doc = "Field `TIAGAIN` writer - TIA Gain Configuration"]
        pub type TIAGAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 3, TIAGAIN>;
        impl<'a, REG> TIAGAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "TIARES=250ohm"]
            #[inline(always)]
            pub fn res250(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res250)
            }
            #[doc = "TIARES=750ohm"]
            #[inline(always)]
            pub fn res750(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res750)
            }
            #[doc = "TIARES=2kohm"]
            #[inline(always)]
            pub fn res2k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res2k)
            }
            #[doc = "TIARES=5kohm"]
            #[inline(always)]
            pub fn res5k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res5k)
            }
            #[doc = "TIARES=10kohm"]
            #[inline(always)]
            pub fn res10k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res10k)
            }
            #[doc = "TIARES=20kohm"]
            #[inline(always)]
            pub fn res20k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res20k)
            }
            #[doc = "TIARES=100kohm"]
            #[inline(always)]
            pub fn res100k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res100k)
            }
        }
        #[doc = "TIA Vbias Selection of VDAC Channel\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIAVDACSEL {
            #[doc = "0: Select VDAC8 as TIA Vbias"]
            Vdac8sel = 0,
            #[doc = "1: Select VDAC9 as TIA Vbias"]
            Vdac9sel = 1,
            #[doc = "2: Select VDAC10 as TIA Vbias"]
            Vdac10sel = 2,
            #[doc = "3: Select VDAC11 as TIA Vbias"]
            Vdac11sel = 3,
        }
        impl From<TIAVDACSEL> for u8 {
            #[inline(always)]
            fn from(variant: TIAVDACSEL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TIAVDACSEL {
            type Ux = u8;
        }
        impl crate::IsEnum for TIAVDACSEL {}
        #[doc = "Field `TIAVDACSEL` reader - TIA Vbias Selection of VDAC Channel"]
        pub type TIAVDACSEL_R = crate::FieldReader<TIAVDACSEL>;
        impl TIAVDACSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TIAVDACSEL {
                match self.bits {
                    0 => TIAVDACSEL::Vdac8sel,
                    1 => TIAVDACSEL::Vdac9sel,
                    2 => TIAVDACSEL::Vdac10sel,
                    3 => TIAVDACSEL::Vdac11sel,
                    _ => unreachable!(),
                }
            }
            #[doc = "Select VDAC8 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac8sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac8sel
            }
            #[doc = "Select VDAC9 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac9sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac9sel
            }
            #[doc = "Select VDAC10 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac10sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac10sel
            }
            #[doc = "Select VDAC11 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac11sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac11sel
            }
        }
        #[doc = "Field `TIAVDACSEL` writer - TIA Vbias Selection of VDAC Channel"]
        pub type TIAVDACSEL_W<'a, REG> = crate::FieldWriter<'a, REG, 2, TIAVDACSEL, crate::Safe>;
        impl<'a, REG> TIAVDACSEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Select VDAC8 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac8sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac8sel)
            }
            #[doc = "Select VDAC9 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac9sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac9sel)
            }
            #[doc = "Select VDAC10 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac10sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac10sel)
            }
            #[doc = "Select VDAC11 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac11sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac11sel)
            }
        }
        #[doc = "Sink Current Ability Improve\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DRVEN {
            #[doc = "0: Disable Isink Ability Improvement, Normal Drive"]
            Drvdisable = 0,
            #[doc = "1: Enable Isink Ability Improvement"]
            Drvenable = 1,
        }
        impl From<DRVEN> for bool {
            #[inline(always)]
            fn from(variant: DRVEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DRVEN` reader - Sink Current Ability Improve"]
        pub type DRVEN_R = crate::BitReader<DRVEN>;
        impl DRVEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DRVEN {
                match self.bits {
                    false => DRVEN::Drvdisable,
                    true => DRVEN::Drvenable,
                }
            }
            #[doc = "Disable Isink Ability Improvement, Normal Drive"]
            #[inline(always)]
            pub fn is_drvdisable(&self) -> bool {
                *self == DRVEN::Drvdisable
            }
            #[doc = "Enable Isink Ability Improvement"]
            #[inline(always)]
            pub fn is_drvenable(&self) -> bool {
                *self == DRVEN::Drvenable
            }
        }
        #[doc = "Field `DRVEN` writer - Sink Current Ability Improve"]
        pub type DRVEN_W<'a, REG> = crate::BitWriter<'a, REG, DRVEN>;
        impl<'a, REG> DRVEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable Isink Ability Improvement, Normal Drive"]
            #[inline(always)]
            pub fn drvdisable(self) -> &'a mut crate::W<REG> {
                self.variant(DRVEN::Drvdisable)
            }
            #[doc = "Enable Isink Ability Improvement"]
            #[inline(always)]
            pub fn drvenable(self) -> &'a mut crate::W<REG> {
                self.variant(DRVEN::Drvenable)
            }
        }
        #[doc = "Select Between Source Mode and Sink Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TIASRCEN {
            #[doc = "0: Sink Mode"]
            Sinkmd = 0,
            #[doc = "1: Source Mode"]
            Sourcemd = 1,
        }
        impl From<TIASRCEN> for bool {
            #[inline(always)]
            fn from(variant: TIASRCEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIASRCEN` reader - Select Between Source Mode and Sink Mode"]
        pub type TIASRCEN_R = crate::BitReader<TIASRCEN>;
        impl TIASRCEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TIASRCEN {
                match self.bits {
                    false => TIASRCEN::Sinkmd,
                    true => TIASRCEN::Sourcemd,
                }
            }
            #[doc = "Sink Mode"]
            #[inline(always)]
            pub fn is_sinkmd(&self) -> bool {
                *self == TIASRCEN::Sinkmd
            }
            #[doc = "Source Mode"]
            #[inline(always)]
            pub fn is_sourcemd(&self) -> bool {
                *self == TIASRCEN::Sourcemd
            }
        }
        #[doc = "Field `TIASRCEN` writer - Select Between Source Mode and Sink Mode"]
        pub type TIASRCEN_W<'a, REG> = crate::BitWriter<'a, REG, TIASRCEN>;
        impl<'a, REG> TIASRCEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Sink Mode"]
            #[inline(always)]
            pub fn sinkmd(self) -> &'a mut crate::W<REG> {
                self.variant(TIASRCEN::Sinkmd)
            }
            #[doc = "Source Mode"]
            #[inline(always)]
            pub fn sourcemd(self) -> &'a mut crate::W<REG> {
                self.variant(TIASRCEN::Sourcemd)
            }
        }
        impl R {
            #[doc = "Bit 0 - PGA Core Power Down"]
            #[inline(always)]
            pub fn pdpgacore(&self) -> PDPGACORE_R {
                PDPGACORE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - PGA or TIA Mode Selection"]
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - PGA DC Mode or AC Couple Mode Selection"]
            #[inline(always)]
            pub fn pgamode(&self) -> PGAMODE_R {
                PGAMODE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 5:7 - PGA Gain Configuration"]
            #[inline(always)]
            pub fn pgagain(&self) -> PGAGAIN_R {
                PGAGAIN_R::new(((self.bits >> 5) & 7) as u8)
            }
            #[doc = "Bits 8:10 - TIA Gain Configuration"]
            #[inline(always)]
            pub fn tiagain(&self) -> TIAGAIN_R {
                TIAGAIN_R::new(((self.bits >> 8) & 7) as u8)
            }
            #[doc = "Bits 11:12 - TIA Vbias Selection of VDAC Channel"]
            #[inline(always)]
            pub fn tiavdacsel(&self) -> TIAVDACSEL_R {
                TIAVDACSEL_R::new(((self.bits >> 11) & 3) as u8)
            }
            #[doc = "Bit 14 - Sink Current Ability Improve"]
            #[inline(always)]
            pub fn drven(&self) -> DRVEN_R {
                DRVEN_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Select Between Source Mode and Sink Mode"]
            #[inline(always)]
            pub fn tiasrcen(&self) -> TIASRCEN_R {
                TIASRCEN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PGA1CON")
                    .field("pdpgacore", &self.pdpgacore())
                    .field("mode", &self.mode())
                    .field("pgamode", &self.pgamode())
                    .field("pgagain", &self.pgagain())
                    .field("tiagain", &self.tiagain())
                    .field("tiavdacsel", &self.tiavdacsel())
                    .field("drven", &self.drven())
                    .field("tiasrcen", &self.tiasrcen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - PGA Core Power Down"]
            #[inline(always)]
            pub fn pdpgacore(&mut self) -> PDPGACORE_W<PGA1CONrs> {
                PDPGACORE_W::new(self, 0)
            }
            #[doc = "Bit 1 - PGA or TIA Mode Selection"]
            #[inline(always)]
            pub fn mode(&mut self) -> MODE_W<PGA1CONrs> {
                MODE_W::new(self, 1)
            }
            #[doc = "Bit 2 - PGA DC Mode or AC Couple Mode Selection"]
            #[inline(always)]
            pub fn pgamode(&mut self) -> PGAMODE_W<PGA1CONrs> {
                PGAMODE_W::new(self, 2)
            }
            #[doc = "Bits 5:7 - PGA Gain Configuration"]
            #[inline(always)]
            pub fn pgagain(&mut self) -> PGAGAIN_W<PGA1CONrs> {
                PGAGAIN_W::new(self, 5)
            }
            #[doc = "Bits 8:10 - TIA Gain Configuration"]
            #[inline(always)]
            pub fn tiagain(&mut self) -> TIAGAIN_W<PGA1CONrs> {
                TIAGAIN_W::new(self, 8)
            }
            #[doc = "Bits 11:12 - TIA Vbias Selection of VDAC Channel"]
            #[inline(always)]
            pub fn tiavdacsel(&mut self) -> TIAVDACSEL_W<PGA1CONrs> {
                TIAVDACSEL_W::new(self, 11)
            }
            #[doc = "Bit 14 - Sink Current Ability Improve"]
            #[inline(always)]
            pub fn drven(&mut self) -> DRVEN_W<PGA1CONrs> {
                DRVEN_W::new(self, 14)
            }
            #[doc = "Bit 15 - Select Between Source Mode and Sink Mode"]
            #[inline(always)]
            pub fn tiasrcen(&mut self) -> TIASRCEN_W<PGA1CONrs> {
                TIASRCEN_W::new(self, 15)
            }
        }
        #[doc = "PGA1 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pga1con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga1con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA1CON)"]
        pub struct PGA1CONrs;
        impl crate::RegisterSpec for PGA1CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pga1con::R`](R) reader structure"]
        impl crate::Readable for PGA1CONrs {}
        #[doc = "`write(|w| ..)` method takes [`pga1con::W`](W) writer structure"]
        impl crate::Writable for PGA1CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PGA1CON to value 0x11"]
        impl crate::Resettable for PGA1CONrs {
            const RESET_VALUE: u32 = 0x11;
        }
    }
    #[doc = "PGA1CHPCON (rw) register accessor: PGA1 Chop Function Ctrl\n\nYou can [`read`](crate::Reg::read) this register and get [`pga1chpcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga1chpcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA1CHPCON)\n\nFor information about available fields see [`mod@pga1chpcon`]
module"]
    pub type PGA1CHPCON = crate::Reg<pga1chpcon::PGA1CHPCONrs>;
    #[doc = "PGA1 Chop Function Ctrl"]
    pub mod pga1chpcon {
        #[doc = "Register `PGA1CHPCON` reader"]
        pub type R = crate::R<PGA1CHPCONrs>;
        #[doc = "Register `PGA1CHPCON` writer"]
        pub type W = crate::W<PGA1CHPCONrs>;
        #[doc = "Disable Chop Function\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CHOPOFF {
            #[doc = "0: Enable Chop Function"]
            Chopen = 0,
            #[doc = "1: Disable Chop Function"]
            Chopdis = 1,
        }
        impl From<CHOPOFF> for bool {
            #[inline(always)]
            fn from(variant: CHOPOFF) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CHOPOFF` reader - Disable Chop Function"]
        pub type CHOPOFF_R = crate::BitReader<CHOPOFF>;
        impl CHOPOFF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CHOPOFF {
                match self.bits {
                    false => CHOPOFF::Chopen,
                    true => CHOPOFF::Chopdis,
                }
            }
            #[doc = "Enable Chop Function"]
            #[inline(always)]
            pub fn is_chopen(&self) -> bool {
                *self == CHOPOFF::Chopen
            }
            #[doc = "Disable Chop Function"]
            #[inline(always)]
            pub fn is_chopdis(&self) -> bool {
                *self == CHOPOFF::Chopdis
            }
        }
        #[doc = "Field `CHOPOFF` writer - Disable Chop Function"]
        pub type CHOPOFF_W<'a, REG> = crate::BitWriter<'a, REG, CHOPOFF>;
        impl<'a, REG> CHOPOFF_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Enable Chop Function"]
            #[inline(always)]
            pub fn chopen(self) -> &'a mut crate::W<REG> {
                self.variant(CHOPOFF::Chopen)
            }
            #[doc = "Disable Chop Function"]
            #[inline(always)]
            pub fn chopdis(self) -> &'a mut crate::W<REG> {
                self.variant(CHOPOFF::Chopdis)
            }
        }
        impl R {
            #[doc = "Bit 0 - Disable Chop Function"]
            #[inline(always)]
            pub fn chopoff(&self) -> CHOPOFF_R {
                CHOPOFF_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PGA1CHPCON")
                    .field("chopoff", &self.chopoff())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Disable Chop Function"]
            #[inline(always)]
            pub fn chopoff(&mut self) -> CHOPOFF_W<PGA1CHPCONrs> {
                CHOPOFF_W::new(self, 0)
            }
        }
        #[doc = "PGA1 Chop Function Ctrl\n\nYou can [`read`](crate::Reg::read) this register and get [`pga1chpcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga1chpcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA1CHPCON)"]
        pub struct PGA1CHPCONrs;
        impl crate::RegisterSpec for PGA1CHPCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pga1chpcon::R`](R) reader structure"]
        impl crate::Readable for PGA1CHPCONrs {}
        #[doc = "`write(|w| ..)` method takes [`pga1chpcon::W`](W) writer structure"]
        impl crate::Writable for PGA1CHPCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PGA1CHPCON to value 0x01"]
        impl crate::Resettable for PGA1CHPCONrs {
            const RESET_VALUE: u32 = 0x01;
        }
    }
    #[doc = "PGA2CON (rw) register accessor: PGA2 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pga2con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga2con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA2CON)\n\nFor information about available fields see [`mod@pga2con`]
module"]
    pub type PGA2CON = crate::Reg<pga2con::PGA2CONrs>;
    #[doc = "PGA2 Control Register"]
    pub mod pga2con {
        #[doc = "Register `PGA2CON` reader"]
        pub type R = crate::R<PGA2CONrs>;
        #[doc = "Register `PGA2CON` writer"]
        pub type W = crate::W<PGA2CONrs>;
        #[doc = "Field `PDPGACORE` reader - PGA Core Power Down"]
        pub type PDPGACORE_R = crate::BitReader;
        #[doc = "Field `PDPGACORE` writer - PGA Core Power Down"]
        pub type PDPGACORE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "PGA or TIA Mode Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE {
            #[doc = "0: PGA Mode Enable"]
            Pgamode = 0,
            #[doc = "1: TIA Mode Enable"]
            Tiamode = 1,
        }
        impl From<MODE> for bool {
            #[inline(always)]
            fn from(variant: MODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MODE` reader - PGA or TIA Mode Selection"]
        pub type MODE_R = crate::BitReader<MODE>;
        impl MODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MODE {
                match self.bits {
                    false => MODE::Pgamode,
                    true => MODE::Tiamode,
                }
            }
            #[doc = "PGA Mode Enable"]
            #[inline(always)]
            pub fn is_pgamode(&self) -> bool {
                *self == MODE::Pgamode
            }
            #[doc = "TIA Mode Enable"]
            #[inline(always)]
            pub fn is_tiamode(&self) -> bool {
                *self == MODE::Tiamode
            }
        }
        #[doc = "Field `MODE` writer - PGA or TIA Mode Selection"]
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG, MODE>;
        impl<'a, REG> MODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PGA Mode Enable"]
            #[inline(always)]
            pub fn pgamode(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Pgamode)
            }
            #[doc = "TIA Mode Enable"]
            #[inline(always)]
            pub fn tiamode(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Tiamode)
            }
        }
        #[doc = "PGA DC Mode or AC Couple Mode Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PGAMODE {
            #[doc = "0: PGA DC Mode Enable"]
            Dccouple = 0,
            #[doc = "1: PGA AC Coupling Mode Enable"]
            Accouple = 1,
        }
        impl From<PGAMODE> for bool {
            #[inline(always)]
            fn from(variant: PGAMODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PGAMODE` reader - PGA DC Mode or AC Couple Mode Selection"]
        pub type PGAMODE_R = crate::BitReader<PGAMODE>;
        impl PGAMODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PGAMODE {
                match self.bits {
                    false => PGAMODE::Dccouple,
                    true => PGAMODE::Accouple,
                }
            }
            #[doc = "PGA DC Mode Enable"]
            #[inline(always)]
            pub fn is_dccouple(&self) -> bool {
                *self == PGAMODE::Dccouple
            }
            #[doc = "PGA AC Coupling Mode Enable"]
            #[inline(always)]
            pub fn is_accouple(&self) -> bool {
                *self == PGAMODE::Accouple
            }
        }
        #[doc = "Field `PGAMODE` writer - PGA DC Mode or AC Couple Mode Selection"]
        pub type PGAMODE_W<'a, REG> = crate::BitWriter<'a, REG, PGAMODE>;
        impl<'a, REG> PGAMODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PGA DC Mode Enable"]
            #[inline(always)]
            pub fn dccouple(self) -> &'a mut crate::W<REG> {
                self.variant(PGAMODE::Dccouple)
            }
            #[doc = "PGA AC Coupling Mode Enable"]
            #[inline(always)]
            pub fn accouple(self) -> &'a mut crate::W<REG> {
                self.variant(PGAMODE::Accouple)
            }
        }
        #[doc = "Bypass the External Cap\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CAPBYPASS {
            #[doc = "0: Select the External CAP"]
            Bypdisable = 0,
            #[doc = "1: Bypass the External Cap"]
            Bypen = 1,
        }
        impl From<CAPBYPASS> for bool {
            #[inline(always)]
            fn from(variant: CAPBYPASS) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CAPBYPASS` reader - Bypass the External Cap"]
        pub type CAPBYPASS_R = crate::BitReader<CAPBYPASS>;
        impl CAPBYPASS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CAPBYPASS {
                match self.bits {
                    false => CAPBYPASS::Bypdisable,
                    true => CAPBYPASS::Bypen,
                }
            }
            #[doc = "Select the External CAP"]
            #[inline(always)]
            pub fn is_bypdisable(&self) -> bool {
                *self == CAPBYPASS::Bypdisable
            }
            #[doc = "Bypass the External Cap"]
            #[inline(always)]
            pub fn is_bypen(&self) -> bool {
                *self == CAPBYPASS::Bypen
            }
        }
        #[doc = "Field `CAPBYPASS` writer - Bypass the External Cap"]
        pub type CAPBYPASS_W<'a, REG> = crate::BitWriter<'a, REG, CAPBYPASS>;
        impl<'a, REG> CAPBYPASS_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Select the External CAP"]
            #[inline(always)]
            pub fn bypdisable(self) -> &'a mut crate::W<REG> {
                self.variant(CAPBYPASS::Bypdisable)
            }
            #[doc = "Bypass the External Cap"]
            #[inline(always)]
            pub fn bypen(self) -> &'a mut crate::W<REG> {
                self.variant(CAPBYPASS::Bypen)
            }
        }
        #[doc = "PGA Gain Configuration\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PGAGAIN {
            #[doc = "0: Gain=1"]
            Gain1 = 0,
            #[doc = "1: GAIN=2"]
            Gain2 = 1,
            #[doc = "2: GAIN=4"]
            Gain4 = 2,
            #[doc = "3: GAIN=6"]
            Gain6 = 3,
            #[doc = "4: GAIN=8"]
            Gain8 = 4,
            #[doc = "5: GAIN=10"]
            Gain10 = 5,
        }
        impl From<PGAGAIN> for u8 {
            #[inline(always)]
            fn from(variant: PGAGAIN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PGAGAIN {
            type Ux = u8;
        }
        impl crate::IsEnum for PGAGAIN {}
        #[doc = "Field `PGAGAIN` reader - PGA Gain Configuration"]
        pub type PGAGAIN_R = crate::FieldReader<PGAGAIN>;
        impl PGAGAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<PGAGAIN> {
                match self.bits {
                    0 => Some(PGAGAIN::Gain1),
                    1 => Some(PGAGAIN::Gain2),
                    2 => Some(PGAGAIN::Gain4),
                    3 => Some(PGAGAIN::Gain6),
                    4 => Some(PGAGAIN::Gain8),
                    5 => Some(PGAGAIN::Gain10),
                    _ => None,
                }
            }
            #[doc = "Gain=1"]
            #[inline(always)]
            pub fn is_gain1(&self) -> bool {
                *self == PGAGAIN::Gain1
            }
            #[doc = "GAIN=2"]
            #[inline(always)]
            pub fn is_gain2(&self) -> bool {
                *self == PGAGAIN::Gain2
            }
            #[doc = "GAIN=4"]
            #[inline(always)]
            pub fn is_gain4(&self) -> bool {
                *self == PGAGAIN::Gain4
            }
            #[doc = "GAIN=6"]
            #[inline(always)]
            pub fn is_gain6(&self) -> bool {
                *self == PGAGAIN::Gain6
            }
            #[doc = "GAIN=8"]
            #[inline(always)]
            pub fn is_gain8(&self) -> bool {
                *self == PGAGAIN::Gain8
            }
            #[doc = "GAIN=10"]
            #[inline(always)]
            pub fn is_gain10(&self) -> bool {
                *self == PGAGAIN::Gain10
            }
        }
        #[doc = "Field `PGAGAIN` writer - PGA Gain Configuration"]
        pub type PGAGAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 3, PGAGAIN>;
        impl<'a, REG> PGAGAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Gain=1"]
            #[inline(always)]
            pub fn gain1(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain1)
            }
            #[doc = "GAIN=2"]
            #[inline(always)]
            pub fn gain2(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain2)
            }
            #[doc = "GAIN=4"]
            #[inline(always)]
            pub fn gain4(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain4)
            }
            #[doc = "GAIN=6"]
            #[inline(always)]
            pub fn gain6(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain6)
            }
            #[doc = "GAIN=8"]
            #[inline(always)]
            pub fn gain8(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain8)
            }
            #[doc = "GAIN=10"]
            #[inline(always)]
            pub fn gain10(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain10)
            }
        }
        #[doc = "TIA Gain Configuration\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIAGAIN {
            #[doc = "0: TIARES=250ohm"]
            Res250 = 0,
            #[doc = "1: TIARES=750ohm"]
            Res750 = 1,
            #[doc = "2: TIARES=2kohm"]
            Res2k = 2,
            #[doc = "3: TIARES=5kohm"]
            Res5k = 3,
            #[doc = "4: TIARES=10kohm"]
            Res10k = 4,
            #[doc = "5: TIARES=20kohm"]
            Res20k = 5,
            #[doc = "6: TIARES=100kohm"]
            Res100k = 6,
        }
        impl From<TIAGAIN> for u8 {
            #[inline(always)]
            fn from(variant: TIAGAIN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TIAGAIN {
            type Ux = u8;
        }
        impl crate::IsEnum for TIAGAIN {}
        #[doc = "Field `TIAGAIN` reader - TIA Gain Configuration"]
        pub type TIAGAIN_R = crate::FieldReader<TIAGAIN>;
        impl TIAGAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<TIAGAIN> {
                match self.bits {
                    0 => Some(TIAGAIN::Res250),
                    1 => Some(TIAGAIN::Res750),
                    2 => Some(TIAGAIN::Res2k),
                    3 => Some(TIAGAIN::Res5k),
                    4 => Some(TIAGAIN::Res10k),
                    5 => Some(TIAGAIN::Res20k),
                    6 => Some(TIAGAIN::Res100k),
                    _ => None,
                }
            }
            #[doc = "TIARES=250ohm"]
            #[inline(always)]
            pub fn is_res250(&self) -> bool {
                *self == TIAGAIN::Res250
            }
            #[doc = "TIARES=750ohm"]
            #[inline(always)]
            pub fn is_res750(&self) -> bool {
                *self == TIAGAIN::Res750
            }
            #[doc = "TIARES=2kohm"]
            #[inline(always)]
            pub fn is_res2k(&self) -> bool {
                *self == TIAGAIN::Res2k
            }
            #[doc = "TIARES=5kohm"]
            #[inline(always)]
            pub fn is_res5k(&self) -> bool {
                *self == TIAGAIN::Res5k
            }
            #[doc = "TIARES=10kohm"]
            #[inline(always)]
            pub fn is_res10k(&self) -> bool {
                *self == TIAGAIN::Res10k
            }
            #[doc = "TIARES=20kohm"]
            #[inline(always)]
            pub fn is_res20k(&self) -> bool {
                *self == TIAGAIN::Res20k
            }
            #[doc = "TIARES=100kohm"]
            #[inline(always)]
            pub fn is_res100k(&self) -> bool {
                *self == TIAGAIN::Res100k
            }
        }
        #[doc = "Field `TIAGAIN` writer - TIA Gain Configuration"]
        pub type TIAGAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 3, TIAGAIN>;
        impl<'a, REG> TIAGAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "TIARES=250ohm"]
            #[inline(always)]
            pub fn res250(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res250)
            }
            #[doc = "TIARES=750ohm"]
            #[inline(always)]
            pub fn res750(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res750)
            }
            #[doc = "TIARES=2kohm"]
            #[inline(always)]
            pub fn res2k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res2k)
            }
            #[doc = "TIARES=5kohm"]
            #[inline(always)]
            pub fn res5k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res5k)
            }
            #[doc = "TIARES=10kohm"]
            #[inline(always)]
            pub fn res10k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res10k)
            }
            #[doc = "TIARES=20kohm"]
            #[inline(always)]
            pub fn res20k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res20k)
            }
            #[doc = "TIARES=100kohm"]
            #[inline(always)]
            pub fn res100k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res100k)
            }
        }
        #[doc = "TIA Vbias Selection of VDAC Channel\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIAVDACSEL {
            #[doc = "0: Select VDAC8 as TIA Vbias"]
            Vdac8sel = 0,
            #[doc = "1: Select VDAC9 as TIA Vbias"]
            Vdac9sel = 1,
            #[doc = "2: Select VDAC10 as TIA Vbias"]
            Vdac10sel = 2,
            #[doc = "3: Select VDAC11 as TIA Vbias"]
            Vdac11sel = 3,
        }
        impl From<TIAVDACSEL> for u8 {
            #[inline(always)]
            fn from(variant: TIAVDACSEL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TIAVDACSEL {
            type Ux = u8;
        }
        impl crate::IsEnum for TIAVDACSEL {}
        #[doc = "Field `TIAVDACSEL` reader - TIA Vbias Selection of VDAC Channel"]
        pub type TIAVDACSEL_R = crate::FieldReader<TIAVDACSEL>;
        impl TIAVDACSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TIAVDACSEL {
                match self.bits {
                    0 => TIAVDACSEL::Vdac8sel,
                    1 => TIAVDACSEL::Vdac9sel,
                    2 => TIAVDACSEL::Vdac10sel,
                    3 => TIAVDACSEL::Vdac11sel,
                    _ => unreachable!(),
                }
            }
            #[doc = "Select VDAC8 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac8sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac8sel
            }
            #[doc = "Select VDAC9 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac9sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac9sel
            }
            #[doc = "Select VDAC10 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac10sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac10sel
            }
            #[doc = "Select VDAC11 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac11sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac11sel
            }
        }
        #[doc = "Field `TIAVDACSEL` writer - TIA Vbias Selection of VDAC Channel"]
        pub type TIAVDACSEL_W<'a, REG> = crate::FieldWriter<'a, REG, 2, TIAVDACSEL, crate::Safe>;
        impl<'a, REG> TIAVDACSEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Select VDAC8 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac8sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac8sel)
            }
            #[doc = "Select VDAC9 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac9sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac9sel)
            }
            #[doc = "Select VDAC10 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac10sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac10sel)
            }
            #[doc = "Select VDAC11 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac11sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac11sel)
            }
        }
        #[doc = "Sink Current Ability Improve\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DRVEN {
            #[doc = "0: Disable Isink Ability Improvement, Normal Drive"]
            Drvdisable = 0,
            #[doc = "1: Enable Isink Ability Improvement"]
            Drvenable = 1,
        }
        impl From<DRVEN> for bool {
            #[inline(always)]
            fn from(variant: DRVEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DRVEN` reader - Sink Current Ability Improve"]
        pub type DRVEN_R = crate::BitReader<DRVEN>;
        impl DRVEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DRVEN {
                match self.bits {
                    false => DRVEN::Drvdisable,
                    true => DRVEN::Drvenable,
                }
            }
            #[doc = "Disable Isink Ability Improvement, Normal Drive"]
            #[inline(always)]
            pub fn is_drvdisable(&self) -> bool {
                *self == DRVEN::Drvdisable
            }
            #[doc = "Enable Isink Ability Improvement"]
            #[inline(always)]
            pub fn is_drvenable(&self) -> bool {
                *self == DRVEN::Drvenable
            }
        }
        #[doc = "Field `DRVEN` writer - Sink Current Ability Improve"]
        pub type DRVEN_W<'a, REG> = crate::BitWriter<'a, REG, DRVEN>;
        impl<'a, REG> DRVEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable Isink Ability Improvement, Normal Drive"]
            #[inline(always)]
            pub fn drvdisable(self) -> &'a mut crate::W<REG> {
                self.variant(DRVEN::Drvdisable)
            }
            #[doc = "Enable Isink Ability Improvement"]
            #[inline(always)]
            pub fn drvenable(self) -> &'a mut crate::W<REG> {
                self.variant(DRVEN::Drvenable)
            }
        }
        #[doc = "Select Between Source Mode and Sink Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TIASRCEN {
            #[doc = "0: Sink Mode"]
            Sinkmd = 0,
            #[doc = "1: Source Mode"]
            Sourcemd = 1,
        }
        impl From<TIASRCEN> for bool {
            #[inline(always)]
            fn from(variant: TIASRCEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIASRCEN` reader - Select Between Source Mode and Sink Mode"]
        pub type TIASRCEN_R = crate::BitReader<TIASRCEN>;
        impl TIASRCEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TIASRCEN {
                match self.bits {
                    false => TIASRCEN::Sinkmd,
                    true => TIASRCEN::Sourcemd,
                }
            }
            #[doc = "Sink Mode"]
            #[inline(always)]
            pub fn is_sinkmd(&self) -> bool {
                *self == TIASRCEN::Sinkmd
            }
            #[doc = "Source Mode"]
            #[inline(always)]
            pub fn is_sourcemd(&self) -> bool {
                *self == TIASRCEN::Sourcemd
            }
        }
        #[doc = "Field `TIASRCEN` writer - Select Between Source Mode and Sink Mode"]
        pub type TIASRCEN_W<'a, REG> = crate::BitWriter<'a, REG, TIASRCEN>;
        impl<'a, REG> TIASRCEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Sink Mode"]
            #[inline(always)]
            pub fn sinkmd(self) -> &'a mut crate::W<REG> {
                self.variant(TIASRCEN::Sinkmd)
            }
            #[doc = "Source Mode"]
            #[inline(always)]
            pub fn sourcemd(self) -> &'a mut crate::W<REG> {
                self.variant(TIASRCEN::Sourcemd)
            }
        }
        impl R {
            #[doc = "Bit 0 - PGA Core Power Down"]
            #[inline(always)]
            pub fn pdpgacore(&self) -> PDPGACORE_R {
                PDPGACORE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - PGA or TIA Mode Selection"]
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - PGA DC Mode or AC Couple Mode Selection"]
            #[inline(always)]
            pub fn pgamode(&self) -> PGAMODE_R {
                PGAMODE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Bypass the External Cap"]
            #[inline(always)]
            pub fn capbypass(&self) -> CAPBYPASS_R {
                CAPBYPASS_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 5:7 - PGA Gain Configuration"]
            #[inline(always)]
            pub fn pgagain(&self) -> PGAGAIN_R {
                PGAGAIN_R::new(((self.bits >> 5) & 7) as u8)
            }
            #[doc = "Bits 8:10 - TIA Gain Configuration"]
            #[inline(always)]
            pub fn tiagain(&self) -> TIAGAIN_R {
                TIAGAIN_R::new(((self.bits >> 8) & 7) as u8)
            }
            #[doc = "Bits 11:12 - TIA Vbias Selection of VDAC Channel"]
            #[inline(always)]
            pub fn tiavdacsel(&self) -> TIAVDACSEL_R {
                TIAVDACSEL_R::new(((self.bits >> 11) & 3) as u8)
            }
            #[doc = "Bit 14 - Sink Current Ability Improve"]
            #[inline(always)]
            pub fn drven(&self) -> DRVEN_R {
                DRVEN_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Select Between Source Mode and Sink Mode"]
            #[inline(always)]
            pub fn tiasrcen(&self) -> TIASRCEN_R {
                TIASRCEN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PGA2CON")
                    .field("pdpgacore", &self.pdpgacore())
                    .field("mode", &self.mode())
                    .field("pgamode", &self.pgamode())
                    .field("capbypass", &self.capbypass())
                    .field("pgagain", &self.pgagain())
                    .field("tiagain", &self.tiagain())
                    .field("tiavdacsel", &self.tiavdacsel())
                    .field("drven", &self.drven())
                    .field("tiasrcen", &self.tiasrcen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - PGA Core Power Down"]
            #[inline(always)]
            pub fn pdpgacore(&mut self) -> PDPGACORE_W<PGA2CONrs> {
                PDPGACORE_W::new(self, 0)
            }
            #[doc = "Bit 1 - PGA or TIA Mode Selection"]
            #[inline(always)]
            pub fn mode(&mut self) -> MODE_W<PGA2CONrs> {
                MODE_W::new(self, 1)
            }
            #[doc = "Bit 2 - PGA DC Mode or AC Couple Mode Selection"]
            #[inline(always)]
            pub fn pgamode(&mut self) -> PGAMODE_W<PGA2CONrs> {
                PGAMODE_W::new(self, 2)
            }
            #[doc = "Bit 3 - Bypass the External Cap"]
            #[inline(always)]
            pub fn capbypass(&mut self) -> CAPBYPASS_W<PGA2CONrs> {
                CAPBYPASS_W::new(self, 3)
            }
            #[doc = "Bits 5:7 - PGA Gain Configuration"]
            #[inline(always)]
            pub fn pgagain(&mut self) -> PGAGAIN_W<PGA2CONrs> {
                PGAGAIN_W::new(self, 5)
            }
            #[doc = "Bits 8:10 - TIA Gain Configuration"]
            #[inline(always)]
            pub fn tiagain(&mut self) -> TIAGAIN_W<PGA2CONrs> {
                TIAGAIN_W::new(self, 8)
            }
            #[doc = "Bits 11:12 - TIA Vbias Selection of VDAC Channel"]
            #[inline(always)]
            pub fn tiavdacsel(&mut self) -> TIAVDACSEL_W<PGA2CONrs> {
                TIAVDACSEL_W::new(self, 11)
            }
            #[doc = "Bit 14 - Sink Current Ability Improve"]
            #[inline(always)]
            pub fn drven(&mut self) -> DRVEN_W<PGA2CONrs> {
                DRVEN_W::new(self, 14)
            }
            #[doc = "Bit 15 - Select Between Source Mode and Sink Mode"]
            #[inline(always)]
            pub fn tiasrcen(&mut self) -> TIASRCEN_W<PGA2CONrs> {
                TIASRCEN_W::new(self, 15)
            }
        }
        #[doc = "PGA2 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pga2con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga2con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA2CON)"]
        pub struct PGA2CONrs;
        impl crate::RegisterSpec for PGA2CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pga2con::R`](R) reader structure"]
        impl crate::Readable for PGA2CONrs {}
        #[doc = "`write(|w| ..)` method takes [`pga2con::W`](W) writer structure"]
        impl crate::Writable for PGA2CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PGA2CON to value 0x19"]
        impl crate::Resettable for PGA2CONrs {
            const RESET_VALUE: u32 = 0x19;
        }
    }
    #[doc = "PGA2CHPCON (rw) register accessor: PGA2 Chop Function Ctrl\n\nYou can [`read`](crate::Reg::read) this register and get [`pga2chpcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga2chpcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA2CHPCON)\n\nFor information about available fields see [`mod@pga2chpcon`]
module"]
    pub type PGA2CHPCON = crate::Reg<pga2chpcon::PGA2CHPCONrs>;
    #[doc = "PGA2 Chop Function Ctrl"]
    pub mod pga2chpcon {
        #[doc = "Register `PGA2CHPCON` reader"]
        pub type R = crate::R<PGA2CHPCONrs>;
        #[doc = "Register `PGA2CHPCON` writer"]
        pub type W = crate::W<PGA2CHPCONrs>;
        #[doc = "Disable Chop Function\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CHOPOFF {
            #[doc = "0: Enable Chop Function"]
            Chopen = 0,
            #[doc = "1: Disable Chop Function"]
            Chopdis = 1,
        }
        impl From<CHOPOFF> for bool {
            #[inline(always)]
            fn from(variant: CHOPOFF) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CHOPOFF` reader - Disable Chop Function"]
        pub type CHOPOFF_R = crate::BitReader<CHOPOFF>;
        impl CHOPOFF_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CHOPOFF {
                match self.bits {
                    false => CHOPOFF::Chopen,
                    true => CHOPOFF::Chopdis,
                }
            }
            #[doc = "Enable Chop Function"]
            #[inline(always)]
            pub fn is_chopen(&self) -> bool {
                *self == CHOPOFF::Chopen
            }
            #[doc = "Disable Chop Function"]
            #[inline(always)]
            pub fn is_chopdis(&self) -> bool {
                *self == CHOPOFF::Chopdis
            }
        }
        #[doc = "Field `CHOPOFF` writer - Disable Chop Function"]
        pub type CHOPOFF_W<'a, REG> = crate::BitWriter<'a, REG, CHOPOFF>;
        impl<'a, REG> CHOPOFF_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Enable Chop Function"]
            #[inline(always)]
            pub fn chopen(self) -> &'a mut crate::W<REG> {
                self.variant(CHOPOFF::Chopen)
            }
            #[doc = "Disable Chop Function"]
            #[inline(always)]
            pub fn chopdis(self) -> &'a mut crate::W<REG> {
                self.variant(CHOPOFF::Chopdis)
            }
        }
        impl R {
            #[doc = "Bit 0 - Disable Chop Function"]
            #[inline(always)]
            pub fn chopoff(&self) -> CHOPOFF_R {
                CHOPOFF_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PGA2CHPCON")
                    .field("chopoff", &self.chopoff())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Disable Chop Function"]
            #[inline(always)]
            pub fn chopoff(&mut self) -> CHOPOFF_W<PGA2CHPCONrs> {
                CHOPOFF_W::new(self, 0)
            }
        }
        #[doc = "PGA2 Chop Function Ctrl\n\nYou can [`read`](crate::Reg::read) this register and get [`pga2chpcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga2chpcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA2CHPCON)"]
        pub struct PGA2CHPCONrs;
        impl crate::RegisterSpec for PGA2CHPCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pga2chpcon::R`](R) reader structure"]
        impl crate::Readable for PGA2CHPCONrs {}
        #[doc = "`write(|w| ..)` method takes [`pga2chpcon::W`](W) writer structure"]
        impl crate::Writable for PGA2CHPCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PGA2CHPCON to value 0x01"]
        impl crate::Resettable for PGA2CHPCONrs {
            const RESET_VALUE: u32 = 0x01;
        }
    }
    #[doc = "PGA3CON (rw) register accessor: PGA3 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pga3con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga3con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA3CON)\n\nFor information about available fields see [`mod@pga3con`]
module"]
    pub type PGA3CON = crate::Reg<pga3con::PGA3CONrs>;
    #[doc = "PGA3 Control Register"]
    pub mod pga3con {
        #[doc = "Register `PGA3CON` reader"]
        pub type R = crate::R<PGA3CONrs>;
        #[doc = "Register `PGA3CON` writer"]
        pub type W = crate::W<PGA3CONrs>;
        #[doc = "Field `PDPGACORE` reader - PGA Core Power Down"]
        pub type PDPGACORE_R = crate::BitReader;
        #[doc = "Field `PDPGACORE` writer - PGA Core Power Down"]
        pub type PDPGACORE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "PGA or TIA Mode Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODE {
            #[doc = "0: PGA Mode Enable"]
            Pgamode = 0,
            #[doc = "1: TIA Mode Enable"]
            Tiamode = 1,
        }
        impl From<MODE> for bool {
            #[inline(always)]
            fn from(variant: MODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MODE` reader - PGA or TIA Mode Selection"]
        pub type MODE_R = crate::BitReader<MODE>;
        impl MODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MODE {
                match self.bits {
                    false => MODE::Pgamode,
                    true => MODE::Tiamode,
                }
            }
            #[doc = "PGA Mode Enable"]
            #[inline(always)]
            pub fn is_pgamode(&self) -> bool {
                *self == MODE::Pgamode
            }
            #[doc = "TIA Mode Enable"]
            #[inline(always)]
            pub fn is_tiamode(&self) -> bool {
                *self == MODE::Tiamode
            }
        }
        #[doc = "Field `MODE` writer - PGA or TIA Mode Selection"]
        pub type MODE_W<'a, REG> = crate::BitWriter<'a, REG, MODE>;
        impl<'a, REG> MODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PGA Mode Enable"]
            #[inline(always)]
            pub fn pgamode(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Pgamode)
            }
            #[doc = "TIA Mode Enable"]
            #[inline(always)]
            pub fn tiamode(self) -> &'a mut crate::W<REG> {
                self.variant(MODE::Tiamode)
            }
        }
        #[doc = "PGA DC Mode or AC Couple Mode Selection\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PGAMODE {
            #[doc = "0: PGA DC Mode Enable"]
            Dccouple = 0,
            #[doc = "1: PGA AC Coupling Mode Enable"]
            Accouple = 1,
        }
        impl From<PGAMODE> for bool {
            #[inline(always)]
            fn from(variant: PGAMODE) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PGAMODE` reader - PGA DC Mode or AC Couple Mode Selection"]
        pub type PGAMODE_R = crate::BitReader<PGAMODE>;
        impl PGAMODE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PGAMODE {
                match self.bits {
                    false => PGAMODE::Dccouple,
                    true => PGAMODE::Accouple,
                }
            }
            #[doc = "PGA DC Mode Enable"]
            #[inline(always)]
            pub fn is_dccouple(&self) -> bool {
                *self == PGAMODE::Dccouple
            }
            #[doc = "PGA AC Coupling Mode Enable"]
            #[inline(always)]
            pub fn is_accouple(&self) -> bool {
                *self == PGAMODE::Accouple
            }
        }
        #[doc = "Field `PGAMODE` writer - PGA DC Mode or AC Couple Mode Selection"]
        pub type PGAMODE_W<'a, REG> = crate::BitWriter<'a, REG, PGAMODE>;
        impl<'a, REG> PGAMODE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PGA DC Mode Enable"]
            #[inline(always)]
            pub fn dccouple(self) -> &'a mut crate::W<REG> {
                self.variant(PGAMODE::Dccouple)
            }
            #[doc = "PGA AC Coupling Mode Enable"]
            #[inline(always)]
            pub fn accouple(self) -> &'a mut crate::W<REG> {
                self.variant(PGAMODE::Accouple)
            }
        }
        #[doc = "PGA Gain Configuration\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PGAGAIN {
            #[doc = "0: Gain=1"]
            Gain1 = 0,
            #[doc = "1: GAIN=2"]
            Gain2 = 1,
            #[doc = "2: GAIN=4"]
            Gain4 = 2,
            #[doc = "3: GAIN=6"]
            Gain6 = 3,
            #[doc = "4: GAIN=8"]
            Gain8 = 4,
            #[doc = "5: GAIN=10"]
            Gain10 = 5,
        }
        impl From<PGAGAIN> for u8 {
            #[inline(always)]
            fn from(variant: PGAGAIN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for PGAGAIN {
            type Ux = u8;
        }
        impl crate::IsEnum for PGAGAIN {}
        #[doc = "Field `PGAGAIN` reader - PGA Gain Configuration"]
        pub type PGAGAIN_R = crate::FieldReader<PGAGAIN>;
        impl PGAGAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<PGAGAIN> {
                match self.bits {
                    0 => Some(PGAGAIN::Gain1),
                    1 => Some(PGAGAIN::Gain2),
                    2 => Some(PGAGAIN::Gain4),
                    3 => Some(PGAGAIN::Gain6),
                    4 => Some(PGAGAIN::Gain8),
                    5 => Some(PGAGAIN::Gain10),
                    _ => None,
                }
            }
            #[doc = "Gain=1"]
            #[inline(always)]
            pub fn is_gain1(&self) -> bool {
                *self == PGAGAIN::Gain1
            }
            #[doc = "GAIN=2"]
            #[inline(always)]
            pub fn is_gain2(&self) -> bool {
                *self == PGAGAIN::Gain2
            }
            #[doc = "GAIN=4"]
            #[inline(always)]
            pub fn is_gain4(&self) -> bool {
                *self == PGAGAIN::Gain4
            }
            #[doc = "GAIN=6"]
            #[inline(always)]
            pub fn is_gain6(&self) -> bool {
                *self == PGAGAIN::Gain6
            }
            #[doc = "GAIN=8"]
            #[inline(always)]
            pub fn is_gain8(&self) -> bool {
                *self == PGAGAIN::Gain8
            }
            #[doc = "GAIN=10"]
            #[inline(always)]
            pub fn is_gain10(&self) -> bool {
                *self == PGAGAIN::Gain10
            }
        }
        #[doc = "Field `PGAGAIN` writer - PGA Gain Configuration"]
        pub type PGAGAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 3, PGAGAIN>;
        impl<'a, REG> PGAGAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Gain=1"]
            #[inline(always)]
            pub fn gain1(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain1)
            }
            #[doc = "GAIN=2"]
            #[inline(always)]
            pub fn gain2(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain2)
            }
            #[doc = "GAIN=4"]
            #[inline(always)]
            pub fn gain4(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain4)
            }
            #[doc = "GAIN=6"]
            #[inline(always)]
            pub fn gain6(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain6)
            }
            #[doc = "GAIN=8"]
            #[inline(always)]
            pub fn gain8(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain8)
            }
            #[doc = "GAIN=10"]
            #[inline(always)]
            pub fn gain10(self) -> &'a mut crate::W<REG> {
                self.variant(PGAGAIN::Gain10)
            }
        }
        #[doc = "TIA Gain Configuration\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIAGAIN {
            #[doc = "0: TIARES=250ohm"]
            Res250 = 0,
            #[doc = "1: TIARES=750ohm"]
            Res750 = 1,
            #[doc = "2: TIARES=2kohm"]
            Res2k = 2,
            #[doc = "3: TIARES=5kohm"]
            Res5k = 3,
            #[doc = "4: TIARES=10kohm"]
            Res10k = 4,
            #[doc = "5: TIARES=20kohm"]
            Res20k = 5,
            #[doc = "6: TIARES=100kohm"]
            Res100k = 6,
        }
        impl From<TIAGAIN> for u8 {
            #[inline(always)]
            fn from(variant: TIAGAIN) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TIAGAIN {
            type Ux = u8;
        }
        impl crate::IsEnum for TIAGAIN {}
        #[doc = "Field `TIAGAIN` reader - TIA Gain Configuration"]
        pub type TIAGAIN_R = crate::FieldReader<TIAGAIN>;
        impl TIAGAIN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<TIAGAIN> {
                match self.bits {
                    0 => Some(TIAGAIN::Res250),
                    1 => Some(TIAGAIN::Res750),
                    2 => Some(TIAGAIN::Res2k),
                    3 => Some(TIAGAIN::Res5k),
                    4 => Some(TIAGAIN::Res10k),
                    5 => Some(TIAGAIN::Res20k),
                    6 => Some(TIAGAIN::Res100k),
                    _ => None,
                }
            }
            #[doc = "TIARES=250ohm"]
            #[inline(always)]
            pub fn is_res250(&self) -> bool {
                *self == TIAGAIN::Res250
            }
            #[doc = "TIARES=750ohm"]
            #[inline(always)]
            pub fn is_res750(&self) -> bool {
                *self == TIAGAIN::Res750
            }
            #[doc = "TIARES=2kohm"]
            #[inline(always)]
            pub fn is_res2k(&self) -> bool {
                *self == TIAGAIN::Res2k
            }
            #[doc = "TIARES=5kohm"]
            #[inline(always)]
            pub fn is_res5k(&self) -> bool {
                *self == TIAGAIN::Res5k
            }
            #[doc = "TIARES=10kohm"]
            #[inline(always)]
            pub fn is_res10k(&self) -> bool {
                *self == TIAGAIN::Res10k
            }
            #[doc = "TIARES=20kohm"]
            #[inline(always)]
            pub fn is_res20k(&self) -> bool {
                *self == TIAGAIN::Res20k
            }
            #[doc = "TIARES=100kohm"]
            #[inline(always)]
            pub fn is_res100k(&self) -> bool {
                *self == TIAGAIN::Res100k
            }
        }
        #[doc = "Field `TIAGAIN` writer - TIA Gain Configuration"]
        pub type TIAGAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 3, TIAGAIN>;
        impl<'a, REG> TIAGAIN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "TIARES=250ohm"]
            #[inline(always)]
            pub fn res250(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res250)
            }
            #[doc = "TIARES=750ohm"]
            #[inline(always)]
            pub fn res750(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res750)
            }
            #[doc = "TIARES=2kohm"]
            #[inline(always)]
            pub fn res2k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res2k)
            }
            #[doc = "TIARES=5kohm"]
            #[inline(always)]
            pub fn res5k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res5k)
            }
            #[doc = "TIARES=10kohm"]
            #[inline(always)]
            pub fn res10k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res10k)
            }
            #[doc = "TIARES=20kohm"]
            #[inline(always)]
            pub fn res20k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res20k)
            }
            #[doc = "TIARES=100kohm"]
            #[inline(always)]
            pub fn res100k(self) -> &'a mut crate::W<REG> {
                self.variant(TIAGAIN::Res100k)
            }
        }
        #[doc = "TIA Vbias Selection of VDAC Channel\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIAVDACSEL {
            #[doc = "0: Select VDAC8 as TIA Vbias"]
            Vdac8sel = 0,
            #[doc = "1: Select VDAC9 as TIA Vbias"]
            Vdac9sel = 1,
            #[doc = "2: Select VDAC10 as TIA Vbias"]
            Vdac10sel = 2,
            #[doc = "3: Select VDAC11 as TIA Vbias"]
            Vdac11sel = 3,
        }
        impl From<TIAVDACSEL> for u8 {
            #[inline(always)]
            fn from(variant: TIAVDACSEL) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for TIAVDACSEL {
            type Ux = u8;
        }
        impl crate::IsEnum for TIAVDACSEL {}
        #[doc = "Field `TIAVDACSEL` reader - TIA Vbias Selection of VDAC Channel"]
        pub type TIAVDACSEL_R = crate::FieldReader<TIAVDACSEL>;
        impl TIAVDACSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TIAVDACSEL {
                match self.bits {
                    0 => TIAVDACSEL::Vdac8sel,
                    1 => TIAVDACSEL::Vdac9sel,
                    2 => TIAVDACSEL::Vdac10sel,
                    3 => TIAVDACSEL::Vdac11sel,
                    _ => unreachable!(),
                }
            }
            #[doc = "Select VDAC8 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac8sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac8sel
            }
            #[doc = "Select VDAC9 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac9sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac9sel
            }
            #[doc = "Select VDAC10 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac10sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac10sel
            }
            #[doc = "Select VDAC11 as TIA Vbias"]
            #[inline(always)]
            pub fn is_vdac11sel(&self) -> bool {
                *self == TIAVDACSEL::Vdac11sel
            }
        }
        #[doc = "Field `TIAVDACSEL` writer - TIA Vbias Selection of VDAC Channel"]
        pub type TIAVDACSEL_W<'a, REG> = crate::FieldWriter<'a, REG, 2, TIAVDACSEL, crate::Safe>;
        impl<'a, REG> TIAVDACSEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Select VDAC8 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac8sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac8sel)
            }
            #[doc = "Select VDAC9 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac9sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac9sel)
            }
            #[doc = "Select VDAC10 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac10sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac10sel)
            }
            #[doc = "Select VDAC11 as TIA Vbias"]
            #[inline(always)]
            pub fn vdac11sel(self) -> &'a mut crate::W<REG> {
                self.variant(TIAVDACSEL::Vdac11sel)
            }
        }
        #[doc = "Sink Current Ability Improve\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DRVEN {
            #[doc = "0: Disable Isink Ability Improvement, Normal Drive"]
            Drvdisable = 0,
            #[doc = "1: Enable Isink Ability Improvement"]
            Drvenable = 1,
        }
        impl From<DRVEN> for bool {
            #[inline(always)]
            fn from(variant: DRVEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DRVEN` reader - Sink Current Ability Improve"]
        pub type DRVEN_R = crate::BitReader<DRVEN>;
        impl DRVEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DRVEN {
                match self.bits {
                    false => DRVEN::Drvdisable,
                    true => DRVEN::Drvenable,
                }
            }
            #[doc = "Disable Isink Ability Improvement, Normal Drive"]
            #[inline(always)]
            pub fn is_drvdisable(&self) -> bool {
                *self == DRVEN::Drvdisable
            }
            #[doc = "Enable Isink Ability Improvement"]
            #[inline(always)]
            pub fn is_drvenable(&self) -> bool {
                *self == DRVEN::Drvenable
            }
        }
        #[doc = "Field `DRVEN` writer - Sink Current Ability Improve"]
        pub type DRVEN_W<'a, REG> = crate::BitWriter<'a, REG, DRVEN>;
        impl<'a, REG> DRVEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable Isink Ability Improvement, Normal Drive"]
            #[inline(always)]
            pub fn drvdisable(self) -> &'a mut crate::W<REG> {
                self.variant(DRVEN::Drvdisable)
            }
            #[doc = "Enable Isink Ability Improvement"]
            #[inline(always)]
            pub fn drvenable(self) -> &'a mut crate::W<REG> {
                self.variant(DRVEN::Drvenable)
            }
        }
        #[doc = "Select Between Source Mode and Sink Mode\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TIASRCEN {
            #[doc = "0: Sink Mode"]
            Sinkmd = 0,
            #[doc = "1: Source Mode"]
            Sourcemd = 1,
        }
        impl From<TIASRCEN> for bool {
            #[inline(always)]
            fn from(variant: TIASRCEN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIASRCEN` reader - Select Between Source Mode and Sink Mode"]
        pub type TIASRCEN_R = crate::BitReader<TIASRCEN>;
        impl TIASRCEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> TIASRCEN {
                match self.bits {
                    false => TIASRCEN::Sinkmd,
                    true => TIASRCEN::Sourcemd,
                }
            }
            #[doc = "Sink Mode"]
            #[inline(always)]
            pub fn is_sinkmd(&self) -> bool {
                *self == TIASRCEN::Sinkmd
            }
            #[doc = "Source Mode"]
            #[inline(always)]
            pub fn is_sourcemd(&self) -> bool {
                *self == TIASRCEN::Sourcemd
            }
        }
        #[doc = "Field `TIASRCEN` writer - Select Between Source Mode and Sink Mode"]
        pub type TIASRCEN_W<'a, REG> = crate::BitWriter<'a, REG, TIASRCEN>;
        impl<'a, REG> TIASRCEN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Sink Mode"]
            #[inline(always)]
            pub fn sinkmd(self) -> &'a mut crate::W<REG> {
                self.variant(TIASRCEN::Sinkmd)
            }
            #[doc = "Source Mode"]
            #[inline(always)]
            pub fn sourcemd(self) -> &'a mut crate::W<REG> {
                self.variant(TIASRCEN::Sourcemd)
            }
        }
        impl R {
            #[doc = "Bit 0 - PGA Core Power Down"]
            #[inline(always)]
            pub fn pdpgacore(&self) -> PDPGACORE_R {
                PDPGACORE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - PGA or TIA Mode Selection"]
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - PGA DC Mode or AC Couple Mode Selection"]
            #[inline(always)]
            pub fn pgamode(&self) -> PGAMODE_R {
                PGAMODE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 5:7 - PGA Gain Configuration"]
            #[inline(always)]
            pub fn pgagain(&self) -> PGAGAIN_R {
                PGAGAIN_R::new(((self.bits >> 5) & 7) as u8)
            }
            #[doc = "Bits 8:10 - TIA Gain Configuration"]
            #[inline(always)]
            pub fn tiagain(&self) -> TIAGAIN_R {
                TIAGAIN_R::new(((self.bits >> 8) & 7) as u8)
            }
            #[doc = "Bits 11:12 - TIA Vbias Selection of VDAC Channel"]
            #[inline(always)]
            pub fn tiavdacsel(&self) -> TIAVDACSEL_R {
                TIAVDACSEL_R::new(((self.bits >> 11) & 3) as u8)
            }
            #[doc = "Bit 14 - Sink Current Ability Improve"]
            #[inline(always)]
            pub fn drven(&self) -> DRVEN_R {
                DRVEN_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Select Between Source Mode and Sink Mode"]
            #[inline(always)]
            pub fn tiasrcen(&self) -> TIASRCEN_R {
                TIASRCEN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PGA3CON")
                    .field("pdpgacore", &self.pdpgacore())
                    .field("mode", &self.mode())
                    .field("pgamode", &self.pgamode())
                    .field("pgagain", &self.pgagain())
                    .field("tiagain", &self.tiagain())
                    .field("tiavdacsel", &self.tiavdacsel())
                    .field("drven", &self.drven())
                    .field("tiasrcen", &self.tiasrcen())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - PGA Core Power Down"]
            #[inline(always)]
            pub fn pdpgacore(&mut self) -> PDPGACORE_W<PGA3CONrs> {
                PDPGACORE_W::new(self, 0)
            }
            #[doc = "Bit 1 - PGA or TIA Mode Selection"]
            #[inline(always)]
            pub fn mode(&mut self) -> MODE_W<PGA3CONrs> {
                MODE_W::new(self, 1)
            }
            #[doc = "Bit 2 - PGA DC Mode or AC Couple Mode Selection"]
            #[inline(always)]
            pub fn pgamode(&mut self) -> PGAMODE_W<PGA3CONrs> {
                PGAMODE_W::new(self, 2)
            }
            #[doc = "Bits 5:7 - PGA Gain Configuration"]
            #[inline(always)]
            pub fn pgagain(&mut self) -> PGAGAIN_W<PGA3CONrs> {
                PGAGAIN_W::new(self, 5)
            }
            #[doc = "Bits 8:10 - TIA Gain Configuration"]
            #[inline(always)]
            pub fn tiagain(&mut self) -> TIAGAIN_W<PGA3CONrs> {
                TIAGAIN_W::new(self, 8)
            }
            #[doc = "Bits 11:12 - TIA Vbias Selection of VDAC Channel"]
            #[inline(always)]
            pub fn tiavdacsel(&mut self) -> TIAVDACSEL_W<PGA3CONrs> {
                TIAVDACSEL_W::new(self, 11)
            }
            #[doc = "Bit 14 - Sink Current Ability Improve"]
            #[inline(always)]
            pub fn drven(&mut self) -> DRVEN_W<PGA3CONrs> {
                DRVEN_W::new(self, 14)
            }
            #[doc = "Bit 15 - Select Between Source Mode and Sink Mode"]
            #[inline(always)]
            pub fn tiasrcen(&mut self) -> TIASRCEN_W<PGA3CONrs> {
                TIASRCEN_W::new(self, 15)
            }
        }
        #[doc = "PGA3 Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`pga3con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pga3con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PGA:PGA3CON)"]
        pub struct PGA3CONrs;
        impl crate::RegisterSpec for PGA3CONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pga3con::R`](R) reader structure"]
        impl crate::Readable for PGA3CONrs {}
        #[doc = "`write(|w| ..)` method takes [`pga3con::W`](W) writer structure"]
        impl crate::Writable for PGA3CONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PGA3CON to value 0x11"]
        impl crate::Resettable for PGA3CONrs {
            const RESET_VALUE: u32 = 0x11;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLL)"]
pub struct PLL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PLL {}
impl PLL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pll::RegisterBlock = 0x4006_9200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pll::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PLL {
    type Target = pll::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PLL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PLL").finish()
    }
}
#[doc = "Unknown"]
pub mod pll {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        pllpdctrl: PLLPDCTRL,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Unknown"]
        #[inline(always)]
        pub const fn pllpdctrl(&self) -> &PLLPDCTRL {
            &self.pllpdctrl
        }
    }
    #[doc = "PLLPDCTRL (rw) register accessor: Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`pllpdctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pllpdctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLL:PLLPDCTRL)\n\nFor information about available fields see [`mod@pllpdctrl`]
module"]
    pub type PLLPDCTRL = crate::Reg<pllpdctrl::PLLPDCTRLrs>;
    #[doc = "Unknown"]
    pub mod pllpdctrl {
        #[doc = "Register `PLLPDCTRL` reader"]
        pub type R = crate::R<PLLPDCTRLrs>;
        #[doc = "Register `PLLPDCTRL` writer"]
        pub type W = crate::W<PLLPDCTRLrs>;
        #[doc = "Field `TOTPDB` reader - PDB of PLL All"]
        pub type TOTPDB_R = crate::BitReader;
        #[doc = "Field `TOTPDB` writer - PDB of PLL All"]
        pub type TOTPDB_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 6 - PDB of PLL All"]
            #[inline(always)]
            pub fn totpdb(&self) -> TOTPDB_R {
                TOTPDB_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PLLPDCTRL")
                    .field("totpdb", &self.totpdb())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 6 - PDB of PLL All"]
            #[inline(always)]
            pub fn totpdb(&mut self) -> TOTPDB_W<PLLPDCTRLrs> {
                TOTPDB_W::new(self, 6)
            }
        }
        #[doc = "Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`pllpdctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pllpdctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#PLL:PLLPDCTRL)"]
        pub struct PLLPDCTRLrs;
        impl crate::RegisterSpec for PLLPDCTRLrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pllpdctrl::R`](R) reader structure"]
        impl crate::Readable for PLLPDCTRLrs {}
        #[doc = "`write(|w| ..)` method takes [`pllpdctrl::W`](W) writer structure"]
        impl crate::Writable for PLLPDCTRLrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PLLPDCTRL to value 0x3f"]
        impl crate::Resettable for PLLPDCTRLrs {
            const RESET_VALUE: u32 = 0x3f;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#TMPSNS)"]
pub struct TMPSNS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMPSNS {}
impl TMPSNS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmpsns::RegisterBlock = 0x4006_9600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmpsns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMPSNS {
    type Target = tmpsns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMPSNS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMPSNS").finish()
    }
}
#[doc = "Unknown"]
pub mod tmpsns {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        tmpsnscon: TMPSNSCON,
        tmpsnschpcon: TMPSNSCHPCON,
        vcmrefcon: VCMREFCON,
        _reserved3: [u8; 0x04],
        vcmbufcon: VCMBUFCON,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Unknown"]
        #[inline(always)]
        pub const fn tmpsnscon(&self) -> &TMPSNSCON {
            &self.tmpsnscon
        }
        #[doc = "0x04 - Unknown"]
        #[inline(always)]
        pub const fn tmpsnschpcon(&self) -> &TMPSNSCHPCON {
            &self.tmpsnschpcon
        }
        #[doc = "0x08 - Unknown"]
        #[inline(always)]
        pub const fn vcmrefcon(&self) -> &VCMREFCON {
            &self.vcmrefcon
        }
        #[doc = "0x10 - Unknown"]
        #[inline(always)]
        pub const fn vcmbufcon(&self) -> &VCMBUFCON {
            &self.vcmbufcon
        }
    }
    #[doc = "TMPSNSCON (rw) register accessor: Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`tmpsnscon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmpsnscon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#TMPSNS:TMPSNSCON)\n\nFor information about available fields see [`mod@tmpsnscon`]
module"]
    pub type TMPSNSCON = crate::Reg<tmpsnscon::TMPSNSCONrs>;
    #[doc = "Unknown"]
    pub mod tmpsnscon {
        #[doc = "Register `TMPSNSCON` reader"]
        pub type R = crate::R<TMPSNSCONrs>;
        #[doc = "Register `TMPSNSCON` writer"]
        pub type W = crate::W<TMPSNSCONrs>;
        #[doc = "Field `ENTMPSNS` reader - Enable Temp Sensor"]
        pub type ENTMPSNS_R = crate::BitReader;
        #[doc = "Field `ENTMPSNS` writer - Enable Temp Sensor"]
        pub type ENTMPSNS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 1 - Enable Temp Sensor"]
            #[inline(always)]
            pub fn entmpsns(&self) -> ENTMPSNS_R {
                ENTMPSNS_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TMPSNSCON")
                    .field("entmpsns", &self.entmpsns())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 1 - Enable Temp Sensor"]
            #[inline(always)]
            pub fn entmpsns(&mut self) -> ENTMPSNS_W<TMPSNSCONrs> {
                ENTMPSNS_W::new(self, 1)
            }
        }
        #[doc = "Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`tmpsnscon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmpsnscon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#TMPSNS:TMPSNSCON)"]
        pub struct TMPSNSCONrs;
        impl crate::RegisterSpec for TMPSNSCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tmpsnscon::R`](R) reader structure"]
        impl crate::Readable for TMPSNSCONrs {}
        #[doc = "`write(|w| ..)` method takes [`tmpsnscon::W`](W) writer structure"]
        impl crate::Writable for TMPSNSCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TMPSNSCON to value 0x02"]
        impl crate::Resettable for TMPSNSCONrs {
            const RESET_VALUE: u32 = 0x02;
        }
    }
    #[doc = "TMPSNSCHPCON (rw) register accessor: Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`tmpsnschpcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmpsnschpcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#TMPSNS:TMPSNSCHPCON)\n\nFor information about available fields see [`mod@tmpsnschpcon`]
module"]
    pub type TMPSNSCHPCON = crate::Reg<tmpsnschpcon::TMPSNSCHPCONrs>;
    #[doc = "Unknown"]
    pub mod tmpsnschpcon {
        #[doc = "Register `TMPSNSCHPCON` reader"]
        pub type R = crate::R<TMPSNSCHPCONrs>;
        #[doc = "Register `TMPSNSCHPCON` writer"]
        pub type W = crate::W<TMPSNSCHPCONrs>;
        #[doc = "Field `CHOFFTMPSNS` reader - Chopping Disable = 1 Enable = 0"]
        pub type CHOFFTMPSNS_R = crate::BitReader;
        #[doc = "Field `CHOFFTMPSNS` writer - Chopping Disable = 1 Enable = 0"]
        pub type CHOFFTMPSNS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Chopping Disable = 1 Enable = 0"]
            #[inline(always)]
            pub fn chofftmpsns(&self) -> CHOFFTMPSNS_R {
                CHOFFTMPSNS_R::new((self.bits & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TMPSNSCHPCON")
                    .field("chofftmpsns", &self.chofftmpsns())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Chopping Disable = 1 Enable = 0"]
            #[inline(always)]
            pub fn chofftmpsns(&mut self) -> CHOFFTMPSNS_W<TMPSNSCHPCONrs> {
                CHOFFTMPSNS_W::new(self, 0)
            }
        }
        #[doc = "Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`tmpsnschpcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tmpsnschpcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#TMPSNS:TMPSNSCHPCON)"]
        pub struct TMPSNSCHPCONrs;
        impl crate::RegisterSpec for TMPSNSCHPCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tmpsnschpcon::R`](R) reader structure"]
        impl crate::Readable for TMPSNSCHPCONrs {}
        #[doc = "`write(|w| ..)` method takes [`tmpsnschpcon::W`](W) writer structure"]
        impl crate::Writable for TMPSNSCHPCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TMPSNSCHPCON to value 0"]
        impl crate::Resettable for TMPSNSCHPCONrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "VCMREFCON (rw) register accessor: Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`vcmrefcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vcmrefcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#TMPSNS:VCMREFCON)\n\nFor information about available fields see [`mod@vcmrefcon`]
module"]
    pub type VCMREFCON = crate::Reg<vcmrefcon::VCMREFCONrs>;
    #[doc = "Unknown"]
    pub mod vcmrefcon {
        #[doc = "Register `VCMREFCON` reader"]
        pub type R = crate::R<VCMREFCONrs>;
        #[doc = "Register `VCMREFCON` writer"]
        pub type W = crate::W<VCMREFCONrs>;
        #[doc = "0.2V or 0.5V Selection for PGA\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PGAREFSEL {
            #[doc = "0: Select 0.2V Reference"]
            Sel0p2v = 0,
            #[doc = "1: Select 0.5V Reference"]
            Sel0p5v = 1,
        }
        impl From<PGAREFSEL> for bool {
            #[inline(always)]
            fn from(variant: PGAREFSEL) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PGAREFSEL` reader - 0.2V or 0.5V Selection for PGA"]
        pub type PGAREFSEL_R = crate::BitReader<PGAREFSEL>;
        impl PGAREFSEL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PGAREFSEL {
                match self.bits {
                    false => PGAREFSEL::Sel0p2v,
                    true => PGAREFSEL::Sel0p5v,
                }
            }
            #[doc = "Select 0.2V Reference"]
            #[inline(always)]
            pub fn is_sel0p2v(&self) -> bool {
                *self == PGAREFSEL::Sel0p2v
            }
            #[doc = "Select 0.5V Reference"]
            #[inline(always)]
            pub fn is_sel0p5v(&self) -> bool {
                *self == PGAREFSEL::Sel0p5v
            }
        }
        #[doc = "Field `PGAREFSEL` writer - 0.2V or 0.5V Selection for PGA"]
        pub type PGAREFSEL_W<'a, REG> = crate::BitWriter<'a, REG, PGAREFSEL>;
        impl<'a, REG> PGAREFSEL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Select 0.2V Reference"]
            #[inline(always)]
            pub fn sel0p2v(self) -> &'a mut crate::W<REG> {
                self.variant(PGAREFSEL::Sel0p2v)
            }
            #[doc = "Select 0.5V Reference"]
            #[inline(always)]
            pub fn sel0p5v(self) -> &'a mut crate::W<REG> {
                self.variant(PGAREFSEL::Sel0p5v)
            }
        }
        impl R {
            #[doc = "Bit 1 - 0.2V or 0.5V Selection for PGA"]
            #[inline(always)]
            pub fn pgarefsel(&self) -> PGAREFSEL_R {
                PGAREFSEL_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VCMREFCON")
                    .field("pgarefsel", &self.pgarefsel())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 1 - 0.2V or 0.5V Selection for PGA"]
            #[inline(always)]
            pub fn pgarefsel(&mut self) -> PGAREFSEL_W<VCMREFCONrs> {
                PGAREFSEL_W::new(self, 1)
            }
        }
        #[doc = "Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`vcmrefcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vcmrefcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#TMPSNS:VCMREFCON)"]
        pub struct VCMREFCONrs;
        impl crate::RegisterSpec for VCMREFCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vcmrefcon::R`](R) reader structure"]
        impl crate::Readable for VCMREFCONrs {}
        #[doc = "`write(|w| ..)` method takes [`vcmrefcon::W`](W) writer structure"]
        impl crate::Writable for VCMREFCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets VCMREFCON to value 0"]
        impl crate::Resettable for VCMREFCONrs {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "VCMBUFCON (rw) register accessor: Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`vcmbufcon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vcmbufcon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#TMPSNS:VCMBUFCON)\n\nFor information about available fields see [`mod@vcmbufcon`]
module"]
    pub type VCMBUFCON = crate::Reg<vcmbufcon::VCMBUFCONrs>;
    #[doc = "Unknown"]
    pub mod vcmbufcon {
        #[doc = "Register `VCMBUFCON` reader"]
        pub type R = crate::R<VCMBUFCONrs>;
        #[doc = "Register `VCMBUFCON` writer"]
        pub type W = crate::W<VCMBUFCONrs>;
        #[doc = "Field `PDBUF0` reader - Power Down Unit Gain Buffer0"]
        pub type PDBUF0_R = crate::BitReader;
        #[doc = "Field `PDBUF0` writer - Power Down Unit Gain Buffer0"]
        pub type PDBUF0_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PDBUF1` reader - Power Down Unit Gain Buffer1"]
        pub type PDBUF1_R = crate::BitReader;
        #[doc = "Field `PDBUF1` writer - Power Down Unit Gain Buffer1"]
        pub type PDBUF1_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Selection 0=2.5V 1=1.25V\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MUXSEL0 {
            #[doc = "0: Input Buffer0 2.5V"]
            Buf0_2p5 = 0,
            #[doc = "1: Input Buffer0 1.25V"]
            Buf0_1p25 = 1,
        }
        impl From<MUXSEL0> for bool {
            #[inline(always)]
            fn from(variant: MUXSEL0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MUXSEL0` reader - Selection 0=2.5V 1=1.25V"]
        pub type MUXSEL0_R = crate::BitReader<MUXSEL0>;
        impl MUXSEL0_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MUXSEL0 {
                match self.bits {
                    false => MUXSEL0::Buf0_2p5,
                    true => MUXSEL0::Buf0_1p25,
                }
            }
            #[doc = "Input Buffer0 2.5V"]
            #[inline(always)]
            pub fn is_buf0_2p5(&self) -> bool {
                *self == MUXSEL0::Buf0_2p5
            }
            #[doc = "Input Buffer0 1.25V"]
            #[inline(always)]
            pub fn is_buf0_1p25(&self) -> bool {
                *self == MUXSEL0::Buf0_1p25
            }
        }
        #[doc = "Field `MUXSEL0` writer - Selection 0=2.5V 1=1.25V"]
        pub type MUXSEL0_W<'a, REG> = crate::BitWriter<'a, REG, MUXSEL0>;
        impl<'a, REG> MUXSEL0_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Input Buffer0 2.5V"]
            #[inline(always)]
            pub fn buf0_2p5(self) -> &'a mut crate::W<REG> {
                self.variant(MUXSEL0::Buf0_2p5)
            }
            #[doc = "Input Buffer0 1.25V"]
            #[inline(always)]
            pub fn buf0_1p25(self) -> &'a mut crate::W<REG> {
                self.variant(MUXSEL0::Buf0_1p25)
            }
        }
        #[doc = "Selection 0=2.5V 1=1.25V\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MUXSEL1 {
            #[doc = "0: Buffer1 Input 2.5V"]
            Buf1_2p5 = 0,
            #[doc = "1: Buffer1 Input 1.25V"]
            Buf1_1p25 = 1,
        }
        impl From<MUXSEL1> for bool {
            #[inline(always)]
            fn from(variant: MUXSEL1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MUXSEL1` reader - Selection 0=2.5V 1=1.25V"]
        pub type MUXSEL1_R = crate::BitReader<MUXSEL1>;
        impl MUXSEL1_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> MUXSEL1 {
                match self.bits {
                    false => MUXSEL1::Buf1_2p5,
                    true => MUXSEL1::Buf1_1p25,
                }
            }
            #[doc = "Buffer1 Input 2.5V"]
            #[inline(always)]
            pub fn is_buf1_2p5(&self) -> bool {
                *self == MUXSEL1::Buf1_2p5
            }
            #[doc = "Buffer1 Input 1.25V"]
            #[inline(always)]
            pub fn is_buf1_1p25(&self) -> bool {
                *self == MUXSEL1::Buf1_1p25
            }
        }
        #[doc = "Field `MUXSEL1` writer - Selection 0=2.5V 1=1.25V"]
        pub type MUXSEL1_W<'a, REG> = crate::BitWriter<'a, REG, MUXSEL1>;
        impl<'a, REG> MUXSEL1_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Buffer1 Input 2.5V"]
            #[inline(always)]
            pub fn buf1_2p5(self) -> &'a mut crate::W<REG> {
                self.variant(MUXSEL1::Buf1_2p5)
            }
            #[doc = "Buffer1 Input 1.25V"]
            #[inline(always)]
            pub fn buf1_1p25(self) -> &'a mut crate::W<REG> {
                self.variant(MUXSEL1::Buf1_1p25)
            }
        }
        impl R {
            #[doc = "Bit 0 - Power Down Unit Gain Buffer0"]
            #[inline(always)]
            pub fn pdbuf0(&self) -> PDBUF0_R {
                PDBUF0_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Power Down Unit Gain Buffer1"]
            #[inline(always)]
            pub fn pdbuf1(&self) -> PDBUF1_R {
                PDBUF1_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Selection 0=2.5V 1=1.25V"]
            #[inline(always)]
            pub fn muxsel0(&self) -> MUXSEL0_R {
                MUXSEL0_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - Selection 0=2.5V 1=1.25V"]
            #[inline(always)]
            pub fn muxsel1(&self) -> MUXSEL1_R {
                MUXSEL1_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("VCMBUFCON")
                    .field("pdbuf0", &self.pdbuf0())
                    .field("pdbuf1", &self.pdbuf1())
                    .field("muxsel0", &self.muxsel0())
                    .field("muxsel1", &self.muxsel1())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 0 - Power Down Unit Gain Buffer0"]
            #[inline(always)]
            pub fn pdbuf0(&mut self) -> PDBUF0_W<VCMBUFCONrs> {
                PDBUF0_W::new(self, 0)
            }
            #[doc = "Bit 1 - Power Down Unit Gain Buffer1"]
            #[inline(always)]
            pub fn pdbuf1(&mut self) -> PDBUF1_W<VCMBUFCONrs> {
                PDBUF1_W::new(self, 1)
            }
            #[doc = "Bit 2 - Selection 0=2.5V 1=1.25V"]
            #[inline(always)]
            pub fn muxsel0(&mut self) -> MUXSEL0_W<VCMBUFCONrs> {
                MUXSEL0_W::new(self, 2)
            }
            #[doc = "Bit 4 - Selection 0=2.5V 1=1.25V"]
            #[inline(always)]
            pub fn muxsel1(&mut self) -> MUXSEL1_W<VCMBUFCONrs> {
                MUXSEL1_W::new(self, 4)
            }
        }
        #[doc = "Unknown\n\nYou can [`read`](crate::Reg::read) this register and get [`vcmbufcon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vcmbufcon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#TMPSNS:VCMBUFCON)"]
        pub struct VCMBUFCONrs;
        impl crate::RegisterSpec for VCMBUFCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vcmbufcon::R`](R) reader structure"]
        impl crate::Readable for VCMBUFCONrs {}
        #[doc = "`write(|w| ..)` method takes [`vcmbufcon::W`](W) writer structure"]
        impl crate::Writable for VCMBUFCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets VCMBUFCON to value 0x13"]
        impl crate::Resettable for VCMBUFCONrs {
            const RESET_VALUE: u32 = 0x13;
        }
    }
}
#[doc = "Unknown"]
#[doc = ""]
#[doc = "See peripheral [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#VDAC)"]
pub struct VDAC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VDAC {}
impl VDAC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vdac::RegisterBlock = 0x4006_9800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vdac::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for VDAC {
    type Target = vdac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VDAC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VDAC").finish()
    }
}
#[doc = "Unknown"]
pub mod vdac {
    #[repr(C)]
    #[derive(Debug)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        daccon: [DACCON; 12],
        dacdat: [DACDAT; 12],
    }
    impl RegisterBlock {
        #[doc = "0x00..0x30 - DAC Control Register"]
        #[inline(always)]
        pub const fn daccon(&self, n: usize) -> &DACCON {
            &self.daccon[n]
        }
        #[doc = "Iterator for array of:"]
        #[doc = "0x00..0x30 - DAC Control Register"]
        #[inline(always)]
        pub fn daccon_iter(&self) -> impl Iterator<Item = &DACCON> {
            self.daccon.iter()
        }
        #[doc = "0x30..0x60 - DAC Data Register"]
        #[inline(always)]
        pub const fn dacdat(&self, n: usize) -> &DACDAT {
            &self.dacdat[n]
        }
        #[doc = "Iterator for array of:"]
        #[doc = "0x30..0x60 - DAC Data Register"]
        #[inline(always)]
        pub fn dacdat_iter(&self) -> impl Iterator<Item = &DACDAT> {
            self.dacdat.iter()
        }
    }
    #[doc = "DACCON (rw) register accessor: DAC Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`daccon::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`daccon::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#VDAC:DACCON[0])\n\nFor information about available fields see [`mod@daccon`]
module"]
    pub type DACCON = crate::Reg<daccon::DACCONrs>;
    #[doc = "DAC Control Register"]
    pub mod daccon {
        #[doc = "Register `DACCON[%s]` reader"]
        pub type R = crate::R<DACCONrs>;
        #[doc = "Register `DACCON[%s]` writer"]
        pub type W = crate::W<DACCONrs>;
        #[doc = "DAC Input Data Clear, Won't Be Controlled by Sync Mode.\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EN {
            #[doc = "0: DAC DATA Clear"]
            Clear = 0,
            #[doc = "1: DAC DATA Normal Input"]
            Clearoff = 1,
        }
        impl From<EN> for bool {
            #[inline(always)]
            fn from(variant: EN) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EN` reader - DAC Input Data Clear, Won't Be Controlled by Sync Mode."]
        pub type EN_R = crate::BitReader<EN>;
        impl EN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> EN {
                match self.bits {
                    false => EN::Clear,
                    true => EN::Clearoff,
                }
            }
            #[doc = "DAC DATA Clear"]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == EN::Clear
            }
            #[doc = "DAC DATA Normal Input"]
            #[inline(always)]
            pub fn is_clearoff(&self) -> bool {
                *self == EN::Clearoff
            }
        }
        #[doc = "Field `EN` writer - DAC Input Data Clear, Won't Be Controlled by Sync Mode."]
        pub type EN_W<'a, REG> = crate::BitWriter<'a, REG, EN>;
        impl<'a, REG> EN_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DAC DATA Clear"]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(EN::Clear)
            }
            #[doc = "DAC DATA Normal Input"]
            #[inline(always)]
            pub fn clearoff(self) -> &'a mut crate::W<REG> {
                self.variant(EN::Clearoff)
            }
        }
        #[doc = "Select Output Full Scale\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FSLVL {
            #[doc = "0: Full Scale is 2.5V"]
            Out2p5 = 0,
            #[doc = "1: Full Scale is 3.3V"]
            Out3v3 = 1,
        }
        impl From<FSLVL> for bool {
            #[inline(always)]
            fn from(variant: FSLVL) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FSLVL` reader - Select Output Full Scale"]
        pub type FSLVL_R = crate::BitReader<FSLVL>;
        impl FSLVL_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> FSLVL {
                match self.bits {
                    false => FSLVL::Out2p5,
                    true => FSLVL::Out3v3,
                }
            }
            #[doc = "Full Scale is 2.5V"]
            #[inline(always)]
            pub fn is_out2p5(&self) -> bool {
                *self == FSLVL::Out2p5
            }
            #[doc = "Full Scale is 3.3V"]
            #[inline(always)]
            pub fn is_out3v3(&self) -> bool {
                *self == FSLVL::Out3v3
            }
        }
        #[doc = "Field `FSLVL` writer - Select Output Full Scale"]
        pub type FSLVL_W<'a, REG> = crate::BitWriter<'a, REG, FSLVL>;
        impl<'a, REG> FSLVL_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Full Scale is 2.5V"]
            #[inline(always)]
            pub fn out2p5(self) -> &'a mut crate::W<REG> {
                self.variant(FSLVL::Out2p5)
            }
            #[doc = "Full Scale is 3.3V"]
            #[inline(always)]
            pub fn out3v3(self) -> &'a mut crate::W<REG> {
                self.variant(FSLVL::Out3v3)
            }
        }
        #[doc = "DAC Top Power Down\n\nValue on reset: 1"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PD {
            #[doc = "0: DAC Top Enable"]
            Dacon = 0,
            #[doc = "1: DAC TOP Power Down"]
            Dacoff = 1,
        }
        impl From<PD> for bool {
            #[inline(always)]
            fn from(variant: PD) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PD` reader - DAC Top Power Down"]
        pub type PD_R = crate::BitReader<PD>;
        impl PD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> PD {
                match self.bits {
                    false => PD::Dacon,
                    true => PD::Dacoff,
                }
            }
            #[doc = "DAC Top Enable"]
            #[inline(always)]
            pub fn is_dacon(&self) -> bool {
                *self == PD::Dacon
            }
            #[doc = "DAC TOP Power Down"]
            #[inline(always)]
            pub fn is_dacoff(&self) -> bool {
                *self == PD::Dacoff
            }
        }
        #[doc = "Field `PD` writer - DAC Top Power Down"]
        pub type PD_W<'a, REG> = crate::BitWriter<'a, REG, PD>;
        impl<'a, REG> PD_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "DAC Top Enable"]
            #[inline(always)]
            pub fn dacon(self) -> &'a mut crate::W<REG> {
                self.variant(PD::Dacon)
            }
            #[doc = "DAC TOP Power Down"]
            #[inline(always)]
            pub fn dacoff(self) -> &'a mut crate::W<REG> {
                self.variant(PD::Dacoff)
            }
        }
        #[doc = "Drive Ability Boost Enable, Can Drive 10mA Load.\n\nValue on reset: 0"]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DRV {
            #[doc = "0: Normal Work Mode"]
            Normal = 0,
            #[doc = "1: Drive Ability Boost Mode"]
            Driveboost = 1,
        }
        impl From<DRV> for bool {
            #[inline(always)]
            fn from(variant: DRV) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DRV` reader - Drive Ability Boost Enable, Can Drive 10mA Load."]
        pub type DRV_R = crate::BitReader<DRV>;
        impl DRV_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> DRV {
                match self.bits {
                    false => DRV::Normal,
                    true => DRV::Driveboost,
                }
            }
            #[doc = "Normal Work Mode"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == DRV::Normal
            }
            #[doc = "Drive Ability Boost Mode"]
            #[inline(always)]
            pub fn is_driveboost(&self) -> bool {
                *self == DRV::Driveboost
            }
        }
        #[doc = "Field `DRV` writer - Drive Ability Boost Enable, Can Drive 10mA Load."]
        pub type DRV_W<'a, REG> = crate::BitWriter<'a, REG, DRV>;
        impl<'a, REG> DRV_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Normal Work Mode"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut crate::W<REG> {
                self.variant(DRV::Normal)
            }
            #[doc = "Drive Ability Boost Mode"]
            #[inline(always)]
            pub fn driveboost(self) -> &'a mut crate::W<REG> {
                self.variant(DRV::Driveboost)
            }
        }
        impl R {
            #[doc = "Bit 4 - DAC Input Data Clear, Won't Be Controlled by Sync Mode."]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Select Output Full Scale"]
            #[inline(always)]
            pub fn fslvl(&self) -> FSLVL_R {
                FSLVL_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 8 - DAC Top Power Down"]
            #[inline(always)]
            pub fn pd(&self) -> PD_R {
                PD_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Drive Ability Boost Enable, Can Drive 10mA Load."]
            #[inline(always)]
            pub fn drv(&self) -> DRV_R {
                DRV_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DACCON")
                    .field("en", &self.en())
                    .field("fslvl", &self.fslvl())
                    .field("pd", &self.pd())
                    .field("drv", &self.drv())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bit 4 - DAC Input Data Clear, Won't Be Controlled by Sync Mode."]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W<DACCONrs> {
                EN_W::new(self, 4)
            }
            #[doc = "Bit 5 - Select Output Full Scale"]
            #[inline(always)]
            pub fn fslvl(&mut self) -> FSLVL_W<DACCONrs> {
                FSLVL_W::new(self, 5)
            }
            #[doc = "Bit 8 - DAC Top Power Down"]
            #[inline(always)]
            pub fn pd(&mut self) -> PD_W<DACCONrs> {
                PD_W::new(self, 8)
            }
            #[doc = "Bit 9 - Drive Ability Boost Enable, Can Drive 10mA Load."]
            #[inline(always)]
            pub fn drv(&mut self) -> DRV_W<DACCONrs> {
                DRV_W::new(self, 9)
            }
        }
        #[doc = "DAC Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`daccon::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`daccon::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#VDAC:DACCON[0])"]
        pub struct DACCONrs;
        impl crate::RegisterSpec for DACCONrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`daccon::R`](R) reader structure"]
        impl crate::Readable for DACCONrs {}
        #[doc = "`write(|w| ..)` method takes [`daccon::W`](W) writer structure"]
        impl crate::Writable for DACCONrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DACCON[%s]
to value 0x0d02"]
        impl crate::Resettable for DACCONrs {
            const RESET_VALUE: u32 = 0x0d02;
        }
    }
    #[doc = "DACDAT (rw) register accessor: DAC Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`dacdat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dacdat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#VDAC:DACDAT[0])\n\nFor information about available fields see [`mod@dacdat`]
module"]
    pub type DACDAT = crate::Reg<dacdat::DACDATrs>;
    #[doc = "DAC Data Register"]
    pub mod dacdat {
        #[doc = "Register `DACDAT[%s]` reader"]
        pub type R = crate::R<DACDATrs>;
        #[doc = "Register `DACDAT[%s]` writer"]
        pub type W = crate::W<DACDATrs>;
        #[doc = "Field `DATAIN` reader - DAC Input Data"]
        pub type DATAIN_R = crate::FieldReader<u16>;
        #[doc = "Field `DATAIN` writer - DAC Input Data"]
        pub type DATAIN_W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 12:27 - DAC Input Data"]
            #[inline(always)]
            pub fn datain(&self) -> DATAIN_R {
                DATAIN_R::new(((self.bits >> 12) & 0xffff) as u16)
            }
        }
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DACDAT")
                    .field("datain", &self.datain())
                    .finish()
            }
        }
        impl W {
            #[doc = "Bits 12:27 - DAC Input Data"]
            #[inline(always)]
            pub fn datain(&mut self) -> DATAIN_W<DACDATrs> {
                DATAIN_W::new(self, 12)
            }
        }
        #[doc = "DAC Data Register\n\nYou can [`read`](crate::Reg::read) this register and get [`dacdat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dacdat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nSee register [structure](https://stm32-rs.github.io/stm32-rs/ADuCM410.html#VDAC:DACDAT[0])"]
        pub struct DACDATrs;
        impl crate::RegisterSpec for DACDATrs {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dacdat::R`](R) reader structure"]
        impl crate::Readable for DACDATrs {}
        #[doc = "`write(|w| ..)` method takes [`dacdat::W`](W) writer structure"]
        impl crate::Writable for DACDATrs {
            type Safety = crate::Unsafe;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DACDAT[%s]
to value 0"]
        impl crate::Resettable for DACDATrs {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "GPT0"]
    pub GPT0: GPT0,
    #[doc = "GPT1"]
    pub GPT1: GPT1,
    #[doc = "GPT2"]
    pub GPT2: GPT2,
    #[doc = "GPTH0"]
    pub GPTH0: GPTH0,
    #[doc = "GPTH1"]
    pub GPTH1: GPTH1,
    #[doc = "MISC16"]
    pub MISC16: MISC16,
    #[doc = "WUT"]
    pub WUT: WUT,
    #[doc = "WDT"]
    pub WDT: WDT,
    #[doc = "ALLON"]
    pub ALLON: ALLON,
    #[doc = "PLA"]
    pub PLA: PLA,
    #[doc = "DMAREQ"]
    pub DMAREQ: DMAREQ,
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "I2C0"]
    pub I2C0: I2C0,
    #[doc = "I2C1"]
    pub I2C1: I2C1,
    #[doc = "I2C2"]
    pub I2C2: I2C2,
    #[doc = "MDIO"]
    pub MDIO: MDIO,
    #[doc = "D2D0"]
    pub D2D0: D2D0,
    #[doc = "D2D1"]
    pub D2D1: D2D1,
    #[doc = "SPI0"]
    pub SPI0: SPI0,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "SPI2"]
    pub SPI2: SPI2,
    #[doc = "DMA"]
    pub DMA: DMA,
    #[doc = "CACHE"]
    pub CACHE: CACHE,
    #[doc = "FLASH"]
    pub FLASH: FLASH,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "CLK"]
    pub CLK: CLK,
    #[doc = "PWM"]
    pub PWM: PWM,
    #[doc = "SRAM"]
    pub SRAM: SRAM,
    #[doc = "CRC"]
    pub CRC: CRC,
    #[doc = "ADC"]
    pub ADC: ADC,
    #[doc = "COMP"]
    pub COMP: COMP,
    #[doc = "PGA"]
    pub PGA: PGA,
    #[doc = "PLL"]
    pub PLL: PLL,
    #[doc = "TMPSNS"]
    pub TMPSNS: TMPSNS,
    #[doc = "VDAC"]
    pub VDAC: VDAC,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            GPT0: GPT0::steal(),
            GPT1: GPT1::steal(),
            GPT2: GPT2::steal(),
            GPTH0: GPTH0::steal(),
            GPTH1: GPTH1::steal(),
            MISC16: MISC16::steal(),
            WUT: WUT::steal(),
            WDT: WDT::steal(),
            ALLON: ALLON::steal(),
            PLA: PLA::steal(),
            DMAREQ: DMAREQ::steal(),
            UART0: UART0::steal(),
            UART1: UART1::steal(),
            I2C0: I2C0::steal(),
            I2C1: I2C1::steal(),
            I2C2: I2C2::steal(),
            MDIO: MDIO::steal(),
            D2D0: D2D0::steal(),
            D2D1: D2D1::steal(),
            SPI0: SPI0::steal(),
            SPI1: SPI1::steal(),
            SPI2: SPI2::steal(),
            DMA: DMA::steal(),
            CACHE: CACHE::steal(),
            FLASH: FLASH::steal(),
            GPIO: GPIO::steal(),
            CLK: CLK::steal(),
            PWM: PWM::steal(),
            SRAM: SRAM::steal(),
            CRC: CRC::steal(),
            ADC: ADC::steal(),
            COMP: COMP::steal(),
            PGA: PGA::steal(),
            PLL: PLL::steal(),
            TMPSNS: TMPSNS::steal(),
            VDAC: VDAC::steal(),
        }
    }
}
